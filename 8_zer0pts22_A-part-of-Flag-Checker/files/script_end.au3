Global Const $COINIT_APARTMENTTHREADED = 0x2
Global Const $COINIT_DISABLE_OLE1DDE = 0x4
Global Const $COINIT_MULTITHREADED = 0x0
Global Const $COINIT_SPEED_OVER_MEMORY = 0x8
Global Const $SYMOPT_ALLOW_ABSOLUTE_SYMBOLS = 0x800
Global Const $SYMOPT_ALLOW_ZERO_ADDRESS = 0x1000000
Global Const $SYMOPT_AUTO_PUBLICS = 0x10000
Global Const $SYMOPT_CASE_INSENSITIVE = 0x1
Global Const $SYMOPT_DEBUG = -2147483648
Global Const $SYMOPT_DEFERRED_LOADS = 0x4
Global Const $SYMOPT_DISABLE_SYMSRV_AUTODETECT = 0x2000000
Global Const $SYMOPT_EXACT_SYMBOLS = 0x400
Global Const $SYMOPT_FAIL_CRITICAL_ERRORS = 0x200
Global Const $SYMOPT_FAVOR_COMPRESSED = 0x800000
Global Const $SYMOPT_FLAT_DIRECTORY = 0x400000
Global Const $SYMOPT_IGNORE_CVREC = 0x80
Global Const $SYMOPT_IGNORE_IMAGEDIR = 0x200000
Global Const $SYMOPT_IGNORE_NT_SYMPATH = 0x1000
Global Const $SYMOPT_INCLUDE_32BIT_MODULES = 0x2000
Global Const $SYMOPT_LOAD_ANYTHING = 0x40
Global Const $SYMOPT_LOAD_LINES = 0x10
Global Const $SYMOPT_NO_CPP = 0x8
Global Const $SYMOPT_NO_IMAGE_SEARCH = 0x20000
Global Const $SYMOPT_NO_PROMPTS = 0x80000
Global Const $SYMOPT_NO_PUBLICS = 0x8000
Global Const $SYMOPT_NO_UNQUALIFIED_LOADS = 0x100
Global Const $SYMOPT_OVERWRITE = 0x100000
Global Const $SYMOPT_PUBLICS_ONLY = 0x4000
Global Const $SYMOPT_SECURE = 0x40000
Global Const $SYMOPT_UNDNAME = 0x2
Global Const $SEM_FAILCRITICALERRORS = 0x1
Global Const $SEM_NOALIGNMENTFAULTEXCEPT = 0x4
Global Const $SEM_NOGPFAULTERRORBOX = 0x2
Global Const $SEM_NOOPENFILEERRORBOX = 0x8000
Global Const $NETWORK_ALIVE_LAN = 0x1
Global Const $NETWORK_ALIVE_WAN = 0x2
Global Const $NETWORK_ALIVE_AOL = 0x4
Global Const $RESTART_NO_CRASH = 0x1
Global Const $RESTART_NO_HANG = 0x2
Global Const $RESTART_NO_PATCH = 0x4
Global Const $RESTART_NO_REBOOT = 0x8
Global Const $UHID_MB = 0x0
Global Const $UHID_BIOS = 0x1
Global Const $UHID_CPU = 0x2
Global Const $UHID_HDD = 0x4
Global Const $UHID_ALL = BitOR($UHID_MB, $UHID_BIOS, $UHID_CPU, $UHID_HDD)
Global Const $__DLG_WM_USER = 0x400
Global Const $BIF_BROWSEFILEJUNCTIONS = 0x10000
Global Const $BIF_BROWSEFORCOMPUTER = 0x1000
Global Const $BIF_BROWSEFORPRINTER = 0x2000
Global Const $BIF_BROWSEINCLUDEFILES = 0x4000
Global Const $BIF_BROWSEINCLUDEURLS = 0x80
Global Const $BIF_DONTGOBELOWDOMAIN = 0x2
Global Const $BIF_EDITBOX = 0x10
Global Const $BIF_NEWDIALOGSTYLE = 0x40
Global Const $BIF_NONEWFOLDERBUTTON = 0x200
Global Const $BIF_NOTRANSLATETARGETS = 0x400
Global Const $BIF_RETURNFSANCESTORS = 0x8
Global Const $BIF_RETURNONLYFSDIRS = 0x1
Global Const $BIF_SHAREABLE = 0x8000
Global Const $BIF_STATUSTEXT = 0x4
Global Const $BIF_USENEWUI = BitOR($BIF_EDITBOX, $BIF_NEWDIALOGSTYLE)
Global Const $BIF_UAHINT = 0x100
Global Const $BIF_VALIDATE = 0x20
Global Const $BFFM_INITIALIZED = 0x1
Global Const $BFFM_IUNKNOWN = 0x5
Global Const $BFFM_SELCHANGED = 0x2
Global Const $BFFM_VALIDATEFAILED = 0x4
Global Const $BFFM_SETSTATUSTEXTA = $__DLG_WM_USER + 0x64
Global Const $BFFM_ENABLEOK = $__DLG_WM_USER + 0x65
Global Const $BFFM_SETSELECTIONA = $__DLG_WM_USER + 0x66
Global Const $BFFM_SETSELECTIONW = $__DLG_WM_USER + 0x67
Global Const $BFFM_SETSTATUSTEXTW = $__DLG_WM_USER + 0x68
Global Const $BFFM_SETOKTEXT = $__DLG_WM_USER + 0x69
Global Const $BFFM_SETEXPANDED = $__DLG_WM_USER + 0x6a
Global Const $CDERR_DIALOGFAILURE = 0xffff
Global Const $CDERR_FINDRESFAILURE = 0x6
Global Const $CDERR_INITIALIZATION = 0x2
Global Const $CDERR_LOADRESFAILURE = 0x7
Global Const $CDERR_LOADSTRFAILURE = 0x5
Global Const $CDERR_LOCKRESFAILURE = 0x8
Global Const $CDERR_MEMALLOCFAILURE = 0x9
Global Const $CDERR_MEMLOCKFAILURE = 0xa
Global Const $CDERR_NOHINSTANCE = 0x4
Global Const $CDERR_NOHOOK = 0xb
Global Const $CDERR_NOTEMPLATE = 0x3
Global Const $CDERR_REGISTERMSGFAIL = 0xc
Global Const $CDERR_STRUCTSIZE = 0x1
Global Const $PDERR_CREATEICFAILURE = 0x100a
Global Const $PDERR_DEFAULTDIFFERENT = 0x100c
Global Const $PDERR_DNDMMISMATCH = 0x1009
Global Const $PDERR_GETDEVMODEFAIL = 0x1005
Global Const $PDERR_INITFAILURE = 0x1006
Global Const $PDERR_LOADDRVFAILURE = 0x1004
Global Const $PDERR_NODEFAULTPRN = 0x1008
Global Const $PDERR_NODEVICES = 0x1007
Global Const $PDERR_PARSEFAILURE = 0x1002
Global Const $PDERR_PRINTERNOTFOUND = 0x100b
Global Const $PDERR_RETDEFFAILURE = 0x1003
Global Const $PDERR_SETUPFAILURE = 0x1001
Global Const $CFERR_MAXLESSTHANMIN = 0x2002
Global Const $CFERR_NOFONTS = 0x2001
Global Const $FNERR_BUFFERTOOSMALL = 0x3003
Global Const $FNERR_INVALIDFILENAME = 0x3002
Global Const $FNERR_SUBCLASSFAILURE = 0x3001
Global Const $FRERR_BUFFERLENGTHZERO = 0x4001
Global Const $FR_DIALOGTERM = 0x40
Global Const $FR_DOWN = 0x1
Global Const $FR_ENABLEHOOK = 0x100
Global Const $FR_ENABLETEMPLATE = 0x200
Global Const $FR_ENABLETEMPLATEHANDLE = 0x2000
Global Const $FR_FINDNEXT = 0x8
Global Const $FR_HIDEUPDOWN = 0x4000
Global Const $FR_HIDEMATCHCASE = 0x8000
Global Const $FR_HIDEWHOLEWORD = 0x10000
Global Const $FR_MATCHCASE = 0x4
Global Const $FR_NOMATCHCASE = 0x800
Global Const $FR_NOUPDOWN = 0x400
Global Const $FR_NOWHOLEWORD = 0x1000
Global Const $FR_REPLACE = 0x10
Global Const $FR_REPLACEALL = 0x20
Global Const $FR_SHOWHELP = 0x80
Global Const $FR_WHOLEWORD = 0x2
Global Const $SHFMT_ID_DEFAULT = 0xffff
Global Const $SHFMT_OPT_FULL = 0x0
Global Const $SHFMT_OPT_QUICKFORMAT = 0x1
Global Const $SHFMT_OPT_SYSONLY = 0x2
Global Const $SHFMT_ERROR = + -1
Global Const $SHFMT_CANCEL = + -2
Global Const $SHFMT_NOFORMAT = + -3
Global Const $CDM_FIRST = $__DLG_WM_USER + 0x64
Global Const $CDM_GETSPEC = $CDM_FIRST
Global Const $CDM_GETFILEPATH = $CDM_FIRST + 0x1
Global Const $CDM_GETFOLDERPATH = $CDM_FIRST + 0x2
Global Const $CDM_GETFOLDERIDLIST = $CDM_FIRST + 0x3
Global Const $CDM_SETCONTROLTEXT = $CDM_FIRST + 0x4
Global Const $CDM_HIDECONTROL = $CDM_FIRST + 0x5
Global Const $CDM_SETDEFEXT = $CDM_FIRST + 0x6
Global Const $CDM_LAST = $__DLG_WM_USER + 0xc8
Global Const $CDN_FIRST = + -601
Global Const $CDN_INITDONE = $CDN_FIRST
Global Const $CDN_SELCHANGE = $CDN_FIRST + -1
Global Const $CDN_FOLDERCHANGE = $CDN_FIRST + -2
Global Const $CDN_SHAREVIOLATION = $CDN_FIRST + -3
Global Const $CDN_HELP = $CDN_FIRST + -4
Global Const $CDN_FILEOK = $CDN_FIRST + -5
Global Const $CDN_TYPECHANGE = $CDN_FIRST + -6
Global Const $CDN_INCLUDEITEM = $CDN_FIRST + -7
Global Const $CDN_LAST = + -699
Global Const $PSD_DEFAULTMINMARGINS = 0x0
Global Const $PSD_DISABLEMARGINS = 0x10
Global Const $PSD_DISABLEORIENTATION = 0x100
Global Const $PSD_DISABLEPAGEPAINTING = 0x80000
Global Const $PSD_DISABLEPAPER = 0x200
Global Const $PSD_DISABLEPRINTER = 0x20
Global Const $PSD_ENABLEPAGEPAINTHOOK = 0x40000
Global Const $PSD_ENABLEPAGESETUPHOOK = 0x2000
Global Const $PSD_ENABLEPAGESETUPTEMPLATE = 0x8000
Global Const $PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 0x20000
Global Const $PSD_INHUNDREDTHSOFMILLIMETERS = 0x8
Global Const $PSD_INTHOUSANDTHSOFINCHES = 0x4
Global Const $PSD_MARGINS = 0x2
Global Const $PSD_MINMARGINS = 0x1
Global Const $PSD_NONETWORKBUTTON = 0x200000
Global Const $PSD_NOWARNING = 0x80
Global Const $PSD_RETURNDEFAULT = 0x400
Global Const $PSD_SHOWHELP = 0x800
Global Const $WM_PSD_PAGESETUPDLG = $__DLG_WM_USER
Global Const $WM_PSD_FULLPAGERECT = $__DLG_WM_USER + 0x1
Global Const $WM_PSD_MINMARGINRECT = $__DLG_WM_USER + 0x2
Global Const $WM_PSD_MARGINRECT = $__DLG_WM_USER + 0x3
Global Const $WM_PSD_GREEKTEXTRECT = $__DLG_WM_USER + 0x4
Global Const $WM_PSD_ENVSTAMPRECT = $__DLG_WM_USER + 0x5
Global Const $WM_PSD_YAFULLPAGERECT = $__DLG_WM_USER + 0x6
Global Const $PD_ALLPAGES = 0x0
Global Const $PD_COLLATE = 0x10
Global Const $PD_CURRENTPAGE = 0x400000
Global Const $PD_DISABLEPRINTTOFILE = 0x80000
Global Const $PD_ENABLEPRINTHOOK = 0x1000
Global Const $PD_ENABLEPRINTTEMPLATE = 0x4000
Global Const $PD_ENABLEPRINTTEMPLATEHANDLE = 0x10000
Global Const $PD_ENABLESETUPHOOK = 0x2000
Global Const $PD_ENABLESETUPTEMPLATE = 0x8000
Global Const $PD_ENABLESETUPTEMPLATEHANDLE = 0x20000
Global Const $PD_EXCLUSIONFLAGS = 0x1000000
Global Const $PD_HIDEPRINTTOFILE = 0x100000
Global Const $PD_NOCURRENTPAGE = 0x800000
Global Const $PD_NONETWORKBUTTON = 0x200000
Global Const $PD_NOPAGENUMS = 0x8
Global Const $PD_NOSELECTION = 0x4
Global Const $PD_NOWARNING = 0x80
Global Const $PD_PAGENUMS = 0x2
Global Const $PD_PRINTSETUP = 0x40
Global Const $PD_PRINTTOFILE = 0x20
Global Const $PD_RETURNDC = 0x100
Global Const $PD_RETURNDEFAULT = 0x400
Global Const $PD_RETURNIC = 0x200
Global Const $PD_SELECTION = 0x1
Global Const $PD_SHOWHELP = 0x800
Global Const $PD_USEDEVMODECOPIES = 0x40000
Global Const $PD_USEDEVMODECOPIESANDCOLLATE = $PD_USEDEVMODECOPIES
Global Const $PD_USELARGETEMPLATE = 0x10000000
Global Const $PD_RESULT_APPLY = 0x2
Global Const $PD_RESULT_CANCEL = 0x0
Global Const $PD_RESULT_PRINT = 0x1
Global Const $EWX_LOGOFF = 0x0
Global Const $EWX_POWEROFF = 0x8
Global Const $EWX_REBOOT = 0x2
Global Const $EWX_SHUTDOWN = 0x1
Global Const $EWX_FORCE = 0x4
Global Const $EWX_FORCEIFHUNG = 0x10
Global Const $OAIF_ALLOW_REGISTRATION = 0x1
Global Const $OAIF_REGISTER_EXT = 0x2
Global Const $OAIF_EXEC = 0x4
Global Const $OAIF_FORCE_REGISTRATION = 0x8
Global Const $OAIF_HIDE_REGISTRATION = 0x20
Global Const $OAIF_URL_PROTOCOL = 0x40
Global Const $CREDUI_FLAGS_ALWAYS_SHOW_UI = 0x80
Global Const $CREDUI_FLAGS_COMPLETE_USERNAME = 0x800
Global Const $CREDUI_FLAGS_DO_NOT_PERSIST = 0x2
Global Const $CREDUI_FLAGS_EXCLUDE_CERTIFICATES = 0x8
Global Const $CREDUI_FLAGS_EXPECT_CONFIRMATION = 0x20000
Global Const $CREDUI_FLAGS_GENERIC_CREDENTIALS = 0x40000
Global Const $CREDUI_FLAGS_INCORRECT_PASSWORD = 0x1
Global Const $CREDUI_FLAGS_KEEP_USERNAME = 0x100000
Global Const $CREDUI_FLAGS_PASSWORD_ONLY_OK = 0x200
Global Const $CREDUI_FLAGS_PERSIST = 0x1000
Global Const $CREDUI_FLAGS_REQUEST_ADMINISTRATOR = 0x4
Global Const $CREDUI_FLAGS_REQUIRE_CERTIFICATE = 0x10
Global Const $CREDUI_FLAGS_REQUIRE_SMARTCARD = 0x100
Global Const $CREDUI_FLAGS_SERVER_CREDENTIAL = 0x4000
Global Const $CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX = 0x40
Global Const $CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS = 0x80000
Global Const $CREDUI_FLAGS_VALIDATE_USERNAME = 0x400
Global Const $CREDUIWIN_AUTHPACKAGE_ONLY = 0x10
Global Const $CREDUIWIN_CHECKBOX = 0x2
Global Const $CREDUIWIN_ENUMERATE_ADMINS = 0x100
Global Const $CREDUIWIN_ENUMERATE_CURRENT_USER = 0x200
Global Const $CREDUIWIN_GENERIC = 0x1
Global Const $CREDUIWIN_IN_CRED_ONLY = 0x20
Global Const $CREDUIWIN_SECURE_PROMPT = 0x1000
Global Const $CREDUIWIN_PACK_32_WOW = 0x10000000
Global Const $CREDUIWIN_PREPROMPTING = 0x2000
Global Const $BACKUP_ALTERNATE_DATA = 0x4
Global Const $BACKUP_DATA = 0x1
Global Const $BACKUP_EA_DATA = 0x2
Global Const $BACKUP_LINK = 0x5
Global Const $BACKUP_OBJECT_ID = 0x7
Global Const $BACKUP_PROPERTY_DATA = 0x6
Global Const $BACKUP_REPARSE_DATA = 0x8
Global Const $BACKUP_SECURITY_DATA = 0x3
Global Const $BACKUP_SPARSE_BLOCK = 0x9
Global Const $BACKUP_TXFS_DATA = 0xa
Global Const $COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 0x8
Global Const $COPY_FILE_COPY_SYMLINK = 0x800
Global Const $COPY_FILE_FAIL_IF_EXISTS = 0x1
Global Const $COPY_FILE_NO_BUFFERING = 0x1000
Global Const $COPY_FILE_OPEN_SOURCE_FOR_WRITE = 0x4
Global Const $COPY_FILE_RESTARTABLE = 0x2
Global Const $MOVE_FILE_COPY_ALLOWED = 0x2
Global Const $MOVE_FILE_CREATE_HARDLINK = 0x10
Global Const $MOVE_FILE_DELAY_UNTIL_REBOOT = 0x4
Global Const $MOVE_FILE_FAIL_IF_NOT_TRACKABLE = 0x20
Global Const $MOVE_FILE_REPLACE_EXISTING = 0x1
Global Const $MOVE_FILE_WRITE_THROUGH = 0x8
Global Const $PROGRESS_CONTINUE = 0x0
Global Const $PROGRESS_CANCEL = 0x1
Global Const $PROGRESS_STOP = 0x2
Global Const $PROGRESS_QUIET = 0x3
Global Const $FILE_APPEND_DATA = 0x4
Global Const $FILE_DELETE_CHILD = 0x40
Global Const $FILE_EXECUTE = 0x20
Global Const $FILE_READ_ATTRIBUTES = 0x80
Global Const $FILE_READ_DATA = 0x1
Global Const $FILE_READ_EA = 0x8
Global Const $FILE_WRITE_ATTRIBUTES = 0x100
Global Const $FILE_WRITE_DATA = 0x2
Global Const $FILE_WRITE_EA = 0x10
Global Const $FILE_ADD_FILE = $FILE_WRITE_DATA
Global Const $FILE_ADD_SUBDIRECTORY = $FILE_APPEND_DATA
Global Const $FILE_CREATE_PIPE_INSTANCE = $FILE_APPEND_DATA
Global Const $FILE_LIST_DIRECTORY = $FILE_READ_DATA
Global Const $FILE_TRAVERSE = $FILE_EXECUTE
Global Const $FILE_ALL_ACCESS = 0x1f01ff
Global Const $FILE_FLAG_BACKUP_SEMANTICS = 0x2000000
Global Const $FILE_FLAG_DELETE_ON_CLOSE = 0x4000000
Global Const $FILE_FLAG_NO_BUFFERING = 0x20000000
Global Const $FILE_FLAG_OPEN_NO_RECALL = 0x100000
Global Const $FILE_FLAG_OPEN_REPARSE_POINT = 0x200000
Global Const $FILE_FLAG_OVERLAPPED = 0x40000000
Global Const $FILE_FLAG_POSIX_SEMANTICS = 0x100000
Global Const $FILE_FLAG_RANDOM_ACCESS = 0x10000000
Global Const $FILE_FLAG_SEQUENTIAL_SCAN = 0x8000000
Global Const $FILE_FLAG_WRITE_THROUGH = -2147483648
Global Const $SECURITY_ANONYMOUS = 0x0
Global Const $SECURITY_CONTEXT_TRACKING = 0x40000
Global Const $SECURITY_DELEGATION = 0x30000
Global Const $SECURITY_EFFECTIVE_ONLY = 0x80000
Global Const $SECURITY_IDENTIFICATION = 0x10000
Global Const $SECURITY_IMPERSONATION = 0x20000
Global Const $SEC_COMMIT = 0x8000000
Global Const $SEC_IMAGE = 0x1000000
Global Const $SEC_LARGE_PAGES = -2147483648
Global Const $SEC_NOCACHE = 0x10000000
Global Const $SEC_RESERVE = 0x4000000
Global Const $SEC_WRITECOMBINE = 0x40000000
Global Const $SECTION_EXTEND_SIZE = 0x10
Global Const $SECTION_MAP_EXECUTE = 0x8
Global Const $SECTION_MAP_READ = 0x4
Global Const $SECTION_MAP_WRITE = 0x2
Global Const $SECTION_QUERY = 0x1
Global Const $SECTION_ALL_ACCESS = 0x1f001f
Global Const $FILE_MAP_COPY = 0x1
Global Const $FILE_MAP_EXECUTE = 0x20
Global Const $FILE_MAP_READ = 0x4
Global Const $FILE_MAP_WRITE = 0x2
Global Const $FILE_MAP_ALL_ACCESS = $SECTION_ALL_ACCESS
Global Const $DDD_EXACT_MATCH_ON_REMOVE = 0x4
Global Const $DDD_NO_BROADCAST_SYSTEM = 0x8
Global Const $DDD_RAW_TARGET_PATH = 0x1
Global Const $DDD_REMOVE_DEFINITION = 0x2
Global Const $FSCTL_ALLOW_EXTENDED_DASD_IO = 0x90083
Global Const $FSCTL_CREATE_OR_GET_OBJECT_ID = 0x900c0
Global Const $FSCTL_CREATE_USN_JOURNAL = 0x900e7
Global Const $FSCTL_DELETE_OBJECT_ID = 0x900a0
Global Const $FSCTL_DELETE_REPARSE_POINT = 0x900ac
Global Const $FSCTL_DELETE_USN_JOURNAL = 0x900f8
Global Const $FSCTL_DISMOUNT_VOLUME = 0x90020
Global Const $FSCTL_DUMP_PROPERTY_DATA = 0x90097
Global Const $FSCTL_ENABLE_UPGRADE = 0x980d0
Global Const $FSCTL_ENCRYPTION_FSCTL_IO = 0x900db
Global Const $FSCTL_ENUM_USN_DATA = 0x900b3
Global Const $FSCTL_EXTEND_VOLUME = 0x900f0
Global Const $FSCTL_FILESYSTEM_GET_STATISTICS = 0x90060
Global Const $FSCTL_FIND_FILES_BY_SID = 0x9008f
Global Const $FSCTL_GET_COMPRESSION = 0x9003c
Global Const $FSCTL_GET_NTFS_FILE_RECORD = 0x90068
Global Const $FSCTL_GET_NTFS_VOLUME_DATA = 0x90064
Global Const $FSCTL_GET_OBJECT_ID = 0x9009c
Global Const $FSCTL_GET_REPARSE_POINT = 0x900a8
Global Const $FSCTL_GET_RETRIEVAL_POINTERS = 0x90073
Global Const $FSCTL_GET_VOLUME_BITMAP = 0x9006f
Global Const $FSCTL_HSM_DATA = 0x9c113
Global Const $FSCTL_HSM_MSG = 0x9c108
Global Const $FSCTL_INVALIDATE_VOLUMES = 0x90054
Global Const $FSCTL_IS_PATHNAME_VALID = 0x9002c
Global Const $FSCTL_IS_VOLUME_DIRTY = 0x90078
Global Const $FSCTL_IS_VOLUME_MOUNTED = 0x90028
Global Const $FSCTL_LOCK_VOLUME = 0x90018
Global Const $FSCTL_MARK_AS_SYSTEM_HIVE = 0x9004f
Global Const $FSCTL_MARK_HANDLE = 0x900fc
Global Const $FSCTL_MARK_VOLUME_DIRTY = 0x90030
Global Const $FSCTL_MOVE_FILE = 0x90074
Global Const $FSCTL_OPBATCH_ACK_CLOSE_PENDING = 0x90010
Global Const $FSCTL_OPLOCK_BREAK_ACK_NO_2 = 0x90050
Global Const $FSCTL_OPLOCK_BREAK_ACKNOWLEDGE = 0x9000c
Global Const $FSCTL_OPLOCK_BREAK_NOTIFY = 0x90014
Global Const $FSCTL_QUERY_ALLOCATED_RANGES = 0x940cf
Global Const $FSCTL_QUERY_FAT_BPB = 0x90058
Global Const $FSCTL_QUERY_RETRIEVAL_POINTERS = 0x9003b
Global Const $FSCTL_QUERY_USN_JOURNAL = 0x900f4
Global Const $FSCTL_READ_FILE_USN_DATA = 0x900eb
Global Const $FSCTL_READ_PROPERTY_DATA = 0x90087
Global Const $FSCTL_READ_RAW_ENCRYPTED = 0x900e3
Global Const $FSCTL_READ_USN_JOURNAL = 0x900bb
Global Const $FSCTL_RECALL_FILE = 0x90117
Global Const $FSCTL_REQUEST_BATCH_OPLOCK = 0x90008
Global Const $FSCTL_REQUEST_FILTER_OPLOCK = 0x9005c
Global Const $FSCTL_REQUEST_OPLOCK_LEVEL_1 = 0x90000
Global Const $FSCTL_REQUEST_OPLOCK_LEVEL_2 = 0x90004
Global Const $FSCTL_SECURITY_ID_CHECK = 0x940b7
Global Const $FSCTL_SET_COMPRESSION = 0x9c040
Global Const $FSCTL_SET_ENCRYPTION = 0x900d7
Global Const $FSCTL_SET_OBJECT_ID = 0x90098
Global Const $FSCTL_SET_OBJECT_ID_EXTENDED = 0x900bc
Global Const $FSCTL_SET_REPARSE_POINT = 0x900a4
Global Const $FSCTL_SET_SPARSE = 0x900c4
Global Const $FSCTL_SET_ZERO_DATA = 0x980c8
Global Const $FSCTL_SIS_COPYFILE = 0x90100
Global Const $FSCTL_SIS_LINK_FILES = 0x9c104
Global Const $FSCTL_UNLOCK_VOLUME = 0x9001c
Global Const $FSCTL_WRITE_PROPERTY_DATA = 0x9008b
Global Const $FSCTL_WRITE_RAW_ENCRYPTED = 0x900df
Global Const $FSCTL_WRITE_USN_CLOSE_RECORD = 0x900ef
Global Const $IOCTL_AACS_END_SESSION = 0x3350cc
Global Const $IOCTL_AACS_GENERATE_BINDING_NONCE = 0x33d0f0
Global Const $IOCTL_AACS_GET_CERTIFICATE = 0x3350d4
Global Const $IOCTL_AACS_GET_CHALLENGE_KEY = 0x3350d8
Global Const $IOCTL_AACS_READ_BINDING_NONCE = 0x3350ec
Global Const $IOCTL_AACS_READ_MEDIA_ID = 0x3350e8
Global Const $IOCTL_AACS_READ_MEDIA_KEY_BLOCK = 0x3350c4
Global Const $IOCTL_AACS_READ_MEDIA_KEY_BLOCK_SIZE = 0x3350c0
Global Const $IOCTL_AACS_READ_SERIAL_NUMBER = 0x3350e4
Global Const $IOCTL_AACS_READ_VOLUME_ID = 0x3350e0
Global Const $IOCTL_AACS_SEND_CERTIFICATE = 0x3350d0
Global Const $IOCTL_AACS_SEND_CHALLENGE_KEY = 0x3350dc
Global Const $IOCTL_AACS_START_SESSION = 0x3350c8
Global Const $IOCTL_ATA_PASS_THROUGH = 0x4d02c
Global Const $IOCTL_ATA_PASS_THROUGH_DIRECT = 0x4d030
Global Const $IOCTL_CDROM_CHECK_VERIFY = 0x24800
Global Const $IOCTL_CDROM_DISK_TYPE = 0x20040
Global Const $IOCTL_CDROM_EJECT_MEDIA = 0x24808
Global Const $IOCTL_CDROM_FIND_NEW_DEVICES = 0x24818
Global Const $IOCTL_CDROM_GET_CONFIGURATION = 0x24058
Global Const $IOCTL_CDROM_GET_CONTROL = 0x24034
Global Const $IOCTL_CDROM_GET_DRIVE_GEOMETRY = 0x2404c
Global Const $IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX = 0x24050
Global Const $IOCTL_CDROM_GET_LAST_SESSION = 0x24038
Global Const $IOCTL_CDROM_GET_VOLUME = 0x24014
Global Const $IOCTL_CDROM_LOAD_MEDIA = 0x2480c
Global Const $IOCTL_CDROM_MEDIA_REMOVAL = 0x24804
Global Const $IOCTL_CDROM_PAUSE_AUDIO = 0x2400c
Global Const $IOCTL_CDROM_PLAY_AUDIO_MSF = 0x24018
Global Const $IOCTL_CDROM_RAW_READ = 0x2403e
Global Const $IOCTL_CDROM_READ_Q_CHANNEL = 0x2402c
Global Const $IOCTL_CDROM_READ_TOC = 0x24000
Global Const $IOCTL_CDROM_READ_TOC_EX = 0x24054
Global Const $IOCTL_CDROM_RELEASE = 0x24814
Global Const $IOCTL_CDROM_RESERVE = 0x24810
Global Const $IOCTL_CDROM_RESUME_AUDIO = 0x24010
Global Const $IOCTL_CDROM_SEEK_AUDIO_MSF = 0x24004
Global Const $IOCTL_CDROM_SET_VOLUME = 0x24028
Global Const $IOCTL_CDROM_STOP_AUDIO = 0x24008
Global Const $IOCTL_CDROM_UNLOAD_DRIVER = 0x25008
Global Const $IOCTL_DISK_CHECK_VERIFY = 0x74800
Global Const $IOCTL_DISK_CONTROLLER_NUMBER = 0x70044
Global Const $IOCTL_DISK_CREATE_DISK = 0x7c058
Global Const $IOCTL_DISK_DELETE_DRIVE_LAYOUT = 0x7c100
Global Const $IOCTL_DISK_EJECT_MEDIA = 0x74808
Global Const $IOCTL_DISK_FIND_NEW_DEVICES = 0x74818
Global Const $IOCTL_DISK_FORMAT_TRACKS = 0x7c018
Global Const $IOCTL_DISK_FORMAT_TRACKS_EX = 0x7c02c
Global Const $IOCTL_DISK_GET_CACHE_INFORMATION = 0x740d4
Global Const $IOCTL_DISK_GET_DRIVE_GEOMETRY = 0x70000
Global Const $IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = 0x700a0
Global Const $IOCTL_DISK_GET_DRIVE_LAYOUT = 0x7400c
Global Const $IOCTL_DISK_GET_DRIVE_LAYOUT_EX = 0x70050
Global Const $IOCTL_DISK_GET_LENGTH_INFO = 0x7405c
Global Const $IOCTL_DISK_GET_MEDIA_TYPES = 0x70c00
Global Const $IOCTL_DISK_GET_PARTITION_INFO = 0x74004
Global Const $IOCTL_DISK_GET_PARTITION_INFO_EX = 0x70048
Global Const $IOCTL_DISK_GET_WRITE_CACHE_STATE = 0x740dc
Global Const $IOCTL_DISK_GROW_PARTITION = 0x7c0d0
Global Const $IOCTL_DISK_HISTOGRAM_DATA = 0x70034
Global Const $IOCTL_DISK_HISTOGRAM_RESET = 0x70038
Global Const $IOCTL_DISK_HISTOGRAM_STRUCTURE = 0x70030
Global Const $IOCTL_DISK_INTERNAL_CLEAR_VERIFY = 0x70407
Global Const $IOCTL_DISK_INTERNAL_SET_NOTIFY = 0x70408
Global Const $IOCTL_DISK_INTERNAL_SET_VERIFY = 0x70403
Global Const $IOCTL_DISK_IS_WRITABLE = 0x70024
Global Const $IOCTL_DISK_LOAD_MEDIA = 0x7480c
Global Const $IOCTL_DISK_LOGGING = 0x70028
Global Const $IOCTL_DISK_MEDIA_REMOVAL = 0x74804
Global Const $IOCTL_DISK_PERFORMANCE = 0x70020
Global Const $IOCTL_DISK_PERFORMANCE_OFF = 0x70060
Global Const $IOCTL_DISK_REASSIGN_BLOCKS = 0x7c01c
Global Const $IOCTL_DISK_RELEASE = 0x74814
Global Const $IOCTL_DISK_REQUEST_DATA = 0x70040
Global Const $IOCTL_DISK_REQUEST_STRUCTURE = 0x7003c
Global Const $IOCTL_DISK_RESERVE = 0x74810
Global Const $IOCTL_DISK_SET_CACHE_INFORMATION = 0x7c0d8
Global Const $IOCTL_DISK_SET_DRIVE_LAYOUT = 0x7c010
Global Const $IOCTL_DISK_SET_DRIVE_LAYOUT_EX = 0x7c054
Global Const $IOCTL_DISK_SET_PARTITION_INFO = 0x7c008
Global Const $IOCTL_DISK_SET_PARTITION_INFO_EX = 0x7c04c
Global Const $IOCTL_DISK_UPDATE_DRIVE_SIZE = 0x7c0c8
Global Const $IOCTL_DISK_UPDATE_PROPERTIES = 0x70140
Global Const $IOCTL_DISK_VERIFY = 0x70014
Global Const $IOCTL_DVD_END_SESSION = 0x33500c
Global Const $IOCTL_DVD_GET_REGION = 0x335014
Global Const $IOCTL_DVD_READ_KEY = 0x335004
Global Const $IOCTL_DVD_READ_STRUCTURE = 0x335140
Global Const $IOCTL_DVD_SEND_KEY = 0x335008
Global Const $IOCTL_DVD_SEND_KEY2 = 0x33d018
Global Const $IOCTL_DVD_SET_READ_AHEAD = 0x335010
Global Const $IOCTL_DVD_START_SESSION = 0x335000
Global Const $IOCTL_MOUNTDEV_LINK_CREATED = 0x4d0010
Global Const $IOCTL_MOUNTDEV_LINK_DELETED = 0x4d0014
Global Const $IOCTL_MOUNTDEV_QUERY_STABLE_GUID = 0x4d0018
Global Const $IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME = 0x4d000c
Global Const $IOCTL_MOUNTDEV_QUERY_UNIQUE_ID = 0x4d0000
Global Const $IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY = 0x4d0004
Global Const $IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS = 0x6dc014
Global Const $IOCTL_MOUNTMGR_CHANGE_NOTIFY = 0x6d4020
Global Const $IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES = 0x6d4028
Global Const $IOCTL_MOUNTMGR_CREATE_POINT = 0x6dc000
Global Const $IOCTL_MOUNTMGR_DELETE_POINTS = 0x6dc004
Global Const $IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY = 0x6dc00c
Global Const $IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE = 0x6dc024
Global Const $IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER = 0x6dc010
Global Const $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH = 0x6d0030
Global Const $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS = 0x6d0034
Global Const $IOCTL_MOUNTMGR_QUERY_POINTS = 0x6d0008
Global Const $IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION = 0x6d402c
Global Const $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED = 0x6dc018
Global Const $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED = 0x6dc01c
Global Const $IOCTL_SCSI_GET_INQUIRY_DATA = 0x4100c
Global Const $IOCTL_SCSI_GET_CAPABILITIES = 0x41010
Global Const $IOCTL_SCSI_GET_ADDRESS = 0x41018
Global Const $IOCTL_SCSI_MINIPORT = 0x4d008
Global Const $IOCTL_SCSI_PASS_THROUGH = 0x4d004
Global Const $IOCTL_SCSI_PASS_THROUGH_DIRECT = 0x4d014
Global Const $IOCTL_SCSI_RESCAN_BUS = 0x4101c
Global Const $IOCTL_STORAGE_BREAK_RESERVATION = 0x2d5014
Global Const $IOCTL_STORAGE_CHECK_VERIFY = 0x2d4800
Global Const $IOCTL_STORAGE_CHECK_VERIFY2 = 0x2d0800
Global Const $IOCTL_STORAGE_EJECT_MEDIA = 0x2d4808
Global Const $IOCTL_STORAGE_EJECTION_CONTROL = 0x2d0940
Global Const $IOCTL_STORAGE_FIND_NEW_DEVICES = 0x2d4818
Global Const $IOCTL_STORAGE_GET_DEVICE_NUMBER = 0x2d1080
Global Const $IOCTL_STORAGE_GET_HOTPLUG_INFO = 0x2d0c14
Global Const $IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = 0x2d0c10
Global Const $IOCTL_STORAGE_GET_MEDIA_TYPES = 0x2d0c00
Global Const $IOCTL_STORAGE_GET_MEDIA_TYPES_EX = 0x2d0c04
Global Const $IOCTL_STORAGE_LOAD_MEDIA = 0x2d480c
Global Const $IOCTL_STORAGE_LOAD_MEDIA2 = 0x2d080c
Global Const $IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES = 0x2d9404
Global Const $IOCTL_STORAGE_MCN_CONTROL = 0x2d0944
Global Const $IOCTL_STORAGE_MEDIA_REMOVAL = 0x2d4804
Global Const $IOCTL_STORAGE_PERSISTENT_RESERVE_IN = 0x2d5018
Global Const $IOCTL_STORAGE_PERSISTENT_RESERVE_OUT = 0x2d501c
Global Const $IOCTL_STORAGE_PREDICT_FAILURE = 0x2d1100
Global Const $IOCTL_STORAGE_QUERY_PROPERTY = 0x2d1400
Global Const $IOCTL_STORAGE_RELEASE = 0x2d4814
Global Const $IOCTL_STORAGE_RESERVE = 0x2d4810
Global Const $IOCTL_STORAGE_RESET_BUS = 0x2d5000
Global Const $IOCTL_STORAGE_RESET_DEVICE = 0x2d5004
Global Const $IOCTL_STORAGE_SET_HOTPLUG_INFO = 0x2dcc18
Global Const $IOCTL_STORAGE_SET_READ_AHEAD = 0x2d4400
Global Const $IOCTL_VOLUME_GET_GPT_ATTRIBUTES = 0x560038
Global Const $IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = 0x560000
Global Const $IOCTL_VOLUME_IS_CLUSTERED = 0x560030
Global Const $IOCTL_VOLUME_IS_IO_CAPABLE = 0x560014
Global Const $IOCTL_VOLUME_IS_OFFLINE = 0x560010
Global Const $IOCTL_VOLUME_IS_PARTITION = 0x560028
Global Const $IOCTL_VOLUME_LOGICAL_TO_PHYSICAL = 0x560020
Global Const $IOCTL_VOLUME_OFFLINE = 0x56c00c
Global Const $IOCTL_VOLUME_ONLINE = 0x56c008
Global Const $IOCTL_VOLUME_PHYSICAL_TO_LOGICAL = 0x560024
Global Const $IOCTL_VOLUME_QUERY_FAILOVER_SET = 0x560018
Global Const $IOCTL_VOLUME_QUERY_VOLUME_NUMBER = 0x56001c
Global Const $IOCTL_VOLUME_READ_PLEX = 0x56402e
Global Const $IOCTL_VOLUME_SET_GPT_ATTRIBUTES = 0x560034
Global Const $IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE = 0x560004
Global Const $SMART_GET_VERSION = 0x74080
Global Const $SMART_RCV_DRIVE_DATA = 0x7c088
Global Const $SMART_SEND_DRIVE_COMMAND = 0x7c084
Global Const $FILE_ENCRYPTABLE = 0x0
Global Const $FILE_IS_ENCRYPTED = 0x1
Global Const $FILE_READ_ONLY = 0x8
Global Const $FILE_ROOT_DIR = 0x3
Global Const $FILE_SYSTEM_ATTR = 0x2
Global Const $FILE_SYSTEM_DIR = 0x4
Global Const $FILE_SYSTEM_NOT_SUPPORT = 0x6
Global Const $FILE_UNKNOWN = 0x5
Global Const $FILE_USER_DISALLOWED = 0x7
Global Const $SCS_32BIT_BINARY = 0x0
Global Const $SCS_64BIT_BINARY = 0x6
Global Const $SCS_DOS_BINARY = 0x1
Global Const $SCS_OS216_BINARY = 0x5
Global Const $SCS_PIF_BINARY = 0x3
Global Const $SCS_POSIX_BINARY = 0x4
Global Const $SCS_WOW_BINARY = 0x2
Global Const $DRIVE_BUS_TYPE_UNKNOWN = 0x0
Global Const $DRIVE_BUS_TYPE_SCSI = 0x1
Global Const $DRIVE_BUS_TYPE_ATAPI = 0x2
Global Const $DRIVE_BUS_TYPE_ATA = 0x3
Global Const $DRIVE_BUS_TYPE_1394 = 0x4
Global Const $DRIVE_BUS_TYPE_SSA = 0x5
Global Const $DRIVE_BUS_TYPE_FIBRE = 0x6
Global Const $DRIVE_BUS_TYPE_USB = 0x7
Global Const $DRIVE_BUS_TYPE_RAID = 0x8
Global Const $DRIVE_BUS_TYPE_ISCSI = 0x9
Global Const $DRIVE_BUS_TYPE_SAS = 0xa
Global Const $DRIVE_BUS_TYPE_SATA = 0xb
Global Const $DRIVE_BUS_TYPE_SD = 0xc
Global Const $DRIVE_BUS_TYPE_MMC = 0xd
Global Const $DRIVE_UNKNOWN = 0x0
Global Const $DRIVE_NO_ROOT_DIR = 0x1
Global Const $DRIVE_REMOVABLE = 0x2
Global Const $DRIVE_FIXED = 0x3
Global Const $DRIVE_REMOTE = 0x4
Global Const $DRIVE_CDROM = 0x5
Global Const $DRIVE_RAMDISK = 0x6
Global Const $FILE_TYPE_CHAR = 0x2
Global Const $FILE_TYPE_DISK = 0x1
Global Const $FILE_TYPE_PIPE = 0x3
Global Const $FILE_TYPE_REMOTE = 0x8000
Global Const $FILE_TYPE_UNKNOWN = 0x0
Global Const $FILE_NAME_NORMALIZED = 0x0
Global Const $FILE_NAME_OPENED = 0x8
Global Const $VOLUME_NAME_DOS = 0x0
Global Const $VOLUME_NAME_GUID = 0x1
Global Const $VOLUME_NAME_NONE = 0x4
Global Const $VOLUME_NAME_NT = 0x2
Global Const $IMAGE_FILE_MACHINE_UNKNOWN = 0x0
Global Const $IMAGE_FILE_MACHINE_AM33 = 0x1d3
Global Const $IMAGE_FILE_MACHINE_AMD64 = 0x8664
Global Const $IMAGE_FILE_MACHINE_ARM = 0x1c0
Global Const $IMAGE_FILE_MACHINE_EBC = 0xebc
Global Const $IMAGE_FILE_MACHINE_I386 = 0x14c
Global Const $IMAGE_FILE_MACHINE_IA64 = 0x200
Global Const $IMAGE_FILE_MACHINE_M32R = 0x9041
Global Const $IMAGE_FILE_MACHINE_MIPS16 = 0x266
Global Const $IMAGE_FILE_MACHINE_MIPSFPU = 0x366
Global Const $IMAGE_FILE_MACHINE_MIPSFPU16 = 0x466
Global Const $IMAGE_FILE_MACHINE_POWERPC = 0x1f0
Global Const $IMAGE_FILE_MACHINE_POWERPCFP = 0x1f1
Global Const $IMAGE_FILE_MACHINE_R4000 = 0x166
Global Const $IMAGE_FILE_MACHINE_SH3 = 0x1a2
Global Const $IMAGE_FILE_MACHINE_SH3DSP = 0x1a3
Global Const $IMAGE_FILE_MACHINE_SH4 = 0x1a6
Global Const $IMAGE_FILE_MACHINE_SH5 = 0x1a8
Global Const $IMAGE_FILE_MACHINE_THUMB = 0x1c2
Global Const $IMAGE_FILE_MACHINE_WCEMIPSV2 = 0x169
Global Const $FILE_CASE_PRESERVED_NAMES = 0x2
Global Const $FILE_CASE_SENSITIVE_SEARCH = 0x1
Global Const $FILE_FILE_COMPRESSION = 0x10
Global Const $FILE_NAMED_STREAMS = 0x40000
Global Const $FILE_PERSISTENT_ACLS = 0x8
Global Const $FILE_READ_ONLY_VOLUME = 0x80000
Global Const $FILE_SEQUENTIAL_WRITE_ONCE = 0x100000
Global Const $FILE_SUPPORTS_ENCRYPTION = 0x20000
Global Const $FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 0x800000
Global Const $FILE_SUPPORTS_HARD_LINKS = 0x400000
Global Const $FILE_SUPPORTS_OBJECT_IDS = 0x10000
Global Const $FILE_SUPPORTS_OPEN_BY_FILE_ID = 0x1000000
Global Const $FILE_SUPPORTS_REPARSE_POINTS = 0x80
Global Const $FILE_SUPPORTS_SPARSE_FILES = 0x40
Global Const $FILE_SUPPORTS_TRANSACTIONS = 0x200000
Global Const $FILE_SUPPORTS_USN_JOURNAL = 0x2000000
Global Const $FILE_UNICODE_ON_DISK = 0x4
Global Const $FILE_VOLUME_IS_COMPRESSED = 0x8000
Global Const $FILE_VOLUME_QUOTAS = 0x20
Global Const $FILE_DEVICE_8042_PORT = 0x27
Global Const $FILE_DEVICE_ACPI = 0x32
Global Const $FILE_DEVICE_BATTERY = 0x29
Global Const $FILE_DEVICE_BEEP = 0x1
Global Const $FILE_DEVICE_BUS_EXTENDER = 0x2a
Global Const $FILE_DEVICE_CD_ROM = 0x2
Global Const $FILE_DEVICE_CD_ROM_FILE_SYSTEM = 0x3
Global Const $FILE_DEVICE_CHANGER = 0x30
Global Const $FILE_DEVICE_CONTROLLER = 0x4
Global Const $FILE_DEVICE_DATALINK = 0x5
Global Const $FILE_DEVICE_DFS = 0x6
Global Const $FILE_DEVICE_DFS_FILE_SYSTEM = 0x35
Global Const $FILE_DEVICE_DFS_VOLUME = 0x36
Global Const $FILE_DEVICE_DISK = 0x7
Global Const $FILE_DEVICE_DISK_FILE_SYSTEM = 0x8
Global Const $FILE_DEVICE_DVD = 0x33
Global Const $FILE_DEVICE_FILE_SYSTEM = 0x9
Global Const $FILE_DEVICE_FIPS = 0x3a
Global Const $FILE_DEVICE_FULLSCREEN_VIDEO = 0x34
Global Const $FILE_DEVICE_INPORT_PORT = 0xa
Global Const $FILE_DEVICE_KEYBOARD = 0xb
Global Const $FILE_DEVICE_KS = 0x2f
Global Const $FILE_DEVICE_KSEC = 0x39
Global Const $FILE_DEVICE_MAILSLOT = 0xc
Global Const $FILE_DEVICE_MASS_STORAGE = 0x2d
Global Const $FILE_DEVICE_MIDI_IN = 0xd
Global Const $FILE_DEVICE_MIDI_OUT = 0xe
Global Const $FILE_DEVICE_MODEM = 0x2b
Global Const $FILE_DEVICE_MOUSE = 0xf
Global Const $FILE_DEVICE_MULTI_UNC_PROVIDER = 0x10
Global Const $FILE_DEVICE_NAMED_PIPE = 0x11
Global Const $FILE_DEVICE_NETWORK = 0x12
Global Const $FILE_DEVICE_NETWORK_BROWSER = 0x13
Global Const $FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x14
Global Const $FILE_DEVICE_NETWORK_REDIRECTOR = 0x28
Global Const $FILE_DEVICE_NULL = 0x15
Global Const $FILE_DEVICE_PARALLEL_PORT = 0x16
Global Const $FILE_DEVICE_PHYSICAL_NETCARD = 0x17
Global Const $FILE_DEVICE_PRINTER = 0x18
Global Const $FILE_DEVICE_SCANNER = 0x19
Global Const $FILE_DEVICE_SCREEN = 0x1c
Global Const $FILE_DEVICE_SERENUM = 0x37
Global Const $FILE_DEVICE_SERIAL_MOUSE_PORT = 0x1a
Global Const $FILE_DEVICE_SERIAL_PORT = 0x1b
Global Const $FILE_DEVICE_SMARTCARD = 0x31
Global Const $FILE_DEVICE_SMB = 0x2e
Global Const $FILE_DEVICE_SOUND = 0x1d
Global Const $FILE_DEVICE_STREAMS = 0x1e
Global Const $FILE_DEVICE_TAPE = 0x1f
Global Const $FILE_DEVICE_TAPE_FILE_SYSTEM = 0x20
Global Const $FILE_DEVICE_TERMSRV = 0x38
Global Const $FILE_DEVICE_TRANSPORT = 0x21
Global Const $FILE_DEVICE_UNKNOWN = 0x22
Global Const $FILE_DEVICE_VDM = 0x2c
Global Const $FILE_DEVICE_VIDEO = 0x23
Global Const $FILE_DEVICE_VIRTUAL_DISK = 0x24
Global Const $FILE_DEVICE_WAVE_IN = 0x25
Global Const $FILE_DEVICE_WAVE_OUT = 0x26
Global Const $FILE_ANY_ACCESS = 0x0
Global Const $FILE_SPECIAL_ACCESS = $FILE_ANY_ACCESS
Global Const $FILE_READ_ACCESS = 0x1
Global Const $FILE_WRITE_ACCESS = 0x2
Global Const $METHOD_BUFFERED = 0x0
Global Const $METHOD_IN_DIRECT = 0x1
Global Const $METHOD_OUT_DIRECT = 0x2
Global Const $METHOD_NEITHER = 0x3
Global Const $FILE_NOTIFY_CHANGE_FILE_NAME = 0x1
Global Const $FILE_NOTIFY_CHANGE_DIR_NAME = 0x2
Global Const $FILE_NOTIFY_CHANGE_ATTRIBUTES = 0x4
Global Const $FILE_NOTIFY_CHANGE_SIZE = 0x8
Global Const $FILE_NOTIFY_CHANGE_LAST_WRITE = 0x10
Global Const $FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x20
Global Const $FILE_NOTIFY_CHANGE_CREATION = 0x40
Global Const $FILE_NOTIFY_CHANGE_SECURITY = 0x100
Global Const $FILE_ACTION_ADDED = 0x1
Global Const $FILE_ACTION_REMOVED = 0x2
Global Const $FILE_ACTION_MODIFIED = 0x3
Global Const $FILE_ACTION_RENAMED_OLD_NAME = 0x4
Global Const $FILE_ACTION_RENAMED_NEW_NAME = 0x5
Global Const $REPLACEFILE_WRITE_THROUGH = 0x1
Global Const $REPLACEFILE_IGNORE_MERGE_ERRORS = 0x2
Global Const $REPLACEFILE_IGNORE_ACL_ERRORS = 0x4
Global Const $BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = 0x1
Global Const $BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = 0x10000
Global Const $BASE_SEARCH_PATH_PERMANENT = 0x8000
Global Const $FR_PRIVATE = 0x10
Global Const $FR_NOT_ENUM = 0x20
Global Const $COMPRESSION_BITMAP_PNG = 0x0
Global Const $COMPRESSION_BITMAP_JPEG = 0x1
Global Const $BS_DIBPATTERN = 0x5
Global Const $BS_DIBPATTERN8X8 = 0x8
Global Const $BS_DIBPATTERNPT = 0x6
Global Const $BS_HATCHED = 0x2
Global Const $BS_HOLLOW = 0x1
Global Const $BS_NULL = 0x1
Global Const $BS_PATTERN = 0x3
Global Const $BS_PATTERN8X8 = 0x7
Global Const $BS_SOLID = 0x0
Global Const $HS_BDIAGONAL = 0x3
Global Const $HS_CROSS = 0x4
Global Const $HS_DIAGCROSS = 0x5
Global Const $HS_FDIAGONAL = 0x2
Global Const $HS_HORIZONTAL = 0x0
Global Const $HS_VERTICAL = 0x1
Global Const $DIB_PAL_COLORS = 0x1
Global Const $DIB_RGB_COLORS = 0x0
Global Const $CA_NEGATIVE = 0x1
Global Const $CA_LOG_FILTER = 0x2
Global Const $ILLUMINANT_DEVICE_DEFAULT = 0x0
Global Const $ILLUMINANT_A = 0x1
Global Const $ILLUMINANT_B = 0x2
Global Const $ILLUMINANT_C = 0x3
Global Const $ILLUMINANT_D50 = 0x4
Global Const $ILLUMINANT_D55 = 0x5
Global Const $ILLUMINANT_D65 = 0x6
Global Const $ILLUMINANT_D75 = 0x7
Global Const $ILLUMINANT_F2 = 0x8
Global Const $ILLUMINANT_TUNGSTEN = $ILLUMINANT_A
Global Const $ILLUMINANT_DAYLIGHT = $ILLUMINANT_C
Global Const $ILLUMINANT_FLUORESCENT = $ILLUMINANT_F2
Global Const $ILLUMINANT_NTSC = $ILLUMINANT_C
Global Const $BI_RGB = 0x0
Global Const $BI_RLE8 = 0x1
Global Const $BI_RLE4 = 0x2
Global Const $BI_BITFIELDS = 0x3
Global Const $BI_JPEG = 0x4
Global Const $BI_PNG = 0x5
Global Const $ALTERNATE = 0x1
Global Const $WINDING = 0x2
Global Const $DWMWA_NCRENDERING_ENABLED = 0x1
Global Const $DWMWA_NCRENDERING_POLICY = 0x2
Global Const $DWMWA_TRANSITIONS_FORCEDISABLED = 0x3
Global Const $DWMWA_ALLOW_NCPAINT = 0x4
Global Const $DWMWA_CAPTION_BUTTON_BOUNDS = 0x5
Global Const $DWMWA_NONCLIENT_RTL_LAYOUT = 0x6
Global Const $DWMWA_FORCE_ICONIC_REPRESENTATION = 0x7
Global Const $DWMWA_FLIP3D_POLICY = 0x8
Global Const $DWMWA_EXTENDED_FRAME_BOUNDS = 0x9
Global Const $DWMWA_HAS_ICONIC_BITMAP = 0xa
Global Const $DWMWA_DISALLOW_PEEK = 0xb
Global Const $DWMWA_EXCLUDED_FROM_PEEK = 0xc
Global Const $DWMNCRP_USEWINDOWSTYLE = 0x0
Global Const $DWMNCRP_DISABLED = 0x1
Global Const $DWMNCRP_ENABLED = 0x2
Global Const $DWMFLIP3D_DEFAULT = 0x0
Global Const $DWMFLIP3D_EXCLUDEBELOW = 0x1
Global Const $DWMFLIP3D_EXCLUDEABOVE = 0x2
Global Const $DM_BITSPERPEL = 0x40000
Global Const $DM_COLLATE = 0x8000
Global Const $DM_COLOR = 0x800
Global Const $DM_COPIES = 0x100
Global Const $DM_DEFAULTSOURCE = 0x200
Global Const $DM_DISPLAYFIXEDOUTPUT = 0x20000000
Global Const $DM_DISPLAYFLAGS = 0x200000
Global Const $DM_DISPLAYFREQUENCY = 0x400000
Global Const $DM_DISPLAYORIENTATION = 0x80
Global Const $DM_DITHERTYPE = 0x4000000
Global Const $DM_DUPLEX = 0x1000
Global Const $DM_FORMNAME = 0x10000
Global Const $DM_ICMINTENT = 0x1000000
Global Const $DM_ICMMETHOD = 0x800000
Global Const $DM_LOGPIXELS = 0x20000
Global Const $DM_MEDIATYPE = 0x2000000
Global Const $DM_NUP = 0x40
Global Const $DM_ORIENTATION = 0x1
Global Const $DM_PANNINGHEIGHT = 0x10000000
Global Const $DM_PANNINGWIDTH = 0x8000000
Global Const $DM_PAPERLENGTH = 0x4
Global Const $DM_PAPERSIZE = 0x2
Global Const $DM_PAPERWIDTH = 0x8
Global Const $DM_PELSHEIGHT = 0x100000
Global Const $DM_PELSWIDTH = 0x80000
Global Const $DM_POSITION = 0x20
Global Const $DM_PRINTQUALITY = 0x400
Global Const $DM_SCALE = 0x10
Global Const $DM_TTOPTION = 0x4000
Global Const $DM_YRESOLUTION = 0x2000
Global Const $DMPAPER_LETTER = 0x1
Global Const $DMPAPER_LETTERSMALL = 0x2
Global Const $DMPAPER_TABLOID = 0x3
Global Const $DMPAPER_LEDGER = 0x4
Global Const $DMPAPER_LEGAL = 0x5
Global Const $DMPAPER_STATEMENT = 0x6
Global Const $DMPAPER_EXECUTIVE = 0x7
Global Const $DMPAPER_A3 = 0x8
Global Const $DMPAPER_A4 = 0x9
Global Const $DMPAPER_A4SMALL = 0xa
Global Const $DMPAPER_A5 = 0xb
Global Const $DMPAPER_B4 = 0xc
Global Const $DMPAPER_B5 = 0xd
Global Const $DMPAPER_FOLIO = 0xe
Global Const $DMPAPER_QUARTO = 0xf
Global Const $DMPAPER_10X14 = 0x10
Global Const $DMPAPER_11X17 = 0x11
Global Const $DMPAPER_NOTE = 0x12
Global Const $DMPAPER_ENV_9 = 0x13
Global Const $DMPAPER_ENV_10 = 0x14
Global Const $DMPAPER_ENV_11 = 0x15
Global Const $DMPAPER_ENV_12 = 0x16
Global Const $DMPAPER_ENV_14 = 0x17
Global Const $DMPAPER_CSHEET = 0x18
Global Const $DMPAPER_DSHEET = 0x19
Global Const $DMPAPER_ESHEET = 0x1a
Global Const $DMPAPER_ENV_DL = 0x1b
Global Const $DMPAPER_ENV_C5 = 0x1c
Global Const $DMPAPER_ENV_C3 = 0x1d
Global Const $DMPAPER_ENV_C4 = 0x1e
Global Const $DMPAPER_ENV_C6 = 0x1f
Global Const $DMPAPER_ENV_C65 = 0x20
Global Const $DMPAPER_ENV_B4 = 0x21
Global Const $DMPAPER_ENV_B5 = 0x22
Global Const $DMPAPER_ENV_B6 = 0x23
Global Const $DMPAPER_ENV_ITALY = 0x24
Global Const $DMPAPER_ENV_MONARCH = 0x25
Global Const $DMPAPER_ENV_PERSONAL = 0x26
Global Const $DMPAPER_FANFOLD_US = 0x27
Global Const $DMPAPER_FANFOLD_STD_GERMAN = 0x28
Global Const $DMPAPER_FANFOLD_LGL_GERMAN = 0x29
Global Const $DMPAPER_ISO_B4 = 0x2a
Global Const $DMPAPER_JAPANESE_POSTCARD = 0x2b
Global Const $DMPAPER_9X11 = 0x2c
Global Const $DMPAPER_10X11 = 0x2d
Global Const $DMPAPER_15X11 = 0x2e
Global Const $DMPAPER_ENV_INVITE = 0x2f
Global Const $DMPAPER_RESERVED_48 = 0x30
Global Const $DMPAPER_RESERVED_49 = 0x31
Global Const $DMPAPER_LETTER_EXTRA = 0x32
Global Const $DMPAPER_LEGAL_EXTRA = 0x33
Global Const $DMPAPER_TABLOID_EXTRA = 0x34
Global Const $DMPAPER_A4_EXTRA = 0x35
Global Const $DMPAPER_LETTER_TRANSVERSE = 0x36
Global Const $DMPAPER_A4_TRANSVERSE = 0x37
Global Const $DMPAPER_LETTER_EXTRA_TRANSVERSE = 0x38
Global Const $DMPAPER_A_PLUS = 0x39
Global Const $DMPAPER_B_PLUS = 0x3a
Global Const $DMPAPER_LETTER_PLUS = 0x3b
Global Const $DMPAPER_A4_PLUS = 0x3c
Global Const $DMPAPER_A5_TRANSVERSE = 0x3d
Global Const $DMPAPER_B5_TRANSVERSE = 0x3e
Global Const $DMPAPER_A3_EXTRA = 0x3f
Global Const $DMPAPER_A5_EXTRA = 0x40
Global Const $DMPAPER_B5_EXTRA = 0x41
Global Const $DMPAPER_A2 = 0x42
Global Const $DMPAPER_A3_TRANSVERSE = 0x43
Global Const $DMPAPER_A3_EXTRA_TRANSVERSE = 0x44
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD = 0x45
Global Const $DMPAPER_A6 = 0x46
Global Const $DMPAPER_JENV_KAKU2 = 0x47
Global Const $DMPAPER_JENV_KAKU3 = 0x48
Global Const $DMPAPER_JENV_CHOU3 = 0x49
Global Const $DMPAPER_JENV_CHOU4 = 0x4a
Global Const $DMPAPER_LETTER_ROTATED = 0x4b
Global Const $DMPAPER_A3_ROTATED = 0x4c
Global Const $DMPAPER_A4_ROTATED = 0x4d
Global Const $DMPAPER_A5_ROTATED = 0x4e
Global Const $DMPAPER_B4_JIS_ROTATED = 0x4f
Global Const $DMPAPER_B5_JIS_ROTATED = 0x50
Global Const $DMPAPER_JAPANESE_POSTCARD_ROTATED = 0x51
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 0x52
Global Const $DMPAPER_A6_ROTATED = 0x53
Global Const $DMPAPER_JENV_KAKU2_ROTATED = 0x54
Global Const $DMPAPER_JENV_KAKU3_ROTATED = 0x55
Global Const $DMPAPER_JENV_CHOU3_ROTATED = 0x56
Global Const $DMPAPER_JENV_CHOU4_ROTATED = 0x57
Global Const $DMPAPER_B6_JIS = 0x58
Global Const $DMPAPER_B6_JIS_ROTATED = 0x59
Global Const $DMPAPER_12X11 = 0x5a
Global Const $DMPAPER_JENV_YOU4 = 0x5b
Global Const $DMPAPER_JENV_YOU4_ROTATED = 0x5c
Global Const $DMPAPER_P16K = 0x5d
Global Const $DMPAPER_P32K = 0x5e
Global Const $DMPAPER_P32KBIG = 0x5f
Global Const $DMPAPER_PENV_1 = 0x60
Global Const $DMPAPER_PENV_2 = 0x61
Global Const $DMPAPER_PENV_3 = 0x62
Global Const $DMPAPER_PENV_4 = 0x63
Global Const $DMPAPER_PENV_5 = 0x64
Global Const $DMPAPER_PENV_6 = 0x65
Global Const $DMPAPER_PENV_7 = 0x66
Global Const $DMPAPER_PENV_8 = 0x67
Global Const $DMPAPER_PENV_9 = 0x68
Global Const $DMPAPER_PENV_10 = 0x69
Global Const $DMPAPER_P16K_ROTATED = 0x6a
Global Const $DMPAPER_P32K_ROTATED = 0x6b
Global Const $DMPAPER_P32KBIG_ROTATED = 0x6c
Global Const $DMPAPER_PENV_1_ROTATED = 0x6d
Global Const $DMPAPER_PENV_2_ROTATED = 0x6e
Global Const $DMPAPER_PENV_3_ROTATED = 0x6f
Global Const $DMPAPER_PENV_4_ROTATED = 0x70
Global Const $DMPAPER_PENV_5_ROTATED = 0x71
Global Const $DMPAPER_PENV_6_ROTATED = 0x72
Global Const $DMPAPER_PENV_7_ROTATED = 0x73
Global Const $DMPAPER_PENV_8_ROTATED = 0x74
Global Const $DMPAPER_PENV_9_ROTATED = 0x75
Global Const $DMPAPER_PENV_10_ROTATED = 0x76
Global Const $DMPAPER_USER = 0x100
Global Const $DMBIN_UPPER = 0x1
Global Const $DMBIN_LOWER = 0x2
Global Const $DMBIN_MIDDLE = 0x3
Global Const $DMBIN_MANUAL = 0x4
Global Const $DMBIN_ENVELOPE = 0x5
Global Const $DMBIN_ENVMANUAL = 0x6
Global Const $DMBIN_AUTO = 0x7
Global Const $DMBIN_TRACTOR = 0x8
Global Const $DMBIN_SMALLFMT = 0x9
Global Const $DMBIN_LARGEFMT = 0xa
Global Const $DMBIN_LARGECAPACITY = 0xb
Global Const $DMBIN_CASSETTE = 0xe
Global Const $DMBIN_FORMSOURCE = 0xf
Global Const $DMBIN_USER = 0x100
Global Const $DMRES_DRAFT = + -1
Global Const $DMRES_LOW = + -2
Global Const $DMRES_MEDIUM = + -3
Global Const $DMRES_HIGH = + -4
Global Const $DMDO_DEFAULT = 0x0
Global Const $DMDO_90 = 0x1
Global Const $DMDO_180 = 0x2
Global Const $DMDO_270 = 0x3
Global Const $DMDFO_DEFAULT = 0x0
Global Const $DMDFO_STRETCH = 0x1
Global Const $DMDFO_CENTER = 0x2
Global Const $DMCOLOR_MONOCHROME = 0x1
Global Const $DMCOLOR_COLOR = 0x2
Global Const $DMDUP_SIMPLEX = 0x1
Global Const $DMDUP_VERTICAL = 0x2
Global Const $DMDUP_HORIZONTAL = 0x3
Global Const $DMTT_BITMAP = 0x1
Global Const $DMTT_DOWNLOAD = 0x2
Global Const $DMTT_SUBDEV = 0x3
Global Const $DMTT_DOWNLOAD_OUTLINE = 0x4
Global Const $DMCOLLATE_FALSE = 0x0
Global Const $DMCOLLATE_TRUE = 0x1
Global Const $DM_GRAYSCALE = 0x1
Global Const $DM_INTERLACED = 0x2
Global Const $DMNUP_SYSTEM = 0x1
Global Const $DMNUP_ONEUP = 0x2
Global Const $DMICMMETHOD_NONE = 0x1
Global Const $DMICMMETHOD_SYSTEM = 0x2
Global Const $DMICMMETHOD_DRIVER = 0x3
Global Const $DMICMMETHOD_DEVICE = 0x4
Global Const $DMICMMETHOD_USER = 0x100
Global Const $DMICM_SATURATE = 0x1
Global Const $DMICM_CONTRAST = 0x2
Global Const $DMICM_COLORIMETRIC = 0x3
Global Const $DMICM_ABS_COLORIMETRIC = 0x4
Global Const $DMICM_USER = 0x100
Global Const $DMMEDIA_STANDARD = 0x1
Global Const $DMMEDIA_TRANSPARENCY = 0x2
Global Const $DMMEDIA_GLOSSY = 0x3
Global Const $DMMEDIA_USER = 0x100
Global Const $DMDITHER_NONE = 0x1
Global Const $DMDITHER_COARSE = 0x2
Global Const $DMDITHER_FINE = 0x3
Global Const $DMDITHER_LINEART = 0x4
Global Const $DMDITHER_ERRORDIFFUSION = 0x5
Global Const $DMDITHER_RESERVED6 = 0x6
Global Const $DMDITHER_RESERVED7 = 0x7
Global Const $DMDITHER_RESERVED8 = 0x8
Global Const $DMDITHER_RESERVED9 = 0x9
Global Const $DMDITHER_GRAYSCALE = 0xa
Global Const $DMDITHER_USER = 0x100
Global Const $ENUM_CURRENT_SETTINGS = + -1
Global Const $ENUM_REGISTRY_SETTINGS = + -2
Global Const $DEVICE_FONTTYPE = 0x2
Global Const $RASTER_FONTTYPE = 0x1
Global Const $TRUETYPE_FONTTYPE = 0x4
Global Const $NTM_BOLD = 0x20
Global Const $NTM_DSIG = 0x200000
Global Const $NTM_ITALIC = 0x1
Global Const $NTM_MULTIPLEMASTER = 0x80000
Global Const $NTM_NONNEGATIVE_AC = 0x10000
Global Const $NTM_PS_OPENTYPE = 0x20000
Global Const $NTM_REGULAR = 0x40
Global Const $NTM_TT_OPENTYPE = 0x40000
Global Const $NTM_TYPE1 = 0x100000
Global Const $FLOODFILLBORDER = 0x0
Global Const $FLOODFILLSURFACE = 0x1
Global Const $AD_COUNTERCLOCKWISE = 0x1
Global Const $AD_CLOCKWISE = 0x2
Global Const $DCB_ACCUMULATE = 0x2
Global Const $DCB_DISABLE = 0x8
Global Const $DCB_ENABLE = 0x4
Global Const $DCB_RESET = 0x1
Global Const $DCB_SET = BitOR($DCB_RESET, $DCB_ACCUMULATE)
Global Const $DCX_WINDOW = 0x1
Global Const $DCX_CACHE = 0x2
Global Const $DCX_PARENTCLIP = 0x20
Global Const $DCX_CLIPSIBLINGS = 0x10
Global Const $DCX_CLIPCHILDREN = 0x8
Global Const $DCX_NORESETATTRS = 0x4
Global Const $DCX_LOCKWINDOWUPDATE = 0x400
Global Const $DCX_EXCLUDERGN = 0x40
Global Const $DCX_INTERSECTRGN = 0x80
Global Const $DCX_INTERSECTUPDATE = 0x200
Global Const $DCX_VALIDATE = 0x200000
Global Const $GGO_BEZIER = 0x3
Global Const $GGO_BITMAP = 0x1
Global Const $GGO_GLYPH_INDEX = 0x80
Global Const $GGO_GRAY2_BITMAP = 0x4
Global Const $GGO_GRAY4_BITMAP = 0x5
Global Const $GGO_GRAY8_BITMAP = 0x6
Global Const $GGO_METRICS = 0x0
Global Const $GGO_NATIVE = 0x2
Global Const $GGO_UNHINTED = 0x100
Global Const $GM_COMPATIBLE = 0x1
Global Const $GM_ADVANCED = 0x2
Global Const $MM_ANISOTROPIC = 0x8
Global Const $MM_HIENGLISH = 0x5
Global Const $MM_HIMETRIC = 0x3
Global Const $MM_ISOTROPIC = 0x7
Global Const $MM_LOENGLISH = 0x4
Global Const $MM_LOMETRIC = 0x2
Global Const $MM_TEXT = 0x1
Global Const $MM_TWIPS = 0x6
Global Const $R2_BLACK = 0x1
Global Const $R2_COPYPEN = 0xd
Global Const $R2_LAST = 0x10
Global Const $R2_MASKNOTPEN = 0x3
Global Const $R2_MASKPEN = 0x9
Global Const $R2_MASKPENNOT = 0x5
Global Const $R2_MERGENOTPEN = 0xc
Global Const $R2_MERGEPEN = 0xf
Global Const $R2_MERGEPENNOT = 0xe
Global Const $R2_NOP = 0xb
Global Const $R2_NOT = 0x6
Global Const $R2_NOTCOPYPEN = 0x4
Global Const $R2_NOTMASKPEN = 0x8
Global Const $R2_NOTMERGEPEN = 0x2
Global Const $R2_NOTXORPEN = 0xa
Global Const $R2_WHITE = 0x10
Global Const $R2_XORPEN = 0x7
Global Const $BLACKONWHITE = 0x1
Global Const $COLORONCOLOR = 0x3
Global Const $HALFTONE = 0x4
Global Const $WHITEONBLACK = 0x2
Global Const $STRETCH_ANDSCANS = $BLACKONWHITE
Global Const $STRETCH_DELETESCANS = $COLORONCOLOR
Global Const $STRETCH_HALFTONE = $HALFTONE
Global Const $STRETCH_ORSCANS = $WHITEONBLACK
Global Const $TA_BASELINE = 0x18
Global Const $TA_BOTTOM = 0x8
Global Const $TA_TOP = 0x0
Global Const $TA_CENTER = 0x6
Global Const $TA_LEFT = 0x0
Global Const $TA_RIGHT = 0x2
Global Const $TA_NOUPDATECP = 0x0
Global Const $TA_RTLREADING = 0x100
Global Const $TA_UPDATECP = 0x1
Global Const $VTA_BASELINE = $TA_BASELINE
Global Const $VTA_BOTTOM = $TA_RIGHT
Global Const $VTA_TOP = $TA_LEFT
Global Const $VTA_CENTER = $TA_CENTER
Global Const $VTA_LEFT = $TA_BOTTOM
Global Const $VTA_RIGHT = $TA_TOP
Global Const $UDF_BGR = 0x1
Global Const $UDF_RGB = 0x0
Global Const $MWT_IDENTITY = 0x1
Global Const $MWT_LEFTMULTIPLY = 0x2
Global Const $MWT_RIGHTMULTIPLY = 0x3
Global Const $MWT_SET = 0x4
Global Const $MONITOR_DEFAULTTONEAREST = 0x2
Global Const $MONITOR_DEFAULTTONULL = 0x0
Global Const $MONITOR_DEFAULTTOPRIMARY = 0x1
Global Const $PT_BEZIERTO = 0x4
Global Const $PT_LINETO = 0x2
Global Const $PT_MOVETO = 0x6
Global Const $PT_CLOSEFIGURE = 0x1
Global Const $LINGUISTIC_IGNORECASE = 0x10
Global Const $LINGUISTIC_IGNOREDIACRITIC = 0x20
Global Const $NORM_IGNORECASE = 0x1
Global Const $NORM_IGNOREKANATYPE = 0x10000
Global Const $NORM_IGNORENONSPACE = 0x2
Global Const $NORM_IGNORESYMBOLS = 0x4
Global Const $NORM_IGNOREWIDTH = 0x20000
Global Const $NORM_LINGUISTIC_CASING = 0x8000000
Global Const $SORT_DIGITSASNUMBERS = 0x8
Global Const $SORT_STRINGSORT = 0x1000
Global Const $CSTR_LESS_THAN = 0x1
Global Const $CSTR_EQUAL = 0x2
Global Const $CSTR_GREATER_THAN = 0x3
Global Const $MUI_LANGUAGE_ID = 0x4
Global Const $MUI_LANGUAGE_NAME = 0x8
Global Const $DATE_AUTOLAYOUT = 0x40
Global Const $DATE_LONGDATE = 0x2
Global Const $DATE_LTRREADING = 0x10
Global Const $DATE_SHORTDATE = 0x1
Global Const $DATE_RTLREADING = 0x20
Global Const $DATE_USE_ALT_CALENDAR = 0x4
Global Const $DATE_YEARMONTH = 0x8
Global Const $GEO_NATION = 0x1
Global Const $GEO_LATITUDE = 0x2
Global Const $GEO_LONGITUDE = 0x3
Global Const $GEO_ISO2 = 0x4
Global Const $GEO_ISO3 = 0x5
Global Const $GEO_RFC1766 = 0x6
Global Const $GEO_LCID = 0x7
Global Const $GEO_FRIENDLYNAME = 0x8
Global Const $GEO_OFFICIALNAME = 0x9
Global Const $GEO_TIMEZONES = 0xa
Global Const $GEO_OFFICIALLANGUAGES = 0xb
Global Const $GEO_ISO_UN_NUMBER = 0xc
Global Const $GEO_PARENT = 0xd
Global Const $LOCALE_ILANGUAGE = 0x1
Global Const $LOCALE_SLANGUAGE = 0x2
Global Const $LOCALE_SENGLANGUAGE = 0x1001
Global Const $LOCALE_SABBREVLANGNAME = 0x3
Global Const $LOCALE_SNATIVELANGNAME = 0x4
Global Const $LOCALE_ICOUNTRY = 0x5
Global Const $LOCALE_SCOUNTRY = 0x6
Global Const $LOCALE_SENGCOUNTRY = 0x1002
Global Const $LOCALE_SABBREVCTRYNAME = 0x7
Global Const $LOCALE_SNATIVECTRYNAME = 0x8
Global Const $LOCALE_IDEFAULTLANGUAGE = 0x9
Global Const $LOCALE_IDEFAULTCOUNTRY = 0xa
Global Const $LOCALE_IDEFAULTCODEPAGE = 0xb
Global Const $LOCALE_IDEFAULTANSICODEPAGE = 0x1004
Global Const $LOCALE_IDEFAULTMACCODEPAGE = 0x1011
Global Const $LOCALE_SLIST = 0xc
Global Const $LOCALE_IMEASURE = 0xd
Global Const $LOCALE_SDECIMAL = 0xe
Global Const $LOCALE_STHOUSAND = 0xf
Global Const $LOCALE_SGROUPING = 0x10
Global Const $LOCALE_IDIGITS = 0x11
Global Const $LOCALE_ILZERO = 0x12
Global Const $LOCALE_INEGNUMBER = 0x1010
Global Const $LOCALE_SNATIVEDIGITS = 0x13
Global Const $LOCALE_SCURRENCY = 0x14
Global Const $LOCALE_SINTLSYMBOL = 0x15
Global Const $LOCALE_SMONDECIMALSEP = 0x16
Global Const $LOCALE_SMONTHOUSANDSEP = 0x17
Global Const $LOCALE_SMONGROUPING = 0x18
Global Const $LOCALE_ICURRDIGITS = 0x19
Global Const $LOCALE_IINTLCURRDIGITS = 0x1a
Global Const $LOCALE_ICURRENCY = 0x1b
Global Const $LOCALE_INEGCURR = 0x1c
Global Const $LOCALE_SDATE = 0x1d
Global Const $LOCALE_STIME = 0x1e
Global Const $LOCALE_SSHORTDATE = 0x1f
Global Const $LOCALE_SLONGDATE = 0x20
Global Const $LOCALE_STIMEFORMAT = 0x1003
Global Const $LOCALE_IDATE = 0x21
Global Const $LOCALE_ILDATE = 0x22
Global Const $LOCALE_ITIME = 0x23
Global Const $LOCALE_ITIMEMARKPOSN = 0x1005
Global Const $LOCALE_ICENTURY = 0x24
Global Const $LOCALE_ITLZERO = 0x25
Global Const $LOCALE_IDAYLZERO = 0x26
Global Const $LOCALE_IMONLZERO = 0x27
Global Const $LOCALE_S1159 = 0x28
Global Const $LOCALE_S2359 = 0x29
Global Const $LOCALE_ICALENDARTYPE = 0x1009
Global Const $LOCALE_IOPTIONALCALENDAR = 0x100b
Global Const $LOCALE_IFIRSTDAYOFWEEK = 0x100c
Global Const $LOCALE_IFIRSTWEEKOFYEAR = 0x100d
Global Const $LOCALE_SDAYNAME1 = 0x2a
Global Const $LOCALE_SDAYNAME2 = 0x2b
Global Const $LOCALE_SDAYNAME3 = 0x2c
Global Const $LOCALE_SDAYNAME4 = 0x2d
Global Const $LOCALE_SDAYNAME5 = 0x2e
Global Const $LOCALE_SDAYNAME6 = 0x2f
Global Const $LOCALE_SDAYNAME7 = 0x30
Global Const $LOCALE_SABBREVDAYNAME1 = 0x31
Global Const $LOCALE_SABBREVDAYNAME2 = 0x32
Global Const $LOCALE_SABBREVDAYNAME3 = 0x33
Global Const $LOCALE_SABBREVDAYNAME4 = 0x34
Global Const $LOCALE_SABBREVDAYNAME5 = 0x35
Global Const $LOCALE_SABBREVDAYNAME6 = 0x36
Global Const $LOCALE_SABBREVDAYNAME7 = 0x37
Global Const $LOCALE_SMONTHNAME1 = 0x38
Global Const $LOCALE_SMONTHNAME2 = 0x39
Global Const $LOCALE_SMONTHNAME3 = 0x3a
Global Const $LOCALE_SMONTHNAME4 = 0x3b
Global Const $LOCALE_SMONTHNAME5 = 0x3c
Global Const $LOCALE_SMONTHNAME6 = 0x3d
Global Const $LOCALE_SMONTHNAME7 = 0x3e
Global Const $LOCALE_SMONTHNAME8 = 0x3f
Global Const $LOCALE_SMONTHNAME9 = 0x40
Global Const $LOCALE_SMONTHNAME10 = 0x41
Global Const $LOCALE_SMONTHNAME11 = 0x42
Global Const $LOCALE_SMONTHNAME12 = 0x43
Global Const $LOCALE_SMONTHNAME13 = 0x100e
Global Const $LOCALE_SABBREVMONTHNAME1 = 0x44
Global Const $LOCALE_SABBREVMONTHNAME2 = 0x45
Global Const $LOCALE_SABBREVMONTHNAME3 = 0x46
Global Const $LOCALE_SABBREVMONTHNAME4 = 0x47
Global Const $LOCALE_SABBREVMONTHNAME5 = 0x48
Global Const $LOCALE_SABBREVMONTHNAME6 = 0x49
Global Const $LOCALE_SABBREVMONTHNAME7 = 0x4a
Global Const $LOCALE_SABBREVMONTHNAME8 = 0x4b
Global Const $LOCALE_SABBREVMONTHNAME9 = 0x4c
Global Const $LOCALE_SABBREVMONTHNAME10 = 0x4d
Global Const $LOCALE_SABBREVMONTHNAME11 = 0x4e
Global Const $LOCALE_SABBREVMONTHNAME12 = 0x4f
Global Const $LOCALE_SABBREVMONTHNAME13 = 0x100f
Global Const $LOCALE_SPOSITIVESIGN = 0x50
Global Const $LOCALE_SNEGATIVESIGN = 0x51
Global Const $LOCALE_IPOSSIGNPOSN = 0x52
Global Const $LOCALE_INEGSIGNPOSN = 0x53
Global Const $LOCALE_IPOSSYMPRECEDES = 0x54
Global Const $LOCALE_IPOSSEPBYSPACE = 0x55
Global Const $LOCALE_INEGSYMPRECEDES = 0x56
Global Const $LOCALE_INEGSEPBYSPACE = 0x57
Global Const $LOCALE_FONTSIGNATURE = 0x58
Global Const $LOCALE_SISO639LANGNAME = 0x59
Global Const $LOCALE_SISO3166CTRYNAME = 0x5a
Global Const $LOCALE_IDEFAULTEBCDICCODEPAGE = 0x1012
Global Const $LOCALE_IPAPERSIZE = 0x100a
Global Const $LOCALE_SENGCURRNAME = 0x1007
Global Const $LOCALE_SNATIVECURRNAME = 0x1008
Global Const $LOCALE_SYEARMONTH = 0x1006
Global Const $LOCALE_SSORTNAME = 0x1013
Global Const $LOCALE_IDIGITSUBSTITUTION = 0x1014
Global Const $LOCALE_CUSTOM_DEFAULT = 0xc00
Global Const $LOCALE_CUSTOM_UI_DEFAULT = 0x1400
Global Const $LOCALE_CUSTOM_UNSPECIFIED = 0x1000
Global Const $LOCALE_INVARIANT = 0x7f
Global Const $LOCALE_SYSTEM_DEFAULT = 0x800
Global Const $LOCALE_USER_DEFAULT = 0x400
Global Const $TIME_FORCE24HOURFORMAT = 0x8
Global Const $TIME_NOMINUTESORSECONDS = 0x1
Global Const $TIME_NOSECONDS = 0x2
Global Const $TIME_NOTIMEMARKER = 0x4
Global Const $LCID_INSTALLED = 0x1
Global Const $LCID_SUPPORTED = 0x2
Global Const $SND_APPLICATION = 0x80
Global Const $SND_ALIAS = 0x10000
Global Const $SND_ALIAS_ID = 0x110000
Global Const $SND_ASYNC = 0x1
Global Const $SND_FILENAME = 0x20000
Global Const $SND_LOOP = 0x8
Global Const $SND_MEMORY = 0x4
Global Const $SND_NODEFAULT = 0x2
Global Const $SND_NOSTOP = 0x10
Global Const $SND_NOWAIT = 0x2000
Global Const $SND_PURGE = 0x40
Global Const $SND_RESOURCE = 0x40004
Global Const $SND_SENTRY = 0x80000
Global Const $SND_SYNC = 0x0
Global Const $SND_SYSTEM = 0x200000
Global Const $SND_SYSTEM_NOSTOP = 0x200010
Global Const $SND_ALIAS_SYSTEMASTERISK = "SystemAsterisk"
Global Const $SND_ALIAS_SYSTEMDEFAULT = "SystemDefault"
Global Const $SND_ALIAS_SYSTEMEXCLAMATION = "SystemExclamation"
Global Const $SND_ALIAS_SYSTEMEXIT = "SystemExit"
Global Const $SND_ALIAS_SYSTEMHAND = "SystemHand"
Global Const $SND_ALIAS_SYSTEMQUESTION = "SystemQuestion"
Global Const $SND_ALIAS_SYSTEMSTART = "SystemStart"
Global Const $SND_ALIAS_SYSTEMWELCOME = "SystemWelcome"
Global Const $CREATE_BREAKAWAY_FROM_JOB = 0x1000000
Global Const $CREATE_DEFAULT_ERROR_MODE = 0x4000000
Global Const $CREATE_NEW_CONSOLE = 0x10
Global Const $CREATE_NEW_PROCESS_GROUP = 0x200
Global Const $CREATE_NO_WINDOW = 0x8000000
Global Const $CREATE_PROTECTED_PROCESS = 0x40000
Global Const $CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x2000000
Global Const $CREATE_SEPARATE_WOW_VDM = 0x800
Global Const $CREATE_SHARED_WOW_VDM = 0x1000
Global Const $CREATE_SUSPENDED = 0x4
Global Const $CREATE_UNICODE_ENVIRONMENT = 0x400
Global Const $LIST_MODULES_32BIT = 0x1
Global Const $LIST_MODULES_64BIT = 0x2
Global Const $LIST_MODULES_ALL = 0x3
Global Const $LIST_MODULES_DEFAULT = 0x0
Global Const $ABOVE_NORMAL_PRIORITY_CLASS = 0x8000
Global Const $BELOW_NORMAL_PRIORITY_CLASS = 0x4000
Global Const $HIGH_PRIORITY_CLASS = 0x80
Global Const $IDLE_PRIORITY_CLASS = 0x40
Global Const $NORMAL_PRIORITY_CLASS = 0x20
Global Const $REALTIME_PRIORITY_CLASS = 0x100
Global Const $PROCESS_MODE_BACKGROUND_BEGIN = 0x100000
Global Const $PROCESS_MODE_BACKGROUND_END = 0x200000
Global Const $MUTEX_MODIFY_STATE = 0x1
Global Const $MUTEX_ALL_ACCESS = 0x1f0001
Global Const $JOB_OBJECT_ASSIGN_PROCESS = 0x1
Global Const $JOB_OBJECT_QUERY = 0x4
Global Const $JOB_OBJECT_SET_ATTRIBUTES = 0x2
Global Const $JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 0x10
Global Const $JOB_OBJECT_TERMINATE = 0x8
Global Const $JOB_OBJECT_ALL_ACCESS = 0x1f001f
Global Const $JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 0x8
Global Const $JOB_OBJECT_LIMIT_AFFINITY = 0x10
Global Const $JOB_OBJECT_LIMIT_BREAKAWAY_OK = 0x800
Global Const $JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x400
Global Const $JOB_OBJECT_LIMIT_JOB_MEMORY = 0x200
Global Const $JOB_OBJECT_LIMIT_JOB_TIME = 0x4
Global Const $JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 0x2000
Global Const $JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 0x40
Global Const $JOB_OBJECT_LIMIT_PRIORITY_CLASS = 0x20
Global Const $JOB_OBJECT_LIMIT_PROCESS_MEMORY = 0x100
Global Const $JOB_OBJECT_LIMIT_PROCESS_TIME = 0x2
Global Const $JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 0x80
Global Const $JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 0x1000
Global Const $JOB_OBJECT_LIMIT_WORKINGSET = 0x1
Global Const $JOB_OBJECT_UILIMIT_DESKTOP = 0x40
Global Const $JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 0x10
Global Const $JOB_OBJECT_UILIMIT_EXITWINDOWS = 0x80
Global Const $JOB_OBJECT_UILIMIT_GLOBALATOMS = 0x20
Global Const $JOB_OBJECT_UILIMIT_HANDLES = 0x1
Global Const $JOB_OBJECT_UILIMIT_READCLIPBOARD = 0x2
Global Const $JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x8
Global Const $JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 0x4
Global Const $JOB_OBJECT_SECURITY_FILTER_TOKENS = 0x8
Global Const $JOB_OBJECT_SECURITY_NO_ADMIN = 0x1
Global Const $JOB_OBJECT_SECURITY_ONLY_TOKEN = 0x4
Global Const $JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x2
Global Const $JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0x0
Global Const $JOB_OBJECT_POST_AT_END_OF_JOB = 0x1
Global Const $SEMAPHORE_MODIFY_STATE = 0x2
Global Const $SEMAPHORE_QUERY_STATE = 0x1
Global Const $SEMAPHORE_ALL_ACCESS = 0x1f0003
Global Const $ES_AWAYMODE_REQUIRED = 0x40
Global Const $ES_CONTINUOUS = -2147483648
Global Const $ES_DISPLAY_REQUIRED = 0x2
Global Const $ES_SYSTEM_REQUIRED = 0x1
Global Const $ES_USER_PRESENT = 0x4
Global Const $PERCEIVED_TYPE_CUSTOM = + -3
Global Const $PERCEIVED_TYPE_UNSPECIFIED = + -2
Global Const $PERCEIVED_TYPE_FOLDER = + -1
Global Const $PERCEIVED_TYPE_UNKNOWN = 0x0
Global Const $PERCEIVED_TYPE_TEXT = 0x1
Global Const $PERCEIVED_TYPE_IMAGE = 0x2
Global Const $PERCEIVED_TYPE_AUDIO = 0x3
Global Const $PERCEIVED_TYPE_VIDEO = 0x4
Global Const $PERCEIVED_TYPE_COMPRESSED = 0x5
Global Const $PERCEIVED_TYPE_DOCUMENT = 0x6
Global Const $PERCEIVED_TYPE_SYSTEM = 0x7
Global Const $PERCEIVED_TYPE_APPLICATION = 0x8
Global Const $PERCEIVED_TYPE_GAMEMEDIA = 0x9
Global Const $PERCEIVED_TYPE_CONTACTS = 0xa
Global Const $PERCEIVEDFLAG_UNDEFINED = 0x0
Global Const $PERCEIVEDFLAG_SOFTCODED = 0x1
Global Const $PERCEIVEDFLAG_HARDCODED = 0x2
Global Const $PERCEIVEDFLAG_NATIVESUPPORT = 0x4
Global Const $PERCEIVEDFLAG_GDIPLUS = 0x10
Global Const $PERCEIVEDFLAG_WMSDK = 0x20
Global Const $PERCEIVEDFLAG_ZIPFOLDER = 0x40
Global Const $ASSOCSTR_COMMAND = 0x1
Global Const $ASSOCSTR_EXECUTABLE = 0x2
Global Const $ASSOCSTR_FRIENDLYDOCNAME = 0x3
Global Const $ASSOCSTR_FRIENDLYAPPNAME = 0x4
Global Const $ASSOCSTR_NOOPEN = 0x5
Global Const $ASSOCSTR_SHELLNEWVALUE = 0x6
Global Const $ASSOCSTR_DDECOMMAND = 0x7
Global Const $ASSOCSTR_DDEIFEXEC = 0x8
Global Const $ASSOCSTR_DDEAPPLICATION = 0x9
Global Const $ASSOCSTR_DDETOPIC = 0xa
Global Const $ASSOCSTR_INFOTIP = 0xb
Global Const $ASSOCSTR_QUICKTIP = 0xc
Global Const $ASSOCSTR_TILEINFO = 0xd
Global Const $ASSOCSTR_CONTENTTYPE = 0xe
Global Const $ASSOCSTR_DEFAULTICON = 0xf
Global Const $ASSOCSTR_SHELLEXTENSION = 0x10
Global Const $ASSOCF_INIT_NOREMAPCLSID = 0x1
Global Const $ASSOCF_INIT_BYEXENAME = 0x2
Global Const $ASSOCF_OPEN_BYEXENAME = 0x2
Global Const $ASSOCF_INIT_DEFAULTTOSTAR = 0x4
Global Const $ASSOCF_INIT_DEFAULTTOFOLDER = 0x8
Global Const $ASSOCF_NOUSERSETTINGS = 0x10
Global Const $ASSOCF_NOTRUNCATE = 0x20
Global Const $ASSOCF_VERIFY = 0x40
Global Const $ASSOCF_REMAPRUNDLL = 0x80
Global Const $ASSOCF_NOFIXUPS = 0x100
Global Const $ASSOCF_IGNOREBASECLASS = 0x200
Global Const $ASSOCF_INIT_IGNOREUNKNOWN = 0x400
Global Const $HKEY_CLASSES_ROOT = -2147483648
Global Const $HKEY_CURRENT_CONFIG = -2147483643
Global Const $HKEY_CURRENT_USER = -2147483647
Global Const $HKEY_LOCAL_MACHINE = -2147483646
Global Const $HKEY_PERFORMANCE_DATA = -2147483644
Global Const $HKEY_PERFORMANCE_NLSTEXT = -2147483552
Global Const $HKEY_PERFORMANCE_TEXT = -2147483568
Global Const $HKEY_USERS = -2147483645
Global Const $KEY_CREATE_LINK = 0x20
Global Const $KEY_CREATE_SUB_KEY = 0x4
Global Const $KEY_ENUMERATE_SUB_KEYS = 0x8
Global Const $KEY_NOTIFY = 0x10
Global Const $KEY_QUERY_VALUE = 0x1
Global Const $KEY_SET_VALUE = 0x2
Global Const $KEY_WOW64_32KEY = 0x200
Global Const $KEY_WOW64_64KEY = 0x100
Global Const $KEY_READ = 0x20019
Global Const $KEY_WRITE = 0x20006
Global Const $KEY_EXECUTE = $KEY_READ
Global Const $KEY_ALL_ACCESS = 0xf003f
Global Const $REG_NOTIFY_CHANGE_NAME = 0x1
Global Const $REG_NOTIFY_CHANGE_ATTRIBUTES = 0x2
Global Const $REG_NOTIFY_CHANGE_LAST_SET = 0x4
Global Const $REG_NOTIFY_CHANGE_SECURITY = 0x8
Global Const $REG_OPTION_BACKUP_RESTORE = 0x4
Global Const $REG_OPTION_CREATE_LINK = 0x2
Global Const $REG_OPTION_NON_VOLATILE = 0x0
Global Const $REG_OPTION_VOLATILE = 0x1
Global Const $RT_ACCELERATOR = 0x9
Global Const $RT_ANICURSOR = 0x15
Global Const $RT_ANIICON = 0x16
Global Const $RT_BITMAP = 0x2
Global Const $RT_CURSOR = 0x1
Global Const $RT_DIALOG = 0x5
Global Const $RT_DLGINCLUDE = 0x11
Global Const $RT_FONT = 0x8
Global Const $RT_FONTDIR = 0x7
Global Const $RT_GROUP_CURSOR = 0xc
Global Const $RT_GROUP_ICON = 0xe
Global Const $RT_HTML = 0x17
Global Const $RT_ICON = 0x3
Global Const $RT_MANIFEST = 0x18
Global Const $RT_MENU = 0x4
Global Const $RT_MESSAGETABLE = 0xb
Global Const $RT_PLUGPLAY = 0x13
Global Const $RT_RCDATA = 0xa
Global Const $RT_STRING = 0x6
Global Const $RT_VERSION = 0x10
Global Const $RT_VXD = 0x14
Global Const $FILE_VER_GET_LOCALISED = 0x1
Global Const $FILE_VER_GET_NEUTRAL = 0x2
Global Const $FILE_VER_GET_PREFETCHED = 0x4
Global Const $OBM_TRTYPE = 0x7fdc
Global Const $OBM_LFARROWI = 0x7fde
Global Const $OBM_RGARROWI = 0x7fdf
Global Const $OBM_DNARROWI = 0x7fe0
Global Const $OBM_UPARROWI = 0x7fe1
Global Const $OBM_COMBO = 0x7fe2
Global Const $OBM_MNARROW = 0x7fe3
Global Const $OBM_LFARROWD = 0x7fe4
Global Const $OBM_RGARROWD = 0x7fe5
Global Const $OBM_DNARROWD = 0x7fe6
Global Const $OBM_UPARROWD = 0x7fe7
Global Const $OBM_RESTORED = 0x7fe8
Global Const $OBM_ZOOMD = 0x7fe9
Global Const $OBM_REDUCED = 0x7fea
Global Const $OBM_RESTORE = 0x7feb
Global Const $OBM_ZOOM = 0x7fec
Global Const $OBM_REDUCE = 0x7fed
Global Const $OBM_LFARROW = 0x7fee
Global Const $OBM_RGARROW = 0x7fef
Global Const $OBM_DNARROW = 0x7ff0
Global Const $OBM_UPARROW = 0x7ff1
Global Const $OBM_CLOSE = 0x7ff2
Global Const $OBM_OLD_RESTORE = 0x7ff3
Global Const $OBM_OLD_ZOOM = 0x7ff4
Global Const $OBM_OLD_REDUCE = 0x7ff5
Global Const $OBM_BTNCORNERS = 0x7ff6
Global Const $OBM_CHECKBOXES = 0x7ff7
Global Const $OBM_CHECK = 0x7ff8
Global Const $OBM_BTSIZE = 0x7ff9
Global Const $OBM_OLD_LFARROW = 0x7ffa
Global Const $OBM_OLD_RGARROW = 0x7ffb
Global Const $OBM_OLD_DNARROW = 0x7ffc
Global Const $OBM_OLD_UPARROW = 0x7ffd
Global Const $OBM_SIZE = 0x7ffe
Global Const $OBM_OLD_CLOSE = 0x7fff
Global Const $OIC_SAMPLE = 0x7f00
Global Const $OIC_HAND = 0x7f01
Global Const $OIC_QUES = 0x7f02
Global Const $OIC_BANG = 0x7f03
Global Const $OIC_NOTE = 0x7f04
Global Const $OIC_WINLOGO = 0x7f05
Global Const $OIC_WARNING = $OIC_BANG
Global Const $OIC_ERROR = $OIC_HAND
Global Const $OIC_INFORMATION = $OIC_NOTE
Global Const $DONT_RESOLVE_DLL_REFERENCES = 0x1
Global Const $LOAD_LIBRARY_AS_DATAFILE = 0x2
Global Const $LOAD_WITH_ALTERED_SEARCH_PATH = 0x8
Global Const $LOAD_IGNORE_CODE_AUTHZ_LEVEL = 0x10
Global Const $LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 0x40
Global Const $LOAD_LIBRARY_AS_IMAGE_RESOURCE = 0x20
Global Const $LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 0x200
Global Const $LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x1000
Global Const $LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 0x100
Global Const $LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x800
Global Const $LOAD_LIBRARY_SEARCH_USER_DIRS = 0x400
Global Const $OCR_NORMAL = 0x7f00
Global Const $OCR_IBEAM = 0x7f01
Global Const $OCR_WAIT = 0x7f02
Global Const $OCR_CROSS = 0x7f03
Global Const $OCR_UP = 0x7f04
Global Const $OCR_SIZE = 0x7f80
Global Const $OCR_ICON = 0x7f81
Global Const $OCR_SIZENWSE = 0x7f82
Global Const $OCR_SIZENESW = 0x7f83
Global Const $OCR_SIZEWE = 0x7f84
Global Const $OCR_SIZENS = 0x7f85
Global Const $OCR_SIZEALL = 0x7f86
Global Const $OCR_ICOCUR = 0x7f87
Global Const $OCR_NO = 0x7f88
Global Const $OCR_HAND = 0x7f89
Global Const $OCR_APPSTARTING = 0x7f8a
Global Const $OCR_HELP = 0x7f8b
Global Const $VS_FF_DEBUG = 0x1
Global Const $VS_FF_INFOINFERRED = 0x10
Global Const $VS_FF_PATCHED = 0x4
Global Const $VS_FF_PRERELEASE = 0x2
Global Const $VS_FF_PRIVATEBUILD = 0x8
Global Const $VS_FF_SPECIALBUILD = 0x20
Global Const $VOS_DOS = 0x10000
Global Const $VOS_NT = 0x40000
Global Const $VOS__WINDOWS16 = 0x1
Global Const $VOS__WINDOWS32 = 0x4
Global Const $VOS_OS216 = 0x20000
Global Const $VOS_OS232 = 0x30000
Global Const $VOS__PM16 = 0x2
Global Const $VOS__PM32 = 0x3
Global Const $VOS_UNKNOWN = 0x0
Global Const $VOS_DOS_WINDOWS16 = 0x10001
Global Const $VOS_DOS_WINDOWS32 = 0x10004
Global Const $VOS_NT_WINDOWS32 = 0x40004
Global Const $VOS_OS216_PM16 = 0x20002
Global Const $VOS_OS232_PM32 = 0x30003
Global Const $VFT_APP = 0x1
Global Const $VFT_DLL = 0x2
Global Const $VFT_DRV = 0x3
Global Const $VFT_FONT = 0x4
Global Const $VFT_STATIC_LIB = 0x7
Global Const $VFT_UNKNOWN = 0x0
Global Const $VFT_VXD = 0x5
Global Const $VFT2_DRV_COMM = 0xa
Global Const $VFT2_DRV_DISPLAY = 0x4
Global Const $VFT2_DRV_INSTALLABLE = 0x8
Global Const $VFT2_DRV_KEYBOARD = 0x2
Global Const $VFT2_DRV_LANGUAGE = 0x3
Global Const $VFT2_DRV_MOUSE = 0x5
Global Const $VFT2_DRV_NETWORK = 0x6
Global Const $VFT2_DRV_PRINTER = 0x1
Global Const $VFT2_DRV_SOUND = 0x9
Global Const $VFT2_DRV_SYSTEM = 0x7
Global Const $VFT2_DRV_VERSIONED_PRINTER = 0xc
Global Const $VFT2_UNKNOWN = 0x0
Global Const $VFT2_FONT_RASTER = 0x1
Global Const $VFT2_FONT_TRUETYPE = 0x3
Global Const $VFT2_FONT_VECTOR = 0x2
Global Const $DLLVER_PLATFORM_WINDOWS = 0x1
Global Const $DLLVER_PLATFORM_NT = 0x2
Global Const $SHCNE_ALLEVENTS = 0x7fffffff
Global Const $SHCNE_ASSOCCHANGED = 0x8000000
Global Const $SHCNE_ATTRIBUTES = 0x800
Global Const $SHCNE_CREATE = 0x2
Global Const $SHCNE_DELETE = 0x4
Global Const $SHCNE_DRIVEADD = 0x100
Global Const $SHCNE_DRIVEADDGUI = 0x10000
Global Const $SHCNE_DRIVEREMOVED = 0x80
Global Const $SHCNE_EXTENDED_EVENT = 0x4000000
Global Const $SHCNE_FREESPACE = 0x40000
Global Const $SHCNE_MEDIAINSERTED = 0x20
Global Const $SHCNE_MEDIAREMOVED = 0x40
Global Const $SHCNE_MKDIR = 0x8
Global Const $SHCNE_NETSHARE = 0x200
Global Const $SHCNE_NETUNSHARE = 0x400
Global Const $SHCNE_RENAMEFOLDER = 0x20000
Global Const $SHCNE_RENAMEITEM = 0x1
Global Const $SHCNE_RMDIR = 0x10
Global Const $SHCNE_SERVERDISCONNECT = 0x4000
Global Const $SHCNE_UPDATEDIR = 0x1000
Global Const $SHCNE_UPDATEIMAGE = 0x8000
Global Const $SHCNE_UPDATEITEM = 0x2000
Global Const $SHCNE_DISKEVENTS = 0x2381f
Global Const $SHCNE_GLOBALEVENTS = 0xc0581e0
Global Const $SHCNE_INTERRUPT = -2147483648
Global Const $SHCNF_DWORD = 0x3
Global Const $SHCNF_IDLIST = 0x0
Global Const $SHCNF_PATH = 0x1
Global Const $SHCNF_PRINTER = 0x2
Global Const $SHCNF_FLUSH = 0x1000
Global Const $SHCNF_FLUSHNOWAIT = 0x2000
Global Const $SHCNF_NOTIFYRECURSIVE = 0x10000
Global Const $SHCNRF_INTERRUPTLEVEL = 0x1
Global Const $SHCNRF_SHELLLEVEL = 0x2
Global Const $SHCNRF_RECURSIVEINTERRUPT = 0x1000
Global Const $SHCNRF_NEWDELIVERY = 0x8000
Global Const $SHERB_NOCONFIRMATION = 0x1
Global Const $SHERB_NOPROGRESSUI = 0x2
Global Const $SHERB_NOSOUND = 0x4
Global Const $SHERB_NO_UI = BitOR($SHERB_NOCONFIRMATION, $SHERB_NOPROGRESSUI, $SHERB_NOSOUND)
Global Const $SEE_MASK_DEFAULT = 0x0
Global Const $SEE_MASK_CLASSNAME = 0x1
Global Const $SEE_MASK_CLASSKEY = 0x3
Global Const $SEE_MASK_IDLIST = 0x4
Global Const $SEE_MASK_INVOKEIDLIST = 0xc
Global Const $SEE_MASK_ICON = 0x10
Global Const $SEE_MASK_HOTKEY = 0x20
Global Const $SEE_MASK_NOCLOSEPROCESS = 0x40
Global Const $SEE_MASK_CONNECTNETDRV = 0x80
Global Const $SEE_MASK_NOASYNC = 0x100
Global Const $SEE_MASK_FLAG_DDEWAIT = $SEE_MASK_NOASYNC
Global Const $SEE_MASK_DOENVSUBST = 0x200
Global Const $SEE_MASK_FLAG_NO_UI = 0x400
Global Const $SEE_MASK_UNICODE = 0x4000
Global Const $SEE_MASK_NO_CONSOLE = 0x8000
Global Const $SEE_MASK_ASYNCOK = 0x100000
Global Const $SEE_MASK_NOQUERYCLASSSTORE = 0x1000000
Global Const $SEE_MASK_HMONITOR = 0x200000
Global Const $SEE_MASK_NOZONECHECKS = 0x800000
Global Const $SEE_MASK_WAITFORINPUTIDLE = 0x2000000
Global Const $SEE_MASK_FLAG_LOG_USAGE = 0x4000000
Global Const $SE_ERR_ACCESSDENIED = 0x5
Global Const $SE_ERR_ASSOCINCOMPLETE = 0x1b
Global Const $SE_ERR_DDEBUSY = 0x1e
Global Const $SE_ERR_DDEFAIL = 0x1d
Global Const $SE_ERR_DDETIMEOUT = 0x1c
Global Const $SE_ERR_DLLNOTFOUND = 0x20
Global Const $SE_ERR_FNF = 0x2
Global Const $SE_ERR_NOASSOC = 0x1f
Global Const $SE_ERR_OOM = 0x8
Global Const $SE_ERR_PNF = 0x3
Global Const $SE_ERR_SHARE = 0x1a
Global Const $FO_COPY = 0x2
Global Const $FO_DELETE = 0x3
Global Const $FO_MOVE = 0x1
Global Const $FO_RENAME = 0x4
Global Const $FOF_ALLOWUNDO = 0x40
Global Const $FOF_CONFIRMMOUSE = 0x2
Global Const $FOF_FILESONLY = 0x80
Global Const $FOF_MULTIDESTFILES = 0x1
Global Const $FOF_NOCONFIRMATION = 0x10
Global Const $FOF_NOCONFIRMMKDIR = 0x200
Global Const $FOF_NO_CONNECTED_ELEMENTS = 0x2000
Global Const $FOF_NOCOPYSECURITYATTRIBS = 0x800
Global Const $FOF_NOERRORUI = 0x400
Global Const $FOF_NORECURSEREPARSE = 0x8000
Global Const $FOF_NORECURSION = 0x1000
Global Const $FOF_RENAMEONCOLLISION = 0x8
Global Const $FOF_SILENT = 0x4
Global Const $FOF_SIMPLEPROGRESS = 0x100
Global Const $FOF_WANTMAPPINGHANDLE = 0x20
Global Const $FOF_WANTNUKEWARNING = 0x4000
Global Const $FOF_NO_UI = BitOR($FOF_NOCONFIRMATION, $FOF_NOCONFIRMMKDIR, $FOF_NOERRORUI, $FOF_SILENT)
Global Const $SHGFI_ADDOVERLAYS = 0x20
Global Const $SHGFI_ATTR_SPECIFIED = 0x20000
Global Const $SHGFI_ATTRIBUTES = 0x800
Global Const $SHGFI_DISPLAYNAME = 0x200
Global Const $SHGFI_EXETYPE = 0x2000
Global Const $SHGFI_ICON = 0x100
Global Const $SHGFI_ICONLOCATION = 0x1000
Global Const $SHGFI_LARGEICON = 0x0
Global Const $SHGFI_LINKOVERLAY = 0x8000
Global Const $SHGFI_OPENICON = 0x2
Global Const $SHGFI_OVERLAYINDEX = 0x40
Global Const $SHGFI_PIDL = 0x8
Global Const $SHGFI_SELECTED = 0x10000
Global Const $SHGFI_SHELLICONSIZE = 0x4
Global Const $SHGFI_SMALLICON = 0x1
Global Const $SHGFI_SYSICONINDEX = 0x4000
Global Const $SHGFI_TYPENAME = 0x400
Global Const $SHGFI_USEFILEATTRIBUTES = 0x10
Global Const $SFGAO_CANCOPY = 0x1
Global Const $SFGAO_CANMOVE = 0x2
Global Const $SFGAO_CANLINK = 0x4
Global Const $SFGAO_STORAGE = 0x8
Global Const $SFGAO_CANRENAME = 0x10
Global Const $SFGAO_CANDELETE = 0x20
Global Const $SFGAO_HASPROPSHEET = 0x40
Global Const $SFGAO_DROPTARGET = 0x100
Global Const $SFGAO_CAPABILITYMASK = BitOR($SFGAO_CANCOPY, $SFGAO_CANMOVE, $SFGAO_CANLINK, $SFGAO_CANRENAME, $SFGAO_CANDELETE, $SFGAO_HASPROPSHEET, $SFGAO_DROPTARGET)
Global Const $SFGAO_SYSTEM = 0x1000
Global Const $SFGAO_ENCRYPTED = 0x2000
Global Const $SFGAO_ISSLOW = 0x4000
Global Const $SFGAO_GHOSTED = 0x8000
Global Const $SFGAO_LINK = 0x10000
Global Const $SFGAO_SHARE = 0x20000
Global Const $SFGAO_READONLY = 0x40000
Global Const $SFGAO_HIDDEN = 0x80000
Global Const $SFGAO_DISPLAYATTRMASK = BitOR($SFGAO_ISSLOW, $SFGAO_GHOSTED, $SFGAO_LINK, $SFGAO_SHARE, $SFGAO_READONLY, $SFGAO_HIDDEN)
Global Const $SFGAO_NONENUMERATED = 0x100000
Global Const $SFGAO_NEWCONTENT = 0x200000
Global Const $SFGAO_STREAM = 0x400000
Global Const $SFGAO_STORAGEANCESTOR = 0x800000
Global Const $SFGAO_VALIDATE = 0x1000000
Global Const $SFGAO_REMOVABLE = 0x2000000
Global Const $SFGAO_COMPRESSED = 0x4000000
Global Const $SFGAO_BROWSABLE = 0x8000000
Global Const $SFGAO_FILESYSANCESTOR = 0x10000000
Global Const $SFGAO_FOLDER = 0x20000000
Global Const $SFGAO_FILESYSTEM = 0x40000000
Global Const $SFGAO_STORAGECAPMASK = BitOR($SFGAO_STORAGE, $SFGAO_LINK, $SFGAO_READONLY, $SFGAO_STREAM, $SFGAO_STORAGEANCESTOR, $SFGAO_FILESYSANCESTOR, $SFGAO_FOLDER, $SFGAO_FILESYSTEM)
Global Const $SFGAO_HASSUBFOLDER = -2147483648
Global Const $SFGAO_CONTENTSMASK = $SFGAO_HASSUBFOLDER
Global Const $SFGAO_PKEYSFGAOMASK = BitOR($SFGAO_ISSLOW, $SFGAO_READONLY, $SFGAO_HASSUBFOLDER, $SFGAO_VALIDATE)
Global Const $IDO_SHGIOI_DEFAULT = 0xffffffc
Global Const $IDO_SHGIOI_LINK = 0xffffffe
Global Const $IDO_SHGIOI_SHARE = 0xfffffff
Global Const $IDO_SHGIOI_SLOWFILE = 0xffffffd
Global Const $FCSM_VIEWID = 0x1
Global Const $FCSM_WEBVIEWTEMPLATE = 0x2
Global Const $FCSM_INFOTIP = 0x4
Global Const $FCSM_CLSID = 0x8
Global Const $FCSM_ICONFILE = 0x10
Global Const $FCSM_LOGO = 0x20
Global Const $FCSM_FLAGS = 0x40
Global Const $FCS_READ = 0x1
Global Const $FCS_FORCEWRITE = 0x2
Global Const $FCS_WRITE = BitOR($FCS_READ, $FCS_FORCEWRITE)
Global Const $SSF_AUTOCHECKSELECT = 0x800000
Global Const $SSF_DESKTOPHTML = 0x200
Global Const $SSF_DONTPRETTYPATH = 0x800
Global Const $SSF_DOUBLECLICKINWEBVIEW = 0x80
Global Const $SSF_HIDEICONS = 0x4000
Global Const $SSF_ICONSONLY = 0x1000000
Global Const $SSF_MAPNETDRVBUTTON = 0x1000
Global Const $SSF_NOCONFIRMRECYCLE = 0x8000
Global Const $SSF_NONETCRAWLING = 0x100000
Global Const $SSF_SEPPROCESS = 0x80000
Global Const $SSF_SHOWALLOBJECTS = 0x1
Global Const $SSF_SHOWCOMPCOLOR = 0x8
Global Const $SSF_SHOWEXTENSIONS = 0x2
Global Const $SSF_SHOWINFOTIP = 0x2000
Global Const $SSF_SHOWSUPERHIDDEN = 0x40000
Global Const $SSF_SHOWSYSFILES = 0x20
Global Const $SSF_SHOWTYPEOVERLAY = 0x2000000
Global Const $SSF_STARTPANELON = 0x200000
Global Const $SSF_WIN95CLASSIC = 0x400
Global Const $SSF_WEBVIEW = 0x20000
Global Const $CSIDL_ADMINTOOLS = 0x30
Global Const $CSIDL_ALTSTARTUP = 0x1d
Global Const $CSIDL_APPDATA = 0x1a
Global Const $CSIDL_BITBUCKET = 0xa
Global Const $CSIDL_CDBURN_AREA = 0x3b
Global Const $CSIDL_COMMON_ADMINTOOLS = 0x2f
Global Const $CSIDL_COMMON_ALTSTARTUP = 0x1e
Global Const $CSIDL_COMMON_APPDATA = 0x23
Global Const $CSIDL_COMMON_DESKTOPDIRECTORY = 0x19
Global Const $CSIDL_COMMON_DOCUMENTS = 0x2e
Global Const $CSIDL_COMMON_FAVORITES = 0x1f
Global Const $CSIDL_COMMON_MUSIC = 0x35
Global Const $CSIDL_COMMON_PICTURES = 0x36
Global Const $CSIDL_COMMON_PROGRAMS = 0x17
Global Const $CSIDL_COMMON_STARTMENU = 0x16
Global Const $CSIDL_COMMON_STARTUP = 0x18
Global Const $CSIDL_COMMON_TEMPLATES = 0x2d
Global Const $CSIDL_COMMON_VIDEO = 0x37
Global Const $CSIDL_COMPUTERSNEARME = 0x3d
Global Const $CSIDL_CONNECTIONS = 0x31
Global Const $CSIDL_CONTROLS = 0x3
Global Const $CSIDL_COOKIES = 0x21
Global Const $CSIDL_DESKTOP = 0x0
Global Const $CSIDL_DESKTOPDIRECTORY = 0x10
Global Const $CSIDL_DRIVES = 0x11
Global Const $CSIDL_FAVORITES = 0x6
Global Const $CSIDL_FONTS = 0x14
Global Const $CSIDL_INTERNET_CACHE = 0x20
Global Const $CSIDL_HISTORY = 0x22
Global Const $CSIDL_LOCAL_APPDATA = 0x1c
Global Const $CSIDL_MYMUSIC = 0xd
Global Const $CSIDL_MYPICTURES = 0x27
Global Const $CSIDL_MYVIDEO = 0xe
Global Const $CSIDL_NETHOOD = 0x13
Global Const $CSIDL_PERSONAL = 0x5
Global Const $CSIDL_PRINTERS = 0x4
Global Const $CSIDL_PRINTHOOD = 0x1b
Global Const $CSIDL_PROFILE = 0x28
Global Const $CSIDL_PROGRAM_FILES = 0x26
Global Const $CSIDL_PROGRAM_FILES_COMMON = 0x2b
Global Const $CSIDL_PROGRAM_FILES_COMMONX86 = 0x2c
Global Const $CSIDL_PROGRAM_FILESX86 = 0x2a
Global Const $CSIDL_PROGRAMS = 0x2
Global Const $CSIDL_RECENT = 0x8
Global Const $CSIDL_SENDTO = 0x9
Global Const $CSIDL_STARTMENU = 0xb
Global Const $CSIDL_STARTUP = 0x7
Global Const $CSIDL_SYSTEM = 0x25
Global Const $CSIDL_SYSTEMX86 = 0x29
Global Const $CSIDL_TEMPLATES = 0x15
Global Const $CSIDL_WINDOWS = 0x24
Global Const $SIID_DOCNOASSOC = 0x0
Global Const $SIID_DOCASSOC = 0x1
Global Const $SIID_APPLICATION = 0x2
Global Const $SIID_FOLDER = 0x3
Global Const $SIID_FOLDEROPEN = 0x4
Global Const $SIID_DRIVE525 = 0x5
Global Const $SIID_DRIVE35 = 0x6
Global Const $SIID_DRIVEREMOVE = 0x7
Global Const $SIID_DRIVEFIXED = 0x8
Global Const $SIID_DRIVENET = 0x9
Global Const $SIID_DRIVENETDISABLED = 0xa
Global Const $SIID_DRIVECD = 0xb
Global Const $SIID_DRIVERAM = 0xc
Global Const $SIID_WORLD = 0xd
Global Const $SIID_SERVER = 0xf
Global Const $SIID_PRINTER = 0x10
Global Const $SIID_MYNETWORK = 0x11
Global Const $SIID_FIND = 0x16
Global Const $SIID_HELP = 0x17
Global Const $SIID_SHARE = 0x1c
Global Const $SIID_LINK = 0x1d
Global Const $SIID_SLOWFILE = 0x1e
Global Const $SIID_RECYCLER = 0x1f
Global Const $SIID_RECYCLERFULL = 0x20
Global Const $SIID_MEDIACDAUDIO = 0x28
Global Const $SIID_LOCK = 0x2f
Global Const $SIID_AUTOLIST = 0x31
Global Const $SIID_PRINTERNET = 0x32
Global Const $SIID_SERVERSHARE = 0x33
Global Const $SIID_PRINTERFAX = 0x34
Global Const $SIID_PRINTERFAXNET = 0x35
Global Const $SIID_PRINTERFILE = 0x36
Global Const $SIID_STACK = 0x37
Global Const $SIID_MEDIASVCD = 0x38
Global Const $SIID_STUFFEDFOLDER = 0x39
Global Const $SIID_DRIVEUNKNOWN = 0x3a
Global Const $SIID_DRIVEDVD = 0x3b
Global Const $SIID_MEDIADVD = 0x3c
Global Const $SIID_MEDIADVDRAM = 0x3d
Global Const $SIID_MEDIADVDRW = 0x3e
Global Const $SIID_MEDIADVDR = 0x3f
Global Const $SIID_MEDIADVDROM = 0x40
Global Const $SIID_MEDIACDAUDIOPLUS = 0x41
Global Const $SIID_MEDIACDRW = 0x42
Global Const $SIID_MEDIACDR = 0x43
Global Const $SIID_MEDIACDBURN = 0x44
Global Const $SIID_MEDIABLANKCD = 0x45
Global Const $SIID_MEDIACDROM = 0x46
Global Const $SIID_AUDIOFILES = 0x47
Global Const $SIID_IMAGEFILES = 0x48
Global Const $SIID_VIDEOFILES = 0x49
Global Const $SIID_MIXEDFILES = 0x4a
Global Const $SIID_FOLDERBACK = 0x4b
Global Const $SIID_FOLDERFRONT = 0x4c
Global Const $SIID_SHIELD = 0x4d
Global Const $SIID_WARNING = 0x4e
Global Const $SIID_INFO = 0x4f
Global Const $SIID_ERROR = 0x50
Global Const $SIID_KEY = 0x51
Global Const $SIID_SOFTWARE = 0x52
Global Const $SIID_RENAME = 0x53
Global Const $SIID_DELETE = 0x54
Global Const $SIID_MEDIAAUDIODVD = 0x55
Global Const $SIID_MEDIAMOVIEDVD = 0x56
Global Const $SIID_MEDIAENHANCEDCD = 0x57
Global Const $SIID_MEDIAENHANCEDDVD = 0x58
Global Const $SIID_MEDIAHDDVD = 0x59
Global Const $SIID_MEDIABLURAY = 0x5a
Global Const $SIID_MEDIAVCD = 0x5b
Global Const $SIID_MEDIADVDPLUSR = 0x5c
Global Const $SIID_MEDIADVDPLUSRW = 0x5d
Global Const $SIID_DESKTOPPC = 0x5e
Global Const $SIID_MOBILEPC = 0x5f
Global Const $SIID_USERS = 0x60
Global Const $SIID_MEDIASMARTMEDIA = 0x61
Global Const $SIID_MEDIACOMPACTFLASH = 0x62
Global Const $SIID_DEVICECELLPHONE = 0x63
Global Const $SIID_DEVICECAMERA = 0x64
Global Const $SIID_DEVICEVIDEOCAMERA = 0x65
Global Const $SIID_DEVICEAUDIOPLAYER = 0x66
Global Const $SIID_NETWORKCONNECT = 0x67
Global Const $SIID_INTERNET = 0x68
Global Const $SIID_ZIPFILE = 0x69
Global Const $SIID_SETTINGS = 0x6a
Global Const $SIID_DRIVEHDDVD = 0x84
Global Const $SIID_DRIVEBD = 0x85
Global Const $SIID_MEDIAHDDVDROM = 0x86
Global Const $SIID_MEDIAHDDVDR = 0x87
Global Const $SIID_MEDIAHDDVDRAM = 0x88
Global Const $SIID_MEDIABDROM = 0x89
Global Const $SIID_MEDIABDR = 0x8a
Global Const $SIID_MEDIABDRE = 0x8b
Global Const $SIID_CLUSTEREDDRIVE = 0x8c
Global Const $SIID_MAX_ICONS = 0xae
Global Const $SHGSI_ICONLOCATION = 0x0
Global Const $SHGSI_ICON = $SHGFI_ICON
Global Const $SHGSI_SYSICONINDEX = $SHGFI_SYSICONINDEX
Global Const $SHGSI_LINKOVERLAY = $SHGFI_LINKOVERLAY
Global Const $SHGSI_SELECTED = $SHGFI_SELECTED
Global Const $SHGSI_LARGEICON = $SHGFI_LARGEICON
Global Const $SHGSI_SMALLICON = $SHGFI_SMALLICON
Global Const $SHGSI_SHELLICONSIZE = $SHGFI_SHELLICONSIZE
Global Const $NIM_ADD = 0x0
Global Const $NIM_MODIFY = 0x1
Global Const $NIM_DELETE = 0x2
Global Const $NIM_SETFOCUS = 0x3
Global Const $NIM_SETVERSION = 0x4
Global Const $NIF_MESSAGE = 0x1
Global Const $NIF_ICON = 0x2
Global Const $NIF_TIP = 0x4
Global Const $NIF_STATE = 0x8
Global Const $NIF_INFO = 0x10
Global Const $NIF_GUID = 0x20
Global Const $NIF_REALTIME = 0x40
Global Const $NIF_SHOWTIP = 0x80
Global Const $NIS_HIDDEN = 0x1
Global Const $NIS_SHAREDICON = 0x2
Global Const $NIIF_NONE = 0x0
Global Const $NIIF_INFO = 0x1
Global Const $NIIF_WARNING = 0x2
Global Const $NIIF_ERROR = 0x3
Global Const $NIIF_USER = 0x4
Global Const $NIIF_NOSOUND = 0x10
Global Const $NIIF_LARGE_ICON = 0x10
Global Const $NIIF_RESPECT_QUIET_TIME = 0x80
Global Const $NIIF_ICON_MASK = 0xf
Global Const $SHOP_PRINTERNAME = 0x1
Global Const $SHOP_FILEPATH = 0x2
Global Const $SHOP_VOLUMEGUID = 0x4
Global Const $OFASI_EDIT = 0x1
Global Const $OFASI_OPENDESKTOP = 0x2
Global Const $QUNS_NOT_PRESENT = 0x1
Global Const $QUNS_BUSY = 0x2
Global Const $QUNS_RUNNING_D3D_FULL_SCREEN = 0x3
Global Const $QUNS_PRESENTATION_MODE = 0x4
Global Const $QUNS_ACCEPTS_NOTIFICATIONS = 0x5
Global Const $QUNS_QUIET_TIME = 0x6
Global Const $REST_NORUN = 0x1
Global Const $REST_NOCLOSE = 0x2
Global Const $REST_NOSAVESET = 0x3
Global Const $REST_NOFILEMENU = 0x4
Global Const $REST_NOSETFOLDERS = 0x5
Global Const $REST_NOSETTASKBAR = 0x6
Global Const $REST_NODESKTOP = 0x7
Global Const $REST_NOFIND = 0x8
Global Const $REST_NODRIVES = 0x9
Global Const $REST_NODRIVEAUTORUN = 0xa
Global Const $REST_NODRIVETYPEAUTORUN = 0xb
Global Const $REST_NONETHOOD = 0xc
Global Const $REST_STARTBANNER = 0xd
Global Const $REST_RESTRICTRUN = 0xe
Global Const $REST_NOPRINTERTABS = 0xf
Global Const $REST_NOPRINTERDELETE = 0x10
Global Const $REST_NOPRINTERADD = 0x11
Global Const $REST_NOSTARTMENUSUBFOLDERS = 0x12
Global Const $REST_MYDOCSONNET = 0x13
Global Const $REST_NOEXITTODOS = 0x14
Global Const $REST_ENFORCESHELLEXTSECURITY = 0x15
Global Const $REST_LINKRESOLVEIGNORELINKINFO = 0x16
Global Const $REST_NOCOMMONGROUPS = 0x17
Global Const $REST_SEPARATEDESKTOPPROCESS = 0x18
Global Const $REST_NOWEB = 0x19
Global Const $REST_NOTRAYCONTEXTMENU = 0x1a
Global Const $REST_NOVIEWCONTEXTMENU = 0x1b
Global Const $REST_NONETCONNECTDISCONNECT = 0x1c
Global Const $REST_STARTMENULOGOFF = 0x1d
Global Const $REST_NOSETTINGSASSIST = 0x1e
Global Const $REST_NOINTERNETICON = 0x1f
Global Const $REST_NORECENTDOCSHISTORY = 0x20
Global Const $REST_NORECENTDOCSMENU = 0x21
Global Const $REST_NOACTIVEDESKTOP = 0x22
Global Const $REST_NOACTIVEDESKTOPCHANGES = 0x23
Global Const $REST_NOFAVORITESMENU = 0x24
Global Const $REST_CLEARRECENTDOCSONEXIT = 0x25
Global Const $REST_CLASSICSHELL = 0x26
Global Const $REST_NOCUSTOMIZEWEBVIEW = 0x27
Global Const $REST_NOHTMLWALLPAPER = 0x28
Global Const $REST_NOCHANGINGWALLPAPER = 0x29
Global Const $REST_NODESKCOMP = 0x2a
Global Const $REST_NOADDDESKCOMP = 0x2b
Global Const $REST_NODELDESKCOMP = 0x2c
Global Const $REST_NOCLOSEDESKCOMP = 0x2d
Global Const $REST_NOCLOSE_DRAGDROPBAND = 0x2e
Global Const $REST_NOMOVINGBAND = 0x2f
Global Const $REST_NOEDITDESKCOMP = 0x30
Global Const $REST_NORESOLVESEARCH = 0x31
Global Const $REST_NORESOLVETRACK = 0x32
Global Const $REST_FORCECOPYACLWITHFILE = 0x33
Global Const $REST_NOLOGO3CHANNELNOTIFY = 0x34
Global Const $REST_NOFORGETSOFTWAREUPDATE = 0x35
Global Const $REST_NOSETACTIVEDESKTOP = 0x36
Global Const $REST_NOUPDATEWINDOWS = 0x37
Global Const $REST_NOCHANGESTARMENU = 0x38
Global Const $REST_NOFOLDEROPTIONS = 0x39
Global Const $REST_HASFINDCOMPUTERS = 0x3a
Global Const $REST_INTELLIMENUS = 0x3b
Global Const $REST_RUNDLGMEMCHECKBOX = 0x3c
Global Const $REST_ARP_SHOWPOSTSETUP = 0x3d
Global Const $REST_NOCSC = 0x3e
Global Const $REST_NOCONTROLPANEL = 0x3f
Global Const $REST_ENUMWORKGROUP = 0x40
Global Const $REST_ARP_NOARP = 0x41
Global Const $REST_ARP_NOREMOVEPAGE = 0x42
Global Const $REST_ARP_NOADDPAGE = 0x43
Global Const $REST_ARP_NOWINSETUPPAGE = 0x44
Global Const $REST_GREYMSIADS = 0x45
Global Const $REST_NOCHANGEMAPPEDDRIVELABEL = 0x46
Global Const $REST_NOCHANGEMAPPEDDRIVECOMMENT = 0x47
Global Const $REST_MAXRECENTDOCS = 0x48
Global Const $REST_NONETWORKCONNECTIONS = 0x49
Global Const $REST_FORCESTARTMENULOGOFF = 0x4a
Global Const $REST_NOWEBVIEW = 0x4b
Global Const $REST_NOCUSTOMIZETHISFOLDER = 0x4c
Global Const $REST_NOENCRYPTION = 0x4d
Global Const $REST_DONTSHOWSUPERHIDDEN = 0x4e
Global Const $REST_NOSHELLSEARCHBUTTON = 0x4f
Global Const $REST_NOHARDWARETAB = 0x50
Global Const $REST_NORUNASINSTALLPROMPT = 0x51
Global Const $REST_PROMPTRUNASINSTALLNETPATH = 0x52
Global Const $REST_NOMANAGEMYCOMPUTERVERB = 0x53
Global Const $REST_NORECENTDOCSNETHOOD = 0x54
Global Const $REST_DISALLOWRUN = 0x55
Global Const $REST_NOWELCOMESCREEN = 0x56
Global Const $REST_RESTRICTCPL = 0x57
Global Const $REST_DISALLOWCPL = 0x58
Global Const $REST_NOSMBALLOONTIP = 0x59
Global Const $REST_NOSMHELP = 0x5a
Global Const $REST_NOWINKEYS = 0x5b
Global Const $REST_NOENCRYPTONMOVE = 0x5c
Global Const $REST_NOLOCALMACHINERUN = 0x5d
Global Const $REST_NOCURRENTUSERRUN = 0x5e
Global Const $REST_NOLOCALMACHINERUNONCE = 0x5f
Global Const $REST_NOCURRENTUSERRUNONCE = 0x60
Global Const $REST_FORCEACTIVEDESKTOPON = 0x61
Global Const $REST_NOCOMPUTERSNEARME = 0x62
Global Const $REST_NOVIEWONDRIVE = 0x63
Global Const $REST_NONETCRAWL = 0x64
Global Const $REST_NOSHAREDDOCUMENTS = 0x65
Global Const $REST_NOSMMYDOCS = 0x66
Global Const $REST_NOSMMYPICS = 0x67
Global Const $REST_ALLOWBITBUCKDRIVES = 0x68
Global Const $REST_NONLEGACYSHELLMODE = 0x69
Global Const $REST_NOCONTROLPANELBARRICADE = 0x6a
Global Const $REST_NOSTARTPAGE = 0x6b
Global Const $REST_NOAUTOTRAYNOTIFY = 0x6c
Global Const $REST_NOTASKGROUPING = 0x6d
Global Const $REST_NOCDBURNING = 0x6e
Global Const $REST_MYCOMPNOPROP = 0x6f
Global Const $REST_MYDOCSNOPROP = 0x70
Global Const $REST_NOSTARTPANEL = 0x71
Global Const $REST_NODISPLAYAPPEARANCEPAGE = 0x72
Global Const $REST_NOTHEMESTAB = 0x73
Global Const $REST_NOVISUALSTYLECHOICE = 0x74
Global Const $REST_NOSIZECHOICE = 0x75
Global Const $REST_NOCOLORCHOICE = 0x76
Global Const $REST_SETVISUALSTYLE = 0x77
Global Const $REST_STARTRUNNOHOMEPATH = 0x78
Global Const $REST_NOUSERNAMEINSTARTPANEL = 0x79
Global Const $REST_NOMYCOMPUTERICON = 0x7a
Global Const $REST_NOSMNETWORKPLACES = 0x7b
Global Const $REST_NOSMPINNEDLIST = 0x7c
Global Const $REST_NOSMMYMUSIC = 0x7d
Global Const $REST_NOSMEJECTPC = 0x7e
Global Const $REST_NOSMMOREPROGRAMS = 0x7f
Global Const $REST_NOSMMFUPROGRAMS = 0x80
Global Const $REST_NOTRAYITEMSDISPLAY = 0x81
Global Const $REST_NOTOOLBARSONTASKBAR = 0x82
Global Const $REST_NOSMCONFIGUREPROGRAMS = 0x83
Global Const $REST_HIDECLOCK = 0x84
Global Const $REST_NOLOWDISKSPACECHECKS = 0x85
Global Const $REST_NOENTIRENETWORK = 0x86
Global Const $REST_NODESKTOPCLEANUP = 0x87
Global Const $REST_BITBUCKNUKEONDELETE = 0x88
Global Const $REST_BITBUCKCONFIRMDELETE = 0x89
Global Const $REST_BITBUCKNOPROP = 0x8a
Global Const $REST_NODISPBACKGROUND = 0x8b
Global Const $REST_NODISPSCREENSAVEPG = 0x8c
Global Const $REST_NODISPSETTINGSPG = 0x8d
Global Const $REST_NODISPSCREENSAVEPREVIEW = 0x8e
Global Const $REST_NODISPLAYCPL = 0x8f
Global Const $REST_HIDERUNASVERB = 0x90
Global Const $REST_NOTHUMBNAILCACHE = 0x91
Global Const $REST_NOSTRCMPLOGICAL = 0x92
Global Const $REST_NOPUBLISHWIZARD = 0x93
Global Const $REST_NOONLINEPRINTSWIZARD = 0x94
Global Const $REST_NOWEBSERVICES = 0x95
Global Const $REST_ALLOWUNHASHEDWEBVIEW = 0x96
Global Const $REST_ALLOWLEGACYWEBVIEW = 0x97
Global Const $REST_REVERTWEBVIEWSECURITY = 0x98
Global Const $REST_INHERITCONSOLEHANDLES = 0x99
Global Const $REST_SORTMAXITEMCOUNT = 0x9a
Global Const $REST_NOREMOTERECURSIVEEVENTS = 0x9b
Global Const $REST_NOREMOTECHANGENOTIFY = 0x9c
Global Const $REST_NOSIMPLENETIDLIST = 0x9d
Global Const $REST_NOENUMENTIRENETWORK = 0x9e
Global Const $REST_NODETAILSTHUMBNAILONNETWORK = 0x9f
Global Const $REST_NOINTERNETOPENWITH = 0xa0
Global Const $REST_ALLOWLEGACYLMZBEHAVIOR = 0xa1
Global Const $REST_DONTRETRYBADNETNAME = 0xa2
Global Const $REST_ALLOWFILECLSIDJUNCTIONS = 0xa3
Global Const $REST_NOUPNPINSTALL = 0xa4
Global Const $REST_ARP_DONTGROUPPATCHES = 0xa5
Global Const $REST_ARP_NOCHOOSEPROGRAMSPAGE = 0xa6
Global Const $REST_NODISCONNECT = 0xa7
Global Const $REST_NOSECURITY = 0xa8
Global Const $REST_NOFILEASSOCIATE = 0xa9
Global Const $REST_ALLOWCOMMENTTOGGLE = 0xaa
Global Const $REST_USEDESKTOPINICACHE = 0xab
Global Const $GIL_DONTCACHE = 0x10
Global Const $GIL_NOTFILENAME = 0x8
Global Const $GIL_PERCLASS = 0x4
Global Const $GIL_PERINSTANCE = 0x2
Global Const $GIL_SIMULATEDOC = 0x1
Global Const $GIL_SHIELD = 0x200
Global Const $GIL_FORCENOSHIELD = 0x400
Global Const $FOLDERID_ADDNEWPROGRAMS = "{DE61D971-5EBC-4F02-A3A9-6C82895E5C04}"
Global Const $FOLDERID_ADMINTOOLS = "{724EF170-A42D-4FEF-9F26-B60E846FBA4F}"
Global Const $FOLDERID_APPUPDATES = "{A305CE99-F527-492B-8B1A-7E76FA98D6E4}"
Global Const $FOLDERID_CDBURNING = "{9E52AB10-F80D-49DF-ACB8-4330F5687855}"
Global Const $FOLDERID_CHANGEREMOVEPROGRAMS = "{DF7266AC-9274-4867-8D55-3BD661DE872D}"
Global Const $FOLDERID_COMMONADMINTOOLS = "{D0384E7D-BAC3-4797-8F14-CBA229B392B5}"
Global Const $FOLDERID_COMMONOEMLINKS = "{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}"
Global Const $FOLDERID_COMMONPROGRAMS = "{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}"
Global Const $FOLDERID_COMMONSTARTMENU = "{A4115719-D62E-491D-AA7C-E74B8BE3B067}"
Global Const $FOLDERID_COMMONSTARTUP = "{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}"
Global Const $FOLDERID_COMMONTEMPLATES = "{B94237E7-57AC-4347-9151-B08C6C32D1F7}"
Global Const $FOLDERID_COMPUTERFOLDER = "{0AC0837C-BBF8-452A-850D-79D08E667CA7}"
Global Const $FOLDERID_CONFLICTFOLDER = "{4BFEFB45-347D-4006-A5BE-AC0CB0567192}"
Global Const $FOLDERID_CONNECTIONSFOLDER = "{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}"
Global Const $FOLDERID_CONTACTS = "{56784854-C6CB-462B-8169-88E350ACB882}"
Global Const $FOLDERID_CONTROLPANELFOLDER = "{82A74AEB-AEB4-465C-A014-D097EE346D63}"
Global Const $FOLDERID_COOKIES = "{2B0F765D-C0E9-4171-908E-08A611B84FF6}"
Global Const $FOLDERID_DESKTOP = "{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}"
Global Const $FOLDERID_DEVICEMETADATASTORE = "{5CE4A5E9-E4EB-479D-B89F-130C02886155}"
Global Const $FOLDERID_DOCUMENTSLIBRARY = "{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}"
Global Const $FOLDERID_DOWNLOADS = "{374DE290-123F-4565-9164-39C4925E467B}"
Global Const $FOLDERID_FAVORITES = "{1777F761-68AD-4D8A-87BD-30B759FA33DD}"
Global Const $FOLDERID_FONTS = "{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}"
Global Const $FOLDERID_GAMES = "{CAC52C1A-B53D-4EDC-92D7-6B2E8AC19434}"
Global Const $FOLDERID_GAMETASKS = "{054FAE61-4DD8-4787-80B6-090220C4B700}"
Global Const $FOLDERID_HISTORY = "{D9DC8A3B-B784-432E-A781-5A1130A75963}"
Global Const $FOLDERID_HOMEGROUP = "{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}"
Global Const $FOLDERID_IMPLICITAPPSHORTCUTS = "{BCB5256F-79F6-4CEE-B725-DC34E402FD46}"
Global Const $FOLDERID_INTERNETCACHE = "{352481E8-33BE-4251-BA85-6007CAEDCF9D}"
Global Const $FOLDERID_INTERNETFOLDER = "{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}"
Global Const $FOLDERID_LIBRARIES = "{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}"
Global Const $FOLDERID_LINKS = "{BFB9D5E0-C6A9-404C-B2B2-AE6DB6AF4968}"
Global Const $FOLDERID_LOCALAPPDATA = "{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}"
Global Const $FOLDERID_LOCALAPPDATALOW = "{A520A1A4-1780-4FF6-BD18-167343C5AF16}"
Global Const $FOLDERID_LOCALIZEDRESOURCESDIR = "{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}"
Global Const $FOLDERID_MUSIC = "{4BD8D571-6D19-48D3-BE97-422220080E43}"
Global Const $FOLDERID_MUSICLIBRARY = "{2112AB0A-C86A-4FFE-A368-0DE96E47012E}"
Global Const $FOLDERID_NETHOOD = "{C5ABBF53-E17F-4121-8900-86626FC2C973}"
Global Const $FOLDERID_NETWORKFOLDER = "{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}"
Global Const $FOLDERID_ORIGINALIMAGES = "{2C36C0AA-5812-4B87-BFD0-4CD0DFB19B39}"
Global Const $FOLDERID_PHOTOALBUMS = "{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}"
Global Const $FOLDERID_PICTURESLIBRARY = "{A990AE9F-A03B-4E80-94BC-9912D7504104}"
Global Const $FOLDERID_PICTURES = "{33E28130-4E1E-4676-835A-98395C3BC3BB}"
Global Const $FOLDERID_PLAYLISTS = "{DE92C1C7-837F-4F69-A3BB-86E631204A23}"
Global Const $FOLDERID_PRINTERSFOLDER = "{76FC4E2D-D6AD-4519-A663-37BD56068185}"
Global Const $FOLDERID_PRINTHOOD = "{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}"
Global Const $FOLDERID_PROFILE = "{5E6C858F-0E22-4760-9AFE-EA3317B67173}"
Global Const $FOLDERID_PROGRAMDATA = "{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}"
Global Const $FOLDERID_PROGRAMFILES = "{905E63B6-C1BF-494E-B29C-65B732D3D21A}"
Global Const $FOLDERID_PROGRAMFILESX64 = "{6D809377-6AF0-444B-8957-A3773F02200E}"
Global Const $FOLDERID_PROGRAMFILESX86 = "{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}"
Global Const $FOLDERID_PROGRAMFILESCOMMON = "{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}"
Global Const $FOLDERID_PROGRAMFILESCOMMONX64 = "{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}"
Global Const $FOLDERID_PROGRAMFILESCOMMONX86 = "{DE974D24-D9C6-4D3E-BF91-F4455120B917}"
Global Const $FOLDERID_PROGRAMS = "{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}"
Global Const $FOLDERID_PUBLIC = "{DFDF76A2-C82A-4D63-906A-5644AC457385}"
Global Const $FOLDERID_PUBLICDESKTOP = "{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}"
Global Const $FOLDERID_PUBLICDOCUMENTS = "{ED4824AF-DCE4-45A8-81E2-FC7965083634}"
Global Const $FOLDERID_PUBLICDOWNLOADS = "{3D644C9B-1FB8-4F30-9B45-F670235F79C0}"
Global Const $FOLDERID_PUBLICGAMETASKS = "{DEBF2536-E1A8-4C59-B6A2-414586476AEA}"
Global Const $FOLDERID_PUBLICLIBRARIES = "{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}"
Global Const $FOLDERID_PUBLICMUSIC = "{3214FAB5-9757-4298-BB61-92A9DEAA44FF}"
Global Const $FOLDERID_PUBLICPICTURES = "{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}"
Global Const $FOLDERID_PUBLICRINGTONES = "{E555AB60-153B-4D17-9F04-A5FE99FC15EC}"
Global Const $FOLDERID_PUBLICVIDEOS = "{2400183A-6185-49FB-A2D8-4A392A602BA3}"
Global Const $FOLDERID_QUICKLAUNCH = "{52A4F021-7B75-48A9-9F6B-4B87A210BC8F}"
Global Const $FOLDERID_RECENT = "{AE50C081-EBD2-438A-8655-8A092E34987A}"
Global Const $FOLDERID_RECORDEDTVLIBRARY = "{1A6FDBA2-F42D-4358-A798-B74D745926C5}"
Global Const $FOLDERID_RECYCLEBINFOLDER = "{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}"
Global Const $FOLDERID_RESOURCEDIR = "{8AD10C31-2ADB-4296-A8F7-E4701232C972}"
Global Const $FOLDERID_RINGTONES = "{C870044B-F49E-4126-A9C3-B52A1FF411E8}"
Global Const $FOLDERID_ROAMINGAPPDATA = "{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}"
Global Const $FOLDERID_SAMPLEMUSIC = "{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}"
Global Const $FOLDERID_SAMPLEPICTURES = "{C4900540-2379-4C75-844B-64E6FAF8716B}"
Global Const $FOLDERID_SAMPLEPLAYLISTS = "{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}"
Global Const $FOLDERID_SAMPLEVIDEOS = "{859EAD94-2E85-48AD-A71A-0969CB56A6CD}"
Global Const $FOLDERID_SAVEDGAMES = "{4C5C32FF-BB9D-43B0-B5B4-2D72E54EAAA4}"
Global Const $FOLDERID_SAVEDSEARCHES = "{7D1D3A04-DEBB-4115-95CF-2F29DA2920DA}"
Global Const $FOLDERID_SEARCH_CSC = "{EE32E446-31CA-4ABA-814F-A5EBD2FD6D5E}"
Global Const $FOLDERID_SEARCH_MAPI = "{98EC0E18-2098-4D44-8644-66979315A281}"
Global Const $FOLDERID_SEARCHHOME = "{190337D1-B8CA-4121-A639-6D472D16972A}"
Global Const $FOLDERID_SENDTO = "{8983036C-27C0-404B-8F08-102D10DCFD74}"
Global Const $FOLDERID_SIDEBARDEFAULTPARTS = "{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}"
Global Const $FOLDERID_SIDEBARPARTS = "{A75D362E-50FC-4FB7-AC2C-A8BEAA314493}"
Global Const $FOLDERID_STARTMENU = "{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}"
Global Const $FOLDERID_STARTUP = "{B97D20BB-F46A-4C97-BA10-5E3608430854}"
Global Const $FOLDERID_SYNCMANAGERFOLDER = "{43668BF8-C14E-49B2-97C9-747784D784B7}"
Global Const $FOLDERID_SYNCRESULTSFOLDER = "{289A9A43-BE44-4057-A41B-587A76D7E7F9}"
Global Const $FOLDERID_SYNCSETUPFOLDER = "{0F214138-B1D3-4A90-BBA9-27CBC0C5389A}"
Global Const $FOLDERID_SYSTEM = "{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}"
Global Const $FOLDERID_SYSTEMX86 = "{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}"
Global Const $FOLDERID_TEMPLATES = "{A63293E8-664E-48DB-A079-DF759E0509F7}"
Global Const $FOLDERID_USERPINNED = "{9E3995AB-1F9C-4F13-B827-48B24B6C7174}"
Global Const $FOLDERID_USERPROFILES = "{0762D272-C50A-4BB0-A382-697DCD729B80}"
Global Const $FOLDERID_USERPROGRAMFILES = "{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}"
Global Const $FOLDERID_USERPROGRAMFILESCOMMON = "{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}"
Global Const $FOLDERID_USERSFILES = "{F3CE0F7C-4901-4ACC-8648-D5D44B04EF8F}"
Global Const $FOLDERID_USERSLIBRARIES = "{A302545D-DEFF-464B-ABE8-61C8648D939B}"
Global Const $FOLDERID_VIDEOS = "{18989B1D-99B5-455B-841C-AB7C74E4DDFC}"
Global Const $FOLDERID_VIDEOSLIBRARY = "{491E922F-5643-4AF4-A7EB-4E7A138D8174}"
Global Const $FOLDERID_WINDOWS = "{F38BF404-1D43-42F2-9305-67DE0B28FC23}"
Global Const $KF_FLAG_ALIAS_ONLY = -2147483648
Global Const $KF_FLAG_CREATE = 0x8000
Global Const $KF_FLAG_DONT_VERIFY = 0x4000
Global Const $KF_FLAG_DONT_UNEXPAND = 0x2000
Global Const $KF_FLAG_NO_ALIAS = 0x1000
Global Const $KF_FLAG_INIT = 0x800
Global Const $KF_FLAG_DEFAULT_PATH = 0x400
Global Const $KF_FLAG_NO_APPCONTAINER_REDIRECTION = 0x10000
Global Const $KF_FLAG_NOT_PARENT_RELATIVE = 0x200
Global Const $KF_FLAG_SIMPLE_IDLIST = 0x100
Global Const $URL_SCHEME_INVALID = + -1
Global Const $URL_SCHEME_UNKNOWN = 0x0
Global Const $URL_SCHEME_FTP = 0x1
Global Const $URL_SCHEME_HTTP = 0x2
Global Const $URL_SCHEME_GOPHER = 0x3
Global Const $URL_SCHEME_MAILTO = 0x4
Global Const $URL_SCHEME_NEWS = 0x5
Global Const $URL_SCHEME_NNTP = 0x6
Global Const $URL_SCHEME_TELNET = 0x7
Global Const $URL_SCHEME_WAIS = 0x8
Global Const $URL_SCHEME_FILE = 0x9
Global Const $URL_SCHEME_MK = 0xa
Global Const $URL_SCHEME_HTTPS = 0xb
Global Const $URL_SCHEME_SHELL = 0xc
Global Const $URL_SCHEME_SNEWS = 0xd
Global Const $URL_SCHEME_LOCAL = 0xe
Global Const $URL_SCHEME_JAVASCRIPT = 0xf
Global Const $URL_SCHEME_VBSCRIPT = 0x10
Global Const $URL_SCHEME_ABOUT = 0x11
Global Const $URL_SCHEME_RES = 0x12
Global Const $URL_SCHEME_MSSHELLROOTED = 0x13
Global Const $URL_SCHEME_MSSHELLIDLIST = 0x14
Global Const $URL_SCHEME_MSHELP = 0x15
Global Const $URL_SCHEME_MSSHELLDEVICE = 0x16
Global Const $URL_SCHEME_WILDCARD = 0x17
Global Const $URL_SCHEME_SEARCH_MS = 0x18
Global Const $URL_SCHEME_SEARCH = 0x19
Global Const $URL_SCHEME_KNOWNFOLDER = 0x1a
Global Const $GCT_INVALID = 0x0
Global Const $GCT_LFNCHAR = 0x1
Global Const $GCT_SEPARATOR = 0x8
Global Const $GCT_SHORTCHAR = 0x2
Global Const $GCT_WILD = 0x4
Global Const $URL_APPLY_DEFAULT = 0x1
Global Const $URL_APPLY_GUESSSCHEME = 0x2
Global Const $URL_APPLY_GUESSFILE = 0x4
Global Const $URL_APPLY_FORCEAPPLY = 0x8
Global Const $URL_DONT_SIMPLIFY = 0x8000000
Global Const $URL_ESCAPE_AS_UTF8 = 0x40000
Global Const $URL_ESCAPE_PERCENT = 0x1000
Global Const $URL_ESCAPE_SPACES_ONLY = 0x4000000
Global Const $URL_ESCAPE_UNSAFE = 0x20000000
Global Const $URL_NO_META = 0x8000000
Global Const $URL_PLUGGABLE_PROTOCOL = 0x40000000
Global Const $URL_UNESCAPE = 0x10000000
Global Const $URL_PART_HOSTNAME = 0x2
Global Const $URL_PART_PASSWORD = 0x4
Global Const $URL_PART_PORT = 0x5
Global Const $URL_PART_QUERY = 0x6
Global Const $URL_PART_SCHEME = 0x1
Global Const $URL_PART_USERNAME = 0x3
Global Const $URLIS_APPLIABLE = 0x4
Global Const $URLIS_DIRECTORY = 0x5
Global Const $URLIS_FILEURL = 0x3
Global Const $URLIS_HASQUERY = 0x6
Global Const $URLIS_NOHISTORY = 0x2
Global Const $URLIS_OPAQUE = 0x1
Global Const $URLIS_URL = 0x0
Global Const $KLF_ACTIVATE = 0x1
Global Const $KLF_NOTELLSHELL = 0x80
Global Const $KLF_REORDER = 0x8
Global Const $KLF_REPLACELANG = 0x10
Global Const $KLF_RESET = 0x40000000
Global Const $KLF_SETFORPROCESS = 0x100
Global Const $KLF_SHIFTLOCK = 0x10000
Global Const $KLF_SUBSTITUTE_OK = 0x2
Global Const $HKL_NEXT = 0x1
Global Const $HKL_PREV = 0x0
Global Const $AW_ACTIVATE = 0x20000
Global Const $AW_BLEND = 0x80000
Global Const $AW_CENTER = 0x10
Global Const $AW_HIDE = 0x10000
Global Const $AW_HOR_NEGATIVE = 0x2
Global Const $AW_HOR_POSITIVE = 0x1
Global Const $AW_SLIDE = 0x40000
Global Const $AW_VER_NEGATIVE = 0x8
Global Const $AW_VER_POSITIVE = 0x4
Global Const $BSF_ALLOWSFW = 0x80
Global Const $BSF_FLUSHDISK = 0x4
Global Const $BSF_FORCEIFHUNG = 0x20
Global Const $BSF_IGNORECURRENTTASK = 0x2
Global Const $BSF_NOHANG = 0x8
Global Const $BSF_NOTIMEOUTIFNOTHUNG = 0x40
Global Const $BSF_POSTMESSAGE = 0x10
Global Const $BSF_QUERY = 0x1
Global Const $BSF_SENDNOTIFYMESSAGE = 0x100
Global Const $BSM_ALLCOMPONENTS = 0x0
Global Const $BSM_ALLDESKTOPS = 0x8
Global Const $BSM_APPLICATIONS = 0x10
Global Const $BSM_INSTALLABLEDRIVERS = 0x4
Global Const $BSM_NETDRIVER = 0x2
Global Const $BSM_VXDS = 0x1
Global Const $MDITILE_HORIZONTAL = 0x1
Global Const $MDITILE_SKIPDISABLED = 0x2
Global Const $MDITILE_VERTICAL = 0x0
Global Const $MDITILE_ZORDER = 0x4
Global Const $MSGFLT_ALLOW = 0x1
Global Const $MSGFLT_DISALLOW = 0x2
Global Const $MSGFLT_RESET = 0x0
Global Const $MSGFLTINFO_ALLOWED_HIGHER = 0x3
Global Const $MSGFLTINFO_ALREADYALLOWED_FORWND = 0x1
Global Const $MSGFLTINFO_ALREADYDISALLOWED_FORWND = 0x2
Global Const $MSGFLTINFO_NONE = 0x0
Global Const $CWP_ALL = 0x0
Global Const $CWP_SKIPINVISIBLE = 0x1
Global Const $CWP_SKIPDISABLED = 0x2
Global Const $CWP_SKIPTRANSPARENT = 0x4
Global Const $COMPRESSION_FORMAT_NONE = 0x0
Global Const $COMPRESSION_FORMAT_DEFAULT = 0x1
Global Const $COMPRESSION_FORMAT_LZNT1 = 0x2
Global Const $COMPRESSION_FORMAT_XPRESS = 0x3
Global Const $COMPRESSION_FORMAT_XPRESS_HUFF = 0x4
Global Const $COMPRESSION_ENGINE_STANDARD = 0x0
Global Const $COMPRESSION_ENGINE_MAXIMUM = 0x100
Global Const $COMPRESSION_ENGINE_HIBER = 0x200
Global Const $WINSTA_ACCESSCLIPBOARD = 0x4
Global Const $WINSTA_ACCESSGLOBALATOMS = 0x20
Global Const $WINSTA_CREATEDESKTOP = 0x8
Global Const $WINSTA_ENUMDESKTOPS = 0x1
Global Const $WINSTA_ENUMERATE = 0x100
Global Const $WINSTA_EXITWINDOWS = 0x40
Global Const $WINSTA_READATTRIBUTES = 0x2
Global Const $WINSTA_READSCREEN = 0x200
Global Const $WINSTA_WRITEATTRIBUTES = 0x10
Global Const $WINSTA_ALL_ACCESS = BitOR($WINSTA_ACCESSCLIPBOARD, $WINSTA_ACCESSGLOBALATOMS, $WINSTA_CREATEDESKTOP, $WINSTA_ENUMDESKTOPS, $WINSTA_ENUMERATE, $WINSTA_EXITWINDOWS, $WINSTA_READATTRIBUTES, $WINSTA_READSCREEN, $WINSTA_WRITEATTRIBUTES)
Global Const $CWF_CREATE_ONLY = 0x1
Global Const $GCL_CBCLSEXTRA = + -20
Global Const $GCL_CBWNDEXTRA = + -18
Global Const $GCL_HBRBACKGROUND = + -10
Global Const $GCL_HCURSOR = + -12
Global Const $GCL_HICON = + -14
Global Const $GCL_HICONSM = + -34
Global Const $GCL_HMODULE = + -16
Global Const $GCL_MENUNAME = + -8
Global Const $GCL_STYLE = + -26
Global Const $GCL_WNDPROC = + -24
Global Const $DOCKINFO_DOCKED = 0x2
Global Const $DOCKINFO_UNDOCKED = 0x1
Global Const $DOCKINFO_USER_SUPPLIED = 0x4
Global Const $DOCKINFO_USER_DOCKED = 0x5
Global Const $DOCKINFO_USER_UNDOCKED = 0x6
Global Const $GUI_CARETBLINKING = 0x1
Global Const $GUI_INMENUMODE = 0x4
Global Const $GUI_INMOVESIZE = 0x2
Global Const $GUI_POPUPMENUMODE = 0x10
Global Const $GUI_SYSTEMMENUMODE = 0x8
Global Const $HANDLE_FLAG_INHERIT = 0x1
Global Const $HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x2
Global Const $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = 0x4
Global Const $GET_MODULE_HANDLE_EX_FLAG_PIN = 0x1
Global Const $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 0x2
Global Const $GET_MODULE_HANDLE_EX_FLAG_DEFAULT = 0x0
Global Const $PROCESSOR_ARCHITECTURE_AMD64 = 0x9
Global Const $PROCESSOR_ARCHITECTURE_IA64 = 0x6
Global Const $PROCESSOR_ARCHITECTURE_INTEL = 0x0
Global Const $PROCESSOR_ARCHITECTURE_UNKNOWN = 0xffff
Global Const $PROCESSOR_INTEL_386 = 0x182
Global Const $PROCESSOR_INTEL_486 = 0x1e6
Global Const $PROCESSOR_INTEL_PENTIUM = 0x24a
Global Const $PROCESSOR_INTEL_IA64 = 0x898
Global Const $PROCESSOR_AMD_X8664 = 0x21d8
Global Const $UOI_FLAGS = 0x1
Global Const $UOI_HEAPSIZE = 0x5
Global Const $UOI_IO = 0x6
Global Const $UOI_NAME = 0x2
Global Const $UOI_TYPE = 0x3
Global Const $UOI_USER_SID = 0x4
Global Const $DF_ALLOWOTHERACCOUNTHOOK = 0x1
Global Const $WSF_VISIBLE = 0x1
Global Const $VER_SUITE_BACKOFFICE = 0x4
Global Const $VER_SUITE_BLADE = 0x400
Global Const $VER_SUITE_COMPUTE_SERVER = 0x4000
Global Const $VER_SUITE_DATACENTER = 0x80
Global Const $VER_SUITE_ENTERPRISE = 0x2
Global Const $VER_SUITE_EMBEDDEDNT = 0x40
Global Const $VER_SUITE_PERSONAL = 0x200
Global Const $VER_SUITE_SINGLEUSERTS = 0x100
Global Const $VER_SUITE_SMALLBUSINESS = 0x1
Global Const $VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x20
Global Const $VER_SUITE_STORAGE_SERVER = 0x2000
Global Const $VER_SUITE_TERMINAL = 0x10
Global Const $VER_SUITE_WH_SERVER = 0x8000
Global Const $VER_NT_DOMAIN_CONTROLLER = 0x2
Global Const $VER_NT_SERVER = 0x3
Global Const $VER_NT_WORKSTATION = 0x1
Global Const $WDA_MONITOR = 0x1
Global Const $WDA_NONE = 0x0
Global Const $PF_3DNOW_INSTRUCTIONS_AVAILABLE = 0x7
Global Const $PF_CHANNELS_ENABLED = 0x10
Global Const $PF_COMPARE_EXCHANGE_DOUBLE = 0x2
Global Const $PF_COMPARE_EXCHANGE128 = 0xe
Global Const $PF_COMPARE64_EXCHANGE128 = 0xf
Global Const $PF_FLOATING_POINT_EMULATED = 0x1
Global Const $PF_FLOATING_POINT_PRECISION_ERRATA = 0x0
Global Const $PF_MMX_INSTRUCTIONS_AVAILABLE = 0x3
Global Const $PF_NX_ENABLED = 0xc
Global Const $PF_PAE_ENABLED = 0x9
Global Const $PF_RDTSC_INSTRUCTION_AVAILABLE = 0x8
Global Const $PF_SSE3_INSTRUCTIONS_AVAILABLE = 0xd
Global Const $PF_XMMI_INSTRUCTIONS_AVAILABLE = 0x6
Global Const $PF_XMMI64_INSTRUCTIONS_AVAILABLE = 0xa
Global Const $PF_XSAVE_ENABLED = 0x11
Global Const $KEYEVENTF_EXTENDEDKEY = 0x1
Global Const $KEYEVENTF_KEYUP = 0x2
Global Const $LIM_SMALL = 0x0
Global Const $LIM_LARGE = 0x1
Global Const $MAPVK_VK_TO_CHAR = 0x2
Global Const $MAPVK_VK_TO_VSC = 0x0
Global Const $MAPVK_VK_TO_VSC_EX = 0x4
Global Const $MAPVK_VSC_TO_VK = 0x1
Global Const $MAPVK_VSC_TO_VK_EX = 0x3
Global Const $MOD_ALT = 0x1
Global Const $MOD_CONTROL = 0x2
Global Const $MOD_NOREPEAT = 0x4000
Global Const $MOD_SHIFT = 0x4
Global Const $MOD_WIN = 0x8
Global Const $GUID_ACDC_POWER_SOURCE = "{5D3E9A59-E9D5-4B00-A6BD-FF34FF516548}"
Global Const $GUID_BATTERY_PERCENTAGE_REMAINING = "{A7AD8041-B45A-4CAE-87A3-EECBB468A9E1}"
Global Const $GUID_IDLE_BACKGROUND_TASK = "{515C31D8-F734-163D-A0FD-11A08C91E8F1}"
Global Const $GUID_MONITOR_POWER_ON = "{02731015-4510-4526-99E6-E5A17EBD1AEA}"
Global Const $GUID_POWERSCHEME_PERSONALITY = "{245D8541-3943-4422-B025-13A784F679B7}"
Global Const $GUID_SYSTEM_AWAYMODE = "{98A7F580-01F7-48AA-9C0F-44352C29E5C0}"
Global Const $GUID_MIN_POWER_SAVINGS = "{8C5E7FDA-E8BF-4A96-9A85-A6E23A8C635C}"
Global Const $GUID_MAX_POWER_SAVINGS = "{A1841308-3541-4FAB-BC81-F71556F20B4A}"
Global Const $GUID_TYPICAL_POWER_SAVINGS = "{381B4222-F694-41F0-9685-FF5BB260DF2E}"
Global Const $HSHELL_WINDOWCREATED = 0x1
Global Const $HSHELL_WINDOWDESTROYED = 0x2
Global Const $HSHELL_ACTIVATESHELLWINDOW = 0x3
Global Const $HSHELL_WINDOWACTIVATED = 0x4
Global Const $HSHELL_GETMINRECT = 0x5
Global Const $HSHELL_REDRAW = 0x6
Global Const $HSHELL_TASKMAN = 0x7
Global Const $HSHELL_LANGUAGE = 0x8
Global Const $HSHELL_SYSMENU = 0x9
Global Const $HSHELL_ENDTASK = 0xa
Global Const $HSHELL_ACCESSIBILITYSTATE = 0xb
Global Const $HSHELL_APPCOMMAND = 0xc
Global Const $HSHELL_WINDOWREPLACED = 0xd
Global Const $HSHELL_WINDOWREPLACING = 0xe
Global Const $HSHELL_RUDEAPPACTIVATED = 0x8004
Global Const $HSHELL_FLASH = 0x8006
Global Const $HWND_BROADCAST = 0xffff
Global Const $SMTO_BLOCK = 0x1
Global Const $SMTO_NORMAL = 0x0
Global Const $SMTO_ABORTIFHUNG = 0x2
Global Const $SMTO_NOTIMEOUTIFNOTHUNG = 0x8
Global Const $SMTO_ERRORONEXIT = 0x20
Global Const $INPUTLANGCHANGE_BACKWARD = 0x4
Global Const $INPUTLANGCHANGE_FORWARD = 0x2
Global Const $INPUTLANGCHANGE_SYSCHARSET = 0x1
Global Const $EVENT_MIN = 0x1
Global Const $EVENT_SYSTEM_SOUND = 0x1
Global Const $EVENT_SYSTEM_ALERT = 0x2
Global Const $EVENT_SYSTEM_FOREGROUND = 0x3
Global Const $EVENT_SYSTEM_MENUSTART = 0x4
Global Const $EVENT_SYSTEM_MENUEND = 0x5
Global Const $EVENT_SYSTEM_MENUPOPUPSTART = 0x6
Global Const $EVENT_SYSTEM_MENUPOPUPEND = 0x7
Global Const $EVENT_SYSTEM_CAPTURESTART = 0x8
Global Const $EVENT_SYSTEM_CAPTUREEND = 0x9
Global Const $EVENT_SYSTEM_MOVESIZESTART = 0xa
Global Const $EVENT_SYSTEM_MOVESIZEEND = 0xb
Global Const $EVENT_SYSTEM_CONTEXTHELPSTART = 0xc
Global Const $EVENT_SYSTEM_CONTEXTHELPEND = 0xd
Global Const $EVENT_SYSTEM_DRAGDROPSTART = 0xe
Global Const $EVENT_SYSTEM_DRAGDROPEND = 0xf
Global Const $EVENT_SYSTEM_DIALOGSTART = 0x10
Global Const $EVENT_SYSTEM_DIALOGEND = 0x11
Global Const $EVENT_SYSTEM_SCROLLINGSTART = 0x12
Global Const $EVENT_SYSTEM_SCROLLINGEND = 0x13
Global Const $EVENT_SYSTEM_SWITCHSTART = 0x14
Global Const $EVENT_SYSTEM_SWITCHEND = 0x15
Global Const $EVENT_SYSTEM_MINIMIZESTART = 0x16
Global Const $EVENT_SYSTEM_MINIMIZEEND = 0x17
Global Const $EVENT_SYSTEM_DESKTOPSWITCH = 0x20
Global Const $EVENT_OBJECT_CREATE = 0x8000
Global Const $EVENT_OBJECT_DESTROY = 0x8001
Global Const $EVENT_OBJECT_SHOW = 0x8002
Global Const $EVENT_OBJECT_HIDE = 0x8003
Global Const $EVENT_OBJECT_REORDER = 0x8004
Global Const $EVENT_OBJECT_FOCUS = 0x8005
Global Const $EVENT_OBJECT_SELECTION = 0x8006
Global Const $EVENT_OBJECT_SELECTIONADD = 0x8007
Global Const $EVENT_OBJECT_SELECTIONREMOVE = 0x8008
Global Const $EVENT_OBJECT_SELECTIONWITHIN = 0x8009
Global Const $EVENT_OBJECT_STATECHANGE = 0x800a
Global Const $EVENT_OBJECT_LOCATIONCHANGE = 0x800b
Global Const $EVENT_OBJECT_NAMECHANGE = 0x800c
Global Const $EVENT_OBJECT_DESCRIPTIONCHANGE = 0x800d
Global Const $EVENT_OBJECT_VALUECHANGE = 0x800e
Global Const $EVENT_OBJECT_PARENTCHANGE = 0x800f
Global Const $EVENT_OBJECT_HELPCHANGE = 0x8010
Global Const $EVENT_OBJECT_DEFACTIONCHANGE = 0x8011
Global Const $EVENT_OBJECT_ACCELERATORCHANGE = 0x8012
Global Const $EVENT_OBJECT_INVOKED = 0x8013
Global Const $EVENT_OBJECT_TEXTSELECTIONCHANGED = 0x8014
Global Const $EVENT_OBJECT_CONTENTSCROLLED = 0x8015
Global Const $EVENT_MAX = 0x7fffffff
Global Const $WINEVENT_INCONTEXT = 0x4
Global Const $WINEVENT_OUTOFCONTEXT = 0x0
Global Const $WINEVENT_SKIPOWNPROCESS = 0x2
Global Const $WINEVENT_SKIPOWNTHREAD = 0x1
Global Const $TME_CANCEL = -2147483648
Global Const $TME_HOVER = 0x1
Global Const $TME_LEAVE = 0x2
Global Const $TME_NONCLIENT = 0x10
Global Const $TME_QUERY = 0x40000000
Global Const $DESKTOP_CREATEMENU = 0x4
Global Const $DESKTOP_CREATEWINDOW = 0x2
Global Const $DESKTOP_ENUMERATE = 0x40
Global Const $DESKTOP_HOOKCONTROL = 0x8
Global Const $DESKTOP_JOURNALPLAYBACK = 0x20
Global Const $DESKTOP_JOURNALRECORD = 0x10
Global Const $DESKTOP_READOBJECTS = 0x1
Global Const $DESKTOP_SWITCHDESKTOP = 0x100
Global Const $DESKTOP_WRITEOBJECTS = 0x80
Global Const $DESKTOP_ALL_ACCESS = BitOR($DESKTOP_CREATEMENU, $DESKTOP_CREATEWINDOW, $DESKTOP_ENUMERATE, $DESKTOP_HOOKCONTROL, $DESKTOP_JOURNALPLAYBACK, $DESKTOP_JOURNALRECORD, $DESKTOP_READOBJECTS, $DESKTOP_SWITCHDESKTOP, $DESKTOP_WRITEOBJECTS)
Global Const $RIDEV_APPKEYS = 0x400
Global Const $RIDEV_CAPTUREMOUSE = 0x200
Global Const $RIDEV_DEVNOTIFY = 0x2000
Global Const $RIDEV_EXCLUDE = 0x10
Global Const $RIDEV_EXINPUTSINK = 0x1000
Global Const $RIDEV_INPUTSINK = 0x100
Global Const $RIDEV_NOHOTKEYS = 0x200
Global Const $RIDEV_NOLEGACY = 0x30
Global Const $RIDEV_PAGEONLY = 0x20
Global Const $RIDEV_REMOVE = 0x1
Global Const $RID_HEADER = 0x10000005
Global Const $RID_INPUT = 0x10000003
Global Const $RIM_TYPEHID = 0x2
Global Const $RIM_TYPEKEYBOARD = 0x1
Global Const $RIM_TYPEMOUSE = 0x0
Global Const $RIDI_DEVICENAME = 0x20000007
Global Const $RIDI_DEVICEINFO = 0x2000000b
Global Const $RIDI_PREPARSEDDATA = 0x20000005
Global Const $MOUSE_ATTRIBUTES_CHANGED = 0x4
Global Const $MOUSE_MOVE_ABSOLUTE = 0x1
Global Const $MOUSE_MOVE_RELATIVE = 0x0
Global Const $MOUSE_VIRTUAL_DESKTOP = 0x2
Global Const $RI_MOUSE_LEFT_BUTTON_DOWN = 0x1
Global Const $RI_MOUSE_LEFT_BUTTON_UP = 0x2
Global Const $RI_MOUSE_MIDDLE_BUTTON_DOWN = 0x10
Global Const $RI_MOUSE_MIDDLE_BUTTON_UP = 0x20
Global Const $RI_MOUSE_RIGHT_BUTTON_DOWN = 0x4
Global Const $RI_MOUSE_RIGHT_BUTTON_UP = 0x8
Global Const $RI_MOUSE_BUTTON_1_DOWN = $RI_MOUSE_LEFT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_1_UP = $RI_MOUSE_LEFT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_2_DOWN = $RI_MOUSE_RIGHT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_2_UP = $RI_MOUSE_RIGHT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_3_DOWN = $RI_MOUSE_MIDDLE_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_3_UP = $RI_MOUSE_MIDDLE_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_4_DOWN = 0x40
Global Const $RI_MOUSE_BUTTON_4_UP = 0x80
Global Const $RI_MOUSE_BUTTON_5_DOWN = 0x100
Global Const $RI_MOUSE_BUTTON_5_UP = 0x200
Global Const $RI_MOUSE_WHEEL = 0x400
Global Const $RI_KEY_BREAK = 0x1
Global Const $RI_KEY_E0 = 0x2
Global Const $RI_KEY_E1 = 0x4
Global Const $RI_KEY_MAKE = 0x0
Global Const $BPBF_COMPATIBLEBITMAP = 0x0
Global Const $BPBF_DIB = 0x1
Global Const $BPBF_TOPDOWNDIB = 0x2
Global Const $BPBF_TOPDOWNMONODIB = 0x3
Global Const $BPPF_ERASE = 0x1
Global Const $BPPF_NOCLIP = 0x2
Global Const $BPPF_NONCLIENT = 0x4
Global Const $DTT_TEXTCOLOR = 0x1
Global Const $DTT_BORDERCOLOR = 0x2
Global Const $DTT_SHADOWCOLOR = 0x4
Global Const $DTT_SHADOWTYPE = 0x8
Global Const $DTT_SHADOWOFFSET = 0x10
Global Const $DTT_BORDERSIZE = 0x20
Global Const $DTT_FONTPROP = 0x40
Global Const $DTT_COLORPROP = 0x80
Global Const $DTT_STATEID = 0x100
Global Const $DTT_CALCRECT = 0x200
Global Const $DTT_APPLYOVERLAY = 0x400
Global Const $DTT_GLOWSIZE = 0x800
Global Const $DTT_CALLBACK = 0x1000
Global Const $DTT_COMPOSITED = 0x2000
Global Const $DTT_VALIDBITS = BitOR($DTT_TEXTCOLOR, $DTT_BORDERCOLOR, $DTT_SHADOWCOLOR, $DTT_SHADOWTYPE, $DTT_SHADOWOFFSET, $DTT_BORDERSIZE, $DTT_FONTPROP, $DTT_COLORPROP, $DTT_STATEID, $DTT_CALCRECT, $DTT_APPLYOVERLAY, $DTT_GLOWSIZE, $DTT_COMPOSITED)
Global Const $TST_NONE = 0x0
Global Const $TST_SINGLE = 0x1
Global Const $TST_CONTINUOUS = 0x2
Global Const $STAP_ALLOW_NONCLIENT = 0x1
Global Const $STAP_ALLOW_CONTROLS = 0x2
Global Const $STAP_ALLOW_WEBCONTENT = 0x4
Global Const $GBF_DIRECT = 0x1
Global Const $GBF_COPY = 0x2
Global Const $GBF_VALIDBITS = BitOR($GBF_DIRECT, $GBF_COPY)
Global Const $SZ_THDOCPROP_AUTHOR = "Author"
Global Const $SZ_THDOCPROP_CANONICALNAME = "ThemeName"
Global Const $SZ_THDOCPROP_DISPLAYNAME = "DisplayName"
Global Const $SZ_THDOCPROP_TOOLTIP = "ToolTip"
Global Const $TS_MIN = 0x0
Global Const $TS_TRUE = 0x1
Global Const $TS_DRAW = 0x2
Global Const $PO_CLASS = 0x2
Global Const $PO_GLOBAL = 0x3
Global Const $PO_NOTFOUND = 0x4
Global Const $PO_PART = 0x1
Global Const $PO_STATE = 0x0
Global Const $TMT_BOOL = 0xcb
Global Const $TMT_COLOR = 0xcc
Global Const $TMT_DIBDATA = 0x2
Global Const $TMT_DISKSTREAM = 0xd5
Global Const $TMT_ENUM = 0xc8
Global Const $TMT_FILENAME = 0xce
Global Const $TMT_FONT = 0xd2
Global Const $TMT_GLYPHDIBDATA = 0x8
Global Const $TMT_HBITMAP = 0xd4
Global Const $TMT_INT = 0xca
Global Const $TMT_INTLIST = 0xd3
Global Const $TMT_MARGINS = 0xcd
Global Const $TMT_POSITION = 0xd0
Global Const $TMT_RECT = 0xd1
Global Const $TMT_SIZE = 0xcf
Global Const $TMT_STRING = 0xc9
Global Const $TMT_ALWAYSSHOWSIZINGBAR = 0x8a0
Global Const $TMT_AUTOSIZE = 0x89a
Global Const $TMT_BGFILL = 0x89d
Global Const $TMT_BORDERONLY = 0x89b
Global Const $TMT_COMPOSITED = 0x89c
Global Const $TMT_COMPOSITEDOPAQUE = 0x8ab
Global Const $TMT_DRAWBORDERS = 0x8a6
Global Const $TMT_FLATMENUS = 0x3e9
Global Const $TMT_GLYPHONLY = 0x89f
Global Const $TMT_GLYPHTRANSPARENT = 0x89e
Global Const $TMT_INTEGRALSIZING = 0x8a3
Global Const $TMT_LOCALIZEDMIRRORIMAGE = 0x8ac
Global Const $TMT_MIRRORIMAGE = 0x8a1
Global Const $TMT_NOETCHEDEFFECT = 0x8a7
Global Const $TMT_SOURCEGROW = 0x8a4
Global Const $TMT_SOURCESHRINK = 0x8a5
Global Const $TMT_TEXTAPPLYOVERLAY = 0x8a8
Global Const $TMT_TEXTGLOW = 0x8a9
Global Const $TMT_TEXTITALIC = 0x8aa
Global Const $TMT_TRANSPARENT = 0x899
Global Const $TMT_UNIFORMSIZING = 0x8a2
Global Const $TMT_USERPICTURE = 0x1389
Global Const $TMT_ACCENTCOLORHINT = 0xeef
Global Const $TMT_ACTIVEBORDER = 0x64b
Global Const $TMT_ACTIVECAPTION = 0x643
Global Const $TMT_APPWORKSPACE = 0x64d
Global Const $TMT_BACKGROUND = 0x642
Global Const $TMT_BLENDCOLOR = 0x138b
Global Const $TMT_BODYTEXTCOLOR = 0xef3
Global Const $TMT_BORDERCOLOR = 0xed9
Global Const $TMT_BORDERCOLORHINT = 0xeee
Global Const $TMT_BTNFACE = 0x650
Global Const $TMT_BTNHIGHLIGHT = 0x655
Global Const $TMT_BTNSHADOW = 0x651
Global Const $TMT_BTNTEXT = 0x653
Global Const $TMT_BUTTONALTERNATEFACE = 0x65a
Global Const $TMT_CAPTIONTEXT = 0x64a
Global Const $TMT_DKSHADOW3D = 0x656
Global Const $TMT_EDGEDKSHADOWCOLOR = 0xedf
Global Const $TMT_EDGEFILLCOLOR = 0xee0
Global Const $TMT_EDGEHIGHLIGHTCOLOR = 0xedd
Global Const $TMT_EDGELIGHTCOLOR = 0xedc
Global Const $TMT_EDGESHADOWCOLOR = 0xede
Global Const $TMT_FILLCOLOR = 0xeda
Global Const $TMT_FILLCOLORHINT = 0xeed
Global Const $TMT_FROMCOLOR1 = 0x7d1
Global Const $TMT_FROMCOLOR2 = 0x7d2
Global Const $TMT_FROMCOLOR3 = 0x7d3
Global Const $TMT_FROMCOLOR4 = 0x7d4
Global Const $TMT_FROMCOLOR5 = 0x7d5
Global Const $TMT_GLOWCOLOR = 0xee8
Global Const $TMT_GLYPHTEXTCOLOR = 0xeeb
Global Const $TMT_GLYPHTRANSPARENTCOLOR = 0xeec
Global Const $TMT_GRADIENTACTIVECAPTION = 0x65c
Global Const $TMT_GRADIENTCOLOR1 = 0xee2
Global Const $TMT_GRADIENTCOLOR2 = 0xee3
Global Const $TMT_GRADIENTCOLOR3 = 0xee4
Global Const $TMT_GRADIENTCOLOR4 = 0xee5
Global Const $TMT_GRADIENTCOLOR5 = 0xee6
Global Const $TMT_GRADIENTINACTIVECAPTION = 0x65d
Global Const $TMT_GRAYTEXT = 0x652
Global Const $TMT_HEADING1TEXTCOLOR = 0xef1
Global Const $TMT_HEADING2TEXTCOLOR = 0xef2
Global Const $TMT_HIGHLIGHT = 0x64e
Global Const $TMT_HIGHLIGHTTEXT = 0x64f
Global Const $TMT_HOTTRACKING = 0x65b
Global Const $TMT_INACTIVEBORDER = 0x64c
Global Const $TMT_INACTIVECAPTION = 0x644
Global Const $TMT_INACTIVECAPTIONTEXT = 0x654
Global Const $TMT_INFOBK = 0x659
Global Const $TMT_INFOTEXT = 0x658
Global Const $TMT_LIGHT3D = 0x657
Global Const $TMT_MENU = 0x645
Global Const $TMT_MENUBAR = 0x65f
Global Const $TMT_MENUHILIGHT = 0x65e
Global Const $TMT_MENUTEXT = 0x648
Global Const $TMT_SCROLLBAR = 0x641
Global Const $TMT_SHADOWCOLOR = 0xee7
Global Const $TMT_TEXTBORDERCOLOR = 0xee9
Global Const $TMT_TEXTCOLOR = 0xedb
Global Const $TMT_TEXTCOLORHINT = 0xef0
Global Const $TMT_TEXTSHADOWCOLOR = 0xeea
Global Const $TMT_TRANSPARENTCOLOR = 0xee1
Global Const $TMT_WINDOW = 0x646
Global Const $TMT_WINDOWFRAME = 0x647
Global Const $TMT_WINDOWTEXT = 0x649
Global Const $TMT_ATLASIMAGE = 0x1f40
Global Const $TMT_BGTYPE = 0xfa1
Global Const $TMT_BORDERTYPE = 0xfa2
Global Const $TMT_CONTENTALIGNMENT = 0xfa6
Global Const $TMT_FILLTYPE = 0xfa3
Global Const $TMT_GLYPHTYPE = 0xfac
Global Const $TMT_GLYPHFONTSIZINGTYPE = 0xfae
Global Const $TMT_HALIGN = 0xfa5
Global Const $TMT_ICONEFFECT = 0xfa9
Global Const $TMT_IMAGELAYOUT = 0xfab
Global Const $TMT_IMAGESELECTTYPE = 0xfad
Global Const $TMT_OFFSETTYPE = 0xfa8
Global Const $TMT_SIZINGTYPE = 0xfa4
Global Const $TMT_TEXTSHADOWTYPE = 0xfaa
Global Const $TMT_TRUESIZESCALINGTYPE = 0xfaf
Global Const $TMT_VALIGN = 0xfa7
Global Const $TMT_GLYPHIMAGEFILE = 0xbc0
Global Const $TMT_IMAGEFILE = 0xbb9
Global Const $TMT_IMAGEFILE1 = 0xbba
Global Const $TMT_IMAGEFILE2 = 0xbbb
Global Const $TMT_IMAGEFILE3 = 0xbbc
Global Const $TMT_IMAGEFILE4 = 0xbbd
Global Const $TMT_IMAGEFILE5 = 0xbbe
Global Const $TMT_SCALEDBACKGROUND = 0x1b59
Global Const $TMT_BODYFONT = 0x329
Global Const $TMT_CAPTIONFONT = 0x321
Global Const $TMT_GLYPHFONT = 0xa29
Global Const $TMT_HEADING1FONT = 0x327
Global Const $TMT_HEADING2FONT = 0x328
Global Const $TMT_ICONTITLEFONT = 0x326
Global Const $TMT_MENUFONT = 0x323
Global Const $TMT_MSGBOXFONT = 0x325
Global Const $TMT_SMALLCAPTIONFONT = 0x322
Global Const $TMT_STATUSFONT = 0x324
Global Const $TMT_ALPHALEVEL = 0x962
Global Const $TMT_ALPHATHRESHOLD = 0x96f
Global Const $TMT_ANIMATIONDELAY = 0x97c
Global Const $TMT_ANIMATIONDURATION = 0x138e
Global Const $TMT_BORDERSIZE = 0x963
Global Const $TMT_CHARSET = 0x193
Global Const $TMT_COLORIZATIONCOLOR = 0x97f
Global Const $TMT_COLORIZATIONOPACITY = 0x980
Global Const $TMT_FRAMESPERSECOND = 0x97a
Global Const $TMT_FROMHUE1 = 0x709
Global Const $TMT_FROMHUE2 = 0x70a
Global Const $TMT_FROMHUE3 = 0x70b
Global Const $TMT_FROMHUE4 = 0x70c
Global Const $TMT_FROMHUE5 = 0x70d
Global Const $TMT_GLOWINTENSITY = 0x97d
Global Const $TMT_GLYPHINDEX = 0x972
Global Const $TMT_GRADIENTRATIO1 = 0x966
Global Const $TMT_GRADIENTRATIO2 = 0x967
Global Const $TMT_GRADIENTRATIO3 = 0x968
Global Const $TMT_GRADIENTRATIO4 = 0x969
Global Const $TMT_GRADIENTRATIO5 = 0x96a
Global Const $TMT_HEIGHT = 0x971
Global Const $TMT_IMAGECOUNT = 0x961
Global Const $TMT_MINCOLORDEPTH = 0x515
Global Const $TMT_MINDPI1 = 0x974
Global Const $TMT_MINDPI2 = 0x975
Global Const $TMT_MINDPI3 = 0x976
Global Const $TMT_MINDPI4 = 0x977
Global Const $TMT_MINDPI5 = 0x978
Global Const $TMT_OPACITY = 0x97e
Global Const $TMT_PIXELSPERFRAME = 0x97b
Global Const $TMT_PROGRESSCHUNKSIZE = 0x96b
Global Const $TMT_PROGRESSSPACESIZE = 0x96c
Global Const $TMT_ROUNDCORNERHEIGHT = 0x965
Global Const $TMT_ROUNDCORNERWIDTH = 0x964
Global Const $TMT_SATURATION = 0x96d
Global Const $TMT_TEXTBORDERSIZE = 0x96e
Global Const $TMT_TEXTGLOWSIZE = 0x979
Global Const $TMT_TOCOLOR1 = 0x7d6
Global Const $TMT_TOCOLOR2 = 0x7d7
Global Const $TMT_TOCOLOR3 = 0x7d8
Global Const $TMT_TOCOLOR4 = 0x7d9
Global Const $TMT_TOCOLOR5 = 0x7da
Global Const $TMT_TOHUE1 = 0x70e
Global Const $TMT_TOHUE2 = 0x70f
Global Const $TMT_TOHUE3 = 0x710
Global Const $TMT_TOHUE4 = 0x711
Global Const $TMT_TOHUE5 = 0x712
Global Const $TMT_TRUESIZESTRETCHMARK = 0x973
Global Const $TMT_WIDTH = 0x970
Global Const $TMT_TRANSITIONDURATIONS = 0x1770
Global Const $TMT_CAPTIONMARGINS = 0xe13
Global Const $TMT_CONTENTMARGINS = 0xe12
Global Const $TMT_SIZINGMARGINS = 0xe11
Global Const $TMT_MINSIZE = 0xd4b
Global Const $TMT_MINSIZE1 = 0xd4c
Global Const $TMT_MINSIZE2 = 0xd4d
Global Const $TMT_MINSIZE3 = 0xd4e
Global Const $TMT_MINSIZE4 = 0xd4f
Global Const $TMT_MINSIZE5 = 0xd50
Global Const $TMT_NORMALSIZE = 0xd51
Global Const $TMT_OFFSET = 0xd49
Global Const $TMT_TEXTSHADOWOFFSET = 0xd4a
Global Const $TMT_ANIMATIONBUTTONRECT = 0x138d
Global Const $TMT_ATLASRECT = 0x1f42
Global Const $TMT_CUSTOMSPLITRECT = 0x138c
Global Const $TMT_DEFAULTPANESIZE = 0x138a
Global Const $TMT_CAPTIONBARHEIGHT = 0x4b5
Global Const $TMT_CAPTIONBARWIDTH = 0x4b4
Global Const $TMT_MENUBARHEIGHT = 0x4b9
Global Const $TMT_MENUBARWIDTH = 0x4b8
Global Const $TMT_PADDEDBORDERWIDTH = 0x4ba
Global Const $TMT_SCROLLBARHEIGHT = 0x4b3
Global Const $TMT_SCROLLBARWIDTH = 0x4b2
Global Const $TMT_SIZINGBORDERWIDTH = 0x4b1
Global Const $TMT_SMCAPTIONBARHEIGHT = 0x4b7
Global Const $TMT_SMCAPTIONBARWIDTH = 0x4b6
Global Const $TMT_ALIAS = 0x57c
Global Const $TMT_ATLASINPUTIMAGE = 0x1f41
Global Const $TMT_AUTHOR = 0x25c
Global Const $TMT_CLASSICVALUE = 0xc82
Global Const $TMT_COLORSCHEMES = 0x191
Global Const $TMT_COMPANY = 0x25b
Global Const $TMT_COPYRIGHT = 0x25d
Global Const $TMT_CSSNAME = 0x579
Global Const $TMT_DESCRIPTION = 0x260
Global Const $TMT_DISPLAYNAME = 0x259
Global Const $TMT_LASTUPDATED = 0x57b
Global Const $TMT_SIZES = 0x192
Global Const $TMT_TEXT = 0xc81
Global Const $TMT_TOOLTIP = 0x25a
Global Const $TMT_URL = 0x25e
Global Const $TMT_VERSION = 0x25f
Global Const $TMT_XMLNAME = 0x57a
Global Const $TMT_NAME = 0x258
Global Const $BDR_RAISEDINNER = 0x4
Global Const $BDR_RAISEDOUTER = 0x1
Global Const $BDR_SUNKENINNER = 0x8
Global Const $BDR_SUNKENOUTER = 0x2
Global Const $EDGE_BUMP = BitOR($BDR_RAISEDOUTER, $BDR_SUNKENINNER)
Global Const $EDGE_ETCHED = BitOR($BDR_SUNKENOUTER, $BDR_RAISEDINNER)
Global Const $EDGE_RAISED = BitOR($BDR_RAISEDOUTER, $BDR_RAISEDINNER)
Global Const $EDGE_SUNKEN = BitOR($BDR_SUNKENOUTER, $BDR_SUNKENINNER)
Global Const $BF_ADJUST = 0x2000
Global Const $BF_BOTTOM = 0x8
Global Const $BF_DIAGONAL = 0x10
Global Const $BF_FLAT = 0x4000
Global Const $BF_LEFT = 0x1
Global Const $BF_MIDDLE = 0x800
Global Const $BF_MONO = 0x8000
Global Const $BF_RIGHT = 0x4
Global Const $BF_SOFT = 0x1000
Global Const $BF_TOP = 0x2
Global Const $BF_BOTTOMLEFT = BitOR($BF_BOTTOM, $BF_LEFT)
Global Const $BF_BOTTOMRIGHT = BitOR($BF_BOTTOM, $BF_RIGHT)
Global Const $BF_TOPLEFT = BitOR($BF_TOP, $BF_LEFT)
Global Const $BF_TOPRIGHT = BitOR($BF_TOP, $BF_RIGHT)
Global Const $BF_RECT = BitOR($BF_LEFT, $BF_TOP, $BF_RIGHT, $BF_BOTTOM)
Global Const $BF_DIAGONAL_ENDBOTTOMLEFT = BitOR($BF_DIAGONAL, $BF_BOTTOM, $BF_LEFT)
Global Const $BF_DIAGONAL_ENDBOTTOMRIGHT = BitOR($BF_DIAGONAL, $BF_BOTTOM, $BF_RIGHT)
Global Const $BF_DIAGONAL_ENDTOPLEFT = BitOR($BF_DIAGONAL, $BF_TOP, $BF_LEFT)
Global Const $BF_DIAGONAL_ENDTOPRIGHT = BitOR($BF_DIAGONAL, $BF_TOP, $BF_RIGHT)
Global Const $COLOR_ALICEBLUE = 0xf0f8ff
Global Const $COLOR_ANTIQUEWHITE = 0xfaebd7
Global Const $COLOR_AQUA = 0xffff
Global Const $COLOR_AQUAMARINE = 0x7fffd4
Global Const $COLOR_AZURE = 0xf0ffff
Global Const $COLOR_BEIGE = 0xf5f5dc
Global Const $COLOR_BISQUE = 0xffe4c4
Global Const $COLOR_BLACK = 0x0
Global Const $COLOR_BLANCHEDALMOND = 0xffebcd
Global Const $COLOR_BLUE = 0xff
Global Const $COLOR_BLUEVIOLET = 0x8a2be2
Global Const $COLOR_BROWN = 0xa52a2a
Global Const $COLOR_BURLYWOOD = 0xdeb887
Global Const $COLOR_CADETBLUE = 0x5f9ea0
Global Const $COLOR_CHARTREUSE = 0x7fff00
Global Const $COLOR_CHOCOLATE = 0xd2691e
Global Const $COLOR_CORAL = 0xff7f50
Global Const $COLOR_CORNFLOWERBLUE = 0x6495ed
Global Const $COLOR_CORNSILK = 0xfff8dc
Global Const $COLOR_CRIMSON = 0xdc143c
Global Const $COLOR_CYAN = 0xffff
Global Const $COLOR_DARKBLUE = 0x8b
Global Const $COLOR_DARKCYAN = 0x8b8b
Global Const $COLOR_DARKGOLDENROD = 0xb8860b
Global Const $COLOR_DARKGRAY = 0xa9a9a9
Global Const $COLOR_DARKGREEN = 0x6400
Global Const $COLOR_DARKKHAKI = 0xbdb76b
Global Const $COLOR_DARKMAGENTA = 0x8b008b
Global Const $COLOR_DARKOLIVEGREEN = 0x556b2f
Global Const $COLOR_DARKORANGE = 0xff8c00
Global Const $COLOR_DARKORCHID = 0x9932cc
Global Const $COLOR_DARKRED = 0x8b0000
Global Const $COLOR_DARKSALMON = 0xe9967a
Global Const $COLOR_DARKSEAGREEN = 0x8fbc8f
Global Const $COLOR_DARKSLATEBLUE = 0x483d8b
Global Const $COLOR_DARKSLATEGRAY = 0x2f4f4f
Global Const $COLOR_DARKTURQUOISE = 0xced1
Global Const $COLOR_DARKVIOLET = 0x9400d3
Global Const $COLOR_DEEPPINK = 0xff1493
Global Const $COLOR_DEEPSKYBLUE = 0xbfff
Global Const $COLOR_DIMGRAY = 0x696969
Global Const $COLOR_DODGERBLUE = 0x1e90ff
Global Const $COLOR_FIREBRICK = 0xb22222
Global Const $COLOR_FLORALWHITE = 0xfffaf0
Global Const $COLOR_FORESTGREEN = 0x228b22
Global Const $COLOR_FUCHSIA = 0xff00ff
Global Const $COLOR_GAINSBORO = 0xdcdcdc
Global Const $COLOR_GHOSTWHITE = 0xf8f8ff
Global Const $COLOR_GOLD = 0xffd700
Global Const $COLOR_GOLDENROD = 0xdaa520
Global Const $COLOR_GRAY = 0x808080
Global Const $COLOR_GREEN = 0x8000
Global Const $COLOR_GREENYELLOW = 0xadff2f
Global Const $COLOR_HONEYDEW = 0xf0fff0
Global Const $COLOR_HOTPINK = 0xff69b4
Global Const $COLOR_INDIANRED = 0xcd5c5c
Global Const $COLOR_INDIGO = 0x4b0082
Global Const $COLOR_IVORY = 0xfffff0
Global Const $COLOR_KHAKI = 0xf0e68c
Global Const $COLOR_LAVENDER = 0xe6e6fa
Global Const $COLOR_LAVENDERBLUSH = 0xfff0f5
Global Const $COLOR_LAWNGREEN = 0x7cfc00
Global Const $COLOR_LEMONCHIFFON = 0xfffacd
Global Const $COLOR_LIGHTBLUE = 0xadd8e6
Global Const $COLOR_LIGHTCORAL = 0xf08080
Global Const $COLOR_LIGHTCYAN = 0xe0ffff
Global Const $COLOR_LIGHTGOLDENRODYELLOW = 0xfafad2
Global Const $COLOR_LIGHTGRAY = 0xd3d3d3
Global Const $COLOR_LIGHTGREEN = 0x90ee90
Global Const $COLOR_LIGHTPINK = 0xffb6c1
Global Const $COLOR_LIGHTSALMON = 0xffa07a
Global Const $COLOR_LIGHTSEAGREEN = 0x20b2aa
Global Const $COLOR_LIGHTSKYBLUE = 0x87cefa
Global Const $COLOR_LIGHTSLATEGRAY = 0x778899
Global Const $COLOR_LIGHTSTEELBLUE = 0xb0c4de
Global Const $COLOR_LIGHTYELLOW = 0xffffe0
Global Const $COLOR_LIME = 0xff00
Global Const $COLOR_LIMEGREEN = 0x32cd32
Global Const $COLOR_LINEN = 0xfaf0e6
Global Const $COLOR_MAGENTA = 0xff00ff
Global Const $COLOR_MAROON = 0x800000
Global Const $COLOR_MEDIUMAQUAMARINE = 0x66cdaa
Global Const $COLOR_MEDIUMBLUE = 0xcd
Global Const $COLOR_MEDIUMORCHID = 0xba55d3
Global Const $COLOR_MEDIUMPURPLE = 0x9370db
Global Const $COLOR_MEDIUMSEAGREEN = 0x3cb371
Global Const $COLOR_MEDIUMSLATEBLUE = 0x7b68ee
Global Const $COLOR_MEDIUMSPRINGGREEN = 0xfa9a
Global Const $COLOR_MEDIUMTURQUOISE = 0x48d1cc
Global Const $COLOR_MEDIUMVIOLETRED = 0xc71585
Global Const $COLOR_MIDNIGHTBLUE = 0x191970
Global Const $COLOR_MINTCREAM = 0xf5fffa
Global Const $COLOR_MISTYROSE = 0xffe4e1
Global Const $COLOR_MOCCASIN = 0xffe4b5
Global Const $COLOR_NAVAJOWHITE = 0xffdead
Global Const $COLOR_NAVY = 0x80
Global Const $COLOR_OLDLACE = 0xfdf5e6
Global Const $COLOR_OLIVE = 0x808000
Global Const $COLOR_OLIVEDRAB = 0x6b8e23
Global Const $COLOR_ORANGE = 0xffa500
Global Const $COLOR_ORANGERED = 0xff4500
Global Const $COLOR_ORCHID = 0xda70d6
Global Const $COLOR_PALEGOLDENROD = 0xeee8aa
Global Const $COLOR_PALEGREEN = 0x98fb98
Global Const $COLOR_PALETURQUOISE = 0xafeeee
Global Const $COLOR_PALEVIOLETRED = 0xdb7093
Global Const $COLOR_PAPAYAWHIP = 0xffefd5
Global Const $COLOR_PEACHPUFF = 0xffdab9
Global Const $COLOR_PERU = 0xcd853f
Global Const $COLOR_PINK = 0xffc0cb
Global Const $COLOR_PLUM = 0xdda0dd
Global Const $COLOR_POWDERBLUE = 0xb0e0e6
Global Const $COLOR_PURPLE = 0x800080
Global Const $COLOR_RED = 0xff0000
Global Const $COLOR_ROSYBROWN = 0xbc8f8f
Global Const $COLOR_ROYALBLUE = 0x4169e1
Global Const $COLOR_SADDLEBROWN = 0x8b4513
Global Const $COLOR_SALMON = 0xfa8072
Global Const $COLOR_SANDYBROWN = 0xf4a460
Global Const $COLOR_SEAGREEN = 0x2e8b57
Global Const $COLOR_SEASHELL = 0xfff5ee
Global Const $COLOR_SIENNA = 0xa0522d
Global Const $COLOR_SILVER = 0xc0c0c0
Global Const $COLOR_SKYBLUE = 0x87ceeb
Global Const $COLOR_SLATEBLUE = 0x6a5acd
Global Const $COLOR_SLATEGRAY = 0x708090
Global Const $COLOR_SNOW = 0xfffafa
Global Const $COLOR_SPRINGGREEN = 0xff7f
Global Const $COLOR_STEELBLUE = 0x4682b4
Global Const $COLOR_TAN = 0xd2b48c
Global Const $COLOR_TEAL = 0x8080
Global Const $COLOR_THISTLE = 0xd8bfd8
Global Const $COLOR_TOMATO = 0xff6347
Global Const $COLOR_TURQUOISE = 0x40e0d0
Global Const $COLOR_VIOLET = 0xee82ee
Global Const $COLOR_WHEAT = 0xf5deb3
Global Const $COLOR_WHITE = 0xffffff
Global Const $COLOR_WHITESMOKE = 0xf5f5f5
Global Const $COLOR_YELLOW = 0xffff00
Global Const $COLOR_YELLOWGREEN = 0x9acd32
Global Const $CLR_NONE = -1
Global Const $CLR_DEFAULT = -16777216
Global Const $CLR_ALICEBLUE = 0xfff8f0
Global Const $CLR_ANTIQUEWHITE = 0xd7ebfa
Global Const $CLR_AQUA = 0xffff00
Global Const $CLR_AQUAMARINE = 0xd4ff7f
Global Const $CLR_AZURE = 0xfffff0
Global Const $CLR_BEIGE = 0xdcf5f5
Global Const $CLR_BISQUE = 0xc4e4ff
Global Const $CLR_BLACK = 0x0
Global Const $CLR_BLANCHEDALMOND = 0xcdebff
Global Const $CLR_BLUE = 0xff0000
Global Const $CLR_BLUEVIOLET = 0xe22b8a
Global Const $CLR_BROWN = 0x2a2aa5
Global Const $CLR_BURLYWOOD = 0x87b8de
Global Const $CLR_CADETBLUE = 0xa09e5f
Global Const $CLR_CHARTREUSE = 0xff7f
Global Const $CLR_CHOCOLATE = 0x1e69d2
Global Const $CLR_CORAL = 0x507fff
Global Const $CLR_CORNFLOWERBLUE = 0xed9564
Global Const $CLR_CORNSILK = 0xdcf8ff
Global Const $CLR_CRIMSON = 0x3c14dc
Global Const $CLR_CYAN = 0xffff00
Global Const $CLR_DARKBLUE = 0x8b0000
Global Const $CLR_DARKCYAN = 0x8b8b00
Global Const $CLR_DARKGOLDENROD = 0xb86b8
Global Const $CLR_DARKGRAY = 0xa9a9a9
Global Const $CLR_DARKGREEN = 0x6400
Global Const $CLR_DARKKHAKI = 0x6bb7bd
Global Const $CLR_DARKMAGENTA = 0x8b008b
Global Const $CLR_DARKOLIVEGREEN = 0x2f6b55
Global Const $CLR_DARKORANGE = 0x8cff
Global Const $CLR_DARKORCHID = 0xcc3299
Global Const $CLR_DARKRED = 0x8b
Global Const $CLR_DARKSALMON = 0x7a96e9
Global Const $CLR_DARKSEAGREEN = 0x8fbc8f
Global Const $CLR_DARKSLATEBLUE = 0x8b3d48
Global Const $CLR_DARKSLATEGRAY = 0x4f4f2f
Global Const $CLR_DARKTURQUOISE = 0xd1ce00
Global Const $CLR_DARKVIOLET = 0xd30094
Global Const $CLR_DEEPPINK = 0x9314ff
Global Const $CLR_DEEPSKYBLUE = 0xffbf00
Global Const $CLR_DIMGRAY = 0x696969
Global Const $CLR_DODGERBLUE = 0xff901e
Global Const $CLR_FIREBRICK = 0x2222b2
Global Const $CLR_FLORALWHITE = 0xf0faff
Global Const $CLR_FORESTGREEN = 0x228b22
Global Const $CLR_FUCHSIA = 0xff00ff
Global Const $CLR_GAINSBORO = 0xdcdcdc
Global Const $CLR_GHOSTWHITE = 0xfff8f8
Global Const $CLR_GOLD = 0xd7ff
Global Const $CLR_GOLDENROD = 0x20a5da
Global Const $CLR_GRAY = 0x808080
Global Const $CLR_GREEN = 0x8000
Global Const $CLR_GREENYELLOW = 0x2fffad
Global Const $CLR_HONEYDEW = 0xf0fff0
Global Const $CLR_HOTPINK = 0xb469ff
Global Const $CLR_INDIANRED = 0x5c5ccd
Global Const $CLR_INDIGO = 0x82004b
Global Const $CLR_IVORY = 0xf0ffff
Global Const $CLR_KHAKI = 0x8ce6f0
Global Const $CLR_LAVENDER = 0xfae6e6
Global Const $CLR_LAVENDERBLUSH = 0xf5f0ff
Global Const $CLR_LAWNGREEN = 0xfc7c
Global Const $CLR_LEMONCHIFFON = 0xcdfaff
Global Const $CLR_LIGHTBLUE = 0xe6d8ad
Global Const $CLR_LIGHTCORAL = 0x8080f0
Global Const $CLR_LIGHTCYAN = 0xffffe0
Global Const $CLR_LIGHTGOLDENRODYELLOW = 0xd2fafa
Global Const $CLR_LIGHTGRAY = 0xd3d3d3
Global Const $CLR_LIGHTGREEN = 0x90ee90
Global Const $CLR_LIGHTPINK = 0xc1b6ff
Global Const $CLR_LIGHTSALMON = 0x7aa0ff
Global Const $CLR_LIGHTSEAGREEN = 0xaab220
Global Const $CLR_LIGHTSKYBLUE = 0xface87
Global Const $CLR_LIGHTSLATEGRAY = 0x998877
Global Const $CLR_LIGHTSTEELBLUE = 0xdec4b0
Global Const $CLR_LIGHTYELLOW = 0xe0ffff
Global Const $CLR_LIME = 0xff00
Global Const $CLR_LIMEGREEN = 0x32cd32
Global Const $CLR_LINEN = 0xe6f0fa
Global Const $CLR_MAGENTA = 0xff00ff
Global Const $CLR_MAROON = 0x80
Global Const $CLR_MEDIUMAQUAMARINE = 0xaacd66
Global Const $CLR_MEDIUMBLUE = 0xcd0000
Global Const $CLR_MEDIUMORCHID = 0xd355ba
Global Const $CLR_MEDIUMPURPLE = 0xdb7093
Global Const $CLR_MEDIUMSEAGREEN = 0x71b33c
Global Const $CLR_MEDIUMSLATEBLUE = 0xee687b
Global Const $CLR_MEDIUMSPRINGGREEN = 0x9afa00
Global Const $CLR_MEDIUMTURQUOISE = 0xccd148
Global Const $CLR_MEDIUMVIOLETRED = 0x8515c7
Global Const $CLR_MIDNIGHTBLUE = 0x701919
Global Const $CLR_MINTCREAM = 0xfafff5
Global Const $CLR_MISTYROSE = 0xe1e4ff
Global Const $CLR_MOCCASIN = 0xb5e4ff
Global Const $CLR_NAVAJOWHITE = 0xaddeff
Global Const $CLR_NAVY = 0x800000
Global Const $CLR_OLDLACE = 0xe6f5fd
Global Const $CLR_OLIVE = 0x8080
Global Const $CLR_OLIVEDRAB = 0x238e6b
Global Const $CLR_ORANGE = 0xa5ff
Global Const $CLR_ORANGERED = 0x45ff
Global Const $CLR_ORCHID = 0xd670da
Global Const $CLR_PALEGOLDENROD = 0xaae8ee
Global Const $CLR_PALEGREEN = 0x98fb98
Global Const $CLR_PALETURQUOISE = 0xeeeeaf
Global Const $CLR_PALEVIOLETRED = 0x9370db
Global Const $CLR_PAPAYAWHIP = 0xd5efff
Global Const $CLR_PEACHPUFF = 0xb9daff
Global Const $CLR_PERU = 0x3f85cd
Global Const $CLR_PINK = 0xcbc0ff
Global Const $CLR_PLUM = 0xdda0dd
Global Const $CLR_POWDERBLUE = 0xe6e0b0
Global Const $CLR_PURPLE = 0x800080
Global Const $CLR_RED = 0xff
Global Const $CLR_ROSYBROWN = 0x8f8fbc
Global Const $CLR_ROYALBLUE = 0xe16941
Global Const $CLR_SADDLEBROWN = 0x13458b
Global Const $CLR_SALMON = 0x7280fa
Global Const $CLR_SANDYBROWN = 0x60a4f4
Global Const $CLR_SEAGREEN = 0x578b2e
Global Const $CLR_SEASHELL = 0xeef5ff
Global Const $CLR_SIENNA = 0x2d52a0
Global Const $CLR_SILVER = 0xc0c0c0
Global Const $CLR_SKYBLUE = 0xebce87
Global Const $CLR_SLATEBLUE = 0xcd5a6a
Global Const $CLR_SLATEGRAY = 0x908070
Global Const $CLR_SNOW = 0xfafaff
Global Const $CLR_SPRINGGREEN = 0x7fff00
Global Const $CLR_STEELBLUE = 0xb48246
Global Const $CLR_TAN = 0x8cb4d2
Global Const $CLR_TEAL = 0x808000
Global Const $CLR_THISTLE = 0xd8bfd8
Global Const $CLR_TOMATO = 0x4763ff
Global Const $CLR_TURQUOISE = 0xd0e040
Global Const $CLR_VIOLET = 0xee82ee
Global Const $CLR_WHEAT = 0xb3def5
Global Const $CLR_WHITE = 0xffffff
Global Const $CLR_WHITESMOKE = 0xf5f5f5
Global Const $CLR_YELLOW = 0xffff
Global Const $CLR_YELLOWGREEN = 0x32cd9a
Global Const $CC_ANYCOLOR = 0x100
Global Const $CC_FULLOPEN = 0x2
Global Const $CC_RGBINIT = 0x1
Global Const $OPT_COORDSRELATIVE = 0x0
Global Const $OPT_COORDSABSOLUTE = 0x1
Global Const $OPT_COORDSCLIENT = 0x2
Global Const $OPT_ERRORSILENT = 0x0
Global Const $OPT_ERRORFATAL = 0x1
Global Const $OPT_CAPSNOSTORE = 0x0
Global Const $OPT_CAPSSTORE = 0x1
Global Const $OPT_MATCHSTART = 0x1
Global Const $OPT_MATCHANY = 0x2
Global Const $OPT_MATCHEXACT = 0x3
Global Const $OPT_MATCHADVANCED = 0x4
Global Const $CCS_TOP = 0x1
Global Const $CCS_NOMOVEY = 0x2
Global Const $CCS_BOTTOM = 0x3
Global Const $CCS_NORESIZE = 0x4
Global Const $CCS_NOPARENTALIGN = 0x8
Global Const $CCS_NOHILITE = 0x10
Global Const $CCS_ADJUSTABLE = 0x20
Global Const $CCS_NODIVIDER = 0x40
Global Const $CCS_VERT = 0x80
Global Const $CCS_LEFT = 0x81
Global Const $CCS_NOMOVEX = 0x82
Global Const $CCS_RIGHT = 0x83
Global Const $DT_DRIVETYPE = 0x1
Global Const $DT_SSDSTATUS = 0x2
Global Const $DT_BUSTYPE = 0x3
Global Const $PROXY_IE = 0x0
Global Const $PROXY_NONE = 0x1
Global Const $PROXY_SPECIFIED = 0x2
Global Const $OBJID_WINDOW = 0x0
Global Const $OBJID_TITLEBAR = -2
Global Const $OBJID_SIZEGRIP = -7
Global Const $OBJID_CARET = -8
Global Const $OBJID_CURSOR = -9
Global Const $OBJID_ALERT = -10
Global Const $OBJID_SOUND = -11
Global Const $DLG_CENTERONTOP = 0x0
Global Const $DLG_NOTITLE = 0x1
Global Const $DLG_NOTONTOP = 0x2
Global Const $DLG_TEXTLEFT = 0x4
Global Const $DLG_TEXTRIGHT = 0x8
Global Const $DLG_MOVEABLE = 0x10
Global Const $DLG_TEXTVCENTER = 0x20
Global Const $MCID_UNKNOWN = + -1
Global Const $MCID_HAND = 0x0
Global Const $MCID_APPSTARTING = 0x1
Global Const $MCID_ARROW = 0x2
Global Const $MCID_CROSS = 0x3
Global Const $MCID_HELP = 0x4
Global Const $MCID_IBEAM = 0x5
Global Const $MCID_ICON = 0x6
Global Const $MCID_NO = 0x7
Global Const $MCID_SIZE = 0x8
Global Const $MCID_SIZEALL = 0x9
Global Const $MCID_SIZENESW = 0xa
Global Const $MCID_SIZENS = 0xb
Global Const $MCID_SIZENWSE = 0xc
Global Const $MCID_SIZEWE = 0xd
Global Const $MCID_UPARROW = 0xe
Global Const $MCID_WAIT = 0xf
Global Const $MCID_NONE = 0x10
Global Const $SD_LOGOFF = 0x0
Global Const $SD_SHUTDOWN = 0x1
Global Const $SD_REBOOT = 0x2
Global Const $SD_FORCE = 0x4
Global Const $SD_POWERDOWN = 0x8
Global Const $SD_FORCEHUNG = 0x10
Global Const $SD_STANDBY = 0x20
Global Const $SD_HIBERNATE = 0x40
Global Const $STDIN_CHILD = 0x1
Global Const $STDOUT_CHILD = 0x2
Global Const $STDERR_CHILD = 0x4
Global Const $STDERR_MERGED = 0x8
Global Const $STDIO_INHERIT_PARENT = 0x10
Global Const $RUN_CREATE_NEW_CONSOLE = 0x10000
Global Const $UBOUND_DIMENSIONS = 0x0
Global Const $UBOUND_ROWS = 0x1
Global Const $UBOUND_COLUMNS = 0x2
Global Const $MOUSEEVENTF_ABSOLUTE = 0x8000
Global Const $MOUSEEVENTF_MOVE = 0x1
Global Const $MOUSEEVENTF_LEFTDOWN = 0x2
Global Const $MOUSEEVENTF_LEFTUP = 0x4
Global Const $MOUSEEVENTF_RIGHTDOWN = 0x8
Global Const $MOUSEEVENTF_RIGHTUP = 0x10
Global Const $MOUSEEVENTF_MIDDLEDOWN = 0x20
Global Const $MOUSEEVENTF_MIDDLEUP = 0x40
Global Const $MOUSEEVENTF_WHEEL = 0x800
Global Const $MOUSEEVENTF_XDOWN = 0x80
Global Const $MOUSEEVENTF_XUP = 0x100
Global Const $REG_NONE = 0x0
Global Const $REG_SZ = 0x1
Global Const $REG_EXPAND_SZ = 0x2
Global Const $REG_BINARY = 0x3
Global Const $REG_DWORD = 0x4
Global Const $REG_DWORD_LITTLE_ENDIAN = 0x4
Global Const $REG_DWORD_BIG_ENDIAN = 0x5
Global Const $REG_LINK = 0x6
Global Const $REG_MULTI_SZ = 0x7
Global Const $REG_RESOURCE_LIST = 0x8
Global Const $REG_FULL_RESOURCE_DESCRIPTOR = 0x9
Global Const $REG_RESOURCE_REQUIREMENTS_LIST = 0xa
Global Const $REG_QWORD = 0xb
Global Const $REG_QWORD_LITTLE_ENDIAN = 0xb
Global Const $HWND_BOTTOM = 0x1
Global Const $HWND_NOTOPMOST = + -2
Global Const $HWND_TOP = 0x0
Global Const $HWND_TOPMOST = + -1
Global Const $SWP_NOSIZE = 0x1
Global Const $SWP_NOMOVE = 0x2
Global Const $SWP_NOZORDER = 0x4
Global Const $SWP_NOREDRAW = 0x8
Global Const $SWP_NOACTIVATE = 0x10
Global Const $SWP_FRAMECHANGED = 0x20
Global Const $SWP_DRAWFRAME = 0x20
Global Const $SWP_SHOWWINDOW = 0x40
Global Const $SWP_HIDEWINDOW = 0x80
Global Const $SWP_NOCOPYBITS = 0x100
Global Const $SWP_NOOWNERZORDER = 0x200
Global Const $SWP_NOREPOSITION = 0x200
Global Const $SWP_NOSENDCHANGING = 0x400
Global Const $SWP_DEFERERASE = 0x2000
Global Const $SWP_ASYNCWINDOWPOS = 0x4000
Global Const $KEYWORD_DEFAULT = 0x1
Global Const $KEYWORD_NULL = 0x2
Global Const $DECLARED_LOCAL = + -1
Global Const $DECLARED_UNKNOWN = 0x0
Global Const $DECLARED_GLOBAL = 0x1
Global Const $ASSIGN_CREATE = 0x0
Global Const $ASSIGN_FORCELOCAL = 0x1
Global Const $ASSIGN_FORCEGLOBAL = 0x2
Global Const $ASSIGN_EXISTFAIL = 0x4
Global Const $BI_ENABLE = 0x0
Global Const $BI_DISABLE = 0x1
Global Const $BREAK_ENABLE = 0x1
Global Const $BREAK_DISABLE = 0x0
Global Const $CDTRAY_OPEN = "open"
Global Const $CDTRAY_CLOSED = "closed"
Global Const $SEND_DEFAULT = 0x0
Global Const $SEND_RAW = 0x1
Global Const $DIR_DEFAULT = 0x0
Global Const $DIR_EXTENDED = 0x1
Global Const $DIR_NORECURSE = 0x2
Global Const $DIR_REMOVE = 0x1
Global Const $DT_ALL = "ALL"
Global Const $DT_CDROM = "CDROM"
Global Const $DT_REMOVABLE = "REMOVABLE"
Global Const $DT_FIXED = "FIXED"
Global Const $DT_NETWORK = "NETWORK"
Global Const $DT_RAMDISK = "RAMDISK"
Global Const $DT_UNKNOWN = "UNKNOWN"
Global Const $DT_UNDEFINED = 0x1
Global Const $DT_FAT = "FAT"
Global Const $DT_FAT32 = "FAT32"
Global Const $DT_EXFAT = "exFAT"
Global Const $DT_NTFS = "NTFS"
Global Const $DT_NWFS = "NWFS"
Global Const $DT_CDFS = "CDFS"
Global Const $DT_UDF = "UDF"
Global Const $DMA_DEFAULT = 0x0
Global Const $DMA_PERSISTENT = 0x1
Global Const $DMA_AUTHENTICATION = 0x8
Global Const $DS_UNKNOWN = "UNKNOWN"
Global Const $DS_READY = "READY"
Global Const $DS_NOTREADY = "NOTREADY"
Global Const $DS_INVALID = "INVALID"
Global Const $MOUSE_CLICK_LEFT = "left"
Global Const $MOUSE_CLICK_RIGHT = "right"
Global Const $MOUSE_CLICK_MIDDLE = "middle"
Global Const $MOUSE_CLICK_MAIN = "main"
Global Const $MOUSE_CLICK_MENU = "menu"
Global Const $MOUSE_CLICK_PRIMARY = "primary"
Global Const $MOUSE_CLICK_SECONDARY = "secondary"
Global Const $MOUSE_WHEEL_UP = "up"
Global Const $MOUSE_WHEEL_DOWN = "down"
Global Const $NUMBER_AUTO = 0x0
Global Const $NUMBER_32BIT = 0x1
Global Const $NUMBER_64BIT = 0x2
Global Const $NUMBER_DOUBLE = 0x3
Global Const $OBJ_NAME = 0x1
Global Const $OBJ_STRING = 0x2
Global Const $OBJ_PROGID = 0x3
Global Const $OBJ_FILE = 0x4
Global Const $OBJ_MODULE = 0x5
Global Const $OBJ_CLSID = 0x6
Global Const $OBJ_IID = 0x7
Global Const $EXITCLOSE_NORMAL = 0x0
Global Const $EXITCLOSE_BYEXIT = 0x1
Global Const $EXITCLOSE_BYCLICK = 0x2
Global Const $EXITCLOSE_BYLOGOFF = 0x3
Global Const $EXITCLOSE_BYSHUTDOWN = 0x4
Global Const $PROCESS_STATS_MEMORY = 0x0
Global Const $PROCESS_STATS_IO = 0x1
Global Const $PROCESS_LOW = 0x0
Global Const $PROCESS_BELOWNORMAL = 0x1
Global Const $PROCESS_NORMAL = 0x2
Global Const $PROCESS_ABOVENORMAL = 0x3
Global Const $PROCESS_HIGH = 0x4
Global Const $PROCESS_REALTIME = 0x5
Global Const $RUN_LOGON_NOPROFILE = 0x0
Global Const $RUN_LOGON_PROFILE = 0x1
Global Const $RUN_LOGON_NETWORK = 0x2
Global Const $RUN_LOGON_INHERIT = 0x4
Global Const $SOUND_NOWAIT = 0x0
Global Const $SOUND_WAIT = 0x1
Global Const $SHEX_OPEN = "open"
Global Const $SHEX_EDIT = "edit"
Global Const $SHEX_PRINT = "print"
Global Const $SHEX_PROPERTIES = "properties"
Global Const $TCP_DATA_DEFAULT = 0x0
Global Const $TCP_DATA_BINARY = 0x1
Global Const $UDP_OPEN_DEFAULT = 0x0
Global Const $UDP_OPEN_BROADCAST = 0x1
Global Const $UDP_DATA_DEFAULT = 0x0
Global Const $UDP_DATA_BINARY = 0x1
Global Const $UDP_DATA_ARRAY = 0x2
Global Const $TIP_NOICON = 0x0
Global Const $TIP_INFOICON = 0x1
Global Const $TIP_WARNINGICON = 0x2
Global Const $TIP_ERRORICON = 0x3
Global Const $TIP_BALLOON = 0x1
Global Const $TIP_CENTER = 0x2
Global Const $TIP_FORCEVISIBLE = 0x4
Global Const $WINDOWS_NOONTOP = 0x0
Global Const $WINDOWS_ONTOP = 0x1
Global Const $WIN_STATE_EXISTS = 0x1
Global Const $WIN_STATE_VISIBLE = 0x2
Global Const $WIN_STATE_ENABLED = 0x4
Global Const $WIN_STATE_ACTIVE = 0x8
Global Const $WIN_STATE_MINIMIZED = 0x10
Global Const $WIN_STATE_MAXIMIZED = 0x20
Global Const $DDL_ARCHIVE = 0x20
Global Const $DDL_DIRECTORY = 0x10
Global Const $DDL_DRIVES = 0x4000
Global Const $DDL_EXCLUSIVE = 0x8000
Global Const $DDL_HIDDEN = 0x2
Global Const $DDL_READONLY = 0x1
Global Const $DDL_READWRITE = 0x0
Global Const $DDL_SYSTEM = 0x4
Global Const $FC_NOOVERWRITE = 0x0
Global Const $FC_OVERWRITE = 0x1
Global Const $FC_CREATEPATH = 0x8
Global Const $FT_MODIFIED = 0x0
Global Const $FT_CREATED = 0x1
Global Const $FT_ACCESSED = 0x2
Global Const $FT_ARRAY = 0x0
Global Const $FT_STRING = 0x1
Global Const $FT_MSEC = 0x2
Global Const $FT_UTC = 0x4
Global Const $FSF_CREATEBUTTON = 0x1
Global Const $FSF_NEWDIALOG = 0x2
Global Const $FSF_EDITCONTROL = 0x4
Global Const $FT_NONRECURSIVE = 0x0
Global Const $FT_RECURSIVE = 0x1
Global Const $FO_READ = 0x0
Global Const $FO_APPEND = 0x1
Global Const $FO_OVERWRITE = 0x2
Global Const $FO_CREATEPATH = 0x8
Global Const $FO_BINARY = 0x10
Global Const $FO_UNICODE = 0x20
Global Const $FO_UTF16_LE = 0x20
Global Const $FO_UTF16_BE = 0x40
Global Const $FO_UTF8 = 0x80
Global Const $FO_UTF8_NOBOM = 0x100
Global Const $FO_ANSI = 0x200
Global Const $FO_UTF16_LE_NOBOM = 0x400
Global Const $FO_UTF16_BE_NOBOM = 0x800
Global Const $FO_UTF8_FULL = 0x4000
Global Const $FO_FULLFILE_DETECT = 0x4000
Global Const $EOF = + -1
Global Const $FD_FILEMUSTEXIST = 0x1
Global Const $FD_PATHMUSTEXIST = 0x2
Global Const $FD_MULTISELECT = 0x4
Global Const $FD_PROMPTCREATENEW = 0x8
Global Const $FD_PROMPTOVERWRITE = 0x10
Global Const $CREATE_NEW = 0x1
Global Const $CREATE_ALWAYS = 0x2
Global Const $OPEN_EXISTING = 0x3
Global Const $OPEN_ALWAYS = 0x4
Global Const $TRUNCATE_EXISTING = 0x5
Global Const $INVALID_SET_FILE_POINTER = + -1
Global Const $FILE_BEGIN = 0x0
Global Const $FILE_CURRENT = 0x1
Global Const $FILE_END = 0x2
Global Const $FILE_ATTRIBUTE_READONLY = 0x1
Global Const $FILE_ATTRIBUTE_HIDDEN = 0x2
Global Const $FILE_ATTRIBUTE_SYSTEM = 0x4
Global Const $FILE_ATTRIBUTE_DIRECTORY = 0x10
Global Const $FILE_ATTRIBUTE_ARCHIVE = 0x20
Global Const $FILE_ATTRIBUTE_DEVICE = 0x40
Global Const $FILE_ATTRIBUTE_NORMAL = 0x80
Global Const $FILE_ATTRIBUTE_TEMPORARY = 0x100
Global Const $FILE_ATTRIBUTE_SPARSE_FILE = 0x200
Global Const $FILE_ATTRIBUTE_REPARSE_POINT = 0x400
Global Const $FILE_ATTRIBUTE_COMPRESSED = 0x800
Global Const $FILE_ATTRIBUTE_OFFLINE = 0x1000
Global Const $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x2000
Global Const $FILE_ATTRIBUTE_ENCRYPTED = 0x4000
Global Const $FILE_SHARE_READ = 0x1
Global Const $FILE_SHARE_WRITE = 0x2
Global Const $FILE_SHARE_DELETE = 0x4
Global Const $FILE_SHARE_READWRITE = BitOR($FILE_SHARE_READ, $FILE_SHARE_WRITE)
Global Const $FILE_SHARE_ANY = BitOR($FILE_SHARE_READ, $FILE_SHARE_WRITE, $FILE_SHARE_DELETE)
Global Const $GENERIC_ALL = 0x10000000
Global Const $GENERIC_EXECUTE = 0x20000000
Global Const $GENERIC_WRITE = 0x40000000
Global Const $GENERIC_READ = -2147483648
Global Const $GENERIC_READWRITE = BitOR($GENERIC_READ, $GENERIC_WRITE)
Global Const $FILE_ENCODING_UTF16LE = 0x20
Global Const $FE_ENTIRE_UTF8 = 0x1
Global Const $FE_PARTIALFIRST_UTF8 = 0x2
Global Const $FN_FULLPATH = 0x0
Global Const $FN_RELATIVEPATH = 0x1
Global Const $FV_COMMENTS = "Comments"
Global Const $FV_COMPANYNAME = "CompanyName"
Global Const $FV_FILEDESCRIPTION = "FileDescription"
Global Const $FV_FILEVERSION = "FileVersion"
Global Const $FV_INTERNALNAME = "InternalName"
Global Const $FV_LEGALCOPYRIGHT = "LegalCopyright"
Global Const $FV_LEGALTRADEMARKS = "LegalTrademarks"
Global Const $FV_ORIGINALFILENAME = "OriginalFilename"
Global Const $FV_PRODUCTNAME = "ProductName"
Global Const $FV_PRODUCTVERSION = "ProductVersion"
Global Const $FV_PRIVATEBUILD = "PrivateBuild"
Global Const $FV_SPECIALBUILD = "SpecialBuild"
Global Const $FRTA_NOCOUNT = 0x0
Global Const $FRTA_COUNT = 0x1
Global Const $FRTA_INTARRAYS = 0x2
Global Const $FRTA_ENTIRESPLIT = 0x4
Global Const $FLTA_FILESFOLDERS = 0x0
Global Const $FLTA_FILES = 0x1
Global Const $FLTA_FOLDERS = 0x2
Global Const $FLTAR_FILESFOLDERS = 0x0
Global Const $FLTAR_FILES = 0x1
Global Const $FLTAR_FOLDERS = 0x2
Global Const $FLTAR_NOHIDDEN = 0x4
Global Const $FLTAR_NOSYSTEM = 0x8
Global Const $FLTAR_NOLINK = 0x10
Global Const $FLTAR_NORECUR = 0x0
Global Const $FLTAR_RECUR = 0x1
Global Const $FLTAR_NOSORT = 0x0
Global Const $FLTAR_SORT = 0x1
Global Const $FLTAR_FASTSORT = 0x2
Global Const $FLTAR_NOPATH = 0x0
Global Const $FLTAR_RELPATH = 0x1
Global Const $FLTAR_FULLPATH = 0x2
Global Const $PATH_ORIGINAL = 0x0
Global Const $PATH_DRIVE = 0x1
Global Const $PATH_DIRECTORY = 0x2
Global Const $PATH_FILENAME = 0x3
Global Const $PATH_EXTENSION = 0x4
Global Const $MB_OK = 0x0
Global Const $MB_OKCANCEL = 0x1
Global Const $MB_ABORTRETRYIGNORE = 0x2
Global Const $MB_YESNOCANCEL = 0x3
Global Const $MB_YESNO = 0x4
Global Const $MB_RETRYCANCEL = 0x5
Global Const $MB_CANCELTRYCONTINUE = 0x6
Global Const $MB_HELP = 0x4000
Global Const $MB_ICONNONE = 0x0
Global Const $MB_ICONSTOP = 0x10
Global Const $MB_ICONERROR = 0x10
Global Const $MB_ICONHAND = 0x10
Global Const $MB_ICONQUESTION = 0x20
Global Const $MB_ICONEXCLAMATION = 0x30
Global Const $MB_ICONWARNING = 0x30
Global Const $MB_ICONINFORMATION = 0x40
Global Const $MB_ICONASTERISK = 0x40
Global Const $MB_USERICON = 0x80
Global Const $MB_DEFBUTTON1 = 0x0
Global Const $MB_DEFBUTTON2 = 0x100
Global Const $MB_DEFBUTTON3 = 0x200
Global Const $MB_DEFBUTTON4 = 0x300
Global Const $MB_APPLMODAL = 0x0
Global Const $MB_SYSTEMMODAL = 0x1000
Global Const $MB_TASKMODAL = 0x2000
Global Const $MB_DEFAULT_DESKTOP_ONLY = 0x20000
Global Const $MB_RIGHT = 0x80000
Global Const $MB_RTLREADING = 0x100000
Global Const $MB_SETFOREGROUND = 0x10000
Global Const $MB_TOPMOST = 0x40000
Global Const $MB_SERVICE_NOTIFICATION = 0x200000
Global Const $MB_RIGHTJUSTIFIED = $MB_RIGHT
Global Const $IDTIMEOUT = + -1
Global Const $IDOK = 0x1
Global Const $IDCANCEL = 0x2
Global Const $IDABORT = 0x3
Global Const $IDRETRY = 0x4
Global Const $IDIGNORE = 0x5
Global Const $IDYES = 0x6
Global Const $IDNO = 0x7
Global Const $IDCLOSE = 0x8
Global Const $IDHELP = 0x9
Global Const $IDTRYAGAIN = 0xa
Global Const $IDCONTINUE = 0xb
Global Const $PROCESS_TERMINATE = 0x1
Global Const $PROCESS_CREATE_THREAD = 0x2
Global Const $PROCESS_SET_SESSIONID = 0x4
Global Const $PROCESS_VM_OPERATION = 0x8
Global Const $PROCESS_VM_READ = 0x10
Global Const $PROCESS_VM_WRITE = 0x20
Global Const $PROCESS_DUP_HANDLE = 0x40
Global Const $PROCESS_CREATE_PROCESS = 0x80
Global Const $PROCESS_SET_QUOTA = 0x100
Global Const $PROCESS_SET_INFORMATION = 0x200
Global Const $PROCESS_QUERY_INFORMATION = 0x400
Global Const $PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
Global Const $PROCESS_SUSPEND_RESUME = 0x800
Global Const $PROCESS_ALL_ACCESS = 0x1f0fff
Global Const $STR_NOCASESENSE = 0x0
Global Const $STR_CASESENSE = 0x1
Global Const $STR_NOCASESENSEBASIC = 0x2
Global Const $STR_STRIPLEADING = 0x1
Global Const $STR_STRIPTRAILING = 0x2
Global Const $STR_STRIPSPACES = 0x4
Global Const $STR_STRIPALL = 0x8
Global Const $STR_CHRSPLIT = 0x0
Global Const $STR_ENTIRESPLIT = 0x1
Global Const $STR_NOCOUNT = 0x2
Global Const $STR_REGEXPMATCH = 0x0
Global Const $STR_REGEXPARRAYMATCH = 0x1
Global Const $STR_REGEXPARRAYFULLMATCH = 0x2
Global Const $STR_REGEXPARRAYGLOBALMATCH = 0x3
Global Const $STR_REGEXPARRAYGLOBALFULLMATCH = 0x4
Global Const $STR_ENDISSTART = 0x0
Global Const $STR_ENDNOTSTART = 0x1
Global Const $SB_ANSI = 0x1
Global Const $SB_UTF16LE = 0x2
Global Const $SB_UTF16BE = 0x3
Global Const $SB_UTF8 = 0x4
Global Const $SE_UTF16 = 0x0
Global Const $SE_ANSI = 0x1
Global Const $SE_UTF8 = 0x2
Global Const $STR_UTF16 = 0x0
Global Const $STR_UCS2 = 0x1
Global Const $TRAY_ITEM_EXIT = 0x3
Global Const $TRAY_ITEM_PAUSE = 0x4
Global Const $TRAY_ITEM_FIRST = 0x7
Global Const $TRAY_CHECKED = 0x1
Global Const $TRAY_UNCHECKED = 0x4
Global Const $TRAY_ENABLE = 0x40
Global Const $TRAY_DISABLE = 0x80
Global Const $TRAY_FOCUS = 0x100
Global Const $TRAY_DEFAULT = 0x200
Global Const $TRAY_EVENT_NONE = 0x0
Global Const $TRAY_EVENT_SHOWICON = + -3
Global Const $TRAY_EVENT_HIDEICON = + -4
Global Const $TRAY_EVENT_FLASHICON = + -5
Global Const $TRAY_EVENT_NOFLASHICON = + -6
Global Const $TRAY_EVENT_PRIMARYDOWN = + -7
Global Const $TRAY_EVENT_PRIMARYUP = + -8
Global Const $TRAY_EVENT_SECONDARYDOWN = + -9
Global Const $TRAY_EVENT_SECONDARYUP = + -10
Global Const $TRAY_EVENT_MOUSEOVER = + -11
Global Const $TRAY_EVENT_MOUSEOUT = + -12
Global Const $TRAY_EVENT_PRIMARYDOUBLE = + -13
Global Const $TRAY_EVENT_SECONDARYDOUBLE = + -14
Global Const $TIP_ICONNONE = 0x0
Global Const $TIP_ICONASTERISK = 0x1
Global Const $TIP_ICONEXCLAMATION = 0x2
Global Const $TIP_ICONHAND = 0x3
Global Const $TIP_NOSOUND = 0x10
Global Const $TRAY_ITEM_NORMAL = 0x0
Global Const $TRAY_ITEM_RADIO = 0x1
Global Const $TRAY_CLICK_SHOW = 0x0
Global Const $TRAY_CLICK_PRIMARYDOWN = 0x1
Global Const $TRAY_CLICK_PRIMARYUP = 0x2
Global Const $TRAY_DBLCLICK_PRIMARY = 0x4
Global Const $TRAY_CLICK_SECONDARYDOWN = 0x8
Global Const $TRAY_CLICK_SECONDARYUP = 0x10
Global Const $TRAY_DBLCLICK_SECONDARY = 0x20
Global Const $TRAY_CLICK_HOVERING = 0x40
Global Const $TRAY_ICONSTATE_SHOW = 0x1
Global Const $TRAY_ICONSTATE_HIDE = 0x2
Global Const $TRAY_ICONSTATE_FLASH = 0x4
Global Const $TRAY_ICONSTATE_STOPFLASH = 0x8
Global Const $TRAY_ICONSTATE_RESET = 0x10
Global Const $FW_DONTCARE = 0x0
Global Const $FW_THIN = 0x64
Global Const $FW_EXTRALIGHT = 0xc8
Global Const $FW_ULTRALIGHT = 0xc8
Global Const $FW_LIGHT = 0x12c
Global Const $FW_NORMAL = 0x190
Global Const $FW_REGULAR = 0x190
Global Const $FW_MEDIUM = 0x1f4
Global Const $FW_SEMIBOLD = 0x258
Global Const $FW_DEMIBOLD = 0x258
Global Const $FW_BOLD = 0x2bc
Global Const $FW_EXTRABOLD = 0x320
Global Const $FW_ULTRABOLD = 0x320
Global Const $FW_HEAVY = 0x384
Global Const $FW_BLACK = 0x384
Global Const $CF_EFFECTS = 0x100
Global Const $CF_PRINTERFONTS = 0x2
Global Const $CF_SCREENFONTS = 0x1
Global Const $CF_NOSCRIPTSEL = 0x800000
Global Const $CF_INITTOLOGFONTSTRUCT = 0x40
Global Const $LOGPIXELSX = 0x58
Global Const $LOGPIXELSY = 0x5a
Global Const $ANSI_CHARSET = 0x0
Global Const $ARABIC_CHARSET = 0xb2
Global Const $BALTIC_CHARSET = 0xba
Global Const $CHINESEBIG5_CHARSET = 0x88
Global Const $DEFAULT_CHARSET = 0x1
Global Const $EASTEUROPE_CHARSET = 0xee
Global Const $GB2312_CHARSET = 0x86
Global Const $GREEK_CHARSET = 0xa1
Global Const $HANGEUL_CHARSET = 0x81
Global Const $HEBREW_CHARSET = 0xb1
Global Const $JOHAB_CHARSET = 0x82
Global Const $MAC_CHARSET = 0x4d
Global Const $OEM_CHARSET = 0xff
Global Const $RUSSIAN_CHARSET = 0xcc
Global Const $SHIFTJIS_CHARSET = 0x80
Global Const $SYMBOL_CHARSET = 0x2
Global Const $THAI_CHARSET = 0xde
Global Const $TURKISH_CHARSET = 0xa2
Global Const $VIETNAMESE_CHARSET = 0xa3
Global Const $OUT_CHARACTER_PRECIS = 0x2
Global Const $OUT_DEFAULT_PRECIS = 0x0
Global Const $OUT_DEVICE_PRECIS = 0x5
Global Const $OUT_OUTLINE_PRECIS = 0x8
Global Const $OUT_PS_ONLY_PRECIS = 0xa
Global Const $OUT_RASTER_PRECIS = 0x6
Global Const $OUT_STRING_PRECIS = 0x1
Global Const $OUT_STROKE_PRECIS = 0x3
Global Const $OUT_TT_ONLY_PRECIS = 0x7
Global Const $OUT_TT_PRECIS = 0x4
Global Const $CLIP_CHARACTER_PRECIS = 0x1
Global Const $CLIP_DEFAULT_PRECIS = 0x0
Global Const $CLIP_DFA_DISABLE = 0x30
Global Const $CLIP_EMBEDDED = 0x80
Global Const $CLIP_LH_ANGLES = 0x10
Global Const $CLIP_MASK = 0xf
Global Const $CLIP_DFA_OVERRIDE = 0x40
Global Const $CLIP_STROKE_PRECIS = 0x2
Global Const $CLIP_TT_ALWAYS = 0x20
Global Const $ANTIALIASED_QUALITY = 0x4
Global Const $DEFAULT_QUALITY = 0x0
Global Const $DRAFT_QUALITY = 0x1
Global Const $NONANTIALIASED_QUALITY = 0x3
Global Const $PROOF_QUALITY = 0x2
Global Const $CLEARTYPE_QUALITY = 0x5
Global Const $DEFAULT_PITCH = 0x0
Global Const $FIXED_PITCH = 0x1
Global Const $VARIABLE_PITCH = 0x2
Global Const $FF_DECORATIVE = 0x50
Global Const $FF_DONTCARE = 0x0
Global Const $FF_MODERN = 0x30
Global Const $FF_ROMAN = 0x10
Global Const $FF_SCRIPT = 0x40
Global Const $FF_SWISS = 0x20
Global Const $FS_REGULAR = 0x0
Global Const $FS_BOLD = 0x1
Global Const $FS_ITALIC = 0x2
Global Const $DFC_BUTTON = 0x4
Global Const $DFC_CAPTION = 0x1
Global Const $DFC_MENU = 0x2
Global Const $DFC_POPUPMENU = 0x5
Global Const $DFC_SCROLL = 0x3
Global Const $DFCS_BUTTON3STATE = 0x8
Global Const $DFCS_BUTTONCHECK = 0x0
Global Const $DFCS_BUTTONPUSH = 0x10
Global Const $DFCS_BUTTONRADIO = 0x4
Global Const $DFCS_BUTTONRADIOIMAGE = 0x1
Global Const $DFCS_BUTTONRADIOMASK = 0x2
Global Const $DFCS_CAPTIONCLOSE = 0x0
Global Const $DFCS_CAPTIONHELP = 0x4
Global Const $DFCS_CAPTIONMAX = 0x2
Global Const $DFCS_CAPTIONMIN = 0x1
Global Const $DFCS_CAPTIONRESTORE = 0x3
Global Const $DFCS_MENUARROW = 0x0
Global Const $DFCS_MENUARROWRIGHT = 0x4
Global Const $DFCS_MENUBULLET = 0x2
Global Const $DFCS_MENUCHECK = 0x1
Global Const $DFCS_SCROLLCOMBOBOX = 0x5
Global Const $DFCS_SCROLLDOWN = 0x1
Global Const $DFCS_SCROLLLEFT = 0x2
Global Const $DFCS_SCROLLRIGHT = 0x3
Global Const $DFCS_SCROLLSIZEGRIP = 0x8
Global Const $DFCS_SCROLLSIZEGRIPRIGHT = 0x10
Global Const $DFCS_SCROLLUP = 0x0
Global Const $DFCS_ADJUSTRECT = 0x2000
Global Const $DFCS_CHECKED = 0x400
Global Const $DFCS_FLAT = 0x4000
Global Const $DFCS_HOT = 0x1000
Global Const $DFCS_INACTIVE = 0x100
Global Const $DFCS_PUSHED = 0x200
Global Const $DFCS_TRANSPARENT = 0x800
Global Const $ACS_CENTER = 0x1
Global Const $ACS_TRANSPARENT = 0x2
Global Const $ACS_AUTOPLAY = 0x4
Global Const $ACS_TIMER = 0x8
Global Const $ACS_NONTRANSPARENT = 0x10
Global Const $GUI_SS_DEFAULT_AVI = $ACS_TRANSPARENT
Global Const $__AVICONSTANT_WM_USER = 0x400
Global Const $ACM_OPENA = $__AVICONSTANT_WM_USER + 0x64
Global Const $ACM_PLAY = $__AVICONSTANT_WM_USER + 0x65
Global Const $ACM_STOP = $__AVICONSTANT_WM_USER + 0x66
Global Const $ACM_ISPLAYING = $__AVICONSTANT_WM_USER + 0x68
Global Const $ACM_OPENW = $__AVICONSTANT_WM_USER + 0x67
Global Const $ACN_START = 0x1
Global Const $ACN_STOP = 0x2
Global Const $BS_GROUPBOX = 0x7
Global Const $BS_BOTTOM = 0x800
Global Const $BS_CENTER = 0x300
Global Const $BS_DEFPUSHBUTTON = 0x1
Global Const $BS_LEFT = 0x100
Global Const $BS_MULTILINE = 0x2000
Global Const $BS_PUSHBOX = 0xa
Global Const $BS_PUSHLIKE = 0x1000
Global Const $BS_RIGHT = 0x200
Global Const $BS_RIGHTBUTTON = 0x20
Global Const $BS_TOP = 0x400
Global Const $BS_VCENTER = 0xc00
Global Const $BS_FLAT = 0x8000
Global Const $BS_ICON = 0x40
Global Const $BS_BITMAP = 0x80
Global Const $BS_NOTIFY = 0x4000
Global Const $BS_SPLITBUTTON = 0xc
Global Const $BS_DEFSPLITBUTTON = 0xd
Global Const $BS_COMMANDLINK = 0xe
Global Const $BS_DEFCOMMANDLINK = 0xf
Global Const $BCSIF_GLYPH = 0x1
Global Const $BCSIF_IMAGE = 0x2
Global Const $BCSIF_STYLE = 0x4
Global Const $BCSIF_SIZE = 0x8
Global Const $BCSS_NOSPLIT = 0x1
Global Const $BCSS_STRETCH = 0x2
Global Const $BCSS_ALIGNLEFT = 0x4
Global Const $BCSS_IMAGE = 0x8
Global Const $BUTTON_IMAGELIST_ALIGN_LEFT = 0x0
Global Const $BUTTON_IMAGELIST_ALIGN_RIGHT = 0x1
Global Const $BUTTON_IMAGELIST_ALIGN_TOP = 0x2
Global Const $BUTTON_IMAGELIST_ALIGN_BOTTOM = 0x3
Global Const $BUTTON_IMAGELIST_ALIGN_CENTER = 0x4
Global Const $BS_3STATE = 0x5
Global Const $BS_AUTO3STATE = 0x6
Global Const $BS_AUTOCHECKBOX = 0x3
Global Const $BS_CHECKBOX = 0x2
Global Const $BS_RADIOBUTTON = 0x4
Global Const $BS_AUTORADIOBUTTON = 0x9
Global Const $BS_OWNERDRAW = 0xb
Global Const $GUI_SS_DEFAULT_BUTTON = 0x0
Global Const $GUI_SS_DEFAULT_CHECKBOX = 0x0
Global Const $GUI_SS_DEFAULT_GROUP = 0x0
Global Const $GUI_SS_DEFAULT_RADIO = 0x0
Global Const $BCM_FIRST = 0x1600
Global Const $BCM_GETIDEALSIZE = ($BCM_FIRST + 0x1)
Global Const $BCM_GETIMAGELIST = ($BCM_FIRST + 0x3)
Global Const $BCM_GETNOTE = ($BCM_FIRST + 0xa)
Global Const $BCM_GETNOTELENGTH = ($BCM_FIRST + 0xb)
Global Const $BCM_GETSPLITINFO = ($BCM_FIRST + 0x8)
Global Const $BCM_GETTEXTMARGIN = ($BCM_FIRST + 0x5)
Global Const $BCM_SETDROPDOWNSTATE = ($BCM_FIRST + 0x6)
Global Const $BCM_SETIMAGELIST = ($BCM_FIRST + 0x2)
Global Const $BCM_SETNOTE = ($BCM_FIRST + 0x9)
Global Const $BCM_SETSHIELD = ($BCM_FIRST + 0xc)
Global Const $BCM_SETSPLITINFO = ($BCM_FIRST + 0x7)
Global Const $BCM_SETTEXTMARGIN = ($BCM_FIRST + 0x4)
Global Const $BM_CLICK = 0xf5
Global Const $BM_GETCHECK = 0xf0
Global Const $BM_GETIMAGE = 0xf6
Global Const $BM_GETSTATE = 0xf2
Global Const $BM_SETCHECK = 0xf1
Global Const $BM_SETDONTCLICK = 0xf8
Global Const $BM_SETIMAGE = 0xf7
Global Const $BM_SETSTATE = 0xf3
Global Const $BM_SETSTYLE = 0xf4
Global Const $BCN_FIRST = + -1250
Global Const $BCN_DROPDOWN = ($BCN_FIRST + 0x2)
Global Const $BCN_HOTITEMCHANGE = ($BCN_FIRST + 0x1)
Global Const $BN_CLICKED = 0x0
Global Const $BN_PAINT = 0x1
Global Const $BN_HILITE = 0x2
Global Const $BN_UNHILITE = 0x3
Global Const $BN_DISABLE = 0x4
Global Const $BN_DOUBLECLICKED = 0x5
Global Const $BN_SETFOCUS = 0x6
Global Const $BN_KILLFOCUS = 0x7
Global Const $BN_PUSHED = $BN_HILITE
Global Const $BN_UNPUSHED = $BN_UNHILITE
Global Const $BN_DBLCLK = $BN_DOUBLECLICKED
Global Const $BST_CHECKED = 0x1
Global Const $BST_INDETERMINATE = 0x2
Global Const $BST_UNCHECKED = 0x0
Global Const $BST_FOCUS = 0x8
Global Const $BST_PUSHED = 0x4
Global Const $BST_DONTCLICK = 0x80
Global Const $CB_ERR = + -1
Global Const $CB_ERRATTRIBUTE = + -3
Global Const $CB_ERRREQUIRED = + -4
Global Const $CB_ERRSPACE = + -2
Global Const $CB_OKAY = 0x0
Global Const $STATE_SYSTEM_INVISIBLE = 0x8000
Global Const $STATE_SYSTEM_PRESSED = 0x8
Global Const $CBS_AUTOHSCROLL = 0x40
Global Const $CBS_DISABLENOSCROLL = 0x800
Global Const $CBS_DROPDOWN = 0x2
Global Const $CBS_DROPDOWNLIST = 0x3
Global Const $CBS_HASSTRINGS = 0x200
Global Const $CBS_LOWERCASE = 0x4000
Global Const $CBS_NOINTEGRALHEIGHT = 0x400
Global Const $CBS_OEMCONVERT = 0x80
Global Const $CBS_OWNERDRAWFIXED = 0x10
Global Const $CBS_OWNERDRAWVARIABLE = 0x20
Global Const $CBS_SIMPLE = 0x1
Global Const $CBS_SORT = 0x100
Global Const $CBS_UPPERCASE = 0x2000
Global Const $CBM_FIRST = 0x1700
Global Const $CB_ADDSTRING = 0x143
Global Const $CB_DELETESTRING = 0x144
Global Const $CB_DIR = 0x145
Global Const $CB_FINDSTRING = 0x14c
Global Const $CB_FINDSTRINGEXACT = 0x158
Global Const $CB_GETCOMBOBOXINFO = 0x164
Global Const $CB_GETCOUNT = 0x146
Global Const $CB_GETCUEBANNER = ($CBM_FIRST + 0x4)
Global Const $CB_GETCURSEL = 0x147
Global Const $CB_GETDROPPEDCONTROLRECT = 0x152
Global Const $CB_GETDROPPEDSTATE = 0x157
Global Const $CB_GETDROPPEDWIDTH = 0x15f
Global Const $CB_GETEDITSEL = 0x140
Global Const $CB_GETEXTENDEDUI = 0x156
Global Const $CB_GETHORIZONTALEXTENT = 0x15d
Global Const $CB_GETITEMDATA = 0x150
Global Const $CB_GETITEMHEIGHT = 0x154
Global Const $CB_GETLBTEXT = 0x148
Global Const $CB_GETLBTEXTLEN = 0x149
Global Const $CB_GETLOCALE = 0x15a
Global Const $CB_GETMINVISIBLE = 0x1702
Global Const $CB_GETTOPINDEX = 0x15b
Global Const $CB_INITSTORAGE = 0x161
Global Const $CB_LIMITTEXT = 0x141
Global Const $CB_RESETCONTENT = 0x14b
Global Const $CB_INSERTSTRING = 0x14a
Global Const $CB_SELECTSTRING = 0x14d
Global Const $CB_SETCUEBANNER = ($CBM_FIRST + 0x3)
Global Const $CB_SETCURSEL = 0x14e
Global Const $CB_SETDROPPEDWIDTH = 0x160
Global Const $CB_SETEDITSEL = 0x142
Global Const $CB_SETEXTENDEDUI = 0x155
Global Const $CB_SETHORIZONTALEXTENT = 0x15e
Global Const $CB_SETITEMDATA = 0x151
Global Const $CB_SETITEMHEIGHT = 0x153
Global Const $CB_SETLOCALE = 0x159
Global Const $CB_SETMINVISIBLE = 0x1701
Global Const $CB_SETTOPINDEX = 0x15c
Global Const $CB_SHOWDROPDOWN = 0x14f
Global Const $CBN_CLOSEUP = 0x8
Global Const $CBN_DBLCLK = 0x2
Global Const $CBN_DROPDOWN = 0x7
Global Const $CBN_EDITCHANGE = 0x5
Global Const $CBN_EDITUPDATE = 0x6
Global Const $CBN_ERRSPACE = (+ -1)
Global Const $CBN_KILLFOCUS = 0x4
Global Const $CBN_SELCHANGE = 0x1
Global Const $CBN_SELENDCANCEL = 0xa
Global Const $CBN_SELENDOK = 0x9
Global Const $CBN_SETFOCUS = 0x3
Global Const $CBES_EX_CASESENSITIVE = 0x10
Global Const $CBES_EX_NOEDITIMAGE = 0x1
Global Const $CBES_EX_NOEDITIMAGEINDENT = 0x2
Global Const $CBES_EX_NOSIZELIMIT = 0x8
Global Const $__COMBOBOXCONSTANT_WM_USER = 0x400
Global Const $CBEM_DELETEITEM = $CB_DELETESTRING
Global Const $CBEM_GETCOMBOCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 0x6)
Global Const $CBEM_GETEDITCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 0x7)
Global Const $CBEM_GETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 0x9)
Global Const $CBEM_GETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 0x9)
Global Const $CBEM_GETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 0x3)
Global Const $CBEM_GETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 0x4)
Global Const $CBEM_GETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 0xd)
Global Const $CBEM_GETUNICODEFORMAT = 0x2000 + 0x6
Global Const $CBEM_HASEDITCHANGED = ($__COMBOBOXCONSTANT_WM_USER + 0xa)
Global Const $CBEM_INSERTITEMA = ($__COMBOBOXCONSTANT_WM_USER + 0x1)
Global Const $CBEM_INSERTITEMW = ($__COMBOBOXCONSTANT_WM_USER + 0xb)
Global Const $CBEM_SETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 0x8)
Global Const $CBEM_SETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 0xe)
Global Const $CBEM_SETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 0x2)
Global Const $CBEM_SETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 0x5)
Global Const $CBEM_SETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 0xc)
Global Const $CBEM_SETUNICODEFORMAT = 0x2000 + 0x5
Global Const $CBEM_SETWINDOWTHEME = 0x2000 + 0xb
Global Const $CBEN_FIRST = (+ -800)
Global Const $CBEN_LAST = (+ -830)
Global Const $CBEN_BEGINEDIT = ($CBEN_FIRST + -4)
Global Const $CBEN_DELETEITEM = ($CBEN_FIRST + -2)
Global Const $CBEN_DRAGBEGINA = ($CBEN_FIRST + -8)
Global Const $CBEN_DRAGBEGINW = ($CBEN_FIRST + -9)
Global Const $CBEN_ENDEDITA = ($CBEN_FIRST + -5)
Global Const $CBEN_ENDEDITW = ($CBEN_FIRST + -6)
Global Const $CBEN_GETDISPINFO = ($CBEN_FIRST + 0x0)
Global Const $CBEN_GETDISPINFOA = ($CBEN_FIRST + 0x0)
Global Const $CBEN_GETDISPINFOW = ($CBEN_FIRST + -7)
Global Const $CBEN_INSERTITEM = ($CBEN_FIRST + -1)
Global Const $CBEIF_DI_SETITEM = 0x10000000
Global Const $CBEIF_IMAGE = 0x2
Global Const $CBEIF_INDENT = 0x10
Global Const $CBEIF_LPARAM = 0x20
Global Const $CBEIF_OVERLAY = 0x8
Global Const $CBEIF_SELECTEDIMAGE = 0x4
Global Const $CBEIF_TEXT = 0x1
Global Const $GUI_SS_DEFAULT_COMBO = 0x200042
Global Const $DTS_SHORTDATEFORMAT = 0x0
Global Const $DTS_UPDOWN = 0x1
Global Const $DTS_SHOWNONE = 0x2
Global Const $DTS_LONGDATEFORMAT = 0x4
Global Const $DTS_TIMEFORMAT = 0x9
Global Const $DTS_RIGHTALIGN = 0x20
Global Const $DTS_SHORTDATECENTURYFORMAT = 0xc
Global Const $DTS_APPCANPARSE = 0x10
Global Const $DMW_LONGNAME = 0x0
Global Const $DMW_SHORTNAME = 0x1
Global Const $DMW_LOCALE_LONGNAME = 0x2
Global Const $DMW_LOCALE_SHORTNAME = 0x3
Global Const $GDT_ERROR = + -1
Global Const $GDT_VALID = 0x0
Global Const $GDT_NONE = 0x1
Global Const $GDTR_MIN = 0x1
Global Const $GDTR_MAX = 0x2
Global Const $MCHT_NOWHERE = 0x0
Global Const $MCHT_TITLE = 0x10000
Global Const $MCHT_CALENDAR = 0x20000
Global Const $MCHT_TODAYLINK = 0x30000
Global Const $MCHT_NEXT = 0x1000000
Global Const $MCHT_PREV = 0x2000000
Global Const $MCHT_TITLEBK = 0x10000
Global Const $MCHT_TITLEMONTH = 0x10001
Global Const $MCHT_TITLEYEAR = 0x10002
Global Const $MCHT_TITLEBTNNEXT = 0x1010003
Global Const $MCHT_TITLEBTNPREV = 0x2010003
Global Const $MCHT_CALENDARBK = 0x20000
Global Const $MCHT_CALENDARDATE = 0x20001
Global Const $MCHT_CALENDARDAY = 0x20002
Global Const $MCHT_CALENDARWEEKNUM = 0x20003
Global Const $MCHT_CALENDARDATENEXT = 0x1020000
Global Const $MCHT_CALENDARDATEPREV = 0x2020000
Global Const $MCS_DAYSTATE = 0x1
Global Const $MCS_MULTISELECT = 0x2
Global Const $MCS_WEEKNUMBERS = 0x4
Global Const $MCS_NOTODAYCIRCLE = 0x8
Global Const $MCS_NOTODAY = 0x10
Global Const $MCS_NOTRAILINGDATES = 0x40
Global Const $MCS_SHORTDAYSOFWEEK = 0x80
Global Const $MCS_NOSELCHANGEONNAV = 0x100
Global Const $MCM_FIRST = 0x1000
Global Const $MCM_GETCALENDARBORDER = ($MCM_FIRST + 0x1f)
Global Const $MCM_GETCALENDARCOUNT = ($MCM_FIRST + 0x17)
Global Const $MCM_GETCALENDARGRIDINFO = ($MCM_FIRST + 0x18)
Global Const $MCM_GETCALID = ($MCM_FIRST + 0x1b)
Global Const $MCM_GETCOLOR = ($MCM_FIRST + 0xb)
Global Const $MCM_GETCURRENTVIEW = ($MCM_FIRST + 0x16)
Global Const $MCM_GETCURSEL = ($MCM_FIRST + 0x1)
Global Const $MCM_GETFIRSTDAYOFWEEK = ($MCM_FIRST + 0x10)
Global Const $MCM_GETMAXSELCOUNT = ($MCM_FIRST + 0x3)
Global Const $MCM_GETMAXTODAYWIDTH = ($MCM_FIRST + 0x15)
Global Const $MCM_GETMINREQRECT = ($MCM_FIRST + 0x9)
Global Const $MCM_GETMONTHDELTA = ($MCM_FIRST + 0x13)
Global Const $MCM_GETMONTHRANGE = ($MCM_FIRST + 0x7)
Global Const $MCM_GETRANGE = ($MCM_FIRST + 0x11)
Global Const $MCM_GETSELRANGE = ($MCM_FIRST + 0x5)
Global Const $MCM_GETTODAY = ($MCM_FIRST + 0xd)
Global Const $MCM_GETUNICODEFORMAT = 0x2000 + 0x6
Global Const $MCM_HITTEST = ($MCM_FIRST + 0xe)
Global Const $MCM_SETCALENDARBORDER = ($MCM_FIRST + 0x1e)
Global Const $MCM_SETCALID = ($MCM_FIRST + 0x1c)
Global Const $MCM_SETCOLOR = ($MCM_FIRST + 0xa)
Global Const $MCM_SETCURRENTVIEW = ($MCM_FIRST + 0x20)
Global Const $MCM_SETCURSEL = ($MCM_FIRST + 0x2)
Global Const $MCM_SETDAYSTATE = ($MCM_FIRST + 0x8)
Global Const $MCM_SETFIRSTDAYOFWEEK = ($MCM_FIRST + 0xf)
Global Const $MCM_SETMAXSELCOUNT = ($MCM_FIRST + 0x4)
Global Const $MCM_SETMONTHDELTA = ($MCM_FIRST + 0x14)
Global Const $MCM_SETRANGE = ($MCM_FIRST + 0x12)
Global Const $MCM_SETSELRANGE = ($MCM_FIRST + 0x6)
Global Const $MCM_SETTODAY = ($MCM_FIRST + 0xc)
Global Const $MCM_SETUNICODEFORMAT = 0x2000 + 0x5
Global Const $MCM_SIZERECTTOMIN = ($MCM_FIRST + 0x1d)
Global Const $MCN_FIRST = + -746
Global Const $MCN_SELCHANGE = ($MCN_FIRST + -3)
Global Const $MCN_GETDAYSTATE = ($MCN_FIRST + -1)
Global Const $MCN_SELECT = ($MCN_FIRST)
Global Const $MCN_VIEWCHANGE = ($MCN_FIRST + -4)
Global Const $MCSC_BACKGROUND = 0x0
Global Const $MCSC_MONTHBK = 0x4
Global Const $MCSC_TEXT = 0x1
Global Const $MCSC_TITLEBK = 0x2
Global Const $MCSC_TITLETEXT = 0x3
Global Const $MCSC_TRAILINGTEXT = 0x5
Global Const $DTM_FIRST = 0x1000
Global Const $DTM_GETSYSTEMTIME = $DTM_FIRST + 0x1
Global Const $DTM_SETSYSTEMTIME = $DTM_FIRST + 0x2
Global Const $DTM_GETRANGE = $DTM_FIRST + 0x3
Global Const $DTM_SETRANGE = $DTM_FIRST + 0x4
Global Const $DTM_SETFORMAT = $DTM_FIRST + 0x5
Global Const $DTM_SETMCCOLOR = $DTM_FIRST + 0x6
Global Const $DTM_GETMCCOLOR = $DTM_FIRST + 0x7
Global Const $DTM_GETMONTHCAL = $DTM_FIRST + 0x8
Global Const $DTM_SETMCFONT = $DTM_FIRST + 0x9
Global Const $DTM_GETMCFONT = $DTM_FIRST + 0xa
Global Const $DTM_SETFORMATW = $DTM_FIRST + 0x32
Global Const $DTN_FIRST = + -740
Global Const $DTN_FIRST2 = + -753
Global Const $DTN_DATETIMECHANGE = $DTN_FIRST2 + -6
Global Const $DTN_USERSTRING = $DTN_FIRST2 + -5
Global Const $DTN_WMKEYDOWN = $DTN_FIRST2 + -4
Global Const $DTN_FORMAT = $DTN_FIRST2 + -3
Global Const $DTN_FORMATQUERY = $DTN_FIRST2 + -2
Global Const $DTN_DROPDOWN = $DTN_FIRST2 + -1
Global Const $DTN_CLOSEUP = $DTN_FIRST2 + 0x0
Global Const $DTN_USERSTRINGW = $DTN_FIRST + -5
Global Const $DTN_WMKEYDOWNW = $DTN_FIRST + -4
Global Const $DTN_FORMATW = $DTN_FIRST + -3
Global Const $DTN_FORMATQUERYW = $DTN_FIRST + -2
Global Const $GUI_SS_DEFAULT_DATE = $DTS_LONGDATEFORMAT
Global Const $GUI_SS_DEFAULT_MONTHCAL = 0x0
Global Const $ES_LEFT = 0x0
Global Const $ES_CENTER = 0x1
Global Const $ES_RIGHT = 0x2
Global Const $ES_MULTILINE = 0x4
Global Const $ES_UPPERCASE = 0x8
Global Const $ES_LOWERCASE = 0x10
Global Const $ES_PASSWORD = 0x20
Global Const $ES_AUTOVSCROLL = 0x40
Global Const $ES_AUTOHSCROLL = 0x80
Global Const $ES_NOHIDESEL = 0x100
Global Const $ES_OEMCONVERT = 0x400
Global Const $ES_READONLY = 0x800
Global Const $ES_WANTRETURN = 0x1000
Global Const $ES_NUMBER = 0x2000
Global Const $EC_ERR = + -1
Global Const $ECM_FIRST = 0x1500
Global Const $EM_CANUNDO = 0xc6
Global Const $EM_CHARFROMPOS = 0xd7
Global Const $EM_EMPTYUNDOBUFFER = 0xcd
Global Const $EM_FMTLINES = 0xc8
Global Const $EM_GETCUEBANNER = ($ECM_FIRST + 0x2)
Global Const $EM_GETFIRSTVISIBLELINE = 0xce
Global Const $EM_GETHANDLE = 0xbd
Global Const $EM_GETIMESTATUS = 0xd9
Global Const $EM_GETLIMITTEXT = 0xd5
Global Const $EM_GETLINE = 0xc4
Global Const $EM_GETLINECOUNT = 0xba
Global Const $EM_GETMARGINS = 0xd4
Global Const $EM_GETMODIFY = 0xb8
Global Const $EM_GETPASSWORDCHAR = 0xd2
Global Const $EM_GETRECT = 0xb2
Global Const $EM_GETSEL = 0xb0
Global Const $EM_GETTHUMB = 0xbe
Global Const $EM_GETWORDBREAKPROC = 0xd1
Global Const $EM_HIDEBALLOONTIP = ($ECM_FIRST + 0x4)
Global Const $EM_LIMITTEXT = 0xc5
Global Const $EM_LINEFROMCHAR = 0xc9
Global Const $EM_LINEINDEX = 0xbb
Global Const $EM_LINELENGTH = 0xc1
Global Const $EM_LINESCROLL = 0xb6
Global Const $EM_POSFROMCHAR = 0xd6
Global Const $EM_REPLACESEL = 0xc2
Global Const $EM_SCROLL = 0xb5
Global Const $EM_SCROLLCARET = 0xb7
Global Const $EM_SETCUEBANNER = ($ECM_FIRST + 0x1)
Global Const $EM_SETHANDLE = 0xbc
Global Const $EM_SETIMESTATUS = 0xd8
Global Const $EM_SETLIMITTEXT = $EM_LIMITTEXT
Global Const $EM_SETMARGINS = 0xd3
Global Const $EM_SETMODIFY = 0xb9
Global Const $EM_SETPASSWORDCHAR = 0xcc
Global Const $EM_SETREADONLY = 0xcf
Global Const $EM_SETRECT = 0xb3
Global Const $EM_SETRECTNP = 0xb4
Global Const $EM_SETSEL = 0xb1
Global Const $EM_SETTABSTOPS = 0xcb
Global Const $EM_SETWORDBREAKPROC = 0xd0
Global Const $EM_SHOWBALLOONTIP = ($ECM_FIRST + 0x3)
Global Const $EM_UNDO = 0xc7
Global Const $EC_LEFTMARGIN = 0x1
Global Const $EC_RIGHTMARGIN = 0x2
Global Const $EC_USEFONTINFO = 0xffff
Global Const $EMSIS_COMPOSITIONSTRING = 0x1
Global Const $EIMES_GETCOMPSTRATONCE = 0x1
Global Const $EIMES_CANCELCOMPSTRINFOCUS = 0x2
Global Const $EIMES_COMPLETECOMPSTRKILLFOCUS = 0x4
Global Const $EN_ALIGN_LTR_EC = 0x700
Global Const $EN_ALIGN_RTL_EC = 0x701
Global Const $EN_CHANGE = 0x300
Global Const $EN_ERRSPACE = 0x500
Global Const $EN_HSCROLL = 0x601
Global Const $EN_KILLFOCUS = 0x200
Global Const $EN_MAXTEXT = 0x501
Global Const $EN_SETFOCUS = 0x100
Global Const $EN_UPDATE = 0x400
Global Const $EN_VSCROLL = 0x602
Global Const $GUI_SS_DEFAULT_EDIT = 0x3010c0
Global Const $GUI_SS_DEFAULT_INPUT = 0x80
Global Const $GUI_EVENT_SINGLE = 0x0
Global Const $GUI_EVENT_ARRAY = 0x1
Global Const $GUI_EVENT_NONE = 0x0
Global Const $GUI_EVENT_CLOSE = + -3
Global Const $GUI_EVENT_MINIMIZE = + -4
Global Const $GUI_EVENT_RESTORE = + -5
Global Const $GUI_EVENT_MAXIMIZE = + -6
Global Const $GUI_EVENT_PRIMARYDOWN = + -7
Global Const $GUI_EVENT_PRIMARYUP = + -8
Global Const $GUI_EVENT_SECONDARYDOWN = + -9
Global Const $GUI_EVENT_SECONDARYUP = + -10
Global Const $GUI_EVENT_MOUSEMOVE = + -11
Global Const $GUI_EVENT_RESIZED = + -12
Global Const $GUI_EVENT_DROPPED = + -13
Global Const $GUI_RUNDEFMSG = "GUI_RUNDEFMSG"
Global Const $GUI_AVISTOP = 0x0
Global Const $GUI_AVISTART = 0x1
Global Const $GUI_AVICLOSE = 0x2
Global Const $GUI_CHECKED = 0x1
Global Const $GUI_INDETERMINATE = 0x2
Global Const $GUI_UNCHECKED = 0x4
Global Const $GUI_DROPACCEPTED = 0x8
Global Const $GUI_NODROPACCEPTED = 0x1000
Global Const $GUI_ACCEPTFILES = $GUI_DROPACCEPTED
Global Const $GUI_SHOW = 0x10
Global Const $GUI_HIDE = 0x20
Global Const $GUI_ENABLE = 0x40
Global Const $GUI_DISABLE = 0x80
Global Const $GUI_FOCUS = 0x100
Global Const $GUI_NOFOCUS = 0x2000
Global Const $GUI_DEFBUTTON = 0x200
Global Const $GUI_EXPAND = 0x400
Global Const $GUI_ONTOP = 0x800
Global Const $GUI_FONTNORMAL = 0x0
Global Const $GUI_FONTITALIC = 0x2
Global Const $GUI_FONTUNDER = 0x4
Global Const $GUI_FONTSTRIKE = 0x8
Global Const $GUI_DOCKAUTO = 0x1
Global Const $GUI_DOCKLEFT = 0x2
Global Const $GUI_DOCKRIGHT = 0x4
Global Const $GUI_DOCKHCENTER = 0x8
Global Const $GUI_DOCKTOP = 0x20
Global Const $GUI_DOCKBOTTOM = 0x40
Global Const $GUI_DOCKVCENTER = 0x80
Global Const $GUI_DOCKWIDTH = 0x100
Global Const $GUI_DOCKHEIGHT = 0x200
Global Const $GUI_DOCKSIZE = 0x300
Global Const $GUI_DOCKMENUBAR = 0x220
Global Const $GUI_DOCKSTATEBAR = 0x240
Global Const $GUI_DOCKALL = 0x322
Global Const $GUI_DOCKBORDERS = 0x66
Global Const $GUI_GR_CLOSE = 0x1
Global Const $GUI_GR_LINE = 0x2
Global Const $GUI_GR_BEZIER = 0x4
Global Const $GUI_GR_MOVE = 0x6
Global Const $GUI_GR_COLOR = 0x8
Global Const $GUI_GR_RECT = 0xa
Global Const $GUI_GR_ELLIPSE = 0xc
Global Const $GUI_GR_PIE = 0xe
Global Const $GUI_GR_DOT = 0x10
Global Const $GUI_GR_PIXEL = 0x12
Global Const $GUI_GR_HINT = 0x14
Global Const $GUI_GR_REFRESH = 0x16
Global Const $GUI_GR_PENSIZE = 0x18
Global Const $GUI_GR_NOBKCOLOR = + -2
Global Const $GUI_BKCOLOR_DEFAULT = + -1
Global Const $GUI_BKCOLOR_TRANSPARENT = + -2
Global Const $GUI_BKCOLOR_LV_ALTERNATE = -33554432
Global Const $GUI_READ_DEFAULT = 0x0
Global Const $GUI_READ_EXTENDED = 0x1
Global Const $GUI_CURSOR_NOOVERRIDE = 0x0
Global Const $GUI_CURSOR_OVERRIDE = 0x1
Global Const $GUI_WS_EX_PARENTDRAG = 0x100000
Global Const $LBS_NOTIFY = 0x1
Global Const $LBS_SORT = 0x2
Global Const $LBS_NOREDRAW = 0x4
Global Const $LBS_MULTIPLESEL = 0x8
Global Const $LBS_OWNERDRAWFIXED = 0x10
Global Const $LBS_OWNERDRAWVARIABLE = 0x20
Global Const $LBS_HASSTRINGS = 0x40
Global Const $LBS_USETABSTOPS = 0x80
Global Const $LBS_NOINTEGRALHEIGHT = 0x100
Global Const $LBS_MULTICOLUMN = 0x200
Global Const $LBS_WANTKEYBOARDINPUT = 0x400
Global Const $LBS_EXTENDEDSEL = 0x800
Global Const $LBS_DISABLENOSCROLL = 0x1000
Global Const $LBS_NODATA = 0x2000
Global Const $LBS_NOSEL = 0x4000
Global Const $LBS_COMBOBOX = 0x8000
Global Const $LBS_STANDARD = 0x3
Global Const $GUI_SS_DEFAULT_LIST = 0xa00003
Global Const $LB_ERR = + -1
Global Const $LB_ERRATTRIBUTE = + -3
Global Const $LB_ERRREQUIRED = + -4
Global Const $LB_ERRSPACE = + -2
Global Const $LB_ADDSTRING = 0x180
Global Const $LB_INSERTSTRING = 0x181
Global Const $LB_DELETESTRING = 0x182
Global Const $LB_SELITEMRANGEEX = 0x183
Global Const $LB_RESETCONTENT = 0x184
Global Const $LB_SETSEL = 0x185
Global Const $LB_SETCURSEL = 0x186
Global Const $LB_GETSEL = 0x187
Global Const $LB_GETCURSEL = 0x188
Global Const $LB_GETTEXT = 0x189
Global Const $LB_GETTEXTLEN = 0x18a
Global Const $LB_GETCOUNT = 0x18b
Global Const $LB_SELECTSTRING = 0x18c
Global Const $LB_DIR = 0x18d
Global Const $LB_GETTOPINDEX = 0x18e
Global Const $LB_FINDSTRING = 0x18f
Global Const $LB_GETSELCOUNT = 0x190
Global Const $LB_GETSELITEMS = 0x191
Global Const $LB_SETTABSTOPS = 0x192
Global Const $LB_GETHORIZONTALEXTENT = 0x193
Global Const $LB_SETHORIZONTALEXTENT = 0x194
Global Const $LB_SETCOLUMNWIDTH = 0x195
Global Const $LB_ADDFILE = 0x196
Global Const $LB_SETTOPINDEX = 0x197
Global Const $LB_GETITEMRECT = 0x198
Global Const $LB_GETITEMDATA = 0x199
Global Const $LB_SETITEMDATA = 0x19a
Global Const $LB_SELITEMRANGE = 0x19b
Global Const $LB_SETANCHORINDEX = 0x19c
Global Const $LB_GETANCHORINDEX = 0x19d
Global Const $LB_SETCARETINDEX = 0x19e
Global Const $LB_GETCARETINDEX = 0x19f
Global Const $LB_SETITEMHEIGHT = 0x1a0
Global Const $LB_GETITEMHEIGHT = 0x1a1
Global Const $LB_FINDSTRINGEXACT = 0x1a2
Global Const $LB_SETLOCALE = 0x1a5
Global Const $LB_GETLOCALE = 0x1a6
Global Const $LB_SETCOUNT = 0x1a7
Global Const $LB_INITSTORAGE = 0x1a8
Global Const $LB_ITEMFROMPOINT = 0x1a9
Global Const $LB_MULTIPLEADDSTRING = 0x1b1
Global Const $LB_GETLISTBOXINFO = 0x1b2
Global Const $LBN_ERRSPACE = -2
Global Const $LBN_SELCHANGE = 0x1
Global Const $LBN_DBLCLK = 0x2
Global Const $LBN_SELCANCEL = 0x3
Global Const $LBN_SETFOCUS = 0x4
Global Const $LBN_KILLFOCUS = 0x5
Global Const $LVGS_NORMAL = 0x0
Global Const $LVGS_COLLAPSED = 0x1
Global Const $LVGS_HIDDEN = 0x2
Global Const $LVGS_NOHEADER = 0x4
Global Const $LVGS_COLLAPSIBLE = 0x8
Global Const $LVGS_FOCUSED = 0x10
Global Const $LVGS_SELECTED = 0x20
Global Const $LVGS_SUBSETED = 0x40
Global Const $LVGS_SUBSETLINKFOCUSED = 0x80
Global Const $LVGGR_GROUP = 0x0
Global Const $LVGGR_HEADER = 0x1
Global Const $LVGGR_LABEL = 0x2
Global Const $LVGGR_SUBSETLINK = 0x3
Global Const $LV_ERR = + -1
Global Const $LVBKIF_SOURCE_NONE = 0x0
Global Const $LVBKIF_SOURCE_HBITMAP = 0x1
Global Const $LVBKIF_SOURCE_URL = 0x2
Global Const $LVBKIF_SOURCE_MASK = 0x3
Global Const $LVBKIF_STYLE_NORMAL = 0x0
Global Const $LVBKIF_STYLE_TILE = 0x10
Global Const $LVBKIF_STYLE_MASK = 0x10
Global Const $LVBKIF_FLAG_TILEOFFSET = 0x100
Global Const $LVBKIF_TYPE_WATERMARK = 0x10000000
Global Const $LV_VIEW_DETAILS = 0x1
Global Const $LV_VIEW_ICON = 0x0
Global Const $LV_VIEW_LIST = 0x3
Global Const $LV_VIEW_SMALLICON = 0x2
Global Const $LV_VIEW_TILE = 0x4
Global Const $LVA_ALIGNLEFT = 0x1
Global Const $LVA_ALIGNTOP = 0x2
Global Const $LVA_DEFAULT = 0x0
Global Const $LVA_SNAPTOGRID = 0x5
Global Const $LVCDI_ITEM = 0x0
Global Const $LVCDI_GROUP = 0x1
Global Const $LVCF_ALLDATA = 0x3f
Global Const $LVCF_FMT = 0x1
Global Const $LVCF_IMAGE = 0x10
Global Const $LVCFMT_JUSTIFYMASK = 0x3
Global Const $LVCF_TEXT = 0x4
Global Const $LVCF_WIDTH = 0x2
Global Const $LVCFMT_BITMAP_ON_RIGHT = 0x1000
Global Const $LVCFMT_CENTER = 0x2
Global Const $LVCFMT_COL_HAS_IMAGES = 0x8000
Global Const $LVCFMT_IMAGE = 0x800
Global Const $LVCFMT_LEFT = 0x0
Global Const $LVCFMT_RIGHT = 0x1
Global Const $LVCFMT_LINE_BREAK = 0x100000
Global Const $LVCFMT_FILL = 0x200000
Global Const $LVCFMT_WRAP = 0x400000
Global Const $LVCFMT_NO_TITLE = 0x800000
Global Const $LVCFMT_TILE_PLACEMENTMASK = BitOR($LVCFMT_LINE_BREAK, $LVCFMT_FILL)
Global Const $LVFI_NEARESTXY = 0x40
Global Const $LVFI_PARAM = 0x1
Global Const $LVFI_PARTIAL = 0x8
Global Const $LVFI_STRING = 0x2
Global Const $LVFI_SUBSTRING = 0x4
Global Const $LVFI_WRAP = 0x20
Global Const $LVGA_FOOTER_LEFT = 0x8
Global Const $LVGA_FOOTER_CENTER = 0x10
Global Const $LVGA_FOOTER_RIGHT = 0x20
Global Const $LVGA_HEADER_LEFT = 0x1
Global Const $LVGA_HEADER_CENTER = 0x2
Global Const $LVGA_HEADER_RIGHT = 0x4
Global Const $LVGF_ALIGN = 0x8
Global Const $LVGF_DESCRIPTIONTOP = 0x400
Global Const $LVGF_DESCRIPTIONBOTTOM = 0x800
Global Const $LVGF_EXTENDEDIMAGE = 0x2000
Global Const $LVGF_FOOTER = 0x2
Global Const $LVGF_GROUPID = 0x10
Global Const $LVGF_HEADER = 0x1
Global Const $LVGF_ITEMS = 0x4000
Global Const $LVGF_NONE = 0x0
Global Const $LVGF_STATE = 0x4
Global Const $LVGF_SUBSET = 0x8000
Global Const $LVGF_SUBSETITEMS = 0x10000
Global Const $LVGF_SUBTITLE = 0x100
Global Const $LVGF_TASK = 0x200
Global Const $LVGF_TITLEIMAGE = 0x1000
Global Const $LVHT_ABOVE = 0x8
Global Const $LVHT_BELOW = 0x10
Global Const $LVHT_NOWHERE = 0x1
Global Const $LVHT_ONITEMICON = 0x2
Global Const $LVHT_ONITEMLABEL = 0x4
Global Const $LVHT_ONITEMSTATEICON = 0x8
Global Const $LVHT_TOLEFT = 0x40
Global Const $LVHT_TORIGHT = 0x20
Global Const $LVHT_ONITEM = BitOR($LVHT_ONITEMICON, $LVHT_ONITEMLABEL, $LVHT_ONITEMSTATEICON)
Global Const $LVHT_EX_GROUP_HEADER = 0x10000000
Global Const $LVHT_EX_GROUP_FOOTER = 0x20000000
Global Const $LVHT_EX_GROUP_COLLAPSE = 0x40000000
Global Const $LVHT_EX_GROUP_BACKGROUND = -2147483648
Global Const $LVHT_EX_GROUP_STATEICON = 0x1000000
Global Const $LVHT_EX_GROUP_SUBSETLINK = 0x2000000
Global Const $LVHT_EX_GROUP = BitOR($LVHT_EX_GROUP_BACKGROUND, $LVHT_EX_GROUP_COLLAPSE, $LVHT_EX_GROUP_FOOTER, $LVHT_EX_GROUP_HEADER, $LVHT_EX_GROUP_STATEICON, $LVHT_EX_GROUP_SUBSETLINK)
Global Const $LVHT_EX_ONCONTENTS = 0x4000000
Global Const $LVHT_EX_FOOTER = 0x8000000
Global Const $LVIF_COLFMT = 0x10000
Global Const $LVIF_COLUMNS = 0x200
Global Const $LVIF_GROUPID = 0x100
Global Const $LVIF_IMAGE = 0x2
Global Const $LVIF_INDENT = 0x10
Global Const $LVIF_NORECOMPUTE = 0x800
Global Const $LVIF_PARAM = 0x4
Global Const $LVIF_STATE = 0x8
Global Const $LVIF_TEXT = 0x1
Global Const $LVIM_AFTER = 0x1
Global Const $LVIR_BOUNDS = 0x0
Global Const $LVIR_ICON = 0x1
Global Const $LVIR_LABEL = 0x2
Global Const $LVIR_SELECTBOUNDS = 0x3
Global Const $LVIS_CUT = 0x4
Global Const $LVIS_DROPHILITED = 0x8
Global Const $LVIS_FOCUSED = 0x1
Global Const $LVIS_OVERLAYMASK = 0xf00
Global Const $LVIS_SELECTED = 0x2
Global Const $LVIS_STATEIMAGEMASK = 0xf000
Global Const $LVS_ALIGNLEFT = 0x800
Global Const $LVS_ALIGNMASK = 0xc00
Global Const $LVS_ALIGNTOP = 0x0
Global Const $LVS_AUTOARRANGE = 0x100
Global Const $LVS_DEFAULT = 0xd
Global Const $LVS_EDITLABELS = 0x200
Global Const $LVS_ICON = 0x0
Global Const $LVS_LIST = 0x3
Global Const $LVS_NOCOLUMNHEADER = 0x4000
Global Const $LVS_NOLABELWRAP = 0x80
Global Const $LVS_NOSCROLL = 0x2000
Global Const $LVS_NOSORTHEADER = 0x8000
Global Const $LVS_OWNERDATA = 0x1000
Global Const $LVS_OWNERDRAWFIXED = 0x400
Global Const $LVS_REPORT = 0x1
Global Const $LVS_SHAREIMAGELISTS = 0x40
Global Const $LVS_SHOWSELALWAYS = 0x8
Global Const $LVS_SINGLESEL = 0x4
Global Const $LVS_SMALLICON = 0x2
Global Const $LVS_SORTASCENDING = 0x10
Global Const $LVS_SORTDESCENDING = 0x20
Global Const $LVS_TYPEMASK = 0x3
Global Const $LVS_TYPESTYLEMASK = 0xfc00
Global Const $LVS_EX_AUTOAUTOARRANGE = 0x1000000
Global Const $LVS_EX_AUTOCHECKSELECT = 0x8000000
Global Const $LVS_EX_AUTOSIZECOLUMNS = 0x10000000
Global Const $LVS_EX_BORDERSELECT = 0x8000
Global Const $LVS_EX_CHECKBOXES = 0x4
Global Const $LVS_EX_COLUMNOVERFLOW = -2147483648
Global Const $LVS_EX_COLUMNSNAPPOINTS = 0x40000000
Global Const $LVS_EX_DOUBLEBUFFER = 0x10000
Global Const $LVS_EX_FLATSB = 0x100
Global Const $LVS_EX_FULLROWSELECT = 0x20
Global Const $LVS_EX_GRIDLINES = 0x1
Global Const $LVS_EX_HEADERDRAGDROP = 0x10
Global Const $LVS_EX_HEADERINALLVIEWS = 0x2000000
Global Const $LVS_EX_HIDELABELS = 0x20000
Global Const $LVS_EX_INFOTIP = 0x400
Global Const $LVS_EX_JUSTIFYCOLUMNS = 0x200000
Global Const $LVS_EX_LABELTIP = 0x4000
Global Const $LVS_EX_MULTIWORKAREAS = 0x2000
Global Const $LVS_EX_ONECLICKACTIVATE = 0x40
Global Const $LVS_EX_REGIONAL = 0x200
Global Const $LVS_EX_SIMPLESELECT = 0x100000
Global Const $LVS_EX_SNAPTOGRID = 0x80000
Global Const $LVS_EX_SUBITEMIMAGES = 0x2
Global Const $LVS_EX_TRACKSELECT = 0x8
Global Const $LVS_EX_TRANSPARENTBKGND = 0x400000
Global Const $LVS_EX_TRANSPARENTSHADOWTEXT = 0x800000
Global Const $LVS_EX_TWOCLICKACTIVATE = 0x80
Global Const $LVS_EX_UNDERLINECOLD = 0x1000
Global Const $LVS_EX_UNDERLINEHOT = 0x800
Global Const $GUI_SS_DEFAULT_LISTVIEW = BitOR($LVS_SHOWSELALWAYS, $LVS_SINGLESEL)
Global Const $LVM_FIRST = 0x1000
Global Const $LVM_APPROXIMATEVIEWRECT = ($LVM_FIRST + 0x40)
Global Const $LVM_ARRANGE = ($LVM_FIRST + 0x16)
Global Const $LVM_CANCELEDITLABEL = ($LVM_FIRST + 0xb3)
Global Const $LVM_CREATEDRAGIMAGE = ($LVM_FIRST + 0x21)
Global Const $LVM_DELETEALLITEMS = ($LVM_FIRST + 0x9)
Global Const $LVM_DELETECOLUMN = ($LVM_FIRST + 0x1c)
Global Const $LVM_DELETEITEM = ($LVM_FIRST + 0x8)
Global Const $LVM_EDITLABELA = ($LVM_FIRST + 0x17)
Global Const $LVM_EDITLABELW = ($LVM_FIRST + 0x76)
Global Const $LVM_EDITLABEL = $LVM_EDITLABELA
Global Const $LVM_ENABLEGROUPVIEW = ($LVM_FIRST + 0x9d)
Global Const $LVM_ENSUREVISIBLE = ($LVM_FIRST + 0x13)
Global Const $LVM_FINDITEM = ($LVM_FIRST + 0xd)
Global Const $LVM_GETBKCOLOR = ($LVM_FIRST + 0x0)
Global Const $LVM_GETBKIMAGEA = ($LVM_FIRST + 0x45)
Global Const $LVM_GETBKIMAGEW = ($LVM_FIRST + 0x8b)
Global Const $LVM_GETCALLBACKMASK = ($LVM_FIRST + 0xa)
Global Const $LVM_GETCOLUMNA = ($LVM_FIRST + 0x19)
Global Const $LVM_GETCOLUMNW = ($LVM_FIRST + 0x5f)
Global Const $LVM_GETCOLUMNORDERARRAY = ($LVM_FIRST + 0x3b)
Global Const $LVM_GETCOLUMNWIDTH = ($LVM_FIRST + 0x1d)
Global Const $LVM_GETCOUNTPERPAGE = ($LVM_FIRST + 0x28)
Global Const $LVM_GETEDITCONTROL = ($LVM_FIRST + 0x18)
Global Const $LVM_GETEMPTYTEXT = ($LVM_FIRST + 0xcc)
Global Const $LVM_GETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 0x37)
Global Const $LVM_GETFOCUSEDGROUP = ($LVM_FIRST + 0x5d)
Global Const $LVM_GETFOOTERINFO = ($LVM_FIRST + 0xce)
Global Const $LVM_GETFOOTERITEM = ($LVM_FIRST + 0xd0)
Global Const $LVM_GETFOOTERITEMRECT = ($LVM_FIRST + 0xcf)
Global Const $LVM_GETFOOTERRECT = ($LVM_FIRST + 0xcd)
Global Const $LVM_GETGROUPCOUNT = ($LVM_FIRST + 0x98)
Global Const $LVM_GETGROUPINFO = ($LVM_FIRST + 0x95)
Global Const $LVM_GETGROUPINFOBYINDEX = ($LVM_FIRST + 0x99)
Global Const $LVM_GETGROUPMETRICS = ($LVM_FIRST + 0x9c)
Global Const $LVM_GETGROUPRECT = ($LVM_FIRST + 0x62)
Global Const $LVM_GETGROUPSTATE = ($LVM_FIRST + 0x5c)
Global Const $LVM_GETHEADER = ($LVM_FIRST + 0x1f)
Global Const $LVM_GETHOTCURSOR = ($LVM_FIRST + 0x3f)
Global Const $LVM_GETHOTITEM = ($LVM_FIRST + 0x3d)
Global Const $LVM_GETHOVERTIME = ($LVM_FIRST + 0x48)
Global Const $LVM_GETIMAGELIST = ($LVM_FIRST + 0x2)
Global Const $LVM_GETINSERTMARK = ($LVM_FIRST + 0xa7)
Global Const $LVM_GETINSERTMARKCOLOR = ($LVM_FIRST + 0xab)
Global Const $LVM_GETINSERTMARKRECT = ($LVM_FIRST + 0xa9)
Global Const $LVM_GETISEARCHSTRINGA = ($LVM_FIRST + 0x34)
Global Const $LVM_GETISEARCHSTRINGW = ($LVM_FIRST + 0x75)
Global Const $LVM_GETITEMA = ($LVM_FIRST + 0x5)
Global Const $LVM_GETITEMW = ($LVM_FIRST + 0x4b)
Global Const $LVM_GETITEMCOUNT = ($LVM_FIRST + 0x4)
Global Const $LVM_GETITEMINDEXRECT = ($LVM_FIRST + 0xd1)
Global Const $LVM_GETITEMPOSITION = ($LVM_FIRST + 0x10)
Global Const $LVM_GETITEMRECT = ($LVM_FIRST + 0xe)
Global Const $LVM_GETITEMSPACING = ($LVM_FIRST + 0x33)
Global Const $LVM_GETITEMSTATE = ($LVM_FIRST + 0x2c)
Global Const $LVM_GETITEMTEXTA = ($LVM_FIRST + 0x2d)
Global Const $LVM_GETITEMTEXTW = ($LVM_FIRST + 0x73)
Global Const $LVM_GETNEXTITEM = ($LVM_FIRST + 0xc)
Global Const $LVM_GETNEXTITEMINDEX = ($LVM_FIRST + 0xd3)
Global Const $LVM_GETNUMBEROFWORKAREAS = ($LVM_FIRST + 0x49)
Global Const $LVM_GETORIGIN = ($LVM_FIRST + 0x29)
Global Const $LVM_GETOUTLINECOLOR = ($LVM_FIRST + 0xb0)
Global Const $LVM_GETSELECTEDCOLUMN = ($LVM_FIRST + 0xae)
Global Const $LVM_GETSELECTEDCOUNT = ($LVM_FIRST + 0x32)
Global Const $LVM_GETSELECTIONMARK = ($LVM_FIRST + 0x42)
Global Const $LVM_GETSTRINGWIDTHA = ($LVM_FIRST + 0x11)
Global Const $LVM_GETSTRINGWIDTHW = ($LVM_FIRST + 0x57)
Global Const $LVM_GETSUBITEMRECT = ($LVM_FIRST + 0x38)
Global Const $LVM_GETTEXTBKCOLOR = ($LVM_FIRST + 0x25)
Global Const $LVM_GETTEXTCOLOR = ($LVM_FIRST + 0x23)
Global Const $LVM_GETTILEINFO = ($LVM_FIRST + 0xa5)
Global Const $LVM_GETTILEVIEWINFO = ($LVM_FIRST + 0xa3)
Global Const $LVM_GETTOOLTIPS = ($LVM_FIRST + 0x4e)
Global Const $LVM_GETTOPINDEX = ($LVM_FIRST + 0x27)
Global Const $LVM_GETUNICODEFORMAT = 0x2000 + 0x6
Global Const $LVM_GETVIEW = ($LVM_FIRST + 0x8f)
Global Const $LVM_GETVIEWRECT = ($LVM_FIRST + 0x22)
Global Const $LVM_GETWORKAREAS = ($LVM_FIRST + 0x46)
Global Const $LVM_HASGROUP = ($LVM_FIRST + 0xa1)
Global Const $LVM_HITTEST = ($LVM_FIRST + 0x12)
Global Const $LVM_INSERTCOLUMNA = ($LVM_FIRST + 0x1b)
Global Const $LVM_INSERTCOLUMNW = ($LVM_FIRST + 0x61)
Global Const $LVM_INSERTGROUP = ($LVM_FIRST + 0x91)
Global Const $LVM_INSERTGROUPSORTED = ($LVM_FIRST + 0x9f)
Global Const $LVM_INSERTITEMA = ($LVM_FIRST + 0x7)
Global Const $LVM_INSERTITEMW = ($LVM_FIRST + 0x4d)
Global Const $LVM_INSERTMARKHITTEST = ($LVM_FIRST + 0xa8)
Global Const $LVM_ISGROUPVIEWENABLED = ($LVM_FIRST + 0xaf)
Global Const $LVM_ISITEMVISIBLE = ($LVM_FIRST + 0xb6)
Global Const $LVM_MAPIDTOINDEX = ($LVM_FIRST + 0xb5)
Global Const $LVM_MAPINDEXTOID = ($LVM_FIRST + 0xb4)
Global Const $LVM_MOVEGROUP = ($LVM_FIRST + 0x97)
Global Const $LVM_REDRAWITEMS = ($LVM_FIRST + 0x15)
Global Const $LVM_REMOVEALLGROUPS = ($LVM_FIRST + 0xa0)
Global Const $LVM_REMOVEGROUP = ($LVM_FIRST + 0x96)
Global Const $LVM_SCROLL = ($LVM_FIRST + 0x14)
Global Const $LVM_SETBKCOLOR = ($LVM_FIRST + 0x1)
Global Const $LVM_SETBKIMAGEA = ($LVM_FIRST + 0x44)
Global Const $LVM_SETBKIMAGEW = ($LVM_FIRST + 0x8a)
Global Const $LVM_SETCALLBACKMASK = ($LVM_FIRST + 0xb)
Global Const $LVM_SETCOLUMNA = ($LVM_FIRST + 0x1a)
Global Const $LVM_SETCOLUMNW = ($LVM_FIRST + 0x60)
Global Const $LVM_SETCOLUMNORDERARRAY = ($LVM_FIRST + 0x3a)
Global Const $LVM_SETCOLUMNWIDTH = ($LVM_FIRST + 0x1e)
Global Const $LVM_SETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 0x36)
Global Const $LVM_SETGROUPINFO = ($LVM_FIRST + 0x93)
Global Const $LVM_SETGROUPMETRICS = ($LVM_FIRST + 0x9b)
Global Const $LVM_SETHOTCURSOR = ($LVM_FIRST + 0x3e)
Global Const $LVM_SETHOTITEM = ($LVM_FIRST + 0x3c)
Global Const $LVM_SETHOVERTIME = ($LVM_FIRST + 0x47)
Global Const $LVM_SETICONSPACING = ($LVM_FIRST + 0x35)
Global Const $LVM_SETIMAGELIST = ($LVM_FIRST + 0x3)
Global Const $LVM_SETINFOTIP = ($LVM_FIRST + 0xad)
Global Const $LVM_SETINSERTMARK = ($LVM_FIRST + 0xa6)
Global Const $LVM_SETINSERTMARKCOLOR = ($LVM_FIRST + 0xaa)
Global Const $LVM_SETITEMA = ($LVM_FIRST + 0x6)
Global Const $LVM_SETITEMW = ($LVM_FIRST + 0x4c)
Global Const $LVM_SETITEMCOUNT = ($LVM_FIRST + 0x2f)
Global Const $LVM_SETITEMINDEXSTATE = ($LVM_FIRST + 0xd2)
Global Const $LVM_SETITEMPOSITION = ($LVM_FIRST + 0xf)
Global Const $LVM_SETITEMPOSITION32 = ($LVM_FIRST + 0x31)
Global Const $LVM_SETITEMSTATE = ($LVM_FIRST + 0x2b)
Global Const $LVM_SETITEMTEXTA = ($LVM_FIRST + 0x2e)
Global Const $LVM_SETITEMTEXTW = ($LVM_FIRST + 0x74)
Global Const $LVM_SETOUTLINECOLOR = ($LVM_FIRST + 0xb1)
Global Const $LVM_SETSELECTEDCOLUMN = ($LVM_FIRST + 0x8c)
Global Const $LVM_SETSELECTIONMARK = ($LVM_FIRST + 0x43)
Global Const $LVM_SETTEXTBKCOLOR = ($LVM_FIRST + 0x26)
Global Const $LVM_SETTEXTCOLOR = ($LVM_FIRST + 0x24)
Global Const $LVM_SETTILEINFO = ($LVM_FIRST + 0xa4)
Global Const $LVM_SETTILEVIEWINFO = ($LVM_FIRST + 0xa2)
Global Const $LVM_SETTILEWIDTH = ($LVM_FIRST + 0x8d)
Global Const $LVM_SETTOOLTIPS = ($LVM_FIRST + 0x4a)
Global Const $LVM_SETUNICODEFORMAT = 0x2000 + 0x5
Global Const $LVM_SETVIEW = ($LVM_FIRST + 0x8e)
Global Const $LVM_SETWORKAREAS = ($LVM_FIRST + 0x41)
Global Const $LVM_SORTGROUPS = ($LVM_FIRST + 0x9e)
Global Const $LVM_SORTITEMS = ($LVM_FIRST + 0x30)
Global Const $LVM_SORTITEMSEX = ($LVM_FIRST + 0x51)
Global Const $LVM_SUBITEMHITTEST = ($LVM_FIRST + 0x39)
Global Const $LVM_UPDATE = ($LVM_FIRST + 0x2a)
Global Const $LVN_FIRST = + -100
Global Const $LVN_LAST = + -199
Global Const $LVN_BEGINDRAG = ($LVN_FIRST + -9)
Global Const $LVN_BEGINLABELEDITA = ($LVN_FIRST + -5)
Global Const $LVN_BEGINLABELEDITW = ($LVN_FIRST + -75)
Global Const $LVN_BEGINRDRAG = ($LVN_FIRST + -11)
Global Const $LVN_BEGINSCROLL = ($LVN_FIRST + -80)
Global Const $LVN_COLUMNCLICK = ($LVN_FIRST + -8)
Global Const $LVN_COLUMNDROPDOWN = ($LVN_FIRST + -64)
Global Const $LVN_COLUMNOVERFLOWCLICK = ($LVN_FIRST + -66)
Global Const $LVN_DELETEALLITEMS = ($LVN_FIRST + -4)
Global Const $LVN_DELETEITEM = ($LVN_FIRST + -3)
Global Const $LVN_ENDLABELEDITA = ($LVN_FIRST + -6)
Global Const $LVN_ENDLABELEDITW = ($LVN_FIRST + -76)
Global Const $LVN_ENDSCROLL = ($LVN_FIRST + -81)
Global Const $LVN_GETDISPINFOA = ($LVN_FIRST + -50)
Global Const $LVN_GETDISPINFOW = ($LVN_FIRST + -77)
Global Const $LVN_GETDISPINFO = $LVN_GETDISPINFOA
Global Const $LVN_GETEMPTYMARKUP = ($LVN_FIRST + -87)
Global Const $LVN_GETINFOTIPA = ($LVN_FIRST + -57)
Global Const $LVN_GETINFOTIPW = ($LVN_FIRST + -58)
Global Const $LVN_HOTTRACK = ($LVN_FIRST + -21)
Global Const $LVN_INCREMENTALSEARCHA = ($LVN_FIRST + -62)
Global Const $LVN_INCREMENTALSEARCHW = ($LVN_FIRST + -63)
Global Const $LVN_INSERTITEM = ($LVN_FIRST + -2)
Global Const $LVN_ITEMACTIVATE = ($LVN_FIRST + -14)
Global Const $LVN_ITEMCHANGED = ($LVN_FIRST + -1)
Global Const $LVN_ITEMCHANGING = ($LVN_FIRST + 0x0)
Global Const $LVN_KEYDOWN = ($LVN_FIRST + -55)
Global Const $LVN_LINKCLICK = ($LVN_FIRST + -84)
Global Const $LVN_MARQUEEBEGIN = ($LVN_FIRST + -56)
Global Const $LVN_ODCACHEHINT = ($LVN_FIRST + -13)
Global Const $LVN_ODFINDITEMA = ($LVN_FIRST + -52)
Global Const $LVN_ODFINDITEMW = ($LVN_FIRST + -79)
Global Const $LVN_ODFINDITEM = $LVN_ODFINDITEMA
Global Const $LVN_ODSTATECHANGED = ($LVN_FIRST + -15)
Global Const $LVN_SETDISPINFOA = ($LVN_FIRST + -51)
Global Const $LVN_SETDISPINFOW = ($LVN_FIRST + -78)
Global Const $LVNI_ABOVE = 0x100
Global Const $LVNI_BELOW = 0x200
Global Const $LVNI_TOLEFT = 0x400
Global Const $LVNI_TORIGHT = 0x800
Global Const $LVNI_ALL = 0x0
Global Const $LVNI_CUT = 0x4
Global Const $LVNI_DROPHILITED = 0x8
Global Const $LVNI_FOCUSED = 0x1
Global Const $LVNI_SELECTED = 0x2
Global Const $LVSCW_AUTOSIZE = + -1
Global Const $LVSCW_AUTOSIZE_USEHEADER = + -2
Global Const $LVSICF_NOINVALIDATEALL = 0x1
Global Const $LVSICF_NOSCROLL = 0x2
Global Const $LVSIL_NORMAL = 0x0
Global Const $LVSIL_SMALL = 0x1
Global Const $LVSIL_STATE = 0x2
Global Const $LVFN_DIR_LEFT = 0x0
Global Const $LVFN_DIR_RIGHT = 0x1
Global Const $LVFN_DIR_UP = 0x2
Global Const $LVFN_DIR_DOWN = 0x3
Global Const $LVFN_DIR_START = 0x4
Global Const $LVFN_DIR_MEND = 0x5
Global Const $LVFN_DIR_PRIOR = 0x6
Global Const $LVFN_DIR_NEXT = 0x7
Global Const $PBS_MARQUEE = 0x8
Global Const $PBS_SMOOTH = 0x1
Global Const $PBS_SMOOTHREVERSE = 0x10
Global Const $PBS_VERTICAL = 0x4
Global Const $GUI_SS_DEFAULT_PROGRESS = 0x0
Global Const $__PROGRESSBARCONSTANT_WM_USER = 0x400
Global Const $PBM_DELTAPOS = $__PROGRESSBARCONSTANT_WM_USER + 0x3
Global Const $PBM_GETBARCOLOR = 0x40f
Global Const $PBM_GETBKCOLOR = 0x40e
Global Const $PBM_GETPOS = $__PROGRESSBARCONSTANT_WM_USER + 0x8
Global Const $PBM_GETRANGE = $__PROGRESSBARCONSTANT_WM_USER + 0x7
Global Const $PBM_GETSTATE = 0x411
Global Const $PBM_GETSTEP = 0x40d
Global Const $PBM_SETBARCOLOR = $__PROGRESSBARCONSTANT_WM_USER + 0x9
Global Const $PBM_SETBKCOLOR = 0x2000 + 0x1
Global Const $PBM_SETMARQUEE = $__PROGRESSBARCONSTANT_WM_USER + 0xa
Global Const $PBM_SETPOS = $__PROGRESSBARCONSTANT_WM_USER + 0x2
Global Const $PBM_SETRANGE = $__PROGRESSBARCONSTANT_WM_USER + 0x1
Global Const $PBM_SETRANGE32 = $__PROGRESSBARCONSTANT_WM_USER + 0x6
Global Const $PBM_SETSTATE = 0x410
Global Const $PBM_SETSTEP = $__PROGRESSBARCONSTANT_WM_USER + 0x4
Global Const $PBM_STEPIT = $__PROGRESSBARCONSTANT_WM_USER + 0x5
Global Const $__RICHEDITCONSTANT_WM_USER = 0x400
Global Const $EM_AUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 0x5b
Global Const $EM_CANPASTE = $__RICHEDITCONSTANT_WM_USER + 0x32
Global Const $EM_CANREDO = $__RICHEDITCONSTANT_WM_USER + 0x55
Global Const $EM_DISPLAYBAND = $__RICHEDITCONSTANT_WM_USER + 0x33
Global Const $EM_EXGETSEL = $__RICHEDITCONSTANT_WM_USER + 0x34
Global Const $EM_EXLIMITTEXT = $__RICHEDITCONSTANT_WM_USER + 0x35
Global Const $EM_EXLINEFROMCHAR = $__RICHEDITCONSTANT_WM_USER + 0x36
Global Const $EM_EXSETSEL = $__RICHEDITCONSTANT_WM_USER + 0x37
Global Const $EM_FINDTEXT = $__RICHEDITCONSTANT_WM_USER + 0x38
Global Const $EM_FINDTEXTEX = $__RICHEDITCONSTANT_WM_USER + 0x4f
Global Const $EM_FINDTEXTEXW = $__RICHEDITCONSTANT_WM_USER + 0x7c
Global Const $EM_FINDTEXTW = $__RICHEDITCONSTANT_WM_USER + 0x7b
Global Const $EM_FINDWORDBREAK = $__RICHEDITCONSTANT_WM_USER + 0x4c
Global Const $EM_FORMATRANGE = $__RICHEDITCONSTANT_WM_USER + 0x39
Global Const $EM_GETAUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 0x5c
Global Const $EM_GETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 0xc9
Global Const $EM_GETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 0x3a
Global Const $EM_GETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 0xcd
Global Const $EM_GETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 0x3b
Global Const $EM_GETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 0x69
Global Const $EM_GETIMECOMPMODE = $__RICHEDITCONSTANT_WM_USER + 0x7a
Global Const $EM_GETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 0x7f
Global Const $EM_GETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 0x6b
Global Const $EM_GETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 0x79
Global Const $EM_GETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 0x4e
Global Const $EM_GETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 0x3d
Global Const $EM_GETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 0x65
Global Const $EM_GETREDONAME = $__RICHEDITCONSTANT_WM_USER + 0x57
Global Const $EM_GETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 0xdd
Global Const $EM_GETTABLEPARMS = $__RICHEDITCONSTANT_WM_USER + 0x109
Global Const $EM_GETSELTEXT = $__RICHEDITCONSTANT_WM_USER + 0x3e
Global Const $EM_GETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 0x5e
Global Const $EM_GETTEXTLENGTHEX = $__RICHEDITCONSTANT_WM_USER + 0x5f
Global Const $EM_GETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 0x5a
Global Const $EM_GETTEXTRANGE = $__RICHEDITCONSTANT_WM_USER + 0x4b
Global Const $EM_GETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 0xcb
Global Const $EM_GETUNDONAME = $__RICHEDITCONSTANT_WM_USER + 0x56
Global Const $EM_GETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 0x50
Global Const $EM_GETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 0x67
Global Const $EM_GETZOOM = $__RICHEDITCONSTANT_WM_USER + 0xe0
Global Const $EM_HIDESELECTION = $__RICHEDITCONSTANT_WM_USER + 0x3f
Global Const $EM_INSERTTABLE = $__RICHEDITCONSTANT_WM_USER + 0xe8
Global Const $EM_PASTESPECIAL = $__RICHEDITCONSTANT_WM_USER + 0x40
Global Const $EM_RECONVERSION = $__RICHEDITCONSTANT_WM_USER + 0x7d
Global Const $EM_REDO = $__RICHEDITCONSTANT_WM_USER + 0x54
Global Const $EM_REQUESTRESIZE = $__RICHEDITCONSTANT_WM_USER + 0x41
Global Const $EM_SELECTIONTYPE = $__RICHEDITCONSTANT_WM_USER + 0x42
Global Const $EM_SETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 0xc8
Global Const $EM_SETBKGNDCOLOR = $__RICHEDITCONSTANT_WM_USER + 0x43
Global Const $EM_SETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 0x44
Global Const $EM_SETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 0xcc
Global Const $EM_SETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 0x45
Global Const $EM_SETFONTSIZE = $__RICHEDITCONSTANT_WM_USER + 0xdf
Global Const $EM_SETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 0x68
Global Const $EM_SETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 0x7e
Global Const $EM_SETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 0x6a
Global Const $EM_SETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 0x78
Global Const $EM_SETOLECALLBACK = $__RICHEDITCONSTANT_WM_USER + 0x46
Global Const $EM_SETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 0x4d
Global Const $EM_SETPALETTE = $__RICHEDITCONSTANT_WM_USER + 0x5d
Global Const $EM_SETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 0x47
Global Const $EM_SETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 0x64
Global Const $EM_SETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 0xde
Global Const $EM_SETTABLEPARMS = $__RICHEDITCONSTANT_WM_USER + 0x133
Global Const $EM_SETTARGETDEVICE = $__RICHEDITCONSTANT_WM_USER + 0x48
Global Const $EM_SETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 0x61
Global Const $EM_SETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 0x59
Global Const $EM_SETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 0xca
Global Const $EM_SETUNDOLIMIT = $__RICHEDITCONSTANT_WM_USER + 0x52
Global Const $EM_SETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 0x51
Global Const $EM_SETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 0x66
Global Const $EM_SETZOOM = $__RICHEDITCONSTANT_WM_USER + 0xe1
Global Const $EM_SHOWSCROLLBAR = $__RICHEDITCONSTANT_WM_USER + 0x60
Global Const $EM_STOPGROUPTYPING = $__RICHEDITCONSTANT_WM_USER + 0x58
Global Const $EM_STREAMIN = $__RICHEDITCONSTANT_WM_USER + 0x49
Global Const $EM_STREAMOUT = $__RICHEDITCONSTANT_WM_USER + 0x4a
Global Const $EN_ALIGNLTR = 0x710
Global Const $EN_ALIGNRTL = 0x711
Global Const $EN_CORRECTTEXT = 0x705
Global Const $EN_DRAGDROPDONE = 0x70c
Global Const $EN_DROPFILES = 0x703
Global Const $EN_IMECHANGE = 0x707
Global Const $EN_LINK = 0x70b
Global Const $EN_MSGFILTER = 0x700
Global Const $EN_OBJECTPOSITIONS = 0x70a
Global Const $EN_OLEOPFAILED = 0x709
Global Const $EN_PROTECTED = 0x704
Global Const $EN_REQUESTRESIZE = 0x701
Global Const $EN_SAVECLIPBOARD = 0x708
Global Const $EN_SELCHANGE = 0x702
Global Const $EN_STOPNOUNDO = 0x706
Global Const $ENM_NONE = 0x0
Global Const $ENM_CHANGE = 0x1
Global Const $ENM_CORRECTTEXT = 0x400000
Global Const $ENM_DRAGDROPDONE = 0x10
Global Const $ENM_DROPFILES = 0x100000
Global Const $ENM_IMECHANGE = 0x800000
Global Const $ENM_KEYEVENTS = 0x10000
Global Const $ENM_LINK = 0x4000000
Global Const $ENM_MOUSEEVENTS = 0x20000
Global Const $ENM_OBJECTPOSITIONS = 0x2000000
Global Const $ENM_PROTECTED = 0x200000
Global Const $ENM_REQUESTRESIZE = 0x40000
Global Const $ENM_SCROLL = 0x4
Global Const $ENM_SCROLLEVENTS = 0x8
Global Const $ENM_SELCHANGE = 0x80000
Global Const $ENM_UPDATE = 0x2
Global Const $BOM_DEFPARADIR = 0x1
Global Const $BOM_PLAINTEXT = 0x2
Global Const $BOM_NEUTRALOVERRIDE = 0x4
Global Const $BOM_CONTEXTREADING = 0x8
Global Const $BOM_CONTEXTALIGNMENT = 0x10
Global Const $BOM_LEGACYBIDICLASS = 0x40
Global Const $BOE_RTLDIR = 0x1
Global Const $BOE_PLAINTEXT = 0x2
Global Const $BOE_NEUTRALOVERRIDE = 0x4
Global Const $BOE_CONTEXTREADING = 0x8
Global Const $BOE_CONTEXTALIGNMENT = 0x10
Global Const $BOE_LEGACYBIDICLASS = 0x40
Global Const $ST_DEFAULT = 0x0
Global Const $ST_KEEPUNDO = 0x1
Global Const $ST_SELECTION = 0x2
Global Const $GT_DEFAULT = 0x0
Global Const $GT_SELECTION = 0x2
Global Const $GT_USECRLF = 0x1
Global Const $GTL_CLOSE = 0x4
Global Const $GTL_DEFAULT = 0x0
Global Const $GTL_NUMBYTES = 0x10
Global Const $GTL_NUMCHARS = 0x8
Global Const $GTL_PRECISE = 0x2
Global Const $GTL_USECRLF = 0x1
Global Const $CFU_UNDERLINENONE = 0x0
Global Const $CFU_UNDERLINE = 0x1
Global Const $CFU_UNDERLINEWORD = 0x2
Global Const $CFU_UNDERLINEDOUBLE = 0x3
Global Const $CFU_UNDERLINEDOTTED = 0x4
Global Const $CP_ACP = 0x0
Global Const $CP_UNICODE = 0x4b0
Global Const $CFE_SUBSCRIPT = 0x10000
Global Const $CFE_SUPERSCRIPT = 0x20000
Global Const $CFM_ALLCAPS = 0x80
Global Const $CFM_ANIMATION = 0x40000
Global Const $CFM_BACKCOLOR = 0x4000000
Global Const $CFM_BOLD = 0x1
Global Const $CFM_CHARSET = 0x8000000
Global Const $CFM_COLOR = 0x40000000
Global Const $CFM_DISABLED = 0x2000
Global Const $CFM_EMBOSS = 0x800
Global Const $CFM_FACE = 0x20000000
Global Const $CFM_HIDDEN = 0x100
Global Const $CFM_IMPRINT = 0x1000
Global Const $CFM_ITALIC = 0x2
Global Const $CFM_KERNING = 0x100000
Global Const $CFM_LCID = 0x2000000
Global Const $CFM_LINK = 0x20
Global Const $CFM_OFFSET = 0x10000000
Global Const $CFM_OUTLINE = 0x200
Global Const $CFM_PROTECTED = 0x10
Global Const $CFM_REVAUTHOR = 0x8000
Global Const $CFM_REVISED = 0x4000
Global Const $CFM_SHADOW = 0x400
Global Const $CFM_SIZE = -2147483648
Global Const $CFM_SMALLCAPS = 0x40
Global Const $CFM_SPACING = 0x200000
Global Const $CFM_STRIKEOUT = 0x8
Global Const $CFM_STYLE = 0x80000
Global Const $CFM_SUBSCRIPT = BitOR($CFE_SUBSCRIPT, $CFE_SUPERSCRIPT)
Global Const $CFM_SUPERSCRIPT = $CFM_SUBSCRIPT
Global Const $CFM_UNDERLINE = 0x4
Global Const $CFM_UNDERLINETYPE = 0x800000
Global Const $CFM_WEIGHT = 0x400000
Global Const $CFE_ALLCAPS = $CFM_ALLCAPS
Global Const $CFE_AUTOBACKCOLOR = $CFM_BACKCOLOR
Global Const $CFE_AUTOCOLOR = $CFM_COLOR
Global Const $CFE_BOLD = $CFM_BOLD
Global Const $CFE_DISABLED = $CFM_DISABLED
Global Const $CFE_EMBOSS = $CFM_EMBOSS
Global Const $CFE_HIDDEN = $CFM_HIDDEN
Global Const $CFE_IMPRINT = $CFM_IMPRINT
Global Const $CFE_ITALIC = $CFM_ITALIC
Global Const $CFE_LINK = $CFM_LINK
Global Const $CFE_OUTLINE = $CFM_OUTLINE
Global Const $CFE_PROTECTED = $CFM_PROTECTED
Global Const $CFE_REVISED = $CFM_REVISED
Global Const $CFE_SHADOW = $CFM_SHADOW
Global Const $CFE_SMALLCAPS = $CFM_SMALLCAPS
Global Const $CFE_STRIKEOUT = $CFM_STRIKEOUT
Global Const $CFE_UNDERLINE = $CFM_UNDERLINE
Global Const $FR_MATCHALEFHAMZA = -2147483648
Global Const $FR_MATCHDIAC = 0x20000000
Global Const $FR_MATCHKASHIDA = 0x40000000
Global Const $SCF_DEFAULT = 0x0
Global Const $SCF_SELECTION = 0x1
Global Const $SCF_WORD = 0x2
Global Const $SCF_ALL = 0x4
Global Const $SCF_USEUIRULES = 0x8
Global Const $SCF_ASSOCIATEFONT = 0x10
Global Const $SCF_NOKBUPDATE = 0x20
Global Const $LF_FACESIZE = 0x20
Global Const $MAX_TAB_STOPS = 0x20
Global Const $PFA_LEFT = 0x1
Global Const $PFA_RIGHT = 0x2
Global Const $PFA_CENTER = 0x3
Global Const $PFA_JUSTIFY = 0x4
Global Const $PFA_FULL_INTERWORD = 0x4
Global Const $PFE_TABLE = 0x4000
Global Const $PFM_NUMBERING = 0x20
Global Const $PFM_ALIGNMENT = 0x8
Global Const $PFM_SPACEBEFORE = 0x40
Global Const $PFM_NUMBERINGSTYLE = 0x2000
Global Const $PFM_NUMBERINGSTART = 0x8000
Global Const $PFM_BORDER = 0x800
Global Const $PFM_RIGHTINDENT = 0x2
Global Const $PFM_STARTINDENT = 0x1
Global Const $PFM_OFFSET = 0x4
Global Const $PFM_LINESPACING = 0x100
Global Const $PFM_SPACEAFTER = 0x80
Global Const $PFM_NUMBERINGTAB = 0x4000
Global Const $PFM_TABLE = 0x40000000
Global Const $PFM_TABSTOPS = 0x10
Global Const $PFN_BULLET = 0x1
Global Const $PFM_RTLPARA = 0x10000
Global Const $PFM_KEEP = 0x20000
Global Const $PFM_KEEPNEXT = 0x40000
Global Const $PFM_PAGEBREAKBEFORE = 0x80000
Global Const $PFM_NOLINENUMBER = 0x100000
Global Const $PFM_NOWIDOWCONTROL = 0x200000
Global Const $PFM_DONOTHYPHEN = 0x400000
Global Const $PFM_SIDEBYSIDE = 0x800000
Global Const $PFE_RTLPARA = 0x1
Global Const $PFE_KEEP = 0x2
Global Const $PFE_KEEPNEXT = 0x4
Global Const $PFE_PAGEBREAKBEFORE = 0x8
Global Const $PFE_NOLINENUMBER = 0x10
Global Const $PFE_NOWIDOWCONTROL = 0x20
Global Const $PFE_DONOTHYPHEN = 0x40
Global Const $PFE_SIDEBYSIDE = 0x80
Global Const $PFM_SHADING = 0x1000
Global Const $WB_CLASSIFY = 0x3
Global Const $WB_ISDELIMITER = 0x2
Global Const $WB_LEFT = 0x0
Global Const $WB_LEFTBREAK = 0x6
Global Const $WB_MOVEWORDLEFT = 0x4
Global Const $WB_MOVEWORDNEXT = 0x5
Global Const $WB_MOVEWORDPREV = 0x4
Global Const $WB_MOVEWORDRIGHT = 0x5
Global Const $WB_NEXTBREAK = 0x7
Global Const $WB_PREVBREAK = 0x6
Global Const $WB_RIGHT = 0x1
Global Const $WB_RIGHTBREAK = 0x7
Global Const $WBF_ISWHITE = 0x10
Global Const $WBF_BREAKLINE = 0x20
Global Const $WBF_BREAKAFTER = 0x40
Global Const $SF_TEXT = 0x1
Global Const $SF_RTF = 0x2
Global Const $SF_RTFNOOBJS = 0x3
Global Const $SF_TEXTIZED = 0x4
Global Const $SF_UNICODE = 0x10
Global Const $SF_USECODEPAGE = 0x20
Global Const $SFF_PLAINRTF = 0x4000
Global Const $SFF_SELECTION = 0x8000
Global Const $TBCD_CHANNEL = 0x3
Global Const $TBCD_THUMB = 0x2
Global Const $TBCD_TICS = 0x1
Global Const $__SLIDERCONSTANT_WM_USER = 0x400
Global Const $TBM_CLEARSEL = $__SLIDERCONSTANT_WM_USER + 0x13
Global Const $TBM_CLEARTICS = $__SLIDERCONSTANT_WM_USER + 0x9
Global Const $TBM_GETBUDDY = $__SLIDERCONSTANT_WM_USER + 0x21
Global Const $TBM_GETCHANNELRECT = $__SLIDERCONSTANT_WM_USER + 0x1a
Global Const $TBM_GETLINESIZE = $__SLIDERCONSTANT_WM_USER + 0x18
Global Const $TBM_GETNUMTICS = $__SLIDERCONSTANT_WM_USER + 0x10
Global Const $TBM_GETPAGESIZE = $__SLIDERCONSTANT_WM_USER + 0x16
Global Const $TBM_GETPOS = $__SLIDERCONSTANT_WM_USER
Global Const $TBM_GETPTICS = $__SLIDERCONSTANT_WM_USER + 0xe
Global Const $TBM_GETSELEND = $__SLIDERCONSTANT_WM_USER + 0x12
Global Const $TBM_GETSELSTART = $__SLIDERCONSTANT_WM_USER + 0x11
Global Const $TBM_GETRANGEMAX = $__SLIDERCONSTANT_WM_USER + 0x2
Global Const $TBM_GETRANGEMIN = $__SLIDERCONSTANT_WM_USER + 0x1
Global Const $TBM_GETTHUMBLENGTH = $__SLIDERCONSTANT_WM_USER + 0x1c
Global Const $TBM_GETTHUMBRECT = $__SLIDERCONSTANT_WM_USER + 0x19
Global Const $TBM_GETTIC = $__SLIDERCONSTANT_WM_USER + 0x3
Global Const $TBM_GETTICPOS = $__SLIDERCONSTANT_WM_USER + 0xf
Global Const $TBM_GETTOOLTIPS = $__SLIDERCONSTANT_WM_USER + 0x1e
Global Const $TBM_GETUNICODEFORMAT = 0x2000 + 0x6
Global Const $TBM_SETBUDDY = $__SLIDERCONSTANT_WM_USER + 0x20
Global Const $TBM_SETLINESIZE = $__SLIDERCONSTANT_WM_USER + 0x17
Global Const $TBM_SETPAGESIZE = $__SLIDERCONSTANT_WM_USER + 0x15
Global Const $TBM_SETPOS = $__SLIDERCONSTANT_WM_USER + 0x5
Global Const $TBM_SETRANGE = $__SLIDERCONSTANT_WM_USER + 0x6
Global Const $TBM_SETRANGEMAX = $__SLIDERCONSTANT_WM_USER + 0x8
Global Const $TBM_SETRANGEMIN = $__SLIDERCONSTANT_WM_USER + 0x7
Global Const $TBM_SETSEL = $__SLIDERCONSTANT_WM_USER + 0xa
Global Const $TBM_SETSELEND = $__SLIDERCONSTANT_WM_USER + 0xc
Global Const $TBM_SETSELSTART = $__SLIDERCONSTANT_WM_USER + 0xb
Global Const $TBM_SETTHUMBLENGTH = $__SLIDERCONSTANT_WM_USER + 0x1b
Global Const $TBM_SETTIC = $__SLIDERCONSTANT_WM_USER + 0x4
Global Const $TBM_SETTICFREQ = $__SLIDERCONSTANT_WM_USER + 0x14
Global Const $TBM_SETTIPSIDE = $__SLIDERCONSTANT_WM_USER + 0x1f
Global Const $TBM_SETTOOLTIPS = $__SLIDERCONSTANT_WM_USER + 0x1d
Global Const $TBM_SETUNICODEFORMAT = 0x2000 + 0x5
Global Const $TBTS_BOTTOM = 0x2
Global Const $TBTS_LEFT = 0x1
Global Const $TBTS_RIGHT = 0x3
Global Const $TBTS_TOP = 0x0
Global Const $TBS_AUTOTICKS = 0x1
Global Const $TBS_BOTH = 0x8
Global Const $TBS_BOTTOM = 0x0
Global Const $TBS_DOWNISLEFT = 0x400
Global Const $TBS_ENABLESELRANGE = 0x20
Global Const $TBS_FIXEDLENGTH = 0x40
Global Const $TBS_HORZ = 0x0
Global Const $TBS_LEFT = 0x4
Global Const $TBS_NOTHUMB = 0x80
Global Const $TBS_NOTICKS = 0x10
Global Const $TBS_REVERSED = 0x200
Global Const $TBS_RIGHT = 0x0
Global Const $TBS_TOP = 0x4
Global Const $TBS_TOOLTIPS = 0x100
Global Const $TBS_VERT = 0x2
Global Const $GUI_SS_DEFAULT_SLIDER = $TBS_AUTOTICKS
Global Const $SS_LEFT = 0x0
Global Const $SS_CENTER = 0x1
Global Const $SS_RIGHT = 0x2
Global Const $SS_ICON = 0x3
Global Const $SS_BLACKRECT = 0x4
Global Const $SS_GRAYRECT = 0x5
Global Const $SS_WHITERECT = 0x6
Global Const $SS_BLACKFRAME = 0x7
Global Const $SS_GRAYFRAME = 0x8
Global Const $SS_WHITEFRAME = 0x9
Global Const $SS_SIMPLE = 0xb
Global Const $SS_LEFTNOWORDWRAP = 0xc
Global Const $SS_BITMAP = 0xe
Global Const $SS_ENHMETAFILE = 0xf
Global Const $SS_ETCHEDHORZ = 0x10
Global Const $SS_ETCHEDVERT = 0x11
Global Const $SS_ETCHEDFRAME = 0x12
Global Const $SS_REALSIZECONTROL = 0x40
Global Const $SS_NOPREFIX = 0x80
Global Const $SS_NOTIFY = 0x100
Global Const $SS_CENTERIMAGE = 0x200
Global Const $SS_RIGHTJUST = 0x400
Global Const $SS_SUNKEN = 0x1000
Global Const $GUI_SS_DEFAULT_LABEL = 0x0
Global Const $GUI_SS_DEFAULT_GRAPHIC = 0x0
Global Const $GUI_SS_DEFAULT_ICON = $SS_NOTIFY
Global Const $GUI_SS_DEFAULT_PIC = $SS_NOTIFY
Global Const $STM_SETICON = 0x170
Global Const $STM_GETICON = 0x171
Global Const $STM_SETIMAGE = 0x172
Global Const $STM_GETIMAGE = 0x173
Global Const $TCS_EX_FLATSEPARATORS = 0x1
Global Const $TCS_EX_REGISTERDROP = 0x2
Global Const $TCHT_NOWHERE = 0x1
Global Const $TCHT_ONITEMICON = 0x2
Global Const $TCHT_ONITEMLABEL = 0x4
Global Const $TCHT_ONITEM = 0x6
Global Const $TCIF_TEXT = 0x1
Global Const $TCIF_IMAGE = 0x2
Global Const $TCIF_RTLREADING = 0x4
Global Const $TCIF_PARAM = 0x8
Global Const $TCIF_STATE = 0x10
Global Const $TCIF_ALLDATA = 0x1b
Global Const $TCIS_BUTTONPRESSED = 0x1
Global Const $TCIS_HIGHLIGHTED = 0x2
Global Const $TC_ERR = + -1
Global Const $TCS_BOTTOM = 0x2
Global Const $TCS_BUTTONS = 0x100
Global Const $TCS_FIXEDWIDTH = 0x400
Global Const $TCS_FLATBUTTONS = 0x8
Global Const $TCS_FOCUSNEVER = 0x8000
Global Const $TCS_FOCUSONBUTTONDOWN = 0x1000
Global Const $TCS_FORCEICONLEFT = 0x10
Global Const $TCS_FORCELABELLEFT = 0x20
Global Const $TCS_HOTTRACK = 0x40
Global Const $TCS_MULTILINE = 0x200
Global Const $TCS_MULTISELECT = 0x4
Global Const $TCS_OWNERDRAWFIXED = 0x2000
Global Const $TCS_RAGGEDRIGHT = 0x800
Global Const $TCS_RIGHT = 0x2
Global Const $TCS_RIGHTJUSTIFY = 0x0
Global Const $TCS_SCROLLOPPOSITE = 0x1
Global Const $TCS_SINGLELINE = 0x0
Global Const $TCS_TABS = 0x0
Global Const $TCS_TOOLTIPS = 0x4000
Global Const $TCS_VERTICAL = 0x80
Global Const $GUI_SS_DEFAULT_TAB = 0x0
Global Const $TCM_FIRST = 0x1300
Global Const $TCCM_FIRST = 0x2000
Global Const $TCM_ADJUSTRECT = ($TCM_FIRST + 0x28)
Global Const $TCM_DELETEALLITEMS = ($TCM_FIRST + 0x9)
Global Const $TCM_DELETEITEM = ($TCM_FIRST + 0x8)
Global Const $TCM_DESELECTALL = ($TCM_FIRST + 0x32)
Global Const $TCM_GETCURFOCUS = ($TCM_FIRST + 0x2f)
Global Const $TCM_GETCURSEL = ($TCM_FIRST + 0xb)
Global Const $TCM_GETEXTENDEDSTYLE = ($TCM_FIRST + 0x35)
Global Const $TCM_GETIMAGELIST = ($TCM_FIRST + 0x2)
Global Const $TCM_GETITEMA = ($TCM_FIRST + 0x5)
Global Const $TCM_GETITEMW = ($TCM_FIRST + 0x3c)
Global Const $TCM_GETITEMCOUNT = ($TCM_FIRST + 0x4)
Global Const $TCM_GETITEMRECT = ($TCM_FIRST + 0xa)
Global Const $TCM_GETROWCOUNT = ($TCM_FIRST + 0x2c)
Global Const $TCM_GETTOOLTIPS = ($TCM_FIRST + 0x2d)
Global Const $TCCM_GETUNICODEFORMAT = ($TCCM_FIRST + 0x6)
Global Const $TCM_GETUNICODEFORMAT = $TCCM_GETUNICODEFORMAT
Global Const $TCM_HIGHLIGHTITEM = ($TCM_FIRST + 0x33)
Global Const $TCM_HITTEST = ($TCM_FIRST + 0xd)
Global Const $TCM_INSERTITEMA = ($TCM_FIRST + 0x7)
Global Const $TCM_INSERTITEMW = ($TCM_FIRST + 0x3e)
Global Const $TCM_REMOVEIMAGE = ($TCM_FIRST + 0x2a)
Global Const $TCM_SETITEMA = ($TCM_FIRST + 0x6)
Global Const $TCM_SETITEMW = ($TCM_FIRST + 0x3d)
Global Const $TCM_SETITEMEXTRA = ($TCM_FIRST + 0xe)
Global Const $TCM_SETITEMSIZE = $TCM_FIRST + 0x29
Global Const $TCM_SETCURFOCUS = ($TCM_FIRST + 0x30)
Global Const $TCM_SETCURSEL = ($TCM_FIRST + 0xc)
Global Const $TCM_SETEXTENDEDSTYLE = ($TCM_FIRST + 0x34)
Global Const $TCM_SETIMAGELIST = $TCM_FIRST + 0x3
Global Const $TCM_SETMINTABWIDTH = ($TCM_FIRST + 0x31)
Global Const $TCM_SETPADDING = ($TCM_FIRST + 0x2b)
Global Const $TCM_SETTOOLTIPS = ($TCM_FIRST + 0x2e)
Global Const $TCCM_SETUNICODEFORMAT = ($TCCM_FIRST + 0x5)
Global Const $TCM_SETUNICODEFORMAT = $TCCM_SETUNICODEFORMAT
Global Const $TCN_FIRST = + -550
Global Const $TCN_FOCUSCHANGE = ($TCN_FIRST + -4)
Global Const $TCN_GETOBJECT = ($TCN_FIRST + -3)
Global Const $TCN_KEYDOWN = ($TCN_FIRST + 0x0)
Global Const $TCN_SELCHANGE = ($TCN_FIRST + -1)
Global Const $TCN_SELCHANGING = ($TCN_FIRST + -2)
Global Const $TVS_HASBUTTONS = 0x1
Global Const $TVS_HASLINES = 0x2
Global Const $TVS_LINESATROOT = 0x4
Global Const $TVS_EDITLABELS = 0x8
Global Const $TVS_DISABLEDRAGDROP = 0x10
Global Const $TVS_SHOWSELALWAYS = 0x20
Global Const $TVS_RTLREADING = 0x40
Global Const $TVS_NOTOOLTIPS = 0x80
Global Const $TVS_CHECKBOXES = 0x100
Global Const $TVS_TRACKSELECT = 0x200
Global Const $TVS_SINGLEEXPAND = 0x400
Global Const $TVS_INFOTIP = 0x800
Global Const $TVS_FULLROWSELECT = 0x1000
Global Const $TVS_NOSCROLL = 0x2000
Global Const $TVS_NONEVENHEIGHT = 0x4000
Global Const $TVS_NOHSCROLL = 0x8000
Global Const $TVS_DEFAULT = 0x37
Global Const $GUI_SS_DEFAULT_TREEVIEW = BitOR($TVS_HASBUTTONS, $TVS_HASLINES, $TVS_LINESATROOT, $TVS_DISABLEDRAGDROP, $TVS_SHOWSELALWAYS)
Global Const $TVE_COLLAPSE = 0x1
Global Const $TVE_EXPAND = 0x2
Global Const $TVE_TOGGLE = 0x3
Global Const $TVE_EXPANDPARTIAL = 0x4000
Global Const $TVE_COLLAPSERESET = 0x8000
Global Const $TVGN_ROOT = 0x0
Global Const $TVGN_NEXT = 0x1
Global Const $TVGN_PREVIOUS = 0x2
Global Const $TVGN_PARENT = 0x3
Global Const $TVGN_CHILD = 0x4
Global Const $TVGN_FIRSTVISIBLE = 0x5
Global Const $TVGN_NEXTVISIBLE = 0x6
Global Const $TVGN_PREVIOUSVISIBLE = 0x7
Global Const $TVGN_DROPHILITE = 0x8
Global Const $TVGN_CARET = 0x9
Global Const $TVGN_LASTVISIBLE = 0xa
Global Const $TVHT_NOWHERE = 0x1
Global Const $TVHT_ONITEMICON = 0x2
Global Const $TVHT_ONITEMLABEL = 0x4
Global Const $TVHT_ONITEMINDENT = 0x8
Global Const $TVHT_ONITEMBUTTON = 0x10
Global Const $TVHT_ONITEMRIGHT = 0x20
Global Const $TVHT_ONITEMSTATEICON = 0x40
Global Const $TVHT_ONITEM = 0x46
Global Const $TVHT_ABOVE = 0x100
Global Const $TVHT_BELOW = 0x200
Global Const $TVHT_TORIGHT = 0x400
Global Const $TVHT_TOLEFT = 0x800
Global Const $TVI_ROOT = -65536
Global Const $TVI_FIRST = -65535
Global Const $TVI_LAST = -65534
Global Const $TVI_SORT = -65533
Global Const $TVIF_TEXT = 0x1
Global Const $TVIF_IMAGE = 0x2
Global Const $TVIF_PARAM = 0x4
Global Const $TVIF_STATE = 0x8
Global Const $TVIF_HANDLE = 0x10
Global Const $TVIF_SELECTEDIMAGE = 0x20
Global Const $TVIF_CHILDREN = 0x40
Global Const $TVIF_INTEGRAL = 0x80
Global Const $TVIF_EXPANDEDIMAGE = 0x100
Global Const $TVIF_STATEEX = 0x200
Global Const $TVIF_DI_SETITEM = 0x1000
Global Const $TVSIL_NORMAL = 0x0
Global Const $TVSIL_STATE = 0x2
Global Const $TVC_BYKEYBOARD = 0x2
Global Const $TVC_BYMOUSE = 0x1
Global Const $TVC_UNKNOWN = 0x0
Global Const $TVIS_FOCUSED = 0x1
Global Const $TVIS_SELECTED = 0x2
Global Const $TVIS_CUT = 0x4
Global Const $TVIS_DROPHILITED = 0x8
Global Const $TVIS_BOLD = 0x10
Global Const $TVIS_EXPANDED = 0x20
Global Const $TVIS_EXPANDEDONCE = 0x40
Global Const $TVIS_EXPANDPARTIAL = 0x80
Global Const $TVIS_OVERLAYMASK = 0xf00
Global Const $TVIS_STATEIMAGEMASK = 0xf000
Global Const $TVIS_USERMASK = 0xf000
Global Const $TVIS_UNCHECKED = 0x1000
Global Const $TVIS_CHECKED = 0x2000
Global Const $TVNA_ADD = 0x1
Global Const $TVNA_ADDFIRST = 0x2
Global Const $TVNA_ADDCHILD = 0x3
Global Const $TVNA_ADDCHILDFIRST = 0x4
Global Const $TVNA_INSERT = 0x5
Global Const $TVTA_ADDFIRST = 0x1
Global Const $TVTA_ADD = 0x2
Global Const $TVTA_INSERT = 0x3
Global Const $TV_FIRST = 0x1100
Global Const $TVM_INSERTITEMA = $TV_FIRST + 0x0
Global Const $TVM_DELETEITEM = $TV_FIRST + 0x1
Global Const $TVM_EXPAND = $TV_FIRST + 0x2
Global Const $TVM_GETITEMRECT = $TV_FIRST + 0x4
Global Const $TVM_GETCOUNT = $TV_FIRST + 0x5
Global Const $TVM_GETINDENT = $TV_FIRST + 0x6
Global Const $TVM_SETINDENT = $TV_FIRST + 0x7
Global Const $TVM_GETIMAGELIST = $TV_FIRST + 0x8
Global Const $TVM_SETIMAGELIST = $TV_FIRST + 0x9
Global Const $TVM_GETNEXTITEM = $TV_FIRST + 0xa
Global Const $TVM_SELECTITEM = $TV_FIRST + 0xb
Global Const $TVM_GETITEMA = $TV_FIRST + 0xc
Global Const $TVM_SETITEMA = $TV_FIRST + 0xd
Global Const $TVM_EDITLABELA = $TV_FIRST + 0xe
Global Const $TVM_GETEDITCONTROL = $TV_FIRST + 0xf
Global Const $TVM_GETVISIBLECOUNT = $TV_FIRST + 0x10
Global Const $TVM_HITTEST = $TV_FIRST + 0x11
Global Const $TVM_CREATEDRAGIMAGE = $TV_FIRST + 0x12
Global Const $TVM_SORTCHILDREN = $TV_FIRST + 0x13
Global Const $TVM_ENSUREVISIBLE = $TV_FIRST + 0x14
Global Const $TVM_SORTCHILDRENCB = $TV_FIRST + 0x15
Global Const $TVM_ENDEDITLABELNOW = $TV_FIRST + 0x16
Global Const $TVM_GETISEARCHSTRINGA = $TV_FIRST + 0x17
Global Const $TVM_SETTOOLTIPS = $TV_FIRST + 0x18
Global Const $TVM_GETTOOLTIPS = $TV_FIRST + 0x19
Global Const $TVM_SETINSERTMARK = $TV_FIRST + 0x1a
Global Const $TVM_SETITEMHEIGHT = $TV_FIRST + 0x1b
Global Const $TVM_GETITEMHEIGHT = $TV_FIRST + 0x1c
Global Const $TVM_SETBKCOLOR = $TV_FIRST + 0x1d
Global Const $TVM_SETTEXTCOLOR = $TV_FIRST + 0x1e
Global Const $TVM_GETBKCOLOR = $TV_FIRST + 0x1f
Global Const $TVM_GETTEXTCOLOR = $TV_FIRST + 0x20
Global Const $TVM_SETSCROLLTIME = $TV_FIRST + 0x21
Global Const $TVM_GETSCROLLTIME = $TV_FIRST + 0x22
Global Const $TVM_SETINSERTMARKCOLOR = $TV_FIRST + 0x25
Global Const $TVM_GETINSERTMARKCOLOR = $TV_FIRST + 0x26
Global Const $TVM_GETITEMSTATE = $TV_FIRST + 0x27
Global Const $TVM_SETLINECOLOR = $TV_FIRST + 0x28
Global Const $TVM_GETLINECOLOR = $TV_FIRST + 0x29
Global Const $TVM_MAPACCIDTOHTREEITEM = $TV_FIRST + 0x2a
Global Const $TVM_MAPHTREEITEMTOACCID = $TV_FIRST + 0x2b
Global Const $TVM_INSERTITEMW = $TV_FIRST + 0x32
Global Const $TVM_GETITEMW = $TV_FIRST + 0x3e
Global Const $TVM_SETITEMW = $TV_FIRST + 0x3f
Global Const $TVM_GETISEARCHSTRINGW = $TV_FIRST + 0x40
Global Const $TVM_EDITLABELW = $TV_FIRST + 0x41
Global Const $TVM_GETUNICODEFORMAT = 0x2000 + 0x6
Global Const $TVM_SETUNICODEFORMAT = 0x2000 + 0x5
Global Const $TVN_FIRST = + -400
Global Const $TVN_SELCHANGINGA = $TVN_FIRST + -1
Global Const $TVN_SELCHANGEDA = $TVN_FIRST + -2
Global Const $TVN_GETDISPINFOA = $TVN_FIRST + -3
Global Const $TVN_SETDISPINFOA = $TVN_FIRST + -4
Global Const $TVN_ITEMEXPANDINGA = $TVN_FIRST + -5
Global Const $TVN_ITEMEXPANDEDA = $TVN_FIRST + -6
Global Const $TVN_BEGINDRAGA = $TVN_FIRST + -7
Global Const $TVN_BEGINRDRAGA = $TVN_FIRST + -8
Global Const $TVN_DELETEITEMA = $TVN_FIRST + -9
Global Const $TVN_BEGINLABELEDITA = $TVN_FIRST + -10
Global Const $TVN_ENDLABELEDITA = $TVN_FIRST + -11
Global Const $TVN_KEYDOWN = $TVN_FIRST + -12
Global Const $TVN_GETINFOTIPA = $TVN_FIRST + -13
Global Const $TVN_GETINFOTIPW = $TVN_FIRST + -14
Global Const $TVN_SINGLEEXPAND = $TVN_FIRST + -15
Global Const $TVN_ITEMCHANGINGA = $TVN_FIRST + -16
Global Const $TVN_ITEMCHANGINGW = $TVN_FIRST + -17
Global Const $TVN_ITEMCHANGEDA = $TVN_FIRST + -18
Global Const $TVN_ITEMCHANGEDW = $TVN_FIRST + -19
Global Const $TVN_SELCHANGINGW = $TVN_FIRST + -50
Global Const $TVN_SELCHANGEDW = $TVN_FIRST + -51
Global Const $TVN_GETDISPINFOW = $TVN_FIRST + -52
Global Const $TVN_SETDISPINFOW = $TVN_FIRST + -53
Global Const $TVN_ITEMEXPANDINGW = $TVN_FIRST + -54
Global Const $TVN_ITEMEXPANDEDW = $TVN_FIRST + -55
Global Const $TVN_BEGINDRAGW = $TVN_FIRST + -56
Global Const $TVN_BEGINRDRAGW = $TVN_FIRST + -57
Global Const $TVN_DELETEITEMW = $TVN_FIRST + -58
Global Const $TVN_BEGINLABELEDITW = $TVN_FIRST + -59
Global Const $TVN_ENDLABELEDITW = $TVN_FIRST + -60
Global Const $UDS_WRAP = 0x1
Global Const $UDS_SETBUDDYINT = 0x2
Global Const $UDS_ALIGNRIGHT = 0x4
Global Const $UDS_ALIGNLEFT = 0x8
Global Const $UDS_ARROWKEYS = 0x20
Global Const $UDS_HORZ = 0x40
Global Const $UDS_NOTHOUSANDS = 0x80
Global Const $GUI_SS_DEFAULT_UPDOWN = $UDS_ALIGNLEFT
Global Const $WC_ANIMATE = "SysAnimate32"
Global Const $WC_BUTTON = "Button"
Global Const $WC_COMBOBOX = "ComboBox"
Global Const $WC_COMBOBOXEX = "ComboBoxEx32"
Global Const $WC_DATETIMEPICK = "SysDateTimePick32"
Global Const $WC_EDIT = "Edit"
Global Const $WC_HEADER = "SysHeader32"
Global Const $WC_HOTKEY = "msctls_hotkey32"
Global Const $WC_IPADDRESS = "SysIPAddress32"
Global Const $WC_LINK = "SysLink"
Global Const $WC_LISTBOX = "ListBox"
Global Const $WC_LISTVIEW = "SysListView32"
Global Const $WC_MONTHCAL = "SysMonthCal32"
Global Const $WC_NATIVEFONTCTL = "NativeFontCtl"
Global Const $WC_PAGESCROLLER = "SysPager"
Global Const $WC_PROGRESS = "msctls_progress32"
Global Const $WC_REBAR = "ReBarWindow32"
Global Const $WC_SCROLLBAR = "ScrollBar"
Global Const $WC_STATIC = "Static"
Global Const $WC_STATUSBAR = "msctls_statusbar32"
Global Const $WC_TABCONTROL = "SysTabControl32"
Global Const $WC_TOOLBAR = "ToolbarWindow32"
Global Const $WC_TOOLTIPS = "tooltips_class32"
Global Const $WC_TRACKBAR = "msctls_trackbar32"
Global Const $WC_TREEVIEW = "SysTreeView32"
Global Const $WC_UPDOWN = "msctls_updown32"
Global Const $WS_OVERLAPPED = 0x0
Global Const $WS_TILED = $WS_OVERLAPPED
Global Const $WS_MAXIMIZEBOX = 0x10000
Global Const $WS_MINIMIZEBOX = 0x20000
Global Const $WS_TABSTOP = 0x10000
Global Const $WS_GROUP = 0x20000
Global Const $WS_SIZEBOX = 0x40000
Global Const $WS_THICKFRAME = $WS_SIZEBOX
Global Const $WS_SYSMENU = 0x80000
Global Const $WS_HSCROLL = 0x100000
Global Const $WS_VSCROLL = 0x200000
Global Const $WS_DLGFRAME = 0x400000
Global Const $WS_BORDER = 0x800000
Global Const $WS_CAPTION = 0xc00000
Global Const $WS_OVERLAPPEDWINDOW = BitOR($WS_CAPTION, $WS_MAXIMIZEBOX, $WS_MINIMIZEBOX, $WS_OVERLAPPED, $WS_SYSMENU, $WS_THICKFRAME)
Global Const $WS_TILEDWINDOW = $WS_OVERLAPPEDWINDOW
Global Const $WS_MAXIMIZE = 0x1000000
Global Const $WS_CLIPCHILDREN = 0x2000000
Global Const $WS_CLIPSIBLINGS = 0x4000000
Global Const $WS_DISABLED = 0x8000000
Global Const $WS_VISIBLE = 0x10000000
Global Const $WS_MINIMIZE = 0x20000000
Global Const $WS_ICONIC = $WS_MINIMIZE
Global Const $WS_CHILD = 0x40000000
Global Const $WS_CHILDWINDOW = $WS_CHILD
Global Const $WS_POPUP = -2147483648
Global Const $WS_POPUPWINDOW = -2138570752
Global Const $DS_3DLOOK = 0x4
Global Const $DS_ABSALIGN = 0x1
Global Const $DS_CENTER = 0x800
Global Const $DS_CENTERMOUSE = 0x1000
Global Const $DS_CONTEXTHELP = 0x2000
Global Const $DS_CONTROL = 0x400
Global Const $DS_FIXEDSYS = 0x8
Global Const $DS_LOCALEDIT = 0x20
Global Const $DS_MODALFRAME = 0x80
Global Const $DS_NOFAILCREATE = 0x10
Global Const $DS_NOIDLEMSG = 0x100
Global Const $DS_SETFONT = 0x40
Global Const $DS_SETFOREGROUND = 0x200
Global Const $DS_SHELLFONT = BitOR($DS_FIXEDSYS, $DS_SETFONT)
Global Const $DS_SYSMODAL = 0x2
Global Const $WS_EX_ACCEPTFILES = 0x10
Global Const $WS_EX_APPWINDOW = 0x40000
Global Const $WS_EX_COMPOSITED = 0x2000000
Global Const $WS_EX_CONTROLPARENT = 0x10000
Global Const $WS_EX_CLIENTEDGE = 0x200
Global Const $WS_EX_CONTEXTHELP = 0x400
Global Const $WS_EX_DLGMODALFRAME = 0x1
Global Const $WS_EX_LAYERED = 0x80000
Global Const $WS_EX_LAYOUTRTL = 0x400000
Global Const $WS_EX_LEFT = 0x0
Global Const $WS_EX_LEFTSCROLLBAR = 0x4000
Global Const $WS_EX_LTRREADING = 0x0
Global Const $WS_EX_MDICHILD = 0x40
Global Const $WS_EX_NOACTIVATE = 0x8000000
Global Const $WS_EX_NOINHERITLAYOUT = 0x100000
Global Const $WS_EX_NOPARENTNOTIFY = 0x4
Global Const $WS_EX_NOREDIRECTIONBITMAP = 0x200000
Global Const $WS_EX_RIGHT = 0x1000
Global Const $WS_EX_RIGHTSCROLLBAR = 0x0
Global Const $WS_EX_RTLREADING = 0x2000
Global Const $WS_EX_STATICEDGE = 0x20000
Global Const $WS_EX_TOOLWINDOW = 0x80
Global Const $WS_EX_TOPMOST = 0x8
Global Const $WS_EX_TRANSPARENT = 0x20
Global Const $WS_EX_WINDOWEDGE = 0x100
Global Const $WS_EX_OVERLAPPEDWINDOW = BitOR($WS_EX_CLIENTEDGE, $WS_EX_WINDOWEDGE)
Global Const $WS_EX_PALETTEWINDOW = BitOR($WS_EX_TOOLWINDOW, $WS_EX_TOPMOST, $WS_EX_WINDOWEDGE)
Global Const $WM_NULL = 0x0
Global Const $WM_CREATE = 0x1
Global Const $WM_DESTROY = 0x2
Global Const $WM_MOVE = 0x3
Global Const $WM_SIZEWAIT = 0x4
Global Const $WM_SIZE = 0x5
Global Const $WM_ACTIVATE = 0x6
Global Const $WM_SETFOCUS = 0x7
Global Const $WM_KILLFOCUS = 0x8
Global Const $WM_SETVISIBLE = 0x9
Global Const $WM_ENABLE = 0xa
Global Const $WM_SETREDRAW = 0xb
Global Const $WM_SETTEXT = 0xc
Global Const $WM_GETTEXT = 0xd
Global Const $WM_GETTEXTLENGTH = 0xe
Global Const $WM_PAINT = 0xf
Global Const $WM_CLOSE = 0x10
Global Const $WM_QUERYENDSESSION = 0x11
Global Const $WM_QUIT = 0x12
Global Const $WM_ERASEBKGND = 0x14
Global Const $WM_QUERYOPEN = 0x13
Global Const $WM_SYSCOLORCHANGE = 0x15
Global Const $WM_ENDSESSION = 0x16
Global Const $WM_SYSTEMERROR = 0x17
Global Const $WM_SHOWWINDOW = 0x18
Global Const $WM_CTLCOLOR = 0x19
Global Const $WM_SETTINGCHANGE = 0x1a
Global Const $WM_WININICHANGE = 0x1a
Global Const $WM_DEVMODECHANGE = 0x1b
Global Const $WM_ACTIVATEAPP = 0x1c
Global Const $WM_FONTCHANGE = 0x1d
Global Const $WM_TIMECHANGE = 0x1e
Global Const $WM_CANCELMODE = 0x1f
Global Const $WM_SETCURSOR = 0x20
Global Const $WM_MOUSEACTIVATE = 0x21
Global Const $WM_CHILDACTIVATE = 0x22
Global Const $WM_QUEUESYNC = 0x23
Global Const $WM_GETMINMAXINFO = 0x24
Global Const $WM_LOGOFF = 0x25
Global Const $WM_PAINTICON = 0x26
Global Const $WM_ICONERASEBKGND = 0x27
Global Const $WM_NEXTDLGCTL = 0x28
Global Const $WM_ALTTABACTIVE = 0x29
Global Const $WM_SPOOLERSTATUS = 0x2a
Global Const $WM_DRAWITEM = 0x2b
Global Const $WM_MEASUREITEM = 0x2c
Global Const $WM_DELETEITEM = 0x2d
Global Const $WM_VKEYTOITEM = 0x2e
Global Const $WM_CHARTOITEM = 0x2f
Global Const $WM_SETFONT = 0x30
Global Const $WM_GETFONT = 0x31
Global Const $WM_SETHOTKEY = 0x32
Global Const $WM_GETHOTKEY = 0x33
Global Const $WM_FILESYSCHANGE = 0x34
Global Const $WM_ISACTIVEICON = 0x35
Global Const $WM_QUERYPARKICON = 0x36
Global Const $WM_QUERYDRAGICON = 0x37
Global Const $WM_WINHELP = 0x38
Global Const $WM_COMPAREITEM = 0x39
Global Const $WM_FULLSCREEN = 0x3a
Global Const $WM_CLIENTSHUTDOWN = 0x3b
Global Const $WM_DDEMLEVENT = 0x3c
Global Const $WM_GETOBJECT = 0x3d
Global Const $WM_CALCSCROLL = 0x3f
Global Const $WM_TESTING = 0x40
Global Const $WM_COMPACTING = 0x41
Global Const $WM_OTHERWINDOWCREATED = 0x42
Global Const $WM_OTHERWINDOWDESTROYED = 0x43
Global Const $WM_COMMNOTIFY = 0x44
Global Const $WM_MEDIASTATUSCHANGE = 0x45
Global Const $WM_WINDOWPOSCHANGING = 0x46
Global Const $WM_WINDOWPOSCHANGED = 0x47
Global Const $WM_POWER = 0x48
Global Const $WM_COPYGLOBALDATA = 0x49
Global Const $WM_COPYDATA = 0x4a
Global Const $WM_CANCELJOURNAL = 0x4b
Global Const $WM_LOGONNOTIFY = 0x4c
Global Const $WM_KEYF1 = 0x4d
Global Const $WM_NOTIFY = 0x4e
Global Const $WM_ACCESS_WINDOW = 0x4f
Global Const $WM_INPUTLANGCHANGEREQUEST = 0x50
Global Const $WM_INPUTLANGCHANGE = 0x51
Global Const $WM_TCARD = 0x52
Global Const $WM_HELP = 0x53
Global Const $WM_USERCHANGED = 0x54
Global Const $WM_NOTIFYFORMAT = 0x55
Global Const $WM_QM_ACTIVATE = 0x60
Global Const $WM_HOOK_DO_CALLBACK = 0x61
Global Const $WM_SYSCOPYDATA = 0x62
Global Const $WM_FINALDESTROY = 0x70
Global Const $WM_MEASUREITEM_CLIENTDATA = 0x71
Global Const $WM_CONTEXTMENU = 0x7b
Global Const $WM_STYLECHANGING = 0x7c
Global Const $WM_STYLECHANGED = 0x7d
Global Const $WM_DISPLAYCHANGE = 0x7e
Global Const $WM_GETICON = 0x7f
Global Const $WM_SETICON = 0x80
Global Const $WM_NCCREATE = 0x81
Global Const $WM_NCDESTROY = 0x82
Global Const $WM_NCCALCSIZE = 0x83
Global Const $WM_NCHITTEST = 0x84
Global Const $WM_NCPAINT = 0x85
Global Const $WM_NCACTIVATE = 0x86
Global Const $WM_GETDLGCODE = 0x87
Global Const $WM_SYNCPAINT = 0x88
Global Const $WM_SYNCTASK = 0x89
Global Const $WM_KLUDGEMINRECT = 0x8b
Global Const $WM_LPKDRAWSWITCHWND = 0x8c
Global Const $WM_UAHDESTROYWINDOW = 0x90
Global Const $WM_UAHDRAWMENU = 0x91
Global Const $WM_UAHDRAWMENUITEM = 0x92
Global Const $WM_UAHINITMENU = 0x93
Global Const $WM_UAHMEASUREMENUITEM = 0x94
Global Const $WM_UAHNCPAINTMENUPOPUP = 0x95
Global Const $WM_NCMOUSEMOVE = 0xa0
Global Const $WM_NCLBUTTONDOWN = 0xa1
Global Const $WM_NCLBUTTONUP = 0xa2
Global Const $WM_NCLBUTTONDBLCLK = 0xa3
Global Const $WM_NCRBUTTONDOWN = 0xa4
Global Const $WM_NCRBUTTONUP = 0xa5
Global Const $WM_NCRBUTTONDBLCLK = 0xa6
Global Const $WM_NCMBUTTONDOWN = 0xa7
Global Const $WM_NCMBUTTONUP = 0xa8
Global Const $WM_NCMBUTTONDBLCLK = 0xa9
Global Const $WM_NCXBUTTONDOWN = 0xab
Global Const $WM_NCXBUTTONUP = 0xac
Global Const $WM_NCXBUTTONDBLCLK = 0xad
Global Const $WM_NCUAHDRAWCAPTION = 0xae
Global Const $WM_NCUAHDRAWFRAME = 0xaf
Global Const $WM_INPUT_DEVICE_CHANGE = 0xfe
Global Const $WM_INPUT = 0xff
Global Const $WM_KEYDOWN = 0x100
Global Const $WM_KEYFIRST = 0x100
Global Const $WM_KEYUP = 0x101
Global Const $WM_CHAR = 0x102
Global Const $WM_DEADCHAR = 0x103
Global Const $WM_SYSKEYDOWN = 0x104
Global Const $WM_SYSKEYUP = 0x105
Global Const $WM_SYSCHAR = 0x106
Global Const $WM_SYSDEADCHAR = 0x107
Global Const $WM_YOMICHAR = 0x108
Global Const $WM_KEYLAST = 0x109
Global Const $WM_UNICHAR = 0x109
Global Const $WM_CONVERTREQUEST = 0x10a
Global Const $WM_CONVERTRESULT = 0x10b
Global Const $WM_IM_INFO = 0x10c
Global Const $WM_IME_STARTCOMPOSITION = 0x10d
Global Const $WM_IME_ENDCOMPOSITION = 0x10e
Global Const $WM_IME_COMPOSITION = 0x10f
Global Const $WM_IME_KEYLAST = 0x10f
Global Const $WM_INITDIALOG = 0x110
Global Const $WM_COMMAND = 0x111
Global Const $WM_SYSCOMMAND = 0x112
Global Const $WM_TIMER = 0x113
Global Const $WM_HSCROLL = 0x114
Global Const $WM_VSCROLL = 0x115
Global Const $WM_INITMENU = 0x116
Global Const $WM_INITMENUPOPUP = 0x117
Global Const $WM_SYSTIMER = 0x118
Global Const $WM_GESTURE = 0x119
Global Const $WM_GESTURENOTIFY = 0x11a
Global Const $WM_GESTUREINPUT = 0x11b
Global Const $WM_GESTURENOTIFIED = 0x11c
Global Const $WM_MENUSELECT = 0x11f
Global Const $WM_MENUCHAR = 0x120
Global Const $WM_ENTERIDLE = 0x121
Global Const $WM_MENURBUTTONUP = 0x122
Global Const $WM_MENUDRAG = 0x123
Global Const $WM_MENUGETOBJECT = 0x124
Global Const $WM_UNINITMENUPOPUP = 0x125
Global Const $WM_MENUCOMMAND = 0x126
Global Const $WM_CHANGEUISTATE = 0x127
Global Const $WM_UPDATEUISTATE = 0x128
Global Const $WM_QUERYUISTATE = 0x129
Global Const $WM_LBTRACKPOINT = 0x131
Global Const $WM_CTLCOLORMSGBOX = 0x132
Global Const $WM_CTLCOLOREDIT = 0x133
Global Const $WM_CTLCOLORLISTBOX = 0x134
Global Const $WM_CTLCOLORBTN = 0x135
Global Const $WM_CTLCOLORDLG = 0x136
Global Const $WM_CTLCOLORSCROLLBAR = 0x137
Global Const $WM_CTLCOLORSTATIC = 0x138
Global Const $MN_GETHMENU = 0x1e1
Global Const $WM_PARENTNOTIFY = 0x210
Global Const $WM_ENTERMENULOOP = 0x211
Global Const $WM_EXITMENULOOP = 0x212
Global Const $WM_NEXTMENU = 0x213
Global Const $WM_SIZING = 0x214
Global Const $WM_CAPTURECHANGED = 0x215
Global Const $WM_MOVING = 0x216
Global Const $WM_POWERBROADCAST = 0x218
Global Const $WM_DEVICECHANGE = 0x219
Global Const $WM_MDICREATE = 0x220
Global Const $WM_MDIDESTROY = 0x221
Global Const $WM_MDIACTIVATE = 0x222
Global Const $WM_MDIRESTORE = 0x223
Global Const $WM_MDINEXT = 0x224
Global Const $WM_MDIMAXIMIZE = 0x225
Global Const $WM_MDITILE = 0x226
Global Const $WM_MDICASCADE = 0x227
Global Const $WM_MDIICONARRANGE = 0x228
Global Const $WM_MDIGETACTIVE = 0x229
Global Const $WM_DROPOBJECT = 0x22a
Global Const $WM_QUERYDROPOBJECT = 0x22b
Global Const $WM_BEGINDRAG = 0x22c
Global Const $WM_DRAGLOOP = 0x22d
Global Const $WM_DRAGSELECT = 0x22e
Global Const $WM_DRAGMOVE = 0x22f
Global Const $WM_MDISETMENU = 0x230
Global Const $WM_ENTERSIZEMOVE = 0x231
Global Const $WM_EXITSIZEMOVE = 0x232
Global Const $WM_DROPFILES = 0x233
Global Const $WM_MDIREFRESHMENU = 0x234
Global Const $WM_TOUCH = 0x240
Global Const $WM_IME_SETCONTEXT = 0x281
Global Const $WM_IME_NOTIFY = 0x282
Global Const $WM_IME_CONTROL = 0x283
Global Const $WM_IME_COMPOSITIONFULL = 0x284
Global Const $WM_IME_SELECT = 0x285
Global Const $WM_IME_CHAR = 0x286
Global Const $WM_IME_SYSTEM = 0x287
Global Const $WM_IME_REQUEST = 0x288
Global Const $WM_IME_KEYDOWN = 0x290
Global Const $WM_IME_KEYUP = 0x291
Global Const $WM_NCMOUSEHOVER = 0x2a0
Global Const $WM_MOUSEHOVER = 0x2a1
Global Const $WM_NCMOUSELEAVE = 0x2a2
Global Const $WM_MOUSELEAVE = 0x2a3
Global Const $WM_WTSSESSION_CHANGE = 0x2b1
Global Const $WM_TABLET_FIRST = 0x2c0
Global Const $WM_TABLET_LAST = 0x2df
Global Const $WM_CUT = 0x300
Global Const $WM_COPY = 0x301
Global Const $WM_PASTE = 0x302
Global Const $WM_CLEAR = 0x303
Global Const $WM_UNDO = 0x304
Global Const $WM_PALETTEISCHANGING = 0x310
Global Const $WM_HOTKEY = 0x312
Global Const $WM_PALETTECHANGED = 0x311
Global Const $WM_SYSMENU = 0x313
Global Const $WM_HOOKMSG = 0x314
Global Const $WM_EXITPROCESS = 0x315
Global Const $WM_WAKETHREAD = 0x316
Global Const $WM_PRINT = 0x317
Global Const $WM_PRINTCLIENT = 0x318
Global Const $WM_APPCOMMAND = 0x319
Global Const $WM_QUERYNEWPALETTE = 0x30f
Global Const $WM_THEMECHANGED = 0x31a
Global Const $WM_UAHINIT = 0x31b
Global Const $WM_DESKTOPNOTIFY = 0x31c
Global Const $WM_CLIPBOARDUPDATE = 0x31d
Global Const $WM_DWMCOMPOSITIONCHANGED = 0x31e
Global Const $WM_DWMNCRENDERINGCHANGED = 0x31f
Global Const $WM_DWMCOLORIZATIONCOLORCHANGED = 0x320
Global Const $WM_DWMWINDOWMAXIMIZEDCHANGE = 0x321
Global Const $WM_DWMEXILEFRAME = 0x322
Global Const $WM_DWMSENDICONICTHUMBNAIL = 0x323
Global Const $WM_MAGNIFICATION_STARTED = 0x324
Global Const $WM_MAGNIFICATION_ENDED = 0x325
Global Const $WM_DWMSENDICONICLIVEPREVIEWBITMAP = 0x326
Global Const $WM_DWMTHUMBNAILSIZECHANGED = 0x327
Global Const $WM_MAGNIFICATION_OUTPUT = 0x328
Global Const $WM_MEASURECONTROL = 0x330
Global Const $WM_GETACTIONTEXT = 0x331
Global Const $WM_FORWARDKEYDOWN = 0x333
Global Const $WM_FORWARDKEYUP = 0x334
Global Const $WM_GETTITLEBARINFOEX = 0x33f
Global Const $WM_NOTIFYWOW = 0x340
Global Const $WM_HANDHELDFIRST = 0x358
Global Const $WM_HANDHELDLAST = 0x35f
Global Const $WM_AFXFIRST = 0x360
Global Const $WM_AFXLAST = 0x37f
Global Const $WM_PENWINFIRST = 0x380
Global Const $WM_PENWINLAST = 0x38f
Global Const $WM_DDE_INITIATE = 0x3e0
Global Const $WM_DDE_TERMINATE = 0x3e1
Global Const $WM_DDE_ADVISE = 0x3e2
Global Const $WM_DDE_UNADVISE = 0x3e3
Global Const $WM_DDE_ACK = 0x3e4
Global Const $WM_DDE_DATA = 0x3e5
Global Const $WM_DDE_REQUEST = 0x3e6
Global Const $WM_DDE_POKE = 0x3e7
Global Const $WM_DDE_EXECUTE = 0x3e8
Global Const $WM_DBNOTIFICATION = 0x3fd
Global Const $WM_NETCONNECT = 0x3fe
Global Const $WM_HIBERNATE = 0x3ff
Global Const $WM_USER = 0x400
Global Const $WM_APP = 0x8000
Global Const $NM_FIRST = 0x0
Global Const $NM_OUTOFMEMORY = $NM_FIRST + -1
Global Const $NM_CLICK = $NM_FIRST + -2
Global Const $NM_DBLCLK = $NM_FIRST + -3
Global Const $NM_RETURN = $NM_FIRST + -4
Global Const $NM_RCLICK = $NM_FIRST + -5
Global Const $NM_RDBLCLK = $NM_FIRST + -6
Global Const $NM_SETFOCUS = $NM_FIRST + -7
Global Const $NM_KILLFOCUS = $NM_FIRST + -8
Global Const $NM_CUSTOMDRAW = $NM_FIRST + -12
Global Const $NM_HOVER = $NM_FIRST + -13
Global Const $NM_NCHITTEST = $NM_FIRST + -14
Global Const $NM_KEYDOWN = $NM_FIRST + -15
Global Const $NM_RELEASEDCAPTURE = $NM_FIRST + -16
Global Const $NM_SETCURSOR = $NM_FIRST + -17
Global Const $NM_CHAR = $NM_FIRST + -18
Global Const $NM_TOOLTIPSCREATED = $NM_FIRST + -19
Global Const $NM_LDOWN = $NM_FIRST + -20
Global Const $NM_RDOWN = $NM_FIRST + -21
Global Const $NM_THEMECHANGED = $NM_FIRST + -22
Global Const $WM_MOUSEFIRST = 0x200
Global Const $WM_MOUSEMOVE = 0x200
Global Const $WM_LBUTTONDOWN = 0x201
Global Const $WM_LBUTTONUP = 0x202
Global Const $WM_LBUTTONDBLCLK = 0x203
Global Const $WM_RBUTTONDOWN = 0x204
Global Const $WM_RBUTTONUP = 0x205
Global Const $WM_RBUTTONDBLCLK = 0x206
Global Const $WM_MBUTTONDOWN = 0x207
Global Const $WM_MBUTTONUP = 0x208
Global Const $WM_MBUTTONDBLCLK = 0x209
Global Const $WM_MOUSEWHEEL = 0x20a
Global Const $WM_XBUTTONDOWN = 0x20b
Global Const $WM_XBUTTONUP = 0x20c
Global Const $WM_XBUTTONDBLCLK = 0x20d
Global Const $WM_MOUSEHWHEEL = 0x20e
Global Const $PS_SOLID = 0x0
Global Const $PS_DASH = 0x1
Global Const $PS_DOT = 0x2
Global Const $PS_DASHDOT = 0x3
Global Const $PS_DASHDOTDOT = 0x4
Global Const $PS_NULL = 0x5
Global Const $PS_INSIDEFRAME = 0x6
Global Const $PS_USERSTYLE = 0x7
Global Const $PS_ALTERNATE = 0x8
Global Const $PS_ENDCAP_ROUND = 0x0
Global Const $PS_ENDCAP_SQUARE = 0x100
Global Const $PS_ENDCAP_FLAT = 0x200
Global Const $PS_JOIN_BEVEL = 0x1000
Global Const $PS_JOIN_MITER = 0x2000
Global Const $PS_JOIN_ROUND = 0x0
Global Const $PS_GEOMETRIC = 0x10000
Global Const $PS_COSMETIC = 0x0
Global Const $LWA_ALPHA = 0x2
Global Const $LWA_COLORKEY = 0x1
Global Const $RGN_AND = 0x1
Global Const $RGN_OR = 0x2
Global Const $RGN_XOR = 0x3
Global Const $RGN_DIFF = 0x4
Global Const $RGN_COPY = 0x5
Global Const $ERRORREGION = 0x0
Global Const $NULLREGION = 0x1
Global Const $SIMPLEREGION = 0x2
Global Const $COMPLEXREGION = 0x3
Global Const $TRANSPARENT = 0x1
Global Const $OPAQUE = 0x2
Global Const $CCM_FIRST = 0x2000
Global Const $CCM_GETUNICODEFORMAT = ($CCM_FIRST + 0x6)
Global Const $CCM_SETUNICODEFORMAT = ($CCM_FIRST + 0x5)
Global Const $CCM_SETBKCOLOR = $CCM_FIRST + 0x1
Global Const $CCM_SETCOLORSCHEME = $CCM_FIRST + 0x2
Global Const $CCM_GETCOLORSCHEME = $CCM_FIRST + 0x3
Global Const $CCM_GETDROPTARGET = $CCM_FIRST + 0x4
Global Const $CCM_SETWINDOWTHEME = $CCM_FIRST + 0xb
Global Const $GA_PARENT = 0x1
Global Const $GA_ROOT = 0x2
Global Const $GA_ROOTOWNER = 0x3
Global Const $SM_CXSCREEN = 0x0
Global Const $SM_CYSCREEN = 0x1
Global Const $SM_CXVSCROLL = 0x2
Global Const $SM_CYHSCROLL = 0x3
Global Const $SM_CYCAPTION = 0x4
Global Const $SM_CXBORDER = 0x5
Global Const $SM_CYBORDER = 0x6
Global Const $SM_CXFIXEDFRAME = 0x7
Global Const $SM_CXDLGFRAME = $SM_CXFIXEDFRAME
Global Const $SM_CYFIXEDFRAME = 0x8
Global Const $SM_CYDLGFRAME = $SM_CYFIXEDFRAME
Global Const $SM_CYVTHUMB = 0x9
Global Const $SM_CXHTHUMB = 0xa
Global Const $SM_CXICON = 0xb
Global Const $SM_CYICON = 0xc
Global Const $SM_CXCURSOR = 0xd
Global Const $SM_CYCURSOR = 0xe
Global Const $SM_CYMENU = 0xf
Global Const $SM_CXFULLSCREEN = 0x10
Global Const $SM_CYFULLSCREEN = 0x11
Global Const $SM_CYKANJIWINDOW = 0x12
Global Const $SM_MOUSEPRESENT = 0x13
Global Const $SM_CYVSCROLL = 0x14
Global Const $SM_CXHSCROLL = 0x15
Global Const $SM_DEBUG = 0x16
Global Const $SM_SWAPBUTTON = 0x17
Global Const $SM_RESERVED1 = 0x18
Global Const $SM_RESERVED2 = 0x19
Global Const $SM_RESERVED3 = 0x1a
Global Const $SM_RESERVED4 = 0x1b
Global Const $SM_CXMIN = 0x1c
Global Const $SM_CYMIN = 0x1d
Global Const $SM_CXSIZE = 0x1e
Global Const $SM_CYSIZE = 0x1f
Global Const $SM_CXSIZEFRAME = 0x20
Global Const $SM_CXFRAME = $SM_CXSIZEFRAME
Global Const $SM_CYSIZEFRAME = 0x21
Global Const $SM_CYFRAME = $SM_CYSIZEFRAME
Global Const $SM_CXMINTRACK = 0x22
Global Const $SM_CYMINTRACK = 0x23
Global Const $SM_CXDOUBLECLK = 0x24
Global Const $SM_CYDOUBLECLK = 0x25
Global Const $SM_CXICONSPACING = 0x26
Global Const $SM_CYICONSPACING = 0x27
Global Const $SM_MENUDROPALIGNMENT = 0x28
Global Const $SM_PENWINDOWS = 0x29
Global Const $SM_DBCSENABLED = 0x2a
Global Const $SM_CMOUSEBUTTONS = 0x2b
Global Const $SM_SECURE = 0x2c
Global Const $SM_CXEDGE = 0x2d
Global Const $SM_CYEDGE = 0x2e
Global Const $SM_CXMINSPACING = 0x2f
Global Const $SM_CYMINSPACING = 0x30
Global Const $SM_CXSMICON = 0x31
Global Const $SM_CYSMICON = 0x32
Global Const $SM_CYSMCAPTION = 0x33
Global Const $SM_CXSMSIZE = 0x34
Global Const $SM_CYSMSIZE = 0x35
Global Const $SM_CXMENUSIZE = 0x36
Global Const $SM_CYMENUSIZE = 0x37
Global Const $SM_ARRANGE = 0x38
Global Const $SM_CXMINIMIZED = 0x39
Global Const $SM_CYMINIMIZED = 0x3a
Global Const $SM_CXMAXTRACK = 0x3b
Global Const $SM_CYMAXTRACK = 0x3c
Global Const $SM_CXMAXIMIZED = 0x3d
Global Const $SM_CYMAXIMIZED = 0x3e
Global Const $SM_NETWORK = 0x3f
Global Const $SM_CLEANBOOT = 0x43
Global Const $SM_CXDRAG = 0x44
Global Const $SM_CYDRAG = 0x45
Global Const $SM_SHOWSOUNDS = 0x46
Global Const $SM_CXMENUCHECK = 0x47
Global Const $SM_CYMENUCHECK = 0x48
Global Const $SM_SLOWMACHINE = 0x49
Global Const $SM_MIDEASTENABLED = 0x4a
Global Const $SM_MOUSEWHEELPRESENT = 0x4b
Global Const $SM_XVIRTUALSCREEN = 0x4c
Global Const $SM_YVIRTUALSCREEN = 0x4d
Global Const $SM_CXVIRTUALSCREEN = 0x4e
Global Const $SM_CYVIRTUALSCREEN = 0x4f
Global Const $SM_CMONITORS = 0x50
Global Const $SM_SAMEDISPLAYFORMAT = 0x51
Global Const $SM_IMMENABLED = 0x52
Global Const $SM_CXFOCUSBORDER = 0x53
Global Const $SM_CYFOCUSBORDER = 0x54
Global Const $SM_TABLETPC = 0x56
Global Const $SM_MEDIACENTER = 0x57
Global Const $SM_STARTER = 0x58
Global Const $SM_SERVERR2 = 0x59
Global Const $SM_CMETRICS = 0x5a
Global Const $SM_REMOTESESSION = 0x1000
Global Const $SM_SHUTTINGDOWN = 0x2000
Global Const $SM_REMOTECONTROL = 0x2001
Global Const $SM_CARETBLINKINGENABLED = 0x2002
Global Const $BLACKNESS = 0x42
Global Const $CAPTUREBLT = 0x40000000
Global Const $DSTINVERT = 0x550009
Global Const $MERGECOPY = 0xc000ca
Global Const $MERGEPAINT = 0xbb0226
Global Const $NOMIRRORBITMAP = -2147483648
Global Const $NOTSRCCOPY = 0x330008
Global Const $NOTSRCERASE = 0x1100a6
Global Const $PATCOPY = 0xf00021
Global Const $PATINVERT = 0x5a0049
Global Const $PATPAINT = 0xfb0a09
Global Const $SRCAND = 0x8800c6
Global Const $SRCCOPY = 0xcc0020
Global Const $SRCERASE = 0x440328
Global Const $SRCINVERT = 0x660046
Global Const $SRCPAINT = 0xee0086
Global Const $WHITENESS = 0xff0062
Global Const $DT_BOTTOM = 0x8
Global Const $DT_CALCRECT = 0x400
Global Const $DT_CENTER = 0x1
Global Const $DT_EDITCONTROL = 0x2000
Global Const $DT_END_ELLIPSIS = 0x8000
Global Const $DT_EXPANDTABS = 0x40
Global Const $DT_EXTERNALLEADING = 0x200
Global Const $DT_HIDEPREFIX = 0x100000
Global Const $DT_INTERNAL = 0x1000
Global Const $DT_LEFT = 0x0
Global Const $DT_MODIFYSTRING = 0x10000
Global Const $DT_NOCLIP = 0x100
Global Const $DT_NOFULLWIDTHCHARBREAK = 0x80000
Global Const $DT_NOPREFIX = 0x800
Global Const $DT_PATH_ELLIPSIS = 0x4000
Global Const $DT_PREFIXONLY = 0x200000
Global Const $DT_RIGHT = 0x2
Global Const $DT_RTLREADING = 0x20000
Global Const $DT_SINGLELINE = 0x20
Global Const $DT_TABSTOP = 0x80
Global Const $DT_TOP = 0x0
Global Const $DT_VCENTER = 0x4
Global Const $DT_WORDBREAK = 0x10
Global Const $DT_WORD_ELLIPSIS = 0x40000
Global Const $RDW_ERASE = 0x4
Global Const $RDW_FRAME = 0x400
Global Const $RDW_INTERNALPAINT = 0x2
Global Const $RDW_INVALIDATE = 0x1
Global Const $RDW_NOERASE = 0x20
Global Const $RDW_NOFRAME = 0x800
Global Const $RDW_NOINTERNALPAINT = 0x10
Global Const $RDW_VALIDATE = 0x8
Global Const $RDW_ERASENOW = 0x200
Global Const $RDW_UPDATENOW = 0x100
Global Const $RDW_ALLCHILDREN = 0x80
Global Const $RDW_NOCHILDREN = 0x40
Global Const $WM_RENDERFORMAT = 0x305
Global Const $WM_RENDERALLFORMATS = 0x306
Global Const $WM_DESTROYCLIPBOARD = 0x307
Global Const $WM_DRAWCLIPBOARD = 0x308
Global Const $WM_PAINTCLIPBOARD = 0x309
Global Const $WM_VSCROLLCLIPBOARD = 0x30a
Global Const $WM_SIZECLIPBOARD = 0x30b
Global Const $WM_ASKCBFORMATNAME = 0x30c
Global Const $WM_CHANGECBCHAIN = 0x30d
Global Const $WM_HSCROLLCLIPBOARD = 0x30e
Global Const $HTERROR = + -2
Global Const $HTTRANSPARENT = + -1
Global Const $HTNOWHERE = 0x0
Global Const $HTCLIENT = 0x1
Global Const $HTCAPTION = 0x2
Global Const $HTSYSMENU = 0x3
Global Const $HTGROWBOX = 0x4
Global Const $HTSIZE = $HTGROWBOX
Global Const $HTMENU = 0x5
Global Const $HTHSCROLL = 0x6
Global Const $HTVSCROLL = 0x7
Global Const $HTMINBUTTON = 0x8
Global Const $HTMAXBUTTON = 0x9
Global Const $HTLEFT = 0xa
Global Const $HTRIGHT = 0xb
Global Const $HTTOP = 0xc
Global Const $HTTOPLEFT = 0xd
Global Const $HTTOPRIGHT = 0xe
Global Const $HTBOTTOM = 0xf
Global Const $HTBOTTOMLEFT = 0x10
Global Const $HTBOTTOMRIGHT = 0x11
Global Const $HTBORDER = 0x12
Global Const $HTREDUCE = $HTMINBUTTON
Global Const $HTZOOM = $HTMAXBUTTON
Global Const $HTSIZEFIRST = $HTLEFT
Global Const $HTSIZELAST = $HTBOTTOMRIGHT
Global Const $HTOBJECT = 0x13
Global Const $HTCLOSE = 0x14
Global Const $HTHELP = 0x15
Global Const $COLOR_SCROLLBAR = 0x0
Global Const $COLOR_BACKGROUND = 0x1
Global Const $COLOR_ACTIVECAPTION = 0x2
Global Const $COLOR_INACTIVECAPTION = 0x3
Global Const $COLOR_MENU = 0x4
Global Const $COLOR_WINDOW = 0x5
Global Const $COLOR_WINDOWFRAME = 0x6
Global Const $COLOR_MENUTEXT = 0x7
Global Const $COLOR_WINDOWTEXT = 0x8
Global Const $COLOR_CAPTIONTEXT = 0x9
Global Const $COLOR_ACTIVEBORDER = 0xa
Global Const $COLOR_INACTIVEBORDER = 0xb
Global Const $COLOR_APPWORKSPACE = 0xc
Global Const $COLOR_HIGHLIGHT = 0xd
Global Const $COLOR_HIGHLIGHTTEXT = 0xe
Global Const $COLOR_BTNFACE = 0xf
Global Const $COLOR_BTNSHADOW = 0x10
Global Const $COLOR_GRAYTEXT = 0x11
Global Const $COLOR_BTNTEXT = 0x12
Global Const $COLOR_INACTIVECAPTIONTEXT = 0x13
Global Const $COLOR_BTNHIGHLIGHT = 0x14
Global Const $COLOR_3DDKSHADOW = 0x15
Global Const $COLOR_3DLIGHT = 0x16
Global Const $COLOR_INFOTEXT = 0x17
Global Const $COLOR_INFOBK = 0x18
Global Const $COLOR_HOTLIGHT = 0x1a
Global Const $COLOR_GRADIENTACTIVECAPTION = 0x1b
Global Const $COLOR_GRADIENTINACTIVECAPTION = 0x1c
Global Const $COLOR_MENUHILIGHT = 0x1d
Global Const $COLOR_MENUBAR = 0x1e
Global Const $COLOR_DESKTOP = 0x1
Global Const $COLOR_3DFACE = 0xf
Global Const $COLOR_3DSHADOW = 0x10
Global Const $COLOR_3DHIGHLIGHT = 0x14
Global Const $COLOR_3DHILIGHT = 0x14
Global Const $COLOR_BTNHILIGHT = 0x14
Global Const $HINST_COMMCTRL = + -1
Global Const $IDB_STD_SMALL_COLOR = 0x0
Global Const $IDB_STD_LARGE_COLOR = 0x1
Global Const $IDB_VIEW_SMALL_COLOR = 0x4
Global Const $IDB_VIEW_LARGE_COLOR = 0x5
Global Const $IDB_HIST_SMALL_COLOR = 0x8
Global Const $IDB_HIST_LARGE_COLOR = 0x9
Global Const $STARTF_FORCEOFFFEEDBACK = 0x80
Global Const $STARTF_FORCEONFEEDBACK = 0x40
Global Const $STARTF_PREVENTPINNING = 0x2000
Global Const $STARTF_RUNFULLSCREEN = 0x20
Global Const $STARTF_TITLEISAPPID = 0x1000
Global Const $STARTF_TITLEISLINKNAME = 0x800
Global Const $STARTF_USECOUNTCHARS = 0x8
Global Const $STARTF_USEFILLATTRIBUTE = 0x10
Global Const $STARTF_USEHOTKEY = 0x200
Global Const $STARTF_USEPOSITION = 0x4
Global Const $STARTF_USESHOWWINDOW = 0x1
Global Const $STARTF_USESIZE = 0x2
Global Const $STARTF_USESTDHANDLES = 0x100
Global Const $CDDS_PREPAINT = 0x1
Global Const $CDDS_POSTPAINT = 0x2
Global Const $CDDS_PREERASE = 0x3
Global Const $CDDS_POSTERASE = 0x4
Global Const $CDDS_ITEM = 0x10000
Global Const $CDDS_ITEMPREPAINT = 0x10001
Global Const $CDDS_ITEMPOSTPAINT = 0x10002
Global Const $CDDS_ITEMPREERASE = 0x10003
Global Const $CDDS_ITEMPOSTERASE = 0x10004
Global Const $CDDS_SUBITEM = 0x20000
Global Const $CDIS_SELECTED = 0x1
Global Const $CDIS_GRAYED = 0x2
Global Const $CDIS_DISABLED = 0x4
Global Const $CDIS_CHECKED = 0x8
Global Const $CDIS_FOCUS = 0x10
Global Const $CDIS_DEFAULT = 0x20
Global Const $CDIS_HOT = 0x40
Global Const $CDIS_MARKED = 0x80
Global Const $CDIS_INDETERMINATE = 0x100
Global Const $CDIS_SHOWKEYBOARDCUES = 0x200
Global Const $CDIS_NEARHOT = 0x400
Global Const $CDIS_OTHERSIDEHOT = 0x800
Global Const $CDIS_DROPHILITED = 0x1000
Global Const $CDRF_DODEFAULT = 0x0
Global Const $CDRF_NEWFONT = 0x2
Global Const $CDRF_SKIPDEFAULT = 0x4
Global Const $CDRF_NOTIFYPOSTPAINT = 0x10
Global Const $CDRF_NOTIFYITEMDRAW = 0x20
Global Const $CDRF_NOTIFYSUBITEMDRAW = 0x20
Global Const $CDRF_NOTIFYPOSTERASE = 0x40
Global Const $CDRF_DOERASE = 0x8
Global Const $CDRF_SKIPPOSTPAINT = 0x100
Global Const $GUI_SS_DEFAULT_GUI = BitOR($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_SYSMENU)
Global Const $GMEM_FIXED = 0x0
Global Const $GMEM_MOVEABLE = 0x2
Global Const $GMEM_NOCOMPACT = 0x10
Global Const $GMEM_NODISCARD = 0x20
Global Const $GMEM_ZEROINIT = 0x40
Global Const $GMEM_MODIFY = 0x80
Global Const $GMEM_DISCARDABLE = 0x100
Global Const $GMEM_NOT_BANKED = 0x1000
Global Const $GMEM_SHARE = 0x2000
Global Const $GMEM_DDESHARE = 0x2000
Global Const $GMEM_NOTIFY = 0x4000
Global Const $GMEM_LOWER = 0x1000
Global Const $GMEM_VALID_FLAGS = 0x7f72
Global Const $GMEM_INVALID_HANDLE = 0x8000
Global Const $GPTR = BitOR($GMEM_FIXED, $GMEM_ZEROINIT)
Global Const $GHND = BitOR($GMEM_MOVEABLE, $GMEM_ZEROINIT)
Global Const $MEM_COMMIT = 0x1000
Global Const $MEM_RESERVE = 0x2000
Global Const $MEM_TOP_DOWN = 0x100000
Global Const $MEM_SHARED = 0x8000000
Global Const $PAGE_NOACCESS = 0x1
Global Const $PAGE_READONLY = 0x2
Global Const $PAGE_READWRITE = 0x4
Global Const $PAGE_EXECUTE = 0x10
Global Const $PAGE_EXECUTE_READ = 0x20
Global Const $PAGE_EXECUTE_READWRITE = 0x40
Global Const $PAGE_EXECUTE_WRITECOPY = 0x80
Global Const $PAGE_GUARD = 0x100
Global Const $PAGE_NOCACHE = 0x200
Global Const $PAGE_WRITECOMBINE = 0x400
Global Const $PAGE_WRITECOPY = 0x8
Global Const $MEM_DECOMMIT = 0x4000
Global Const $MEM_RELEASE = 0x8000
Global Enum $MEM_LOAD, $MEM_TOTALPHYSRAM, $MEM_AVAILPHYSRAM, $MEM_TOTALPAGEFILE, $MEM_AVAILPAGEFILE, $MEM_TOTALVIRTUAL, $MEM_AVAILVIRTUAL
Global Const $MF_UNHILITE = 0x0
Global Const $MF_ENABLED = 0x0
Global Const $MF_UNCHECKED = 0x0
Global Const $MF_STRING = 0x0
Global Const $MF_GRAYED = 0x1
Global Const $MF_DISABLED = 0x2
Global Const $MF_BITMAP = 0x4
Global Const $MF_CHECKED = 0x8
Global Const $MF_POPUP = 0x10
Global Const $MF_MENUBARBREAK = 0x20
Global Const $MF_MENUBREAK = 0x40
Global Const $MF_HILITE = 0x80
Global Const $MF_OWNERDRAW = 0x100
Global Const $MF_USECHECKBITMAPS = 0x200
Global Const $MF_BYPOSITION = 0x400
Global Const $MF_SEPARATOR = 0x800
Global Const $MF_DEFAULT = 0x1000
Global Const $MF_SYSMENU = 0x2000
Global Const $MF_HELP = 0x4000
Global Const $MF_RIGHTJUSTIFY = 0x4000
Global Const $MF_MOUSESELECT = 0x8000
Global Const $MFS_GRAYED = 0x3
Global Const $MFS_DISABLED = $MFS_GRAYED
Global Const $MFS_CHECKED = $MF_CHECKED
Global Const $MFS_HILITE = $MF_HILITE
Global Const $MFS_ENABLED = $MF_ENABLED
Global Const $MFS_UNCHECKED = $MF_UNCHECKED
Global Const $MFS_UNHILITE = $MF_UNHILITE
Global Const $MFS_DEFAULT = $MF_DEFAULT
Global Const $MFT_STRING = $MF_STRING
Global Const $MFT_BITMAP = $MF_BITMAP
Global Const $MFT_MENUBARBREAK = $MF_MENUBARBREAK
Global Const $MFT_MENUBREAK = $MF_MENUBREAK
Global Const $MFT_OWNERDRAW = $MF_OWNERDRAW
Global Const $MFT_RADIOCHECK = 0x200
Global Const $MFT_SEPARATOR = $MF_SEPARATOR
Global Const $MFT_RIGHTORDER = 0x2000
Global Const $MFT_RIGHTJUSTIFY = $MF_RIGHTJUSTIFY
Global Const $MIIM_STATE = 0x1
Global Const $MIIM_ID = 0x2
Global Const $MIIM_SUBMENU = 0x4
Global Const $MIIM_CHECKMARKS = 0x8
Global Const $MIIM_TYPE = 0x10
Global Const $MIIM_DATA = 0x20
Global Const $MIIM_DATAMASK = 0x3f
Global Const $MIIM_STRING = 0x40
Global Const $MIIM_BITMAP = 0x80
Global Const $MIIM_FTYPE = 0x100
Global Const $MIM_MAXHEIGHT = 0x1
Global Const $MIM_BACKGROUND = 0x2
Global Const $MIM_HELPID = 0x4
Global Const $MIM_MENUDATA = 0x8
Global Const $MIM_STYLE = 0x10
Global Const $MIM_APPLYTOSUBMENUS = -2147483648
Global Const $MNS_CHECKORBMP = 0x4000000
Global Const $MNS_NOTIFYBYPOS = 0x8000000
Global Const $MNS_AUTODISMISS = 0x10000000
Global Const $MNS_DRAGDROP = 0x20000000
Global Const $MNS_MODELESS = 0x40000000
Global Const $MNS_NOCHECK = -2147483648
Global Const $TPM_LEFTBUTTON = 0x0
Global Const $TPM_LEFTALIGN = 0x0
Global Const $TPM_TOPALIGN = 0x0
Global Const $TPM_HORIZONTAL = 0x0
Global Const $TPM_RECURSE = 0x1
Global Const $TPM_RIGHTBUTTON = 0x2
Global Const $TPM_CENTERALIGN = 0x4
Global Const $TPM_RIGHTALIGN = 0x8
Global Const $TPM_VCENTERALIGN = 0x10
Global Const $TPM_BOTTOMALIGN = 0x20
Global Const $TPM_VERTICAL = 0x40
Global Const $TPM_NONOTIFY = 0x80
Global Const $TPM_RETURNCMD = 0x100
Global Const $TPM_HORPOSANIMATION = 0x400
Global Const $TPM_HORNEGANIMATION = 0x800
Global Const $TPM_VERPOSANIMATION = 0x1000
Global Const $TPM_VERNEGANIMATION = 0x2000
Global Const $TPM_NOANIMATION = 0x4000
Global Const $TPM_LAYOUTRTL = 0x8000
Global Const $TPM_WORKAREA = 0x10000
Global Const $SC_SIZE = 0xf000
Global Const $SC_MOVE = 0xf010
Global Const $SC_MINIMIZE = 0xf020
Global Const $SC_MAXIMIZE = 0xf030
Global Const $SC_NEXTWINDOW = 0xf040
Global Const $SC_PREVWINDOW = 0xf050
Global Const $SC_CLOSE = 0xf060
Global Const $SC_VSCROLL = 0xf070
Global Const $SC_HSCROLL = 0xf080
Global Const $SC_MOUSEMENU = 0xf090
Global Const $SC_KEYMENU = 0xf100
Global Const $SC_ARRANGE = 0xf110
Global Const $SC_RESTORE = 0xf120
Global Const $SC_TASKLIST = 0xf130
Global Const $SC_SCREENSAVE = 0xf140
Global Const $SC_HOTKEY = 0xf150
Global Const $SC_DEFAULT = 0xf160
Global Const $SC_MONITORPOWER = 0xf170
Global Const $SC_CONTEXTHELP = 0xf180
Global Const $SC_SEPARATOR = 0xf00f
Global Const $OBJID_SYSMENU = -1
Global Const $OBJID_MENU = -3
Global Const $SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege"
Global Const $SE_AUDIT_NAME = "SeAuditPrivilege"
Global Const $SE_BACKUP_NAME = "SeBackupPrivilege"
Global Const $SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege"
Global Const $SE_CREATE_GLOBAL_NAME = "SeCreateGlobalPrivilege"
Global Const $SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege"
Global Const $SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege"
Global Const $SE_CREATE_SYMBOLIC_LINK_NAME = "SeCreateSymbolicLinkPrivilege"
Global Const $SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege"
Global Const $SE_DEBUG_NAME = "SeDebugPrivilege"
Global Const $SE_ENABLE_DELEGATION_NAME = "SeEnableDelegationPrivilege"
Global Const $SE_IMPERSONATE_NAME = "SeImpersonatePrivilege"
Global Const $SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege"
Global Const $SE_INC_WORKING_SET_NAME = "SeIncreaseWorkingSetPrivilege"
Global Const $SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege"
Global Const $SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege"
Global Const $SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege"
Global Const $SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege"
Global Const $SE_MANAGE_VOLUME_NAME = "SeManageVolumePrivilege"
Global Const $SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege"
Global Const $SE_RELABEL_NAME = "SeRelabelPrivilege"
Global Const $SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"
Global Const $SE_RESTORE_NAME = "SeRestorePrivilege"
Global Const $SE_SECURITY_NAME = "SeSecurityPrivilege"
Global Const $SE_SHUTDOWN_NAME = "SeShutdownPrivilege"
Global Const $SE_SYNC_AGENT_NAME = "SeSyncAgentPrivilege"
Global Const $SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege"
Global Const $SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege"
Global Const $SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege"
Global Const $SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege"
Global Const $SE_TCB_NAME = "SeTcbPrivilege"
Global Const $SE_TIME_ZONE_NAME = "SeTimeZonePrivilege"
Global Const $SE_TRUSTED_CREDMAN_ACCESS_NAME = "SeTrustedCredManAccessPrivilege"
Global Const $SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
Global Const $SE_UNDOCK_NAME = "SeUndockPrivilege"
Global Const $SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x1
Global Const $SE_PRIVILEGE_ENABLED = 0x2
Global Const $SE_PRIVILEGE_REMOVED = 0x4
Global Const $SE_PRIVILEGE_USED_FOR_ACCESS = -2147483648
Global Const $SE_GROUP_MANDATORY = 0x1
Global Const $SE_GROUP_ENABLED_BY_DEFAULT = 0x2
Global Const $SE_GROUP_ENABLED = 0x4
Global Const $SE_GROUP_OWNER = 0x8
Global Const $SE_GROUP_USE_FOR_DENY_ONLY = 0x10
Global Const $SE_GROUP_INTEGRITY = 0x20
Global Const $SE_GROUP_INTEGRITY_ENABLED = 0x40
Global Const $SE_GROUP_RESOURCE = 0x20000000
Global Const $SE_GROUP_LOGON_ID = -1073741824
Global Enum $TOKENPRIMARY = 0x1, $TOKENIMPERSONATION
Global Enum $SECURITYANONYMOUS = 0x0, $SECURITYIDENTIFICATION, $SECURITYIMPERSONATION, $SECURITYDELEGATION
Global Enum $TOKENUSER = 0x1, $TOKENGROUPS, $TOKENPRIVILEGES, $TOKENOWNER, $TOKENPRIMARYGROUP, $TOKENDEFAULTDACL, $TOKENSOURCE, $TOKENTYPE, $TOKENIMPERSONATIONLEVEL, $TOKENSTATISTICS, $TOKENRESTRICTEDSIDS, $TOKENSESSIONID, $TOKENGROUPSANDPRIVILEGES, $TOKENSESSIONREFERENCE, $TOKENSANDBOXINERT, $TOKENAUDITPOLICY, $TOKENORIGIN, $TOKENELEVATIONTYPE, $TOKENLINKEDTOKEN, $TOKENELEVATION, $TOKENHASRESTRICTIONS, $TOKENACCESSINFORMATION, $TOKENVIRTUALIZATIONALLOWED, $TOKENVIRTUALIZATIONENABLED, $TOKENINTEGRITYLEVEL, $TOKENUIACCESS, $TOKENMANDATORYPOLICY, $TOKENLOGONSID
Global Const $TOKEN_ASSIGN_PRIMARY = 0x1
Global Const $TOKEN_DUPLICATE = 0x2
Global Const $TOKEN_IMPERSONATE = 0x4
Global Const $TOKEN_QUERY = 0x8
Global Const $TOKEN_QUERY_SOURCE = 0x10
Global Const $TOKEN_ADJUST_PRIVILEGES = 0x20
Global Const $TOKEN_ADJUST_GROUPS = 0x40
Global Const $TOKEN_ADJUST_DEFAULT = 0x80
Global Const $TOKEN_ADJUST_SESSIONID = 0x100
Global Const $TOKEN_ALL_ACCESS = 0xf01ff
Global Const $TOKEN_READ = 0x20008
Global Const $TOKEN_WRITE = 0x200e0
Global Const $TOKEN_EXECUTE = 0x20000
Global Const $TOKEN_HAS_TRAVERSE_PRIVILEGE = 0x1
Global Const $TOKEN_HAS_BACKUP_PRIVILEGE = 0x2
Global Const $TOKEN_HAS_RESTORE_PRIVILEGE = 0x4
Global Const $TOKEN_HAS_ADMIN_GROUP = 0x8
Global Const $TOKEN_IS_RESTRICTED = 0x10
Global Const $TOKEN_SESSION_NOT_REFERENCED = 0x20
Global Const $TOKEN_SANDBOX_INERT = 0x40
Global Const $TOKEN_HAS_IMPERSONATE_PRIVILEGE = 0x80
Global Const $STANDARD_RIGHTS_DELETE = 0x10000
Global Const $READ_CONTROL = 0x20000
Global Const $WRITE_DAC = 0x40000
Global Const $WRITE_OWNER = 0x80000
Global Const $STANDARD_RIGHTS_SYNCHRONIZE = 0x100000
Global Const $ACCESS_SYSTEM_SECURITY = 0x1000000
Global Const $STANDARD_RIGHTS_REQUIRED = 0xf0000
Global Const $STANDARD_RIGHTS_READ = $READ_CONTROL
Global Const $STANDARD_RIGHTS_WRITE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_EXECUTE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_ALL = 0x1f0000
Global Const $SPECIFIC_RIGHTS_ALL = 0xffff
Global Enum $NOT_USED_ACCESS = 0x0, $GRANT_ACCESS, $SET_ACCESS, $DENY_ACCESS, $REVOKE_ACCESS, $SET_AUDIT_SUCCESS, $SET_AUDIT_FAILURE
Global Enum $TRUSTEE_IS_UNKNOWN = 0x0, $TRUSTEE_IS_USER, $TRUSTEE_IS_GROUP, $TRUSTEE_IS_DOMAIN, $TRUSTEE_IS_ALIAS, $TRUSTEE_IS_WELL_KNOWN_GROUP, $TRUSTEE_IS_DELETED, $TRUSTEE_IS_INVALID, $TRUSTEE_IS_COMPUTER
Global Const $LOGON_WITH_PROFILE = 0x1
Global Const $LOGON_NETCREDENTIALS_ONLY = 0x2
Global Enum $SIDTYPEUSER = 0x1, $SIDTYPEGROUP, $SIDTYPEDOMAIN, $SIDTYPEALIAS, $SIDTYPEWELLKNOWNGROUP, $SIDTYPEDELETEDACCOUNT, $SIDTYPEINVALID, $SIDTYPEUNKNOWN, $SIDTYPECOMPUTER, $SIDTYPELABEL
Global Const $SID_ADMINISTRATORS = "S-1-5-32-544"
Global Const $SID_USERS = "S-1-5-32-545"
Global Const $SID_GUESTS = "S-1-5-32-546"
Global Const $SID_ACCOUNT_OPERATORS = "S-1-5-32-548"
Global Const $SID_SERVER_OPERATORS = "S-1-5-32-549"
Global Const $SID_PRINT_OPERATORS = "S-1-5-32-550"
Global Const $SID_BACKUP_OPERATORS = "S-1-5-32-551"
Global Const $SID_REPLICATOR = "S-1-5-32-552"
Global Const $SID_OWNER = "S-1-3-0"
Global Const $SID_EVERYONE = "S-1-1-0"
Global Const $SID_NETWORK = "S-1-5-2"
Global Const $SID_INTERACTIVE = "S-1-5-4"
Global Const $SID_SYSTEM = "S-1-5-18"
Global Const $SID_AUTHENTICATED_USERS = "S-1-5-11"
Global Const $SID_SCHANNEL_AUTHENTICATION = "S-1-5-64-14"
Global Const $SID_DIGEST_AUTHENTICATION = "S-1-5-64-21"
Global Const $SID_NT_SERVICE = "S-1-5-80"
Global Const $SID_UNTRUSTED_MANDATORY_LEVEL = "S-1-16-0"
Global Const $SID_LOW_MANDATORY_LEVEL = "S-1-16-4096"
Global Const $SID_MEDIUM_MANDATORY_LEVEL = "S-1-16-8192"
Global Const $SID_MEDIUM_PLUS_MANDATORY_LEVEL = "S-1-16-8448"
Global Const $SID_HIGH_MANDATORY_LEVEL = "S-1-16-12288"
Global Const $SID_SYSTEM_MANDATORY_LEVEL = "S-1-16-16384"
Global Const $SID_PROTECTED_PROCESS_MANDATORY_LEVEL = "S-1-16-20480"
Global Const $SID_SECURE_PROCESS_MANDATORY_LEVEL = "S-1-16-28672"
Global Const $SID_ALL_SERVICES = "S-1-5-80-0"
Global Const $HGDI_ERROR = Ptr(+ -1)
Global Const $INVALID_HANDLE_VALUE = Ptr(+ -1)
Global Const $CLR_INVALID = + -1
Global Const $MB_PRECOMPOSED = 0x1
Global Const $MB_COMPOSITE = 0x2
Global Const $MB_USEGLYPHCHARS = 0x4
Global Const $ULW_ALPHA = 0x2
Global Const $ULW_COLORKEY = 0x1
Global Const $ULW_OPAQUE = 0x4
Global Const $ULW_EX_NORESIZE = 0x8
Global Const $WH_CALLWNDPROC = 0x4
Global Const $WH_CALLWNDPROCRET = 0xc
Global Const $WH_CBT = 0x5
Global Const $WH_DEBUG = 0x9
Global Const $WH_FOREGROUNDIDLE = 0xb
Global Const $WH_GETMESSAGE = 0x3
Global Const $WH_JOURNALPLAYBACK = 0x1
Global Const $WH_JOURNALRECORD = 0x0
Global Const $WH_KEYBOARD = 0x2
Global Const $WH_KEYBOARD_LL = 0xd
Global Const $WH_MOUSE = 0x7
Global Const $WH_MOUSE_LL = 0xe
Global Const $WH_MSGFILTER = + -1
Global Const $WH_SHELL = 0xa
Global Const $WH_SYSMSGFILTER = 0x6
Global Const $WPF_ASYNCWINDOWPLACEMENT = 0x4
Global Const $WPF_RESTORETOMAXIMIZED = 0x2
Global Const $WPF_SETMINPOSITION = 0x1
Global Const $KF_EXTENDED = 0x100
Global Const $KF_ALTDOWN = 0x2000
Global Const $KF_UP = 0x8000
Global Const $LLKHF_EXTENDED = BitShift($KF_EXTENDED, 0x8)
Global Const $LLKHF_LOWER_IL_INJECTED = 0x2
Global Const $LLKHF_INJECTED = 0x10
Global Const $LLKHF_ALTDOWN = BitShift($KF_ALTDOWN, 0x8)
Global Const $LLKHF_UP = BitShift($KF_UP, 0x8)
Global Const $LVKF_ALT = 0x1
Global Const $LVKF_CONTROL = 0x2
Global Const $LVKF_SHIFT = 0x4
Global Const $OFN_ALLOWMULTISELECT = 0x200
Global Const $OFN_CREATEPROMPT = 0x2000
Global Const $OFN_DONTADDTORECENT = 0x2000000
Global Const $OFN_ENABLEHOOK = 0x20
Global Const $OFN_ENABLEINCLUDENOTIFY = 0x400000
Global Const $OFN_ENABLESIZING = 0x800000
Global Const $OFN_ENABLETEMPLATE = 0x40
Global Const $OFN_ENABLETEMPLATEHANDLE = 0x80
Global Const $OFN_EXPLORER = 0x80000
Global Const $OFN_EXTENSIONDIFFERENT = 0x400
Global Const $OFN_FILEMUSTEXIST = 0x1000
Global Const $OFN_FORCESHOWHIDDEN = 0x10000000
Global Const $OFN_HIDEREADONLY = 0x4
Global Const $OFN_LONGNAMES = 0x200000
Global Const $OFN_NOCHANGEDIR = 0x8
Global Const $OFN_NODEREFERENCELINKS = 0x100000
Global Const $OFN_NOLONGNAMES = 0x40000
Global Const $OFN_NONETWORKBUTTON = 0x20000
Global Const $OFN_NOREADONLYRETURN = 0x8000
Global Const $OFN_NOTESTFILECREATE = 0x10000
Global Const $OFN_NOVALIDATE = 0x100
Global Const $OFN_OVERWRITEPROMPT = 0x2
Global Const $OFN_PATHMUSTEXIST = 0x800
Global Const $OFN_READONLY = 0x1
Global Const $OFN_SHAREAWARE = 0x4000
Global Const $OFN_SHOWHELP = 0x10
Global Const $OFN_EX_NOPLACESBAR = 0x1
Global Const $STD_CUT = 0x0
Global Const $STD_COPY = 0x1
Global Const $STD_PASTE = 0x2
Global Const $STD_UNDO = 0x3
Global Const $STD_REDOW = 0x4
Global Const $STD_DELETE = 0x5
Global Const $STD_FILENEW = 0x6
Global Const $STD_FILEOPEN = 0x7
Global Const $STD_FILESAVE = 0x8
Global Const $STD_PRINTPRE = 0x9
Global Const $STD_PROPERTIES = 0xa
Global Const $STD_HELP = 0xb
Global Const $STD_FIND = 0xc
Global Const $STD_REPLACE = 0xd
Global Const $STD_PRINT = 0xe
Global Const $KB_SENDSPECIAL = 0x0
Global Const $KB_SENDRAW = 0x1
Global Const $KB_CAPSOFF = 0x0
Global Const $KB_CAPSON = 0x1
Global Const $S_OK = 0x0
Global Const $E_ABORT = -2147467260
Global Const $E_ACCESSDENIED = -2147024891
Global Const $E_FAIL = -2147467259
Global Const $E_HANDLE = -2147024890
Global Const $E_INVALIDARG = -2147024809
Global Const $E_NOINTERFACE = -2147467262
Global Const $E_NOTIMPL = -2147467263
Global Const $E_OUTOFMEMORY = -2147024882
Global Const $E_POINTER = -2147467261
Global Const $E_UNEXPECTED = -2147418113
Global Const $SPI_GETBEEP = 0x1
Global Const $SPI_SETBEEP = 0x2
Global Const $SPI_GETMOUSE = 0x3
Global Const $SPI_SETMOUSE = 0x4
Global Const $SPI_GETBORDER = 0x5
Global Const $SPI_SETBORDER = 0x6
Global Const $SPI_GETKEYBOARDSPEED = 0xa
Global Const $SPI_SETKEYBOARDSPEED = 0xb
Global Const $SPI_LANGDRIVER = 0xc
Global Const $SPI_ICONHORIZONTALSPACING = 0xd
Global Const $SPI_GETSCREENSAVETIMEOUT = 0xe
Global Const $SPI_SETSCREENSAVETIMEOUT = 0xf
Global Const $SPI_GETSCREENSAVEACTIVE = 0x10
Global Const $SPI_SETSCREENSAVEACTIVE = 0x11
Global Const $SPI_GETGRIDGRANULARITY = 0x12
Global Const $SPI_SETGRIDGRANULARITY = 0x13
Global Const $SPI_SETDESKWALLPAPER = 0x14
Global Const $SPI_SETDESKPATTERN = 0x15
Global Const $SPI_GETKEYBOARDDELAY = 0x16
Global Const $SPI_SETKEYBOARDDELAY = 0x17
Global Const $SPI_ICONVERTICALSPACING = 0x18
Global Const $SPI_GETICONTITLEWRAP = 0x19
Global Const $SPI_SETICONTITLEWRAP = 0x1a
Global Const $SPI_GETMENUDROPALIGNMENT = 0x1b
Global Const $SPI_SETMENUDROPALIGNMENT = 0x1c
Global Const $SPI_SETDOUBLECLKWIDTH = 0x1d
Global Const $SPI_SETDOUBLECLKHEIGHT = 0x1e
Global Const $SPI_GETICONTITLELOGFONT = 0x1f
Global Const $SPI_SETDOUBLECLICKTIME = 0x20
Global Const $SPI_SETMOUSEBUTTONSWAP = 0x21
Global Const $SPI_SETICONTITLELOGFONT = 0x22
Global Const $SPI_GETFASTTASKSWITCH = 0x23
Global Const $SPI_SETFASTTASKSWITCH = 0x24
Global Const $SPI_SETDRAGFULLWINDOWS = 0x25
Global Const $SPI_GETDRAGFULLWINDOWS = 0x26
Global Const $SPI_GETNONCLIENTMETRICS = 0x29
Global Const $SPI_SETNONCLIENTMETRICS = 0x2a
Global Const $SPI_GETMINIMIZEDMETRICS = 0x2b
Global Const $SPI_SETMINIMIZEDMETRICS = 0x2c
Global Const $SPI_GETICONMETRICS = 0x2d
Global Const $SPI_SETICONMETRICS = 0x2e
Global Const $SPI_SETWORKAREA = 0x2f
Global Const $SPI_GETWORKAREA = 0x30
Global Const $SPI_SETPENWINDOWS = 0x31
Global Const $SPI_GETHIGHCONTRAST = 0x42
Global Const $SPI_SETHIGHCONTRAST = 0x43
Global Const $SPI_GETKEYBOARDPREF = 0x44
Global Const $SPI_SETKEYBOARDPREF = 0x45
Global Const $SPI_GETSCREENREADER = 0x46
Global Const $SPI_SETSCREENREADER = 0x47
Global Const $SPI_GETANIMATION = 0x48
Global Const $SPI_SETANIMATION = 0x49
Global Const $SPI_GETFONTSMOOTHING = 0x4a
Global Const $SPI_SETFONTSMOOTHING = 0x4b
Global Const $SPI_SETDRAGWIDTH = 0x4c
Global Const $SPI_SETDRAGHEIGHT = 0x4d
Global Const $SPI_SETHANDHELD = 0x4e
Global Const $SPI_GETLOWPOWERTIMEOUT = 0x4f
Global Const $SPI_GETPOWEROFFTIMEOUT = 0x50
Global Const $SPI_SETLOWPOWERTIMEOUT = 0x51
Global Const $SPI_SETPOWEROFFTIMEOUT = 0x52
Global Const $SPI_GETLOWPOWERACTIVE = 0x53
Global Const $SPI_GETPOWEROFFACTIVE = 0x54
Global Const $SPI_SETLOWPOWERACTIVE = 0x55
Global Const $SPI_SETPOWEROFFACTIVE = 0x56
Global Const $SPI_SETCURSORS = 0x57
Global Const $SPI_SETICONS = 0x58
Global Const $SPI_GETDEFAULTINPUTLANG = 0x59
Global Const $SPI_SETDEFAULTINPUTLANG = 0x5a
Global Const $SPI_SETLANGTOGGLE = 0x5b
Global Const $SPI_GETWINDOWSEXTENSION = 0x5c
Global Const $SPI_SETMOUSETRAILS = 0x5d
Global Const $SPI_GETMOUSETRAILS = 0x5e
Global Const $SPI_SETSCREENSAVERRUNNING = 0x61
Global Const $SPI_SCREENSAVERRUNNING = $SPI_SETSCREENSAVERRUNNING
Global Const $SPI_GETFILTERKEYS = 0x32
Global Const $SPI_SETFILTERKEYS = 0x33
Global Const $SPI_GETTOGGLEKEYS = 0x34
Global Const $SPI_SETTOGGLEKEYS = 0x35
Global Const $SPI_GETMOUSEKEYS = 0x36
Global Const $SPI_SETMOUSEKEYS = 0x37
Global Const $SPI_GETSHOWSOUNDS = 0x38
Global Const $SPI_SETSHOWSOUNDS = 0x39
Global Const $SPI_GETSTICKYKEYS = 0x3a
Global Const $SPI_SETSTICKYKEYS = 0x3b
Global Const $SPI_GETACCESSTIMEOUT = 0x3c
Global Const $SPI_SETACCESSTIMEOUT = 0x3d
Global Const $SPI_GETSERIALKEYS = 0x3e
Global Const $SPI_SETSERIALKEYS = 0x3f
Global Const $SPI_GETSOUNDSENTRY = 0x40
Global Const $SPI_SETSOUNDSENTRY = 0x41
Global Const $SPI_GETSNAPTODEFBUTTON = 0x5f
Global Const $SPI_SETSNAPTODEFBUTTON = 0x60
Global Const $SPI_GETMOUSEHOVERWIDTH = 0x62
Global Const $SPI_SETMOUSEHOVERWIDTH = 0x63
Global Const $SPI_GETMOUSEHOVERHEIGHT = 0x64
Global Const $SPI_SETMOUSEHOVERHEIGHT = 0x65
Global Const $SPI_GETMOUSEHOVERTIME = 0x66
Global Const $SPI_SETMOUSEHOVERTIME = 0x67
Global Const $SPI_GETWHEELSCROLLLINES = 0x68
Global Const $SPI_SETWHEELSCROLLLINES = 0x69
Global Const $SPI_GETMENUSHOWDELAY = 0x6a
Global Const $SPI_SETMENUSHOWDELAY = 0x6b
Global Const $SPI_GETSHOWIMEUI = 0x6e
Global Const $SPI_SETSHOWIMEUI = 0x6f
Global Const $SPI_GETMOUSESPEED = 0x70
Global Const $SPI_SETMOUSESPEED = 0x71
Global Const $SPI_GETSCREENSAVERRUNNING = 0x72
Global Const $SPI_GETDESKWALLPAPER = 0x73
Global Const $SPI_GETACTIVEWINDOWTRACKING = 0x1000
Global Const $SPI_SETACTIVEWINDOWTRACKING = 0x1001
Global Const $SPI_GETMENUANIMATION = 0x1002
Global Const $SPI_SETMENUANIMATION = 0x1003
Global Const $SPI_GETCOMBOBOXANIMATION = 0x1004
Global Const $SPI_SETCOMBOBOXANIMATION = 0x1005
Global Const $SPI_GETLISTBOXSMOOTHSCROLLING = 0x1006
Global Const $SPI_SETLISTBOXSMOOTHSCROLLING = 0x1007
Global Const $SPI_GETGRADIENTCAPTIONS = 0x1008
Global Const $SPI_SETGRADIENTCAPTIONS = 0x1009
Global Const $SPI_GETKEYBOARDCUES = 0x100a
Global Const $SPI_SETKEYBOARDCUES = 0x100b
Global Const $SPI_GETMENUUNDERLINES = $SPI_GETKEYBOARDCUES
Global Const $SPI_SETMENUUNDERLINES = $SPI_SETKEYBOARDCUES
Global Const $SPI_GETACTIVEWNDTRKZORDER = 0x100c
Global Const $SPI_SETACTIVEWNDTRKZORDER = 0x100d
Global Const $SPI_GETHOTTRACKING = 0x100e
Global Const $SPI_SETHOTTRACKING = 0x100f
Global Const $SPI_GETMENUFADE = 0x1012
Global Const $SPI_SETMENUFADE = 0x1013
Global Const $SPI_GETSELECTIONFADE = 0x1014
Global Const $SPI_SETSELECTIONFADE = 0x1015
Global Const $SPI_GETTOOLTIPANIMATION = 0x1016
Global Const $SPI_SETTOOLTIPANIMATION = 0x1017
Global Const $SPI_GETTOOLTIPFADE = 0x1018
Global Const $SPI_SETTOOLTIPFADE = 0x1019
Global Const $SPI_GETCURSORSHADOW = 0x101a
Global Const $SPI_SETCURSORSHADOW = 0x101b
Global Const $SPI_GETMOUSESONAR = 0x101c
Global Const $SPI_SETMOUSESONAR = 0x101d
Global Const $SPI_GETMOUSECLICKLOCK = 0x101e
Global Const $SPI_SETMOUSECLICKLOCK = 0x101f
Global Const $SPI_GETMOUSEVANISH = 0x1020
Global Const $SPI_SETMOUSEVANISH = 0x1021
Global Const $SPI_GETFLATMENU = 0x1022
Global Const $SPI_SETFLATMENU = 0x1023
Global Const $SPI_GETDROPSHADOW = 0x1024
Global Const $SPI_SETDROPSHADOW = 0x1025
Global Const $SPI_GETBLOCKSENDINPUTRESETS = 0x1026
Global Const $SPI_SETBLOCKSENDINPUTRESETS = 0x1027
Global Const $SPI_GETUIEFFECTS = 0x103e
Global Const $SPI_SETUIEFFECTS = 0x103f
Global Const $SPI_GETFOREGROUNDLOCKTIMEOUT = 0x2000
Global Const $SPI_SETFOREGROUNDLOCKTIMEOUT = 0x2001
Global Const $SPI_GETACTIVEWNDTRKTIMEOUT = 0x2002
Global Const $SPI_SETACTIVEWNDTRKTIMEOUT = 0x2003
Global Const $SPI_GETFOREGROUNDFLASHCOUNT = 0x2004
Global Const $SPI_SETFOREGROUNDFLASHCOUNT = 0x2005
Global Const $SPI_GETCARETWIDTH = 0x2006
Global Const $SPI_SETCARETWIDTH = 0x2007
Global Const $SPI_GETMOUSECLICKLOCKTIME = 0x2008
Global Const $SPI_SETMOUSECLICKLOCKTIME = 0x2009
Global Const $SPI_GETFONTSMOOTHINGTYPE = 0x200a
Global Const $SPI_SETFONTSMOOTHINGTYPE = 0x200b
Global Const $SPI_GETFONTSMOOTHINGCONTRAST = 0x200c
Global Const $SPI_SETFONTSMOOTHINGCONTRAST = 0x200d
Global Const $SPI_GETFOCUSBORDERWIDTH = 0x200e
Global Const $SPI_SETFOCUSBORDERWIDTH = 0x200f
Global Const $SPI_GETFOCUSBORDERHEIGHT = 0x2010
Global Const $SPI_SETFOCUSBORDERHEIGHT = 0x2011
Global Const $SPI_GETFONTSMOOTHINGORIENTATION = 0x2012
Global Const $SPI_SETFONTSMOOTHINGORIENTATION = 0x2013
Global Const $FE_FONTSMOOTHINGSTANDARD = 0x1
Global Const $FE_FONTSMOOTHINGCLEARTYPE = 0x2
Global Const $FE_FONTSMOOTHINGDOCKING = 0x8000
Global Const $FE_FONTSMOOTHINGORIENTATIONBGR = 0x0
Global Const $FE_FONTSMOOTHINGORIENTATIONRGB = 0x1
Global Const $SPIF_UPDATEINIFILE = 0x1
Global Const $SPIF_SENDWININICHANGE = 0x2
Global Const $SPIF_SENDCHANGE = $SPIF_SENDWININICHANGE
Global Const $VK_LBUTTON = 0x1
Global Const $VK_RBUTTON = 0x2
Global Const $VK_CANCEL = 0x3
Global Const $VK_MBUTTON = 0x4
Global Const $VK_XBUTTON1 = 0x5
Global Const $VK_XBUTTON2 = 0x6
Global Const $VK_BACK = 0x8
Global Const $VK_TAB = 0x9
Global Const $VK_CLEAR = 0xc
Global Const $VK_RETURN = 0xd
Global Const $VK_SHIFT = 0x10
Global Const $VK_CONTROL = 0x11
Global Const $VK_MENU = 0x12
Global Const $VK_PAUSE = 0x13
Global Const $VK_CAPITAL = 0x14
Global Const $VK_KANA = 0x15
Global Const $VK_HANGUL = 0x15
Global Const $VK_JUNJA = 0x17
Global Const $VK_FINAL = 0x18
Global Const $VK_HANJA = 0x19
Global Const $VK_KANJI = 0x19
Global Const $VK_ESCAPE = 0x1b
Global Const $VK_CONVERT = 0x1c
Global Const $VK_NONCONVERT = 0x1d
Global Const $VK_ACCEPT = 0x1e
Global Const $VK_MODECHANGE = 0x1f
Global Const $VK_SPACE = 0x20
Global Const $VK_PRIOR = 0x21
Global Const $VK_NEXT = 0x22
Global Const $VK_END = 0x23
Global Const $VK_HOME = 0x24
Global Const $VK_LEFT = 0x25
Global Const $VK_UP = 0x26
Global Const $VK_RIGHT = 0x27
Global Const $VK_DOWN = 0x28
Global Const $VK_SELECT = 0x29
Global Const $VK_PRINT = 0x2a
Global Const $VK_EXECUTE = 0x2b
Global Const $VK_SNAPSHOT = 0x2c
Global Const $VK_INSERT = 0x2d
Global Const $VK_DELETE = 0x2e
Global Const $VK_HELP = 0x2f
Global Const $VK_0 = 0x30
Global Const $VK_1 = 0x31
Global Const $VK_2 = 0x32
Global Const $VK_3 = 0x33
Global Const $VK_4 = 0x34
Global Const $VK_5 = 0x35
Global Const $VK_6 = 0x36
Global Const $VK_7 = 0x37
Global Const $VK_8 = 0x38
Global Const $VK_9 = 0x39
Global Const $VK_A = 0x41
Global Const $VK_B = 0x42
Global Const $VK_C = 0x43
Global Const $VK_D = 0x44
Global Const $VK_E = 0x45
Global Const $VK_F = 0x46
Global Const $VK_G = 0x47
Global Const $VK_H = 0x48
Global Const $VK_I = 0x49
Global Const $VK_J = 0x4a
Global Const $VK_K = 0x4b
Global Const $VK_L = 0x4c
Global Const $VK_M = 0x4d
Global Const $VK_N = 0x4e
Global Const $VK_O = 0x4f
Global Const $VK_P = 0x50
Global Const $VK_Q = 0x51
Global Const $VK_R = 0x52
Global Const $VK_S = 0x53
Global Const $VK_T = 0x54
Global Const $VK_U = 0x55
Global Const $VK_V = 0x56
Global Const $VK_W = 0x57
Global Const $VK_X = 0x58
Global Const $VK_Y = 0x59
Global Const $VK_Z = 0x5a
Global Const $VK_LWIN = 0x5b
Global Const $VK_RWIN = 0x5c
Global Const $VK_APPS = 0x5d
Global Const $VK_SLEEP = 0x5f
Global Const $VK_NUMPAD0 = 0x60
Global Const $VK_NUMPAD1 = 0x61
Global Const $VK_NUMPAD2 = 0x62
Global Const $VK_NUMPAD3 = 0x63
Global Const $VK_NUMPAD4 = 0x64
Global Const $VK_NUMPAD5 = 0x65
Global Const $VK_NUMPAD6 = 0x66
Global Const $VK_NUMPAD7 = 0x67
Global Const $VK_NUMPAD8 = 0x68
Global Const $VK_NUMPAD9 = 0x69
Global Const $VK_MULTIPLY = 0x6a
Global Const $VK_ADD = 0x6b
Global Const $VK_SEPARATOR = 0x6c
Global Const $VK_SUBTRACT = 0x6d
Global Const $VK_DECIMAL = 0x6e
Global Const $VK_DIVIDE = 0x6f
Global Const $VK_F1 = 0x70
Global Const $VK_F2 = 0x71
Global Const $VK_F3 = 0x72
Global Const $VK_F4 = 0x73
Global Const $VK_F5 = 0x74
Global Const $VK_F6 = 0x75
Global Const $VK_F7 = 0x76
Global Const $VK_F8 = 0x77
Global Const $VK_F9 = 0x78
Global Const $VK_F10 = 0x79
Global Const $VK_F11 = 0x7a
Global Const $VK_F12 = 0x7b
Global Const $VK_F13 = 0x7c
Global Const $VK_F14 = 0x7d
Global Const $VK_F15 = 0x7e
Global Const $VK_F16 = 0x7f
Global Const $VK_F17 = 0x80
Global Const $VK_F18 = 0x81
Global Const $VK_F19 = 0x82
Global Const $VK_F20 = 0x83
Global Const $VK_F21 = 0x84
Global Const $VK_F22 = 0x85
Global Const $VK_F23 = 0x86
Global Const $VK_F24 = 0x87
Global Const $VK_NUMLOCK = 0x90
Global Const $VK_SCROLL = 0x91
Global Const $VK_LSHIFT = 0xa0
Global Const $VK_RSHIFT = 0xa1
Global Const $VK_LCONTROL = 0xa2
Global Const $VK_RCONTROL = 0xa3
Global Const $VK_LMENU = 0xa4
Global Const $VK_RMENU = 0xa5
Global Const $VK_BROWSER_BACK = 0xa6
Global Const $VK_BROWSER_FORWARD = 0xa7
Global Const $VK_BROWSER_REFRESH = 0xa8
Global Const $VK_BROWSER_STOP = 0xa9
Global Const $VK_BROWSER_SEARCH = 0xaa
Global Const $VK_BROWSER_FAVORITES = 0xab
Global Const $VK_BROWSER_HOME = 0xac
Global Const $VK_VOLUME_MUTE = 0xad
Global Const $VK_VOLUME_DOWN = 0xae
Global Const $VK_VOLUME_UP = 0xaf
Global Const $VK_MEDIA_NEXT_TRACK = 0xb0
Global Const $VK_MEDIA_PREV_TRACK = 0xb1
Global Const $VK_MEDIA_STOP = 0xb2
Global Const $VK_MEDIA_PLAY_PAUSE = 0xb3
Global Const $VK_LAUNCH_MAIL = 0xb4
Global Const $VK_LAUNCH_MEDIA_SELECT = 0xb5
Global Const $VK_LAUNCH_APP1 = 0xb6
Global Const $VK_LAUNCH_APP2 = 0xb7
Global Const $VK_OEM_1 = 0xba
Global Const $VK_OEM_PLUS = 0xbb
Global Const $VK_OEM_COMMA = 0xbc
Global Const $VK_OEM_MINUS = 0xbd
Global Const $VK_OEM_PERIOD = 0xbe
Global Const $VK_OEM_2 = 0xbf
Global Const $VK_OEM_3 = 0xc0
Global Const $VK_OEM_4 = 0xdb
Global Const $VK_OEM_5 = 0xdc
Global Const $VK_OEM_6 = 0xdd
Global Const $VK_OEM_7 = 0xde
Global Const $VK_OEM_8 = 0xdf
Global Const $VK_OEM_102 = 0xe2
Global Const $VK_PROCESSKEY = 0xe5
Global Const $VK_PACKET = 0xe7
Global Const $VK_ATTN = 0xf6
Global Const $VK_CRSEL = 0xf7
Global Const $VK_EXSEL = 0xf8
Global Const $VK_EREOF = 0xf9
Global Const $VK_PLAY = 0xfa
Global Const $VK_ZOOM = 0xfb
Global Const $VK_NONAME = 0xfc
Global Const $VK_PA1 = 0xfd
Global Const $VK_OEM_CLEAR = 0xfe
Global Const $ERROR_SUCCESS = 0x0
Global Const $ERROR_INVALID_FUNCTION = 0x1
Global Const $ERROR_FILE_NOT_FOUND = 0x2
Global Const $ERROR_PATH_NOT_FOUND = 0x3
Global Const $ERROR_TOO_MANY_OPEN_FILES = 0x4
Global Const $ERROR_ACCESS_DENIED = 0x5
Global Const $ERROR_INVALID_HANDLE = 0x6
Global Const $ERROR_ARENA_TRASHED = 0x7
Global Const $ERROR_NOT_ENOUGH_MEMORY = 0x8
Global Const $ERROR_INVALID_BLOCK = 0x9
Global Const $ERROR_BAD_ENVIRONMENT = 0xa
Global Const $ERROR_BAD_FORMAT = 0xb
Global Const $ERROR_INVALID_ACCESS = 0xc
Global Const $ERROR_INVALID_DATA = 0xd
Global Const $ERROR_OUTOFMEMORY = 0xe
Global Const $ERROR_INVALID_DRIVE = 0xf
Global Const $ERROR_CURRENT_DIRECTORY = 0x10
Global Const $ERROR_NOT_SAME_DEVICE = 0x11
Global Const $ERROR_NO_MORE_FILES = 0x12
Global Const $ERROR_WRITE_PROTECT = 0x13
Global Const $ERROR_BAD_UNIT = 0x14
Global Const $ERROR_NOT_READY = 0x15
Global Const $ERROR_BAD_COMMAND = 0x16
Global Const $ERROR_CRC = 0x17
Global Const $ERROR_BAD_LENGTH = 0x18
Global Const $ERROR_SEEK = 0x19
Global Const $ERROR_NOT_DOS_DISK = 0x1a
Global Const $ERROR_SECTOR_NOT_FOUND = 0x1b
Global Const $ERROR_OUT_OF_PAPER = 0x1c
Global Const $ERROR_WRITE_FAULT = 0x1d
Global Const $ERROR_READ_FAULT = 0x1e
Global Const $ERROR_GEN_FAILURE = 0x1f
Global Const $ERROR_SHARING_VIOLATION = 0x20
Global Const $ERROR_LOCK_VIOLATION = 0x21
Global Const $ERROR_WRONG_DISK = 0x22
Global Const $ERROR_SHARING_BUFFER_EXCEEDED = 0x24
Global Const $ERROR_HANDLE_EOF = 0x26
Global Const $ERROR_HANDLE_DISK_FULL = 0x27
Global Const $ERROR_NOT_SUPPORTED = 0x32
Global Const $ERROR_REM_NOT_LIST = 0x33
Global Const $ERROR_DUP_NAME = 0x34
Global Const $ERROR_BAD_NETPATH = 0x35
Global Const $ERROR_NETWORK_BUSY = 0x36
Global Const $ERROR_DEV_NOT_EXIST = 0x37
Global Const $ERROR_TOO_MANY_CMDS = 0x38
Global Const $ERROR_ADAP_HDW_ERR = 0x39
Global Const $ERROR_BAD_NET_RESP = 0x3a
Global Const $ERROR_UNEXP_NET_ERR = 0x3b
Global Const $ERROR_BAD_REM_ADAP = 0x3c
Global Const $ERROR_PRINTQ_FULL = 0x3d
Global Const $ERROR_NO_SPOOL_SPACE = 0x3e
Global Const $ERROR_PRINT_CANCELLED = 0x3f
Global Const $ERROR_NETNAME_DELETED = 0x40
Global Const $ERROR_NETWORK_ACCESS_DENIED = 0x41
Global Const $ERROR_BAD_DEV_TYPE = 0x42
Global Const $ERROR_BAD_NET_NAME = 0x43
Global Const $ERROR_TOO_MANY_NAMES = 0x44
Global Const $ERROR_TOO_MANY_SESS = 0x45
Global Const $ERROR_SHARING_PAUSED = 0x46
Global Const $ERROR_REQ_NOT_ACCEP = 0x47
Global Const $ERROR_REDIR_PAUSED = 0x48
Global Const $ERROR_FILE_EXISTS = 0x50
Global Const $ERROR_CANNOT_MAKE = 0x52
Global Const $ERROR_FAIL_I24 = 0x53
Global Const $ERROR_OUT_OF_STRUCTURES = 0x54
Global Const $ERROR_ALREADY_ASSIGNED = 0x55
Global Const $ERROR_INVALID_PASSWORD = 0x56
Global Const $ERROR_INVALID_PARAMETER = 0x57
Global Const $ERROR_NET_WRITE_FAULT = 0x58
Global Const $ERROR_NO_PROC_SLOTS = 0x59
Global Const $ERROR_TOO_MANY_SEMAPHORES = 0x64
Global Const $ERROR_EXCL_SEM_ALREADY_OWNED = 0x65
Global Const $ERROR_SEM_IS_SET = 0x66
Global Const $ERROR_TOO_MANY_SEM_REQUESTS = 0x67
Global Const $ERROR_INVALID_AT_INTERRUPT_TIME = 0x68
Global Const $ERROR_SEM_OWNER_DIED = 0x69
Global Const $ERROR_SEM_USER_LIMIT = 0x6a
Global Const $ERROR_DISK_CHANGE = 0x6b
Global Const $ERROR_DRIVE_LOCKED = 0x6c
Global Const $ERROR_BROKEN_PIPE = 0x6d
Global Const $ERROR_OPEN_FAILED = 0x6e
Global Const $ERROR_BUFFER_OVERFLOW = 0x6f
Global Const $ERROR_DISK_FULL = 0x70
Global Const $ERROR_NO_MORE_SEARCH_HANDLES = 0x71
Global Const $ERROR_INVALID_TARGET_HANDLE = 0x72
Global Const $ERROR_INVALID_CATEGORY = 0x75
Global Const $ERROR_INVALID_VERIFY_SWITCH = 0x76
Global Const $ERROR_BAD_DRIVER_LEVEL = 0x77
Global Const $ERROR_CALL_NOT_IMPLEMENTED = 0x78
Global Const $ERROR_SEM_TIMEOUT = 0x79
Global Const $ERROR_INSUFFICIENT_BUFFER = 0x7a
Global Const $ERROR_INVALID_NAME = 0x7b
Global Const $ERROR_INVALID_LEVEL = 0x7c
Global Const $ERROR_NO_VOLUME_LABEL = 0x7d
Global Const $ERROR_MOD_NOT_FOUND = 0x7e
Global Const $ERROR_PROC_NOT_FOUND = 0x7f
Global Const $ERROR_WAIT_NO_CHILDREN = 0x80
Global Const $ERROR_CHILD_NOT_COMPLETE = 0x81
Global Const $ERROR_DIRECT_ACCESS_HANDLE = 0x82
Global Const $ERROR_NEGATIVE_SEEK = 0x83
Global Const $ERROR_SEEK_ON_DEVICE = 0x84
Global Const $ERROR_IS_JOIN_TARGET = 0x85
Global Const $ERROR_IS_JOINED = 0x86
Global Const $ERROR_IS_SUBSTED = 0x87
Global Const $ERROR_NOT_JOINED = 0x88
Global Const $ERROR_NOT_SUBSTED = 0x89
Global Const $ERROR_JOIN_TO_JOIN = 0x8a
Global Const $ERROR_SUBST_TO_SUBST = 0x8b
Global Const $ERROR_JOIN_TO_SUBST = 0x8c
Global Const $ERROR_SUBST_TO_JOIN = 0x8d
Global Const $ERROR_BUSY_DRIVE = 0x8e
Global Const $ERROR_SAME_DRIVE = 0x8f
Global Const $ERROR_DIR_NOT_ROOT = 0x90
Global Const $ERROR_DIR_NOT_EMPTY = 0x91
Global Const $ERROR_IS_SUBST_PATH = 0x92
Global Const $ERROR_IS_JOIN_PATH = 0x93
Global Const $ERROR_PATH_BUSY = 0x94
Global Const $ERROR_IS_SUBST_TARGET = 0x95
Global Const $ERROR_SYSTEM_TRACE = 0x96
Global Const $ERROR_INVALID_EVENT_COUNT = 0x97
Global Const $ERROR_TOO_MANY_MUXWAITERS = 0x98
Global Const $ERROR_INVALID_LIST_FORMAT = 0x99
Global Const $ERROR_LABEL_TOO_LONG = 0x9a
Global Const $ERROR_TOO_MANY_TCBS = 0x9b
Global Const $ERROR_SIGNAL_REFUSED = 0x9c
Global Const $ERROR_DISCARDED = 0x9d
Global Const $ERROR_NOT_LOCKED = 0x9e
Global Const $ERROR_BAD_THREADID_ADDR = 0x9f
Global Const $ERROR_BAD_ARGUMENTS = 0xa0
Global Const $ERROR_BAD_PATHNAME = 0xa1
Global Const $ERROR_SIGNAL_PENDING = 0xa2
Global Const $ERROR_MAX_THRDS_REACHED = 0xa4
Global Const $ERROR_LOCK_FAILED = 0xa7
Global Const $ERROR_BUSY = 0xaa
Global Const $ERROR_CANCEL_VIOLATION = 0xad
Global Const $ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 0xae
Global Const $ERROR_INVALID_SEGMENT_NUMBER = 0xb4
Global Const $ERROR_INVALID_ORDINAL = 0xb6
Global Const $ERROR_ALREADY_EXISTS = 0xb7
Global Const $ERROR_INVALID_FLAG_NUMBER = 0xba
Global Const $ERROR_SEM_NOT_FOUND = 0xbb
Global Const $ERROR_INVALID_STARTING_CODESEG = 0xbc
Global Const $ERROR_INVALID_STACKSEG = 0xbd
Global Const $ERROR_INVALID_MODULETYPE = 0xbe
Global Const $ERROR_INVALID_EXE_SIGNATURE = 0xbf
Global Const $ERROR_EXE_MARKED_INVALID = 0xc0
Global Const $ERROR_BAD_EXE_FORMAT = 0xc1
Global Const $ERROR_ITERATED_DATA_EXCEEDS_64K = 0xc2
Global Const $ERROR_INVALID_MINALLOCSIZE = 0xc3
Global Const $ERROR_DYNLINK_FROM_INVALID_RING = 0xc4
Global Const $ERROR_IOPL_NOT_ENABLED = 0xc5
Global Const $ERROR_INVALID_SEGDPL = 0xc6
Global Const $ERROR_AUTODATASEG_EXCEEDS_64K = 0xc7
Global Const $ERROR_RING2SEG_MUST_BE_MOVABLE = 0xc8
Global Const $ERROR_RELOC_CHAIN_XEEDS_SEGLIM = 0xc9
Global Const $ERROR_INFLOOP_IN_RELOC_CHAIN = 0xca
Global Const $ERROR_ENVVAR_NOT_FOUND = 0xcb
Global Const $ERROR_NO_SIGNAL_SENT = 0xcd
Global Const $ERROR_FILENAME_EXCED_RANGE = 0xce
Global Const $ERROR_RING2_STACK_IN_USE = 0xcf
Global Const $ERROR_META_EXPANSION_TOO_LONG = 0xd0
Global Const $ERROR_INVALID_SIGNAL_NUMBER = 0xd1
Global Const $ERROR_THREAD_1_INACTIVE = 0xd2
Global Const $ERROR_LOCKED = 0xd4
Global Const $ERROR_TOO_MANY_MODULES = 0xd6
Global Const $ERROR_NESTING_NOT_ALLOWED = 0xd7
Global Const $ERROR_EXE_MACHINE_TYPE_MISMATCH = 0xd8
Global Const $ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY = 0xd9
Global Const $ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY = 0xda
Global Const $ERROR_FILE_CHECKED_OUT = 0xdc
Global Const $ERROR_CHECKOUT_REQUIRED = 0xdd
Global Const $ERROR_BAD_FILE_TYPE = 0xde
Global Const $ERROR_FILE_TOO_LARGE = 0xdf
Global Const $ERROR_FORMS_AUTH_REQUIRED = 0xe0
Global Const $ERROR_VIRUS_INFECTED = 0xe1
Global Const $ERROR_VIRUS_DELETED = 0xe2
Global Const $ERROR_PIPE_LOCAL = 0xe5
Global Const $ERROR_BAD_PIPE = 0xe6
Global Const $ERROR_PIPE_BUSY = 0xe7
Global Const $ERROR_NO_DATA = 0xe8
Global Const $ERROR_PIPE_NOT_CONNECTED = 0xe9
Global Const $ERROR_MORE_DATA = 0xea
Global Const $ERROR_VC_DISCONNECTED = 0xf0
Global Const $ERROR_INVALID_EA_NAME = 0xfe
Global Const $ERROR_EA_LIST_INCONSISTENT = 0xff
Global Const $WAIT_TIMEOUT = 0x102
Global Const $ERROR_NO_MORE_ITEMS = 0x103
Global Const $ERROR_CANNOT_COPY = 0x10a
Global Const $ERROR_DIRECTORY = 0x10b
Global Const $ERROR_EAS_DIDNT_FIT = 0x113
Global Const $ERROR_EA_FILE_CORRUPT = 0x114
Global Const $ERROR_EA_TABLE_FULL = 0x115
Global Const $ERROR_INVALID_EA_HANDLE = 0x116
Global Const $ERROR_EAS_NOT_SUPPORTED = 0x11a
Global Const $ERROR_NOT_OWNER = 0x120
Global Const $ERROR_TOO_MANY_POSTS = 0x12a
Global Const $ERROR_PARTIAL_COPY = 0x12b
Global Const $ERROR_OPLOCK_NOT_GRANTED = 0x12c
Global Const $ERROR_INVALID_OPLOCK_PROTOCOL = 0x12d
Global Const $ERROR_DISK_TOO_FRAGMENTED = 0x12e
Global Const $ERROR_DELETE_PENDING = 0x12f
Global Const $ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 0x130
Global Const $ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = 0x131
Global Const $ERROR_SECURITY_STREAM_IS_INCONSISTENT = 0x132
Global Const $ERROR_INVALID_LOCK_RANGE = 0x133
Global Const $ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT = 0x134
Global Const $ERROR_NOTIFICATION_GUID_ALREADY_DEFINED = 0x135
Global Const $ERROR_MR_MID_NOT_FOUND = 0x13d
Global Const $ERROR_SCOPE_NOT_FOUND = 0x13e
Global Const $ERROR_FAIL_NOACTION_REBOOT = 0x15e
Global Const $ERROR_FAIL_SHUTDOWN = 0x15f
Global Const $ERROR_FAIL_RESTART = 0x160
Global Const $ERROR_MAX_SESSIONS_REACHED = 0x161
Global Const $ERROR_THREAD_MODE_ALREADY_BACKGROUND = 0x190
Global Const $ERROR_THREAD_MODE_NOT_BACKGROUND = 0x191
Global Const $ERROR_PROCESS_MODE_ALREADY_BACKGROUND = 0x192
Global Const $ERROR_PROCESS_MODE_NOT_BACKGROUND = 0x193
Global Const $ERROR_INVALID_ADDRESS = 0x1e7
Global Const $ERROR_USER_PROFILE_LOAD = 0x1f4
Global Const $ERROR_ARITHMETIC_OVERFLOW = 0x216
Global Const $ERROR_PIPE_CONNECTED = 0x217
Global Const $ERROR_PIPE_LISTENING = 0x218
Global Const $ERROR_VERIFIER_STOP = 0x219
Global Const $ERROR_ABIOS_ERROR = 0x21a
Global Const $ERROR_WX86_WARNING = 0x21b
Global Const $ERROR_WX86_ERROR = 0x21c
Global Const $ERROR_TIMER_NOT_CANCELED = 0x21d
Global Const $ERROR_UNWIND = 0x21e
Global Const $ERROR_BAD_STACK = 0x21f
Global Const $ERROR_INVALID_UNWIND_TARGET = 0x220
Global Const $ERROR_INVALID_PORT_ATTRIBUTES = 0x221
Global Const $ERROR_PORT_MESSAGE_TOO_LONG = 0x222
Global Const $ERROR_INVALID_QUOTA_LOWER = 0x223
Global Const $ERROR_DEVICE_ALREADY_ATTACHED = 0x224
Global Const $ERROR_INSTRUCTION_MISALIGNMENT = 0x225
Global Const $ERROR_PROFILING_NOT_STARTED = 0x226
Global Const $ERROR_PROFILING_NOT_STOPPED = 0x227
Global Const $ERROR_COULD_NOT_INTERPRET = 0x228
Global Const $ERROR_PROFILING_AT_LIMIT = 0x229
Global Const $ERROR_CANT_WAIT = 0x22a
Global Const $ERROR_CANT_TERMINATE_SELF = 0x22b
Global Const $ERROR_UNEXPECTED_MM_CREATE_ERR = 0x22c
Global Const $ERROR_UNEXPECTED_MM_MAP_ERROR = 0x22d
Global Const $ERROR_UNEXPECTED_MM_EXTEND_ERR = 0x22e
Global Const $ERROR_BAD_FUNCTION_TABLE = 0x22f
Global Const $ERROR_NO_GUID_TRANSLATION = 0x230
Global Const $ERROR_INVALID_LDT_SIZE = 0x231
Global Const $ERROR_INVALID_LDT_OFFSET = 0x233
Global Const $ERROR_INVALID_LDT_DESCRIPTOR = 0x234
Global Const $ERROR_TOO_MANY_THREADS = 0x235
Global Const $ERROR_THREAD_NOT_IN_PROCESS = 0x236
Global Const $ERROR_PAGEFILE_QUOTA_EXCEEDED = 0x237
Global Const $ERROR_LOGON_SERVER_CONFLICT = 0x238
Global Const $ERROR_SYNCHRONIZATION_REQUIRED = 0x239
Global Const $ERROR_NET_OPEN_FAILED = 0x23a
Global Const $ERROR_IO_PRIVILEGE_FAILED = 0x23b
Global Const $ERROR_CONTROL_C_EXIT = 0x23c
Global Const $ERROR_MISSING_SYSTEMFILE = 0x23d
Global Const $ERROR_UNHANDLED_EXCEPTION = 0x23e
Global Const $ERROR_APP_INIT_FAILURE = 0x23f
Global Const $ERROR_PAGEFILE_CREATE_FAILED = 0x240
Global Const $ERROR_INVALID_IMAGE_HASH = 0x241
Global Const $ERROR_NO_PAGEFILE = 0x242
Global Const $ERROR_ILLEGAL_FLOAT_CONTEXT = 0x243
Global Const $ERROR_NO_EVENT_PAIR = 0x244
Global Const $ERROR_DOMAIN_CTRLR_CONFIG_ERROR = 0x245
Global Const $ERROR_ILLEGAL_CHARACTER = 0x246
Global Const $ERROR_UNDEFINED_CHARACTER = 0x247
Global Const $ERROR_FLOPPY_VOLUME = 0x248
Global Const $ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT = 0x249
Global Const $ERROR_BACKUP_CONTROLLER = 0x24a
Global Const $ERROR_MUTANT_LIMIT_EXCEEDED = 0x24b
Global Const $ERROR_FS_DRIVER_REQUIRED = 0x24c
Global Const $ERROR_CANNOT_LOAD_REGISTRY_FILE = 0x24d
Global Const $ERROR_DEBUG_ATTACH_FAILED = 0x24e
Global Const $ERROR_SYSTEM_PROCESS_TERMINATED = 0x24f
Global Const $ERROR_DATA_NOT_ACCEPTED = 0x250
Global Const $ERROR_VDM_HARD_ERROR = 0x251
Global Const $ERROR_DRIVER_CANCEL_TIMEOUT = 0x252
Global Const $ERROR_REPLY_MESSAGE_MISMATCH = 0x253
Global Const $ERROR_LOST_WRITEBEHIND_DATA = 0x254
Global Const $ERROR_CLIENT_SERVER_PARAMETERS_INVALID = 0x255
Global Const $ERROR_NOT_TINY_STREAM = 0x256
Global Const $ERROR_STACK_OVERFLOW_READ = 0x257
Global Const $ERROR_CONVERT_TO_LARGE = 0x258
Global Const $ERROR_FOUND_OUT_OF_SCOPE = 0x259
Global Const $ERROR_ALLOCATE_BUCKET = 0x25a
Global Const $ERROR_MARSHALL_OVERFLOW = 0x25b
Global Const $ERROR_INVALID_VARIANT = 0x25c
Global Const $ERROR_BAD_COMPRESSION_BUFFER = 0x25d
Global Const $ERROR_AUDIT_FAILED = 0x25e
Global Const $ERROR_TIMER_RESOLUTION_NOT_SET = 0x25f
Global Const $ERROR_INSUFFICIENT_LOGON_INFO = 0x260
Global Const $ERROR_BAD_DLL_ENTRYPOINT = 0x261
Global Const $ERROR_BAD_SERVICE_ENTRYPOINT = 0x262
Global Const $ERROR_IP_ADDRESS_CONFLICT1 = 0x263
Global Const $ERROR_IP_ADDRESS_CONFLICT2 = 0x264
Global Const $ERROR_REGISTRY_QUOTA_LIMIT = 0x265
Global Const $ERROR_NO_CALLBACK_ACTIVE = 0x266
Global Const $ERROR_PWD_TOO_SHORT = 0x267
Global Const $ERROR_PWD_TOO_RECENT = 0x268
Global Const $ERROR_PWD_HISTORY_CONFLICT = 0x269
Global Const $ERROR_UNSUPPORTED_COMPRESSION = 0x26a
Global Const $ERROR_INVALID_HW_PROFILE = 0x26b
Global Const $ERROR_INVALID_PLUGPLAY_DEVICE_PATH = 0x26c
Global Const $ERROR_QUOTA_LIST_INCONSISTENT = 0x26d
Global Const $ERROR_EVALUATION_EXPIRATION = 0x26e
Global Const $ERROR_ILLEGAL_DLL_RELOCATION = 0x26f
Global Const $ERROR_DLL_INIT_FAILED_LOGOFF = 0x270
Global Const $ERROR_VALIDATE_CONTINUE = 0x271
Global Const $ERROR_NO_MORE_MATCHES = 0x272
Global Const $ERROR_RANGE_LIST_CONFLICT = 0x273
Global Const $ERROR_SERVER_SID_MISMATCH = 0x274
Global Const $ERROR_CANT_ENABLE_DENY_ONLY = 0x275
Global Const $ERROR_FLOAT_MULTIPLE_FAULTS = 0x276
Global Const $ERROR_FLOAT_MULTIPLE_TRAPS = 0x277
Global Const $ERROR_NOINTERFACE = 0x278
Global Const $ERROR_DRIVER_FAILED_SLEEP = 0x279
Global Const $ERROR_CORRUPT_SYSTEM_FILE = 0x27a
Global Const $ERROR_COMMITMENT_MINIMUM = 0x27b
Global Const $ERROR_PNP_RESTART_ENUMERATION = 0x27c
Global Const $ERROR_SYSTEM_IMAGE_BAD_SIGNATURE = 0x27d
Global Const $ERROR_PNP_REBOOT_REQUIRED = 0x27e
Global Const $ERROR_INSUFFICIENT_POWER = 0x27f
Global Const $ERROR_MULTIPLE_FAULT_VIOLATION = 0x280
Global Const $ERROR_SYSTEM_SHUTDOWN = 0x281
Global Const $ERROR_PORT_NOT_SET = 0x282
Global Const $ERROR_DS_VERSION_CHECK_FAILURE = 0x283
Global Const $ERROR_RANGE_NOT_FOUND = 0x284
Global Const $ERROR_NOT_SAFE_MODE_DRIVER = 0x286
Global Const $ERROR_FAILED_DRIVER_ENTRY = 0x287
Global Const $ERROR_DEVICE_ENUMERATION_ERROR = 0x288
Global Const $ERROR_MOUNT_POINT_NOT_RESOLVED = 0x289
Global Const $ERROR_INVALID_DEVICE_OBJECT_PARAMETER = 0x28a
Global Const $ERROR_MCA_OCCURED = 0x28b
Global Const $ERROR_DRIVER_DATABASE_ERROR = 0x28c
Global Const $ERROR_SYSTEM_HIVE_TOO_LARGE = 0x28d
Global Const $ERROR_DRIVER_FAILED_PRIOR_UNLOAD = 0x28e
Global Const $ERROR_VOLSNAP_PREPARE_HIBERNATE = 0x28f
Global Const $ERROR_HIBERNATION_FAILURE = 0x290
Global Const $ERROR_FILE_SYSTEM_LIMITATION = 0x299
Global Const $ERROR_ASSERTION_FAILURE = 0x29c
Global Const $ERROR_ACPI_ERROR = 0x29d
Global Const $ERROR_WOW_ASSERTION = 0x29e
Global Const $ERROR_PNP_BAD_MPS_TABLE = 0x29f
Global Const $ERROR_PNP_TRANSLATION_FAILED = 0x2a0
Global Const $ERROR_PNP_IRQ_TRANSLATION_FAILED = 0x2a1
Global Const $ERROR_PNP_INVALID_ID = 0x2a2
Global Const $ERROR_WAKE_SYSTEM_DEBUGGER = 0x2a3
Global Const $ERROR_HANDLES_CLOSED = 0x2a4
Global Const $ERROR_EXTRANEOUS_INFORMATION = 0x2a5
Global Const $ERROR_RXACT_COMMIT_NECESSARY = 0x2a6
Global Const $ERROR_MEDIA_CHECK = 0x2a7
Global Const $ERROR_GUID_SUBSTITUTION_MADE = 0x2a8
Global Const $ERROR_STOPPED_ON_SYMLINK = 0x2a9
Global Const $ERROR_LONGJUMP = 0x2aa
Global Const $ERROR_PLUGPLAY_QUERY_VETOED = 0x2ab
Global Const $ERROR_UNWIND_CONSOLIDATE = 0x2ac
Global Const $ERROR_REGISTRY_HIVE_RECOVERED = 0x2ad
Global Const $ERROR_DLL_MIGHT_BE_INSECURE = 0x2ae
Global Const $ERROR_DLL_MIGHT_BE_INCOMPATIBLE = 0x2af
Global Const $ERROR_DBG_EXCEPTION_NOT_HANDLED = 0x2b0
Global Const $ERROR_DBG_REPLY_LATER = 0x2b1
Global Const $ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE = 0x2b2
Global Const $ERROR_DBG_TERMINATE_THREAD = 0x2b3
Global Const $ERROR_DBG_TERMINATE_PROCESS = 0x2b4
Global Const $ERROR_DBG_CONTROL_C = 0x2b5
Global Const $ERROR_DBG_PRINTEXCEPTION_C = 0x2b6
Global Const $ERROR_DBG_RIPEXCEPTION = 0x2b7
Global Const $ERROR_DBG_CONTROL_BREAK = 0x2b8
Global Const $ERROR_DBG_COMMAND_EXCEPTION = 0x2b9
Global Const $ERROR_OBJECT_NAME_EXISTS = 0x2ba
Global Const $ERROR_THREAD_WAS_SUSPENDED = 0x2bb
Global Const $ERROR_IMAGE_NOT_AT_BASE = 0x2bc
Global Const $ERROR_RXACT_STATE_CREATED = 0x2bd
Global Const $ERROR_SEGMENT_NOTIFICATION = 0x2be
Global Const $ERROR_BAD_CURRENT_DIRECTORY = 0x2bf
Global Const $ERROR_FT_READ_RECOVERY_FROM_BACKUP = 0x2c0
Global Const $ERROR_FT_WRITE_RECOVERY = 0x2c1
Global Const $ERROR_IMAGE_MACHINE_TYPE_MISMATCH = 0x2c2
Global Const $ERROR_RECEIVE_PARTIAL = 0x2c3
Global Const $ERROR_RECEIVE_EXPEDITED = 0x2c4
Global Const $ERROR_RECEIVE_PARTIAL_EXPEDITED = 0x2c5
Global Const $ERROR_EVENT_DONE = 0x2c6
Global Const $ERROR_EVENT_PENDING = 0x2c7
Global Const $ERROR_CHECKING_FILE_SYSTEM = 0x2c8
Global Const $ERROR_FATAL_APP_EXIT = 0x2c9
Global Const $ERROR_PREDEFINED_HANDLE = 0x2ca
Global Const $ERROR_WAS_UNLOCKED = 0x2cb
Global Const $ERROR_SERVICE_NOTIFICATION = 0x2cc
Global Const $ERROR_WAS_LOCKED = 0x2cd
Global Const $ERROR_LOG_HARD_ERROR = 0x2ce
Global Const $ERROR_ALREADY_WIN32 = 0x2cf
Global Const $ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE = 0x2d0
Global Const $ERROR_NO_YIELD_PERFORMED = 0x2d1
Global Const $ERROR_TIMER_RESUME_IGNORED = 0x2d2
Global Const $ERROR_ARBITRATION_UNHANDLED = 0x2d3
Global Const $ERROR_CARDBUS_NOT_SUPPORTED = 0x2d4
Global Const $ERROR_MP_PROCESSOR_MISMATCH = 0x2d5
Global Const $ERROR_HIBERNATED = 0x2d6
Global Const $ERROR_RESUME_HIBERNATION = 0x2d7
Global Const $ERROR_FIRMWARE_UPDATED = 0x2d8
Global Const $ERROR_DRIVERS_LEAKING_LOCKED_PAGES = 0x2d9
Global Const $ERROR_WAKE_SYSTEM = 0x2da
Global Const $ERROR_WAIT_1 = 0x2db
Global Const $ERROR_WAIT_2 = 0x2dc
Global Const $ERROR_WAIT_3 = 0x2dd
Global Const $ERROR_WAIT_63 = 0x2de
Global Const $ERROR_ABANDONED_WAIT_0 = 0x2df
Global Const $ERROR_ABANDONED_WAIT_63 = 0x2e0
Global Const $ERROR_USER_APC = 0x2e1
Global Const $ERROR_KERNEL_APC = 0x2e2
Global Const $ERROR_ALERTED = 0x2e3
Global Const $ERROR_ELEVATION_REQUIRED = 0x2e4
Global Const $ERROR_REPARSE = 0x2e5
Global Const $ERROR_OPLOCK_BREAK_IN_PROGRESS = 0x2e6
Global Const $ERROR_VOLUME_MOUNTED = 0x2e7
Global Const $ERROR_RXACT_COMMITTED = 0x2e8
Global Const $ERROR_NOTIFY_CLEANUP = 0x2e9
Global Const $ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED = 0x2ea
Global Const $ERROR_PAGE_FAULT_TRANSITION = 0x2eb
Global Const $ERROR_PAGE_FAULT_DEMAND_ZERO = 0x2ec
Global Const $ERROR_PAGE_FAULT_COPY_ON_WRITE = 0x2ed
Global Const $ERROR_PAGE_FAULT_GUARD_PAGE = 0x2ee
Global Const $ERROR_PAGE_FAULT_PAGING_FILE = 0x2ef
Global Const $ERROR_CACHE_PAGE_LOCKED = 0x2f0
Global Const $ERROR_CRASH_DUMP = 0x2f1
Global Const $ERROR_BUFFER_ALL_ZEROS = 0x2f2
Global Const $ERROR_REPARSE_OBJECT = 0x2f3
Global Const $ERROR_RESOURCE_REQUIREMENTS_CHANGED = 0x2f4
Global Const $ERROR_TRANSLATION_COMPLETE = 0x2f5
Global Const $ERROR_NOTHING_TO_TERMINATE = 0x2f6
Global Const $ERROR_PROCESS_NOT_IN_JOB = 0x2f7
Global Const $ERROR_PROCESS_IN_JOB = 0x2f8
Global Const $ERROR_VOLSNAP_HIBERNATE_READY = 0x2f9
Global Const $ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY = 0x2fa
Global Const $ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED = 0x2fb
Global Const $ERROR_INTERRUPT_STILL_CONNECTED = 0x2fc
Global Const $ERROR_WAIT_FOR_OPLOCK = 0x2fd
Global Const $ERROR_DBG_EXCEPTION_HANDLED = 0x2fe
Global Const $ERROR_DBG_CONTINUE = 0x2ff
Global Const $ERROR_CALLBACK_POP_STACK = 0x300
Global Const $ERROR_COMPRESSION_DISABLED = 0x301
Global Const $ERROR_CANTFETCHBACKWARDS = 0x302
Global Const $ERROR_CANTSCROLLBACKWARDS = 0x303
Global Const $ERROR_ROWSNOTRELEASED = 0x304
Global Const $ERROR_BAD_ACCESSOR_FLAGS = 0x305
Global Const $ERROR_ERRORS_ENCOUNTERED = 0x306
Global Const $ERROR_NOT_CAPABLE = 0x307
Global Const $ERROR_REQUEST_OUT_OF_SEQUENCE = 0x308
Global Const $ERROR_VERSION_PARSE_ERROR = 0x309
Global Const $ERROR_BADSTARTPOSITION = 0x30a
Global Const $ERROR_MEMORY_HARDWARE = 0x30b
Global Const $ERROR_DISK_REPAIR_DISABLED = 0x30c
Global Const $ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = 0x30d
Global Const $ERROR_SYSTEM_POWERSTATE_TRANSITION = 0x30e
Global Const $ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = 0x30f
Global Const $ERROR_MCA_EXCEPTION = 0x310
Global Const $ERROR_ACCESS_AUDIT_BY_POLICY = 0x311
Global Const $ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = 0x312
Global Const $ERROR_ABANDON_HIBERFILE = 0x313
Global Const $ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = 0x314
Global Const $ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = 0x315
Global Const $ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = 0x316
Global Const $ERROR_BAD_MCFG_TABLE = 0x317
Global Const $ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE = 0x320
Global Const $ERROR_CANNOT_GRANT_REQUESTED_OPLOCK = 0x321
Global Const $ERROR_CANNOT_BREAK_OPLOCK = 0x322
Global Const $ERROR_OPLOCK_HANDLE_CLOSED = 0x323
Global Const $ERROR_NO_ACE_CONDITION = 0x324
Global Const $ERROR_INVALID_ACE_CONDITION = 0x325
Global Const $ERROR_EA_ACCESS_DENIED = 0x3e2
Global Const $ERROR_OPERATION_ABORTED = 0x3e3
Global Const $ERROR_IO_INCOMPLETE = 0x3e4
Global Const $ERROR_IO_PENDING = 0x3e5
Global Const $ERROR_NOACCESS = 0x3e6
Global Const $ERROR_SWAPERROR = 0x3e7
Global Const $ERROR_STACK_OVERFLOW = 0x3e9
Global Const $ERROR_INVALID_MESSAGE = 0x3ea
Global Const $ERROR_CAN_NOT_COMPLETE = 0x3eb
Global Const $ERROR_INVALID_FLAGS = 0x3ec
Global Const $ERROR_UNRECOGNIZED_VOLUME = 0x3ed
Global Const $ERROR_FILE_INVALID = 0x3ee
Global Const $ERROR_FULLSCREEN_MODE = 0x3ef
Global Const $ERROR_NO_TOKEN = 0x3f0
Global Const $ERROR_BADDB = 0x3f1
Global Const $ERROR_BADKEY = 0x3f2
Global Const $ERROR_CANTOPEN = 0x3f3
Global Const $ERROR_CANTREAD = 0x3f4
Global Const $ERROR_CANTWRITE = 0x3f5
Global Const $ERROR_REGISTRY_RECOVERED = 0x3f6
Global Const $ERROR_REGISTRY_CORRUPT = 0x3f7
Global Const $ERROR_REGISTRY_IO_FAILED = 0x3f8
Global Const $ERROR_NOT_REGISTRY_FILE = 0x3f9
Global Const $ERROR_KEY_DELETED = 0x3fa
Global Const $ERROR_NO_LOG_SPACE = 0x3fb
Global Const $ERROR_KEY_HAS_CHILDREN = 0x3fc
Global Const $ERROR_CHILD_MUST_BE_VOLATILE = 0x3fd
Global Const $ERROR_NOTIFY_ENUM_DIR = 0x3fe
Global Const $ERROR_DEPENDENT_SERVICES_RUNNING = 0x41b
Global Const $ERROR_INVALID_SERVICE_CONTROL = 0x41c
Global Const $ERROR_SERVICE_REQUEST_TIMEOUT = 0x41d
Global Const $ERROR_SERVICE_NO_THREAD = 0x41e
Global Const $ERROR_SERVICE_DATABASE_LOCKED = 0x41f
Global Const $ERROR_SERVICE_ALREADY_RUNNING = 0x420
Global Const $ERROR_INVALID_SERVICE_ACCOUNT = 0x421
Global Const $ERROR_SERVICE_DISABLED = 0x422
Global Const $ERROR_CIRCULAR_DEPENDENCY = 0x423
Global Const $ERROR_SERVICE_DOES_NOT_EXIST = 0x424
Global Const $ERROR_SERVICE_CANNOT_ACCEPT_CTRL = 0x425
Global Const $ERROR_SERVICE_NOT_ACTIVE = 0x426
Global Const $ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 0x427
Global Const $ERROR_EXCEPTION_IN_SERVICE = 0x428
Global Const $ERROR_DATABASE_DOES_NOT_EXIST = 0x429
Global Const $ERROR_SERVICE_SPECIFIC_ERROR = 0x42a
Global Const $ERROR_PROCESS_ABORTED = 0x42b
Global Const $ERROR_SERVICE_DEPENDENCY_FAIL = 0x42c
Global Const $ERROR_SERVICE_LOGON_FAILED = 0x42d
Global Const $ERROR_SERVICE_START_HANG = 0x42e
Global Const $ERROR_INVALID_SERVICE_LOCK = 0x42f
Global Const $ERROR_SERVICE_MARKED_FOR_DELETE = 0x430
Global Const $ERROR_SERVICE_EXISTS = 0x431
Global Const $ERROR_ALREADY_RUNNING_LKG = 0x432
Global Const $ERROR_SERVICE_DEPENDENCY_DELETED = 0x433
Global Const $ERROR_BOOT_ALREADY_ACCEPTED = 0x434
Global Const $ERROR_SERVICE_NEVER_STARTED = 0x435
Global Const $ERROR_DUPLICATE_SERVICE_NAME = 0x436
Global Const $ERROR_DIFFERENT_SERVICE_ACCOUNT = 0x437
Global Const $ERROR_CANNOT_DETECT_DRIVER_FAILURE = 0x438
Global Const $ERROR_CANNOT_DETECT_PROCESS_ABORT = 0x439
Global Const $ERROR_NO_RECOVERY_PROGRAM = 0x43a
Global Const $ERROR_SERVICE_NOT_IN_EXE = 0x43b
Global Const $ERROR_NOT_SAFEBOOT_SERVICE = 0x43c
Global Const $ERROR_END_OF_MEDIA = 0x44c
Global Const $ERROR_FILEMARK_DETECTED = 0x44d
Global Const $ERROR_BEGINNING_OF_MEDIA = 0x44e
Global Const $ERROR_SETMARK_DETECTED = 0x44f
Global Const $ERROR_NO_DATA_DETECTED = 0x450
Global Const $ERROR_PARTITION_FAILURE = 0x451
Global Const $ERROR_INVALID_BLOCK_LENGTH = 0x452
Global Const $ERROR_DEVICE_NOT_PARTITIONED = 0x453
Global Const $ERROR_UNABLE_TO_LOCK_MEDIA = 0x454
Global Const $ERROR_UNABLE_TO_UNLOAD_MEDIA = 0x455
Global Const $ERROR_MEDIA_CHANGED = 0x456
Global Const $ERROR_BUS_RESET = 0x457
Global Const $ERROR_NO_MEDIA_IN_DRIVE = 0x458
Global Const $ERROR_NO_UNICODE_TRANSLATION = 0x459
Global Const $ERROR_DLL_INIT_FAILED = 0x45a
Global Const $ERROR_SHUTDOWN_IN_PROGRESS = 0x45b
Global Const $ERROR_NO_SHUTDOWN_IN_PROGRESS = 0x45c
Global Const $ERROR_IO_DEVICE = 0x45d
Global Const $ERROR_SERIAL_NO_DEVICE = 0x45e
Global Const $ERROR_IRQ_BUSY = 0x45f
Global Const $ERROR_MORE_WRITES = 0x460
Global Const $ERROR_COUNTER_TIMEOUT = 0x461
Global Const $ERROR_FLOPPY_ID_MARK_NOT_FOUND = 0x462
Global Const $ERROR_FLOPPY_WRONG_CYLINDER = 0x463
Global Const $ERROR_FLOPPY_UNKNOWN_ERROR = 0x464
Global Const $ERROR_FLOPPY_BAD_REGISTERS = 0x465
Global Const $ERROR_DISK_RECALIBRATE_FAILED = 0x466
Global Const $ERROR_DISK_OPERATION_FAILED = 0x467
Global Const $ERROR_DISK_RESET_FAILED = 0x468
Global Const $ERROR_EOM_OVERFLOW = 0x469
Global Const $ERROR_NOT_ENOUGH_SERVER_MEMORY = 0x46a
Global Const $ERROR_POSSIBLE_DEADLOCK = 0x46b
Global Const $ERROR_MAPPED_ALIGNMENT = 0x46c
Global Const $ERROR_SET_POWER_STATE_VETOED = 0x474
Global Const $ERROR_SET_POWER_STATE_FAILED = 0x475
Global Const $ERROR_TOO_MANY_LINKS = 0x476
Global Const $ERROR_OLD_WIN_VERSION = 0x47e
Global Const $ERROR_APP_WRONG_OS = 0x47f
Global Const $ERROR_SINGLE_INSTANCE_APP = 0x480
Global Const $ERROR_RMODE_APP = 0x481
Global Const $ERROR_INVALID_DLL = 0x482
Global Const $ERROR_NO_ASSOCIATION = 0x483
Global Const $ERROR_DDE_FAIL = 0x484
Global Const $ERROR_DLL_NOT_FOUND = 0x485
Global Const $ERROR_NO_MORE_USER_HANDLES = 0x486
Global Const $ERROR_MESSAGE_SYNC_ONLY = 0x487
Global Const $ERROR_SOURCE_ELEMENT_EMPTY = 0x488
Global Const $ERROR_DESTINATION_ELEMENT_FULL = 0x489
Global Const $ERROR_ILLEGAL_ELEMENT_ADDRESS = 0x48a
Global Const $ERROR_MAGAZINE_NOT_PRESENT = 0x48b
Global Const $ERROR_DEVICE_REINITIALIZATION_NEEDED = 0x48c
Global Const $ERROR_DEVICE_REQUIRES_CLEANING = 0x48d
Global Const $ERROR_DEVICE_DOOR_OPEN = 0x48e
Global Const $ERROR_DEVICE_NOT_CONNECTED = 0x48f
Global Const $ERROR_NOT_FOUND = 0x490
Global Const $ERROR_NO_MATCH = 0x491
Global Const $ERROR_SET_NOT_FOUND = 0x492
Global Const $ERROR_POINT_NOT_FOUND = 0x493
Global Const $ERROR_NO_TRACKING_SERVICE = 0x494
Global Const $ERROR_NO_VOLUME_ID = 0x495
Global Const $ERROR_UNABLE_TO_REMOVE_REPLACED = 0x497
Global Const $ERROR_UNABLE_TO_MOVE_REPLACEMENT = 0x498
Global Const $ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 = 0x499
Global Const $ERROR_JOURNAL_DELETE_IN_PROGRESS = 0x49a
Global Const $ERROR_JOURNAL_NOT_ACTIVE = 0x49b
Global Const $ERROR_POTENTIAL_FILE_FOUND = 0x49c
Global Const $ERROR_JOURNAL_ENTRY_DELETED = 0x49d
Global Const $ERROR_SHUTDOWN_IS_SCHEDULED = 0x4a6
Global Const $ERROR_SHUTDOWN_USERS_LOGGED_ON = 0x4a7
Global Const $ERROR_BAD_DEVICE = 0x4b0
Global Const $ERROR_CONNECTION_UNAVAIL = 0x4b1
Global Const $ERROR_DEVICE_ALREADY_REMEMBERED = 0x4b2
Global Const $ERROR_NO_NET_OR_BAD_PATH = 0x4b3
Global Const $ERROR_BAD_PROVIDER = 0x4b4
Global Const $ERROR_CANNOT_OPEN_PROFILE = 0x4b5
Global Const $ERROR_BAD_PROFILE = 0x4b6
Global Const $ERROR_NOT_CONTAINER = 0x4b7
Global Const $ERROR_EXTENDED_ERROR = 0x4b8
Global Const $ERROR_INVALID_GROUPNAME = 0x4b9
Global Const $ERROR_INVALID_COMPUTERNAME = 0x4ba
Global Const $ERROR_INVALID_EVENTNAME = 0x4bb
Global Const $ERROR_INVALID_DOMAINNAME = 0x4bc
Global Const $ERROR_INVALID_SERVICENAME = 0x4bd
Global Const $ERROR_INVALID_NETNAME = 0x4be
Global Const $ERROR_INVALID_SHARENAME = 0x4bf
Global Const $ERROR_INVALID_PASSWORDNAME = 0x4c0
Global Const $ERROR_INVALID_MESSAGENAME = 0x4c1
Global Const $ERROR_INVALID_MESSAGEDEST = 0x4c2
Global Const $ERROR_SESSION_CREDENTIAL_CONFLICT = 0x4c3
Global Const $ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = 0x4c4
Global Const $ERROR_DUP_DOMAINNAME = 0x4c5
Global Const $ERROR_NO_NETWORK = 0x4c6
Global Const $ERROR_CANCELLED = 0x4c7
Global Const $ERROR_USER_MAPPED_FILE = 0x4c8
Global Const $ERROR_CONNECTION_REFUSED = 0x4c9
Global Const $ERROR_GRACEFUL_DISCONNECT = 0x4ca
Global Const $ERROR_ADDRESS_ALREADY_ASSOCIATED = 0x4cb
Global Const $ERROR_ADDRESS_NOT_ASSOCIATED = 0x4cc
Global Const $ERROR_CONNECTION_INVALID = 0x4cd
Global Const $ERROR_CONNECTION_ACTIVE = 0x4ce
Global Const $ERROR_NETWORK_UNREACHABLE = 0x4cf
Global Const $ERROR_HOST_UNREACHABLE = 0x4d0
Global Const $ERROR_PROTOCOL_UNREACHABLE = 0x4d1
Global Const $ERROR_PORT_UNREACHABLE = 0x4d2
Global Const $ERROR_REQUEST_ABORTED = 0x4d3
Global Const $ERROR_CONNECTION_ABORTED = 0x4d4
Global Const $ERROR_RETRY = 0x4d5
Global Const $ERROR_CONNECTION_COUNT_LIMIT = 0x4d6
Global Const $ERROR_LOGIN_TIME_RESTRICTION = 0x4d7
Global Const $ERROR_LOGIN_WKSTA_RESTRICTION = 0x4d8
Global Const $ERROR_INCORRECT_ADDRESS = 0x4d9
Global Const $ERROR_ALREADY_REGISTERED = 0x4da
Global Const $ERROR_SERVICE_NOT_FOUND = 0x4db
Global Const $ERROR_NOT_AUTHENTICATED = 0x4dc
Global Const $ERROR_NOT_LOGGED_ON = 0x4dd
Global Const $ERROR_CONTINUE = 0x4de
Global Const $ERROR_ALREADY_INITIALIZED = 0x4df
Global Const $ERROR_NO_MORE_DEVICES = 0x4e0
Global Const $ERROR_NO_SUCH_SITE = 0x4e1
Global Const $ERROR_DOMAIN_CONTROLLER_EXISTS = 0x4e2
Global Const $ERROR_ONLY_IF_CONNECTED = 0x4e3
Global Const $ERROR_OVERRIDE_NOCHANGES = 0x4e4
Global Const $ERROR_BAD_USER_PROFILE = 0x4e5
Global Const $ERROR_NOT_SUPPORTED_ON_SBS = 0x4e6
Global Const $ERROR_SERVER_SHUTDOWN_IN_PROGRESS = 0x4e7
Global Const $ERROR_HOST_DOWN = 0x4e8
Global Const $ERROR_NON_ACCOUNT_SID = 0x4e9
Global Const $ERROR_NON_DOMAIN_SID = 0x4ea
Global Const $ERROR_APPHELP_BLOCK = 0x4eb
Global Const $ERROR_ACCESS_DISABLED_BY_POLICY = 0x4ec
Global Const $ERROR_REG_NAT_CONSUMPTION = 0x4ed
Global Const $ERROR_CSCSHARE_OFFLINE = 0x4ee
Global Const $ERROR_PKINIT_FAILURE = 0x4ef
Global Const $ERROR_SMARTCARD_SUBSYSTEM_FAILURE = 0x4f0
Global Const $ERROR_DOWNGRADE_DETECTED = 0x4f1
Global Const $ERROR_MACHINE_LOCKED = 0x4f7
Global Const $ERROR_CALLBACK_SUPPLIED_INVALID_DATA = 0x4f9
Global Const $ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED = 0x4fa
Global Const $ERROR_DRIVER_BLOCKED = 0x4fb
Global Const $ERROR_INVALID_IMPORT_OF_NON_DLL = 0x4fc
Global Const $ERROR_ACCESS_DISABLED_WEBBLADE = 0x4fd
Global Const $ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER = 0x4fe
Global Const $ERROR_RECOVERY_FAILURE = 0x4ff
Global Const $ERROR_ALREADY_FIBER = 0x500
Global Const $ERROR_ALREADY_THREAD = 0x501
Global Const $ERROR_STACK_BUFFER_OVERRUN = 0x502
Global Const $ERROR_PARAMETER_QUOTA_EXCEEDED = 0x503
Global Const $ERROR_DEBUGGER_INACTIVE = 0x504
Global Const $ERROR_DELAY_LOAD_FAILED = 0x505
Global Const $ERROR_VDM_DISALLOWED = 0x506
Global Const $ERROR_UNIDENTIFIED_ERROR = 0x507
Global Const $ERROR_INVALID_CRUNTIME_PARAMETER = 0x508
Global Const $ERROR_BEYOND_VDL = 0x509
Global Const $ERROR_INCOMPATIBLE_SERVICE_SID_TYPE = 0x50a
Global Const $ERROR_DRIVER_PROCESS_TERMINATED = 0x50b
Global Const $ERROR_IMPLEMENTATION_LIMIT = 0x50c
Global Const $ERROR_PROCESS_IS_PROTECTED = 0x50d
Global Const $ERROR_SERVICE_NOTIFY_CLIENT_LAGGING = 0x50e
Global Const $ERROR_DISK_QUOTA_EXCEEDED = 0x50f
Global Const $ERROR_CONTENT_BLOCKED = 0x510
Global Const $ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE = 0x511
Global Const $ERROR_APP_HANG = 0x512
Global Const $ERROR_INVALID_LABEL = 0x513
Global Const $ERROR_NOT_ALL_ASSIGNED = 0x514
Global Const $ERROR_SOME_NOT_MAPPED = 0x515
Global Const $ERROR_NO_QUOTAS_FOR_ACCOUNT = 0x516
Global Const $ERROR_LOCAL_USER_SESSION_KEY = 0x517
Global Const $ERROR_NULL_LM_PASSWORD = 0x518
Global Const $ERROR_UNKNOWN_REVISION = 0x519
Global Const $ERROR_REVISION_MISMATCH = 0x51a
Global Const $ERROR_INVALID_OWNER = 0x51b
Global Const $ERROR_INVALID_PRIMARY_GROUP = 0x51c
Global Const $ERROR_NO_IMPERSONATION_TOKEN = 0x51d
Global Const $ERROR_CANT_DISABLE_MANDATORY = 0x51e
Global Const $ERROR_NO_LOGON_SERVERS = 0x51f
Global Const $ERROR_NO_SUCH_LOGON_SESSION = 0x520
Global Const $ERROR_NO_SUCH_PRIVILEGE = 0x521
Global Const $ERROR_PRIVILEGE_NOT_HELD = 0x522
Global Const $ERROR_INVALID_ACCOUNT_NAME = 0x523
Global Const $ERROR_USER_EXISTS = 0x524
Global Const $ERROR_NO_SUCH_USER = 0x525
Global Const $ERROR_GROUP_EXISTS = 0x526
Global Const $ERROR_NO_SUCH_GROUP = 0x527
Global Const $ERROR_MEMBER_IN_GROUP = 0x528
Global Const $ERROR_MEMBER_NOT_IN_GROUP = 0x529
Global Const $ERROR_LAST_ADMIN = 0x52a
Global Const $ERROR_WRONG_PASSWORD = 0x52b
Global Const $ERROR_ILL_FORMED_PASSWORD = 0x52c
Global Const $ERROR_PASSWORD_RESTRICTION = 0x52d
Global Const $ERROR_LOGON_FAILURE = 0x52e
Global Const $ERROR_ACCOUNT_RESTRICTION = 0x52f
Global Const $ERROR_INVALID_LOGON_HOURS = 0x530
Global Const $ERROR_INVALID_WORKSTATION = 0x531
Global Const $ERROR_PASSWORD_EXPIRED = 0x532
Global Const $ERROR_ACCOUNT_DISABLED = 0x533
Global Const $ERROR_NONE_MAPPED = 0x534
Global Const $ERROR_TOO_MANY_LUIDS_REQUESTED = 0x535
Global Const $ERROR_LUIDS_EXHAUSTED = 0x536
Global Const $ERROR_INVALID_SUB_AUTHORITY = 0x537
Global Const $ERROR_INVALID_ACL = 0x538
Global Const $ERROR_INVALID_SID = 0x539
Global Const $ERROR_INVALID_SECURITY_DESCR = 0x53a
Global Const $ERROR_BAD_INHERITANCE_ACL = 0x53c
Global Const $ERROR_SERVER_DISABLED = 0x53d
Global Const $ERROR_SERVER_NOT_DISABLED = 0x53e
Global Const $ERROR_INVALID_ID_AUTHORITY = 0x53f
Global Const $ERROR_ALLOTTED_SPACE_EXCEEDED = 0x540
Global Const $ERROR_INVALID_GROUP_ATTRIBUTES = 0x541
Global Const $ERROR_BAD_IMPERSONATION_LEVEL = 0x542
Global Const $ERROR_CANT_OPEN_ANONYMOUS = 0x543
Global Const $ERROR_BAD_VALIDATION_CLASS = 0x544
Global Const $ERROR_BAD_TOKEN_TYPE = 0x545
Global Const $ERROR_NO_SECURITY_ON_OBJECT = 0x546
Global Const $ERROR_CANT_ACCESS_DOMAIN_INFO = 0x547
Global Const $ERROR_INVALID_SERVER_STATE = 0x548
Global Const $ERROR_INVALID_DOMAIN_STATE = 0x549
Global Const $ERROR_INVALID_DOMAIN_ROLE = 0x54a
Global Const $ERROR_NO_SUCH_DOMAIN = 0x54b
Global Const $ERROR_DOMAIN_EXISTS = 0x54c
Global Const $ERROR_DOMAIN_LIMIT_EXCEEDED = 0x54d
Global Const $ERROR_INTERNAL_DB_CORRUPTION = 0x54e
Global Const $ERROR_INTERNAL_ERROR = 0x54f
Global Const $ERROR_GENERIC_NOT_MAPPED = 0x550
Global Const $ERROR_BAD_DESCRIPTOR_FORMAT = 0x551
Global Const $ERROR_NOT_LOGON_PROCESS = 0x552
Global Const $ERROR_LOGON_SESSION_EXISTS = 0x553
Global Const $ERROR_NO_SUCH_PACKAGE = 0x554
Global Const $ERROR_BAD_LOGON_SESSION_STATE = 0x555
Global Const $ERROR_LOGON_SESSION_COLLISION = 0x556
Global Const $ERROR_INVALID_LOGON_TYPE = 0x557
Global Const $ERROR_CANNOT_IMPERSONATE = 0x558
Global Const $ERROR_RXACT_INVALID_STATE = 0x559
Global Const $ERROR_RXACT_COMMIT_FAILURE = 0x55a
Global Const $ERROR_SPECIAL_ACCOUNT = 0x55b
Global Const $ERROR_SPECIAL_GROUP = 0x55c
Global Const $ERROR_SPECIAL_USER = 0x55d
Global Const $ERROR_MEMBERS_PRIMARY_GROUP = 0x55e
Global Const $ERROR_TOKEN_ALREADY_IN_USE = 0x55f
Global Const $ERROR_NO_SUCH_ALIAS = 0x560
Global Const $ERROR_MEMBER_NOT_IN_ALIAS = 0x561
Global Const $ERROR_MEMBER_IN_ALIAS = 0x562
Global Const $ERROR_ALIAS_EXISTS = 0x563
Global Const $ERROR_LOGON_NOT_GRANTED = 0x564
Global Const $ERROR_TOO_MANY_SECRETS = 0x565
Global Const $ERROR_SECRET_TOO_LONG = 0x566
Global Const $ERROR_INTERNAL_DB_ERROR = 0x567
Global Const $ERROR_TOO_MANY_CONTEXT_IDS = 0x568
Global Const $ERROR_LOGON_TYPE_NOT_GRANTED = 0x569
Global Const $ERROR_NT_CROSS_ENCRYPTION_REQUIRED = 0x56a
Global Const $ERROR_NO_SUCH_MEMBER = 0x56b
Global Const $ERROR_INVALID_MEMBER = 0x56c
Global Const $ERROR_TOO_MANY_SIDS = 0x56d
Global Const $ERROR_LM_CROSS_ENCRYPTION_REQUIRED = 0x56e
Global Const $ERROR_NO_INHERITANCE = 0x56f
Global Const $ERROR_FILE_CORRUPT = 0x570
Global Const $ERROR_DISK_CORRUPT = 0x571
Global Const $ERROR_NO_USER_SESSION_KEY = 0x572
Global Const $ERROR_LICENSE_QUOTA_EXCEEDED = 0x573
Global Const $ERROR_WRONG_TARGET_NAME = 0x574
Global Const $ERROR_MUTUAL_AUTH_FAILED = 0x575
Global Const $ERROR_TIME_SKEW = 0x576
Global Const $ERROR_CURRENT_DOMAIN_NOT_ALLOWED = 0x577
Global Const $ERROR_INVALID_WINDOW_HANDLE = 0x578
Global Const $ERROR_INVALID_MENU_HANDLE = 0x579
Global Const $ERROR_INVALID_CURSOR_HANDLE = 0x57a
Global Const $ERROR_INVALID_ACCEL_HANDLE = 0x57b
Global Const $ERROR_INVALID_HOOK_HANDLE = 0x57c
Global Const $ERROR_INVALID_DWP_HANDLE = 0x57d
Global Const $ERROR_TLW_WITH_WSCHILD = 0x57e
Global Const $ERROR_CANNOT_FIND_WND_CLASS = 0x57f
Global Const $ERROR_WINDOW_OF_OTHER_THREAD = 0x580
Global Const $ERROR_HOTKEY_ALREADY_REGISTERED = 0x581
Global Const $ERROR_CLASS_ALREADY_EXISTS = 0x582
Global Const $ERROR_CLASS_DOES_NOT_EXIST = 0x583
Global Const $ERROR_CLASS_HAS_WINDOWS = 0x584
Global Const $ERROR_INVALID_INDEX = 0x585
Global Const $ERROR_INVALID_ICON_HANDLE = 0x586
Global Const $ERROR_PRIVATE_DIALOG_INDEX = 0x587
Global Const $ERROR_LISTBOX_ID_NOT_FOUND = 0x588
Global Const $ERROR_NO_WILDCARD_CHARACTERS = 0x589
Global Const $ERROR_CLIPBOARD_NOT_OPEN = 0x58a
Global Const $ERROR_HOTKEY_NOT_REGISTERED = 0x58b
Global Const $ERROR_WINDOW_NOT_DIALOG = 0x58c
Global Const $ERROR_CONTROL_ID_NOT_FOUND = 0x58d
Global Const $ERROR_INVALID_COMBOBOX_MESSAGE = 0x58e
Global Const $ERROR_WINDOW_NOT_COMBOBOX = 0x58f
Global Const $ERROR_INVALID_EDIT_HEIGHT = 0x590
Global Const $ERROR_DC_NOT_FOUND = 0x591
Global Const $ERROR_INVALID_HOOK_FILTER = 0x592
Global Const $ERROR_INVALID_FILTER_PROC = 0x593
Global Const $ERROR_HOOK_NEEDS_HMOD = 0x594
Global Const $ERROR_GLOBAL_ONLY_HOOK = 0x595
Global Const $ERROR_JOURNAL_HOOK_SET = 0x596
Global Const $ERROR_HOOK_NOT_INSTALLED = 0x597
Global Const $ERROR_INVALID_LB_MESSAGE = 0x598
Global Const $ERROR_SETCOUNT_ON_BAD_LB = 0x599
Global Const $ERROR_LB_WITHOUT_TABSTOPS = 0x59a
Global Const $ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = 0x59b
Global Const $ERROR_CHILD_WINDOW_MENU = 0x59c
Global Const $ERROR_NO_SYSTEM_MENU = 0x59d
Global Const $ERROR_INVALID_MSGBOX_STYLE = 0x59e
Global Const $ERROR_INVALID_SPI_VALUE = 0x59f
Global Const $ERROR_SCREEN_ALREADY_LOCKED = 0x5a0
Global Const $ERROR_HWNDS_HAVE_DIFF_PARENT = 0x5a1
Global Const $ERROR_NOT_CHILD_WINDOW = 0x5a2
Global Const $ERROR_INVALID_GW_COMMAND = 0x5a3
Global Const $ERROR_INVALID_THREAD_ID = 0x5a4
Global Const $ERROR_NON_MDICHILD_WINDOW = 0x5a5
Global Const $ERROR_POPUP_ALREADY_ACTIVE = 0x5a6
Global Const $ERROR_NO_SCROLLBARS = 0x5a7
Global Const $ERROR_INVALID_SCROLLBAR_RANGE = 0x5a8
Global Const $ERROR_INVALID_SHOWWIN_COMMAND = 0x5a9
Global Const $ERROR_NO_SYSTEM_RESOURCES = 0x5aa
Global Const $ERROR_NONPAGED_SYSTEM_RESOURCES = 0x5ab
Global Const $ERROR_PAGED_SYSTEM_RESOURCES = 0x5ac
Global Const $ERROR_WORKING_SET_QUOTA = 0x5ad
Global Const $ERROR_PAGEFILE_QUOTA = 0x5ae
Global Const $ERROR_COMMITMENT_LIMIT = 0x5af
Global Const $ERROR_MENU_ITEM_NOT_FOUND = 0x5b0
Global Const $ERROR_INVALID_KEYBOARD_HANDLE = 0x5b1
Global Const $ERROR_HOOK_TYPE_NOT_ALLOWED = 0x5b2
Global Const $ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION = 0x5b3
Global Const $ERROR_TIMEOUT = 0x5b4
Global Const $ERROR_INVALID_MONITOR_HANDLE = 0x5b5
Global Const $ERROR_INCORRECT_SIZE = 0x5b6
Global Const $ERROR_SYMLINK_CLASS_DISABLED = 0x5b7
Global Const $ERROR_SYMLINK_NOT_SUPPORTED = 0x5b8
Global Const $ERROR_XML_PARSE_ERROR = 0x5b9
Global Const $ERROR_XMLDSIG_ERROR = 0x5ba
Global Const $ERROR_RESTART_APPLICATION = 0x5bb
Global Const $ERROR_WRONG_COMPARTMENT = 0x5bc
Global Const $ERROR_AUTHIP_FAILURE = 0x5bd
Global Const $ERROR_NO_NVRAM_RESOURCES = 0x5be
Global Const $ERROR_EVENTLOG_FILE_CORRUPT = 0x5dc
Global Const $ERROR_EVENTLOG_CANT_START = 0x5dd
Global Const $ERROR_LOG_FILE_FULL = 0x5de
Global Const $ERROR_EVENTLOG_FILE_CHANGED = 0x5df
Global Const $ERROR_INVALID_TASK_NAME = 0x60e
Global Const $ERROR_INVALID_TASK_INDEX = 0x60f
Global Const $ERROR_THREAD_ALREADY_IN_TASK = 0x610
Global Const $ERROR_INSTALL_SERVICE_FAILURE = 0x641
Global Const $ERROR_INSTALL_USEREXIT = 0x642
Global Const $ERROR_INSTALL_FAILURE = 0x643
Global Const $ERROR_INSTALL_SUSPEND = 0x644
Global Const $ERROR_UNKNOWN_PRODUCT = 0x645
Global Const $ERROR_UNKNOWN_FEATURE = 0x646
Global Const $ERROR_UNKNOWN_COMPONENT = 0x647
Global Const $ERROR_UNKNOWN_PROPERTY = 0x648
Global Const $ERROR_INVALID_HANDLE_STATE = 0x649
Global Const $ERROR_BAD_CONFIGURATION = 0x64a
Global Const $ERROR_INDEX_ABSENT = 0x64b
Global Const $ERROR_INSTALL_SOURCE_ABSENT = 0x64c
Global Const $ERROR_INSTALL_PACKAGE_VERSION = 0x64d
Global Const $ERROR_PRODUCT_UNINSTALLED = 0x64e
Global Const $ERROR_BAD_QUERY_SYNTAX = 0x64f
Global Const $ERROR_INVALID_FIELD = 0x650
Global Const $ERROR_DEVICE_REMOVED = 0x651
Global Const $ERROR_INSTALL_ALREADY_RUNNING = 0x652
Global Const $ERROR_INSTALL_PACKAGE_OPEN_FAILED = 0x653
Global Const $ERROR_INSTALL_PACKAGE_INVALID = 0x654
Global Const $ERROR_INSTALL_UI_FAILURE = 0x655
Global Const $ERROR_INSTALL_LOG_FAILURE = 0x656
Global Const $ERROR_INSTALL_LANGUAGE_UNSUPPORTED = 0x657
Global Const $ERROR_INSTALL_TRANSFORM_FAILURE = 0x658
Global Const $ERROR_INSTALL_PACKAGE_REJECTED = 0x659
Global Const $ERROR_FUNCTION_NOT_CALLED = 0x65a
Global Const $ERROR_FUNCTION_FAILED = 0x65b
Global Const $ERROR_INVALID_TABLE = 0x65c
Global Const $ERROR_DATATYPE_MISMATCH = 0x65d
Global Const $ERROR_UNSUPPORTED_TYPE = 0x65e
Global Const $ERROR_CREATE_FAILED = 0x65f
Global Const $ERROR_INSTALL_TEMP_UNWRITABLE = 0x660
Global Const $ERROR_INSTALL_PLATFORM_UNSUPPORTED = 0x661
Global Const $ERROR_INSTALL_NOTUSED = 0x662
Global Const $ERROR_PATCH_PACKAGE_OPEN_FAILED = 0x663
Global Const $ERROR_PATCH_PACKAGE_INVALID = 0x664
Global Const $ERROR_PATCH_PACKAGE_UNSUPPORTED = 0x665
Global Const $ERROR_PRODUCT_VERSION = 0x666
Global Const $ERROR_INVALID_COMMAND_LINE = 0x667
Global Const $ERROR_INSTALL_REMOTE_DISALLOWED = 0x668
Global Const $ERROR_SUCCESS_REBOOT_INITIATED = 0x669
Global Const $ERROR_PATCH_TARGET_NOT_FOUND = 0x66a
Global Const $ERROR_PATCH_PACKAGE_REJECTED = 0x66b
Global Const $ERROR_INSTALL_TRANSFORM_REJECTED = 0x66c
Global Const $ERROR_INSTALL_REMOTE_PROHIBITED = 0x66d
Global Const $ERROR_PATCH_REMOVAL_UNSUPPORTED = 0x66e
Global Const $ERROR_UNKNOWN_PATCH = 0x66f
Global Const $ERROR_PATCH_NO_SEQUENCE = 0x670
Global Const $ERROR_PATCH_REMOVAL_DISALLOWED = 0x671
Global Const $ERROR_INVALID_PATCH_XML = 0x672
Global Const $ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT = 0x673
Global Const $ERROR_INSTALL_SERVICE_SAFEBOOT = 0x674
Global Const $ERROR_FAIL_FAST_EXCEPTION = 0x675
Global Const $RPC_S_INVALID_STRING_BINDING = 0x6a4
Global Const $RPC_S_WRONG_KIND_OF_BINDING = 0x6a5
Global Const $RPC_S_INVALID_BINDING = 0x6a6
Global Const $RPC_S_PROTSEQ_NOT_SUPPORTED = 0x6a7
Global Const $RPC_S_INVALID_RPC_PROTSEQ = 0x6a8
Global Const $RPC_S_INVALID_STRING_UUID = 0x6a9
Global Const $RPC_S_INVALID_ENDPOINT_FORMAT = 0x6aa
Global Const $RPC_S_INVALID_NET_ADDR = 0x6ab
Global Const $RPC_S_NO_ENDPOINT_FOUND = 0x6ac
Global Const $RPC_S_INVALID_TIMEOUT = 0x6ad
Global Const $RPC_S_OBJECT_NOT_FOUND = 0x6ae
Global Const $RPC_S_ALREADY_REGISTERED = 0x6af
Global Const $RPC_S_TYPE_ALREADY_REGISTERED = 0x6b0
Global Const $RPC_S_ALREADY_LISTENING = 0x6b1
Global Const $RPC_S_NO_PROTSEQS_REGISTERED = 0x6b2
Global Const $RPC_S_NOT_LISTENING = 0x6b3
Global Const $RPC_S_UNKNOWN_MGR_TYPE = 0x6b4
Global Const $RPC_S_UNKNOWN_IF = 0x6b5
Global Const $RPC_S_NO_BINDINGS = 0x6b6
Global Const $RPC_S_NO_PROTSEQS = 0x6b7
Global Const $RPC_S_CANT_CREATE_ENDPOINT = 0x6b8
Global Const $RPC_S_OUT_OF_RESOURCES = 0x6b9
Global Const $RPC_S_SERVER_UNAVAILABLE = 0x6ba
Global Const $RPC_S_SERVER_TOO_BUSY = 0x6bb
Global Const $RPC_S_INVALID_NETWORK_OPTIONS = 0x6bc
Global Const $RPC_S_NO_CALL_ACTIVE = 0x6bd
Global Const $RPC_S_CALL_FAILED = 0x6be
Global Const $RPC_S_CALL_FAILED_DNE = 0x6bf
Global Const $RPC_S_PROTOCOL_ERROR = 0x6c0
Global Const $RPC_S_PROXY_ACCESS_DENIED = 0x6c1
Global Const $RPC_S_UNSUPPORTED_TRANS_SYN = 0x6c2
Global Const $RPC_S_UNSUPPORTED_TYPE = 0x6c4
Global Const $RPC_S_INVALID_TAG = 0x6c5
Global Const $RPC_S_INVALID_BOUND = 0x6c6
Global Const $RPC_S_NO_ENTRY_NAME = 0x6c7
Global Const $RPC_S_INVALID_NAME_SYNTAX = 0x6c8
Global Const $RPC_S_UNSUPPORTED_NAME_SYNTAX = 0x6c9
Global Const $RPC_S_UUID_NO_ADDRESS = 0x6cb
Global Const $RPC_S_DUPLICATE_ENDPOINT = 0x6cc
Global Const $RPC_S_UNKNOWN_AUTHN_TYPE = 0x6cd
Global Const $RPC_S_MAX_CALLS_TOO_SMALL = 0x6ce
Global Const $RPC_S_STRING_TOO_LONG = 0x6cf
Global Const $RPC_S_PROTSEQ_NOT_FOUND = 0x6d0
Global Const $RPC_S_PROCNUM_OUT_OF_RANGE = 0x6d1
Global Const $RPC_S_BINDING_HAS_NO_AUTH = 0x6d2
Global Const $RPC_S_UNKNOWN_AUTHN_SERVICE = 0x6d3
Global Const $RPC_S_UNKNOWN_AUTHN_LEVEL = 0x6d4
Global Const $RPC_S_INVALID_AUTH_IDENTITY = 0x6d5
Global Const $RPC_S_UNKNOWN_AUTHZ_SERVICE = 0x6d6
Global Const $EPT_S_INVALID_ENTRY = 0x6d7
Global Const $EPT_S_CANT_PERFORM_OP = 0x6d8
Global Const $EPT_S_NOT_REGISTERED = 0x6d9
Global Const $RPC_S_NOTHING_TO_EXPORT = 0x6da
Global Const $RPC_S_INCOMPLETE_NAME = 0x6db
Global Const $RPC_S_INVALID_VERS_OPTION = 0x6dc
Global Const $RPC_S_NO_MORE_MEMBERS = 0x6dd
Global Const $RPC_S_NOT_ALL_OBJS_UNEXPORTED = 0x6de
Global Const $RPC_S_INTERFACE_NOT_FOUND = 0x6df
Global Const $RPC_S_ENTRY_ALREADY_EXISTS = 0x6e0
Global Const $RPC_S_ENTRY_NOT_FOUND = 0x6e1
Global Const $RPC_S_NAME_SERVICE_UNAVAILABLE = 0x6e2
Global Const $RPC_S_INVALID_NAF_ID = 0x6e3
Global Const $RPC_S_CANNOT_SUPPORT = 0x6e4
Global Const $RPC_S_NO_CONTEXT_AVAILABLE = 0x6e5
Global Const $RPC_S_INTERNAL_ERROR = 0x6e6
Global Const $RPC_S_ZERO_DIVIDE = 0x6e7
Global Const $RPC_S_ADDRESS_ERROR = 0x6e8
Global Const $RPC_S_FP_DIV_ZERO = 0x6e9
Global Const $RPC_S_FP_UNDERFLOW = 0x6ea
Global Const $RPC_S_FP_OVERFLOW = 0x6eb
Global Const $RPC_X_NO_MORE_ENTRIES = 0x6ec
Global Const $RPC_X_SS_CHAR_TRANS_OPEN_FAIL = 0x6ed
Global Const $RPC_X_SS_CHAR_TRANS_SHORT_FILE = 0x6ee
Global Const $RPC_X_SS_IN_NULL_CONTEXT = 0x6ef
Global Const $RPC_X_SS_CONTEXT_DAMAGED = 0x6f1
Global Const $RPC_X_SS_HANDLES_MISMATCH = 0x6f2
Global Const $RPC_X_SS_CANNOT_GET_CALL_HANDLE = 0x6f3
Global Const $RPC_X_NULL_REF_POINTER = 0x6f4
Global Const $RPC_X_ENUM_VALUE_OUT_OF_RANGE = 0x6f5
Global Const $RPC_X_BYTE_COUNT_TOO_SMALL = 0x6f6
Global Const $RPC_X_BAD_STUB_DATA = 0x6f7
Global Const $ERROR_INVALID_USER_BUFFER = 0x6f8
Global Const $ERROR_UNRECOGNIZED_MEDIA = 0x6f9
Global Const $ERROR_NO_TRUST_LSA_SECRET = 0x6fa
Global Const $ERROR_NO_TRUST_SAM_ACCOUNT = 0x6fb
Global Const $ERROR_TRUSTED_DOMAIN_FAILURE = 0x6fc
Global Const $ERROR_TRUSTED_RELATIONSHIP_FAILURE = 0x6fd
Global Const $ERROR_TRUST_FAILURE = 0x6fe
Global Const $RPC_S_CALL_IN_PROGRESS = 0x6ff
Global Const $ERROR_NETLOGON_NOT_STARTED = 0x700
Global Const $ERROR_ACCOUNT_EXPIRED = 0x701
Global Const $ERROR_REDIRECTOR_HAS_OPEN_HANDLES = 0x702
Global Const $ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = 0x703
Global Const $ERROR_UNKNOWN_PORT = 0x704
Global Const $ERROR_UNKNOWN_PRINTER_DRIVER = 0x705
Global Const $ERROR_UNKNOWN_PRINTPROCESSOR = 0x706
Global Const $ERROR_INVALID_SEPARATOR_FILE = 0x707
Global Const $ERROR_INVALID_PRIORITY = 0x708
Global Const $ERROR_INVALID_PRINTER_NAME = 0x709
Global Const $ERROR_PRINTER_ALREADY_EXISTS = 0x70a
Global Const $ERROR_INVALID_PRINTER_COMMAND = 0x70b
Global Const $ERROR_INVALID_DATATYPE = 0x70c
Global Const $ERROR_INVALID_ENVIRONMENT = 0x70d
Global Const $RPC_S_NO_MORE_BINDINGS = 0x70e
Global Const $ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 0x70f
Global Const $ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 0x710
Global Const $ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = 0x711
Global Const $ERROR_DOMAIN_TRUST_INCONSISTENT = 0x712
Global Const $ERROR_SERVER_HAS_OPEN_HANDLES = 0x713
Global Const $ERROR_RESOURCE_DATA_NOT_FOUND = 0x714
Global Const $ERROR_RESOURCE_TYPE_NOT_FOUND = 0x715
Global Const $ERROR_RESOURCE_NAME_NOT_FOUND = 0x716
Global Const $ERROR_RESOURCE_LANG_NOT_FOUND = 0x717
Global Const $ERROR_NOT_ENOUGH_QUOTA = 0x718
Global Const $RPC_S_NO_INTERFACES = 0x719
Global Const $RPC_S_CALL_CANCELLED = 0x71a
Global Const $RPC_S_BINDING_INCOMPLETE = 0x71b
Global Const $RPC_S_COMM_FAILURE = 0x71c
Global Const $RPC_S_UNSUPPORTED_AUTHN_LEVEL = 0x71d
Global Const $RPC_S_NO_PRINC_NAME = 0x71e
Global Const $RPC_S_NOT_RPC_ERROR = 0x71f
Global Const $RPC_S_UUID_LOCAL_ONLY = 0x720
Global Const $RPC_S_SEC_PKG_ERROR = 0x721
Global Const $RPC_S_NOT_CANCELLED = 0x722
Global Const $RPC_X_INVALID_ES_ACTION = 0x723
Global Const $RPC_X_WRONG_ES_VERSION = 0x724
Global Const $RPC_X_WRONG_STUB_VERSION = 0x725
Global Const $RPC_X_INVALID_PIPE_OBJECT = 0x726
Global Const $RPC_X_WRONG_PIPE_ORDER = 0x727
Global Const $RPC_X_WRONG_PIPE_VERSION = 0x728
Global Const $RPC_S_COOKIE_AUTH_FAILED = 0x729
Global Const $RPC_S_GROUP_MEMBER_NOT_FOUND = 0x76a
Global Const $EPT_S_CANT_CREATE = 0x76b
Global Const $RPC_S_INVALID_OBJECT = 0x76c
Global Const $ERROR_INVALID_TIME = 0x76d
Global Const $ERROR_INVALID_FORM_NAME = 0x76e
Global Const $ERROR_INVALID_FORM_SIZE = 0x76f
Global Const $ERROR_ALREADY_WAITING = 0x770
Global Const $ERROR_PRINTER_DELETED = 0x771
Global Const $ERROR_INVALID_PRINTER_STATE = 0x772
Global Const $ERROR_PASSWORD_MUST_CHANGE = 0x773
Global Const $ERROR_DOMAIN_CONTROLLER_NOT_FOUND = 0x774
Global Const $ERROR_ACCOUNT_LOCKED_OUT = 0x775
Global Const $OR_INVALID_OXID = 0x776
Global Const $OR_INVALID_OID = 0x777
Global Const $OR_INVALID_SET = 0x778
Global Const $RPC_S_SEND_INCOMPLETE = 0x779
Global Const $RPC_S_INVALID_ASYNC_HANDLE = 0x77a
Global Const $RPC_S_INVALID_ASYNC_CALL = 0x77b
Global Const $RPC_X_PIPE_CLOSED = 0x77c
Global Const $RPC_X_PIPE_DISCIPLINE_ERROR = 0x77d
Global Const $RPC_X_PIPE_EMPTY = 0x77e
Global Const $ERROR_NO_SITENAME = 0x77f
Global Const $ERROR_CANT_ACCESS_FILE = 0x780
Global Const $ERROR_CANT_RESOLVE_FILENAME = 0x781
Global Const $RPC_S_ENTRY_TYPE_MISMATCH = 0x782
Global Const $RPC_S_NOT_ALL_OBJS_EXPORTED = 0x783
Global Const $RPC_S_INTERFACE_NOT_EXPORTED = 0x784
Global Const $RPC_S_PROFILE_NOT_ADDED = 0x785
Global Const $RPC_S_PRF_ELT_NOT_ADDED = 0x786
Global Const $RPC_S_PRF_ELT_NOT_REMOVED = 0x787
Global Const $RPC_S_GRP_ELT_NOT_ADDED = 0x788
Global Const $RPC_S_GRP_ELT_NOT_REMOVED = 0x789
Global Const $ERROR_KM_DRIVER_BLOCKED = 0x78a
Global Const $ERROR_CONTEXT_EXPIRED = 0x78b
Global Const $ERROR_PER_USER_TRUST_QUOTA_EXCEEDED = 0x78c
Global Const $ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED = 0x78d
Global Const $ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED = 0x78e
Global Const $ERROR_AUTHENTICATION_FIREWALL_FAILED = 0x78f
Global Const $ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED = 0x790
Global Const $ERROR_NTLM_BLOCKED = 0x791
Global Const $ERROR_INVALID_PIXEL_FORMAT = 0x7d0
Global Const $ERROR_BAD_DRIVER = 0x7d1
Global Const $ERROR_INVALID_WINDOW_STYLE = 0x7d2
Global Const $ERROR_METAFILE_NOT_SUPPORTED = 0x7d3
Global Const $ERROR_TRANSFORM_NOT_SUPPORTED = 0x7d4
Global Const $ERROR_CLIPPING_NOT_SUPPORTED = 0x7d5
Global Const $ERROR_INVALID_CMM = 0x7da
Global Const $ERROR_INVALID_PROFILE = 0x7db
Global Const $ERROR_TAG_NOT_FOUND = 0x7dc
Global Const $ERROR_TAG_NOT_PRESENT = 0x7dd
Global Const $ERROR_DUPLICATE_TAG = 0x7de
Global Const $ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE = 0x7df
Global Const $ERROR_PROFILE_NOT_FOUND = 0x7e0
Global Const $ERROR_INVALID_COLORSPACE = 0x7e1
Global Const $ERROR_ICM_NOT_ENABLED = 0x7e2
Global Const $ERROR_DELETING_ICM_XFORM = 0x7e3
Global Const $ERROR_INVALID_TRANSFORM = 0x7e4
Global Const $ERROR_COLORSPACE_MISMATCH = 0x7e5
Global Const $ERROR_INVALID_COLORINDEX = 0x7e6
Global Const $ERROR_PROFILE_DOES_NOT_MATCH_DEVICE = 0x7e7
Global Const $ERROR_CONNECTED_OTHER_PASSWORD = 0x83c
Global Const $ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT = 0x83d
Global Const $ERROR_BAD_USERNAME = 0x89a
Global Const $ERROR_NOT_CONNECTED = 0x8ca
Global Const $ERROR_OPEN_FILES = 0x961
Global Const $ERROR_ACTIVE_CONNECTIONS = 0x962
Global Const $ERROR_DEVICE_IN_USE = 0x964
Global Const $ERROR_UNKNOWN_PRINT_MONITOR = 0xbb8
Global Const $ERROR_PRINTER_DRIVER_IN_USE = 0xbb9
Global Const $ERROR_SPOOL_FILE_NOT_FOUND = 0xbba
Global Const $ERROR_SPL_NO_STARTDOC = 0xbbb
Global Const $ERROR_SPL_NO_ADDJOB = 0xbbc
Global Const $ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED = 0xbbd
Global Const $ERROR_PRINT_MONITOR_ALREADY_INSTALLED = 0xbbe
Global Const $ERROR_INVALID_PRINT_MONITOR = 0xbbf
Global Const $ERROR_PRINT_MONITOR_IN_USE = 0xbc0
Global Const $ERROR_PRINTER_HAS_JOBS_QUEUED = 0xbc1
Global Const $ERROR_SUCCESS_REBOOT_REQUIRED = 0xbc2
Global Const $ERROR_SUCCESS_RESTART_REQUIRED = 0xbc3
Global Const $ERROR_PRINTER_NOT_FOUND = 0xbc4
Global Const $ERROR_PRINTER_DRIVER_WARNED = 0xbc5
Global Const $ERROR_PRINTER_DRIVER_BLOCKED = 0xbc6
Global Const $ERROR_PRINTER_DRIVER_PACKAGE_IN_USE = 0xbc7
Global Const $ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND = 0xbc8
Global Const $ERROR_FAIL_REBOOT_REQUIRED = 0xbc9
Global Const $ERROR_FAIL_REBOOT_INITIATED = 0xbca
Global Const $ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED = 0xbcb
Global Const $ERROR_PRINT_JOB_RESTART_REQUIRED = 0xbcc
Global Const $ERROR_IO_REISSUE_AS_CACHED = 0xf6e
Global Const $ERROR_WINS_INTERNAL = 0xfa0
Global Const $ERROR_CAN_NOT_DEL_LOCAL_WINS = 0xfa1
Global Const $ERROR_STATIC_INIT = 0xfa2
Global Const $ERROR_INC_BACKUP = 0xfa3
Global Const $ERROR_FULL_BACKUP = 0xfa4
Global Const $ERROR_REC_NON_EXISTENT = 0xfa5
Global Const $ERROR_RPL_NOT_ALLOWED = 0xfa6
Global Const $ERROR_DHCP_ADDRESS_CONFLICT = 0x1004
Global Const $ERROR_WMI_GUID_NOT_FOUND = 0x1068
Global Const $ERROR_WMI_INSTANCE_NOT_FOUND = 0x1069
Global Const $ERROR_WMI_ITEMID_NOT_FOUND = 0x106a
Global Const $ERROR_WMI_TRY_AGAIN = 0x106b
Global Const $ERROR_WMI_DP_NOT_FOUND = 0x106c
Global Const $ERROR_WMI_UNRESOLVED_INSTANCE_REF = 0x106d
Global Const $ERROR_WMI_ALREADY_ENABLED = 0x106e
Global Const $ERROR_WMI_GUID_DISCONNECTED = 0x106f
Global Const $ERROR_WMI_SERVER_UNAVAILABLE = 0x1070
Global Const $ERROR_WMI_DP_FAILED = 0x1071
Global Const $ERROR_WMI_INVALID_MOF = 0x1072
Global Const $ERROR_WMI_INVALID_REGINFO = 0x1073
Global Const $ERROR_WMI_ALREADY_DISABLED = 0x1074
Global Const $ERROR_WMI_READ_ONLY = 0x1075
Global Const $ERROR_WMI_SET_FAILURE = 0x1076
Global Const $ERROR_INVALID_MEDIA = 0x10cc
Global Const $ERROR_INVALID_LIBRARY = 0x10cd
Global Const $ERROR_INVALID_MEDIA_POOL = 0x10ce
Global Const $ERROR_DRIVE_MEDIA_MISMATCH = 0x10cf
Global Const $ERROR_MEDIA_OFFLINE = 0x10d0
Global Const $ERROR_LIBRARY_OFFLINE = 0x10d1
Global Const $ERROR_EMPTY = 0x10d2
Global Const $ERROR_NOT_EMPTY = 0x10d3
Global Const $ERROR_MEDIA_UNAVAILABLE = 0x10d4
Global Const $ERROR_RESOURCE_DISABLED = 0x10d5
Global Const $ERROR_INVALID_CLEANER = 0x10d6
Global Const $ERROR_UNABLE_TO_CLEAN = 0x10d7
Global Const $ERROR_OBJECT_NOT_FOUND = 0x10d8
Global Const $ERROR_DATABASE_FAILURE = 0x10d9
Global Const $ERROR_DATABASE_FULL = 0x10da
Global Const $ERROR_MEDIA_INCOMPATIBLE = 0x10db
Global Const $ERROR_RESOURCE_NOT_PRESENT = 0x10dc
Global Const $ERROR_INVALID_OPERATION = 0x10dd
Global Const $ERROR_MEDIA_NOT_AVAILABLE = 0x10de
Global Const $ERROR_DEVICE_NOT_AVAILABLE = 0x10df
Global Const $ERROR_REQUEST_REFUSED = 0x10e0
Global Const $ERROR_INVALID_DRIVE_OBJECT = 0x10e1
Global Const $ERROR_LIBRARY_FULL = 0x10e2
Global Const $ERROR_MEDIUM_NOT_ACCESSIBLE = 0x10e3
Global Const $ERROR_UNABLE_TO_LOAD_MEDIUM = 0x10e4
Global Const $ERROR_UNABLE_TO_INVENTORY_DRIVE = 0x10e5
Global Const $ERROR_UNABLE_TO_INVENTORY_SLOT = 0x10e6
Global Const $ERROR_UNABLE_TO_INVENTORY_TRANSPORT = 0x10e7
Global Const $ERROR_TRANSPORT_FULL = 0x10e8
Global Const $ERROR_CONTROLLING_IEPORT = 0x10e9
Global Const $ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA = 0x10ea
Global Const $ERROR_CLEANER_SLOT_SET = 0x10eb
Global Const $ERROR_CLEANER_SLOT_NOT_SET = 0x10ec
Global Const $ERROR_CLEANER_CARTRIDGE_SPENT = 0x10ed
Global Const $ERROR_UNEXPECTED_OMID = 0x10ee
Global Const $ERROR_CANT_DELETE_LAST_ITEM = 0x10ef
Global Const $ERROR_MESSAGE_EXCEEDS_MAX_SIZE = 0x10f0
Global Const $ERROR_VOLUME_CONTAINS_SYS_FILES = 0x10f1
Global Const $ERROR_INDIGENOUS_TYPE = 0x10f2
Global Const $ERROR_NO_SUPPORTING_DRIVES = 0x10f3
Global Const $ERROR_CLEANER_CARTRIDGE_INSTALLED = 0x10f4
Global Const $ERROR_IEPORT_FULL = 0x10f5
Global Const $ERROR_FILE_OFFLINE = 0x10fe
Global Const $ERROR_REMOTE_STORAGE_NOT_ACTIVE = 0x10ff
Global Const $ERROR_REMOTE_STORAGE_MEDIA_ERROR = 0x1100
Global Const $ERROR_NOT_A_REPARSE_POINT = 0x1126
Global Const $ERROR_REPARSE_ATTRIBUTE_CONFLICT = 0x1127
Global Const $ERROR_INVALID_REPARSE_DATA = 0x1128
Global Const $ERROR_REPARSE_TAG_INVALID = 0x1129
Global Const $ERROR_REPARSE_TAG_MISMATCH = 0x112a
Global Const $ERROR_VOLUME_NOT_SIS_ENABLED = 0x1194
Global Const $ERROR_DEPENDENT_RESOURCE_EXISTS = 0x1389
Global Const $ERROR_DEPENDENCY_NOT_FOUND = 0x138a
Global Const $ERROR_DEPENDENCY_ALREADY_EXISTS = 0x138b
Global Const $ERROR_RESOURCE_NOT_ONLINE = 0x138c
Global Const $ERROR_HOST_NODE_NOT_AVAILABLE = 0x138d
Global Const $ERROR_RESOURCE_NOT_AVAILABLE = 0x138e
Global Const $ERROR_RESOURCE_NOT_FOUND = 0x138f
Global Const $ERROR_SHUTDOWN_CLUSTER = 0x1390
Global Const $ERROR_CANT_EVICT_ACTIVE_NODE = 0x1391
Global Const $ERROR_OBJECT_ALREADY_EXISTS = 0x1392
Global Const $ERROR_OBJECT_IN_LIST = 0x1393
Global Const $ERROR_GROUP_NOT_AVAILABLE = 0x1394
Global Const $ERROR_GROUP_NOT_FOUND = 0x1395
Global Const $ERROR_GROUP_NOT_ONLINE = 0x1396
Global Const $ERROR_HOST_NODE_NOT_RESOURCE_OWNER = 0x1397
Global Const $ERROR_HOST_NODE_NOT_GROUP_OWNER = 0x1398
Global Const $ERROR_RESMON_CREATE_FAILED = 0x1399
Global Const $ERROR_RESMON_ONLINE_FAILED = 0x139a
Global Const $ERROR_RESOURCE_ONLINE = 0x139b
Global Const $ERROR_QUORUM_RESOURCE = 0x139c
Global Const $ERROR_NOT_QUORUM_CAPABLE = 0x139d
Global Const $ERROR_CLUSTER_SHUTTING_DOWN = 0x139e
Global Const $ERROR_INVALID_STATE = 0x139f
Global Const $ERROR_RESOURCE_PROPERTIES_STORED = 0x13a0
Global Const $ERROR_NOT_QUORUM_CLASS = 0x13a1
Global Const $ERROR_CORE_RESOURCE = 0x13a2
Global Const $ERROR_QUORUM_RESOURCE_ONLINE_FAILED = 0x13a3
Global Const $ERROR_QUORUMLOG_OPEN_FAILED = 0x13a4
Global Const $ERROR_CLUSTERLOG_CORRUPT = 0x13a5
Global Const $ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE = 0x13a6
Global Const $ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE = 0x13a7
Global Const $ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND = 0x13a8
Global Const $ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE = 0x13a9
Global Const $ERROR_QUORUM_OWNER_ALIVE = 0x13aa
Global Const $ERROR_NETWORK_NOT_AVAILABLE = 0x13ab
Global Const $ERROR_NODE_NOT_AVAILABLE = 0x13ac
Global Const $ERROR_ALL_NODES_NOT_AVAILABLE = 0x13ad
Global Const $ERROR_RESOURCE_FAILED = 0x13ae
Global Const $ERROR_CLUSTER_INVALID_NODE = 0x13af
Global Const $ERROR_CLUSTER_NODE_EXISTS = 0x13b0
Global Const $ERROR_CLUSTER_JOIN_IN_PROGRESS = 0x13b1
Global Const $ERROR_CLUSTER_NODE_NOT_FOUND = 0x13b2
Global Const $ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND = 0x13b3
Global Const $ERROR_CLUSTER_NETWORK_EXISTS = 0x13b4
Global Const $ERROR_CLUSTER_NETWORK_NOT_FOUND = 0x13b5
Global Const $ERROR_CLUSTER_NETINTERFACE_EXISTS = 0x13b6
Global Const $ERROR_CLUSTER_NETINTERFACE_NOT_FOUND = 0x13b7
Global Const $ERROR_CLUSTER_INVALID_REQUEST = 0x13b8
Global Const $ERROR_CLUSTER_INVALID_NETWORK_PROVIDER = 0x13b9
Global Const $ERROR_CLUSTER_NODE_DOWN = 0x13ba
Global Const $ERROR_CLUSTER_NODE_UNREACHABLE = 0x13bb
Global Const $ERROR_CLUSTER_NODE_NOT_MEMBER = 0x13bc
Global Const $ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS = 0x13bd
Global Const $ERROR_CLUSTER_INVALID_NETWORK = 0x13be
Global Const $ERROR_CLUSTER_NODE_UP = 0x13c0
Global Const $ERROR_CLUSTER_IPADDR_IN_USE = 0x13c1
Global Const $ERROR_CLUSTER_NODE_NOT_PAUSED = 0x13c2
Global Const $ERROR_CLUSTER_NO_SECURITY_CONTEXT = 0x13c3
Global Const $ERROR_CLUSTER_NETWORK_NOT_INTERNAL = 0x13c4
Global Const $ERROR_CLUSTER_NODE_ALREADY_UP = 0x13c5
Global Const $ERROR_CLUSTER_NODE_ALREADY_DOWN = 0x13c6
Global Const $ERROR_CLUSTER_NETWORK_ALREADY_ONLINE = 0x13c7
Global Const $ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE = 0x13c8
Global Const $ERROR_CLUSTER_NODE_ALREADY_MEMBER = 0x13c9
Global Const $ERROR_CLUSTER_LAST_INTERNAL_NETWORK = 0x13ca
Global Const $ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS = 0x13cb
Global Const $ERROR_INVALID_OPERATION_ON_QUORUM = 0x13cc
Global Const $ERROR_DEPENDENCY_NOT_ALLOWED = 0x13cd
Global Const $ERROR_CLUSTER_NODE_PAUSED = 0x13ce
Global Const $ERROR_NODE_CANT_HOST_RESOURCE = 0x13cf
Global Const $ERROR_CLUSTER_NODE_NOT_READY = 0x13d0
Global Const $ERROR_CLUSTER_NODE_SHUTTING_DOWN = 0x13d1
Global Const $ERROR_CLUSTER_JOIN_ABORTED = 0x13d2
Global Const $ERROR_CLUSTER_INCOMPATIBLE_VERSIONS = 0x13d3
Global Const $ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED = 0x13d4
Global Const $ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED = 0x13d5
Global Const $ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND = 0x13d6
Global Const $ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED = 0x13d7
Global Const $ERROR_CLUSTER_RESNAME_NOT_FOUND = 0x13d8
Global Const $ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED = 0x13d9
Global Const $ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST = 0x13da
Global Const $ERROR_CLUSTER_DATABASE_SEQMISMATCH = 0x13db
Global Const $ERROR_RESMON_INVALID_STATE = 0x13dc
Global Const $ERROR_CLUSTER_GUM_NOT_LOCKER = 0x13dd
Global Const $ERROR_QUORUM_DISK_NOT_FOUND = 0x13de
Global Const $ERROR_DATABASE_BACKUP_CORRUPT = 0x13df
Global Const $ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT = 0x13e0
Global Const $ERROR_RESOURCE_PROPERTY_UNCHANGEABLE = 0x13e1
Global Const $ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE = 0x1702
Global Const $ERROR_CLUSTER_QUORUMLOG_NOT_FOUND = 0x1703
Global Const $ERROR_CLUSTER_MEMBERSHIP_HALT = 0x1704
Global Const $ERROR_CLUSTER_INSTANCE_ID_MISMATCH = 0x1705
Global Const $ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP = 0x1706
Global Const $ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH = 0x1707
Global Const $ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP = 0x1708
Global Const $ERROR_CLUSTER_PARAMETER_MISMATCH = 0x1709
Global Const $ERROR_NODE_CANNOT_BE_CLUSTERED = 0x170a
Global Const $ERROR_CLUSTER_WRONG_OS_VERSION = 0x170b
Global Const $ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME = 0x170c
Global Const $ERROR_CLUSCFG_ALREADY_COMMITTED = 0x170d
Global Const $ERROR_CLUSCFG_ROLLBACK_FAILED = 0x170e
Global Const $ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT = 0x170f
Global Const $ERROR_CLUSTER_OLD_VERSION = 0x1710
Global Const $ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME = 0x1711
Global Const $ERROR_CLUSTER_NO_NET_ADAPTERS = 0x1712
Global Const $ERROR_CLUSTER_POISONED = 0x1713
Global Const $ERROR_CLUSTER_GROUP_MOVING = 0x1714
Global Const $ERROR_CLUSTER_RESOURCE_TYPE_BUSY = 0x1715
Global Const $ERROR_RESOURCE_CALL_TIMED_OUT = 0x1716
Global Const $ERROR_INVALID_CLUSTER_IPV6_ADDRESS = 0x1717
Global Const $ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION = 0x1718
Global Const $ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS = 0x1719
Global Const $ERROR_CLUSTER_PARTIAL_SEND = 0x171a
Global Const $ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION = 0x171b
Global Const $ERROR_CLUSTER_INVALID_STRING_TERMINATION = 0x171c
Global Const $ERROR_CLUSTER_INVALID_STRING_FORMAT = 0x171d
Global Const $ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS = 0x171e
Global Const $ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS = 0x171f
Global Const $ERROR_CLUSTER_NULL_DATA = 0x1720
Global Const $ERROR_CLUSTER_PARTIAL_READ = 0x1721
Global Const $ERROR_CLUSTER_PARTIAL_WRITE = 0x1722
Global Const $ERROR_CLUSTER_CANT_DESERIALIZE_DATA = 0x1723
Global Const $ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT = 0x1724
Global Const $ERROR_CLUSTER_NO_QUORUM = 0x1725
Global Const $ERROR_CLUSTER_INVALID_IPV6_NETWORK = 0x1726
Global Const $ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK = 0x1727
Global Const $ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP = 0x1728
Global Const $ERROR_DEPENDENCY_TREE_TOO_COMPLEX = 0x1729
Global Const $ERROR_EXCEPTION_IN_RESOURCE_CALL = 0x172a
Global Const $ERROR_CLUSTER_RHS_FAILED_INITIALIZATION = 0x172b
Global Const $ERROR_CLUSTER_NOT_INSTALLED = 0x172c
Global Const $ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE = 0x172d
Global Const $ERROR_CLUSTER_MAX_NODES_IN_CLUSTER = 0x172e
Global Const $ERROR_CLUSTER_TOO_MANY_NODES = 0x172f
Global Const $ERROR_CLUSTER_OBJECT_ALREADY_USED = 0x1730
Global Const $ERROR_NONCORE_GROUPS_FOUND = 0x1731
Global Const $ERROR_FILE_SHARE_RESOURCE_CONFLICT = 0x1732
Global Const $ERROR_CLUSTER_EVICT_INVALID_REQUEST = 0x1733
Global Const $ERROR_CLUSTER_SINGLETON_RESOURCE = 0x1734
Global Const $ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE = 0x1735
Global Const $ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED = 0x1736
Global Const $ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR = 0x1737
Global Const $ERROR_CLUSTER_GROUP_BUSY = 0x1738
Global Const $ERROR_CLUSTER_NOT_SHARED_VOLUME = 0x1739
Global Const $ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR = 0x173a
Global Const $ERROR_CLUSTER_SHARED_VOLUMES_IN_USE = 0x173b
Global Const $ERROR_CLUSTER_USE_SHARED_VOLUMES_API = 0x173c
Global Const $ERROR_CLUSTER_BACKUP_IN_PROGRESS = 0x173d
Global Const $ERROR_ENCRYPTION_FAILED = 0x1770
Global Const $ERROR_DECRYPTION_FAILED = 0x1771
Global Const $ERROR_FILE_ENCRYPTED = 0x1772
Global Const $ERROR_NO_RECOVERY_POLICY = 0x1773
Global Const $ERROR_NO_EFS = 0x1774
Global Const $ERROR_WRONG_EFS = 0x1775
Global Const $ERROR_NO_USER_KEYS = 0x1776
Global Const $ERROR_FILE_NOT_ENCRYPTED = 0x1777
Global Const $ERROR_NOT_EXPORT_FORMAT = 0x1778
Global Const $ERROR_FILE_READ_ONLY = 0x1779
Global Const $ERROR_DIR_EFS_DISALLOWED = 0x177a
Global Const $ERROR_EFS_SERVER_NOT_TRUSTED = 0x177b
Global Const $ERROR_BAD_RECOVERY_POLICY = 0x177c
Global Const $ERROR_EFS_ALG_BLOB_TOO_BIG = 0x177d
Global Const $ERROR_VOLUME_NOT_SUPPORT_EFS = 0x177e
Global Const $ERROR_EFS_DISABLED = 0x177f
Global Const $ERROR_EFS_VERSION_NOT_SUPPORT = 0x1780
Global Const $ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = 0x1781
Global Const $ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER = 0x1782
Global Const $ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = 0x1783
Global Const $ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = 0x1784
Global Const $ERROR_CS_ENCRYPTION_FILE_NOT_CSE = 0x1785
Global Const $ERROR_ENCRYPTION_POLICY_DENIES_OPERATION = 0x1786
Global Const $ERROR_NO_BROWSER_SERVERS_FOUND = 0x17e6
Global Const $SCHED_E_SERVICE_NOT_LOCALSYSTEM = 0x1838
Global Const $ERROR_LOG_SECTOR_INVALID = 0x19c8
Global Const $ERROR_LOG_SECTOR_PARITY_INVALID = 0x19c9
Global Const $ERROR_LOG_SECTOR_REMAPPED = 0x19ca
Global Const $ERROR_LOG_BLOCK_INCOMPLETE = 0x19cb
Global Const $ERROR_LOG_INVALID_RANGE = 0x19cc
Global Const $ERROR_LOG_BLOCKS_EXHAUSTED = 0x19cd
Global Const $ERROR_LOG_READ_CONTEXT_INVALID = 0x19ce
Global Const $ERROR_LOG_RESTART_INVALID = 0x19cf
Global Const $ERROR_LOG_BLOCK_VERSION = 0x19d0
Global Const $ERROR_LOG_BLOCK_INVALID = 0x19d1
Global Const $ERROR_LOG_READ_MODE_INVALID = 0x19d2
Global Const $ERROR_LOG_NO_RESTART = 0x19d3
Global Const $ERROR_LOG_METADATA_CORRUPT = 0x19d4
Global Const $ERROR_LOG_METADATA_INVALID = 0x19d5
Global Const $ERROR_LOG_METADATA_INCONSISTENT = 0x19d6
Global Const $ERROR_LOG_RESERVATION_INVALID = 0x19d7
Global Const $ERROR_LOG_CANT_DELETE = 0x19d8
Global Const $ERROR_LOG_CONTAINER_LIMIT_EXCEEDED = 0x19d9
Global Const $ERROR_LOG_START_OF_LOG = 0x19da
Global Const $ERROR_LOG_POLICY_ALREADY_INSTALLED = 0x19db
Global Const $ERROR_LOG_POLICY_NOT_INSTALLED = 0x19dc
Global Const $ERROR_LOG_POLICY_INVALID = 0x19dd
Global Const $ERROR_LOG_POLICY_CONFLICT = 0x19de
Global Const $ERROR_LOG_PINNED_ARCHIVE_TAIL = 0x19df
Global Const $ERROR_LOG_RECORD_NONEXISTENT = 0x19e0
Global Const $ERROR_LOG_RECORDS_RESERVED_INVALID = 0x19e1
Global Const $ERROR_LOG_SPACE_RESERVED_INVALID = 0x19e2
Global Const $ERROR_LOG_TAIL_INVALID = 0x19e3
Global Const $ERROR_LOG_FULL = 0x19e4
Global Const $ERROR_COULD_NOT_RESIZE_LOG = 0x19e5
Global Const $ERROR_LOG_MULTIPLEXED = 0x19e6
Global Const $ERROR_LOG_DEDICATED = 0x19e7
Global Const $ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS = 0x19e8
Global Const $ERROR_LOG_ARCHIVE_IN_PROGRESS = 0x19e9
Global Const $ERROR_LOG_EPHEMERAL = 0x19ea
Global Const $ERROR_LOG_NOT_ENOUGH_CONTAINERS = 0x19eb
Global Const $ERROR_LOG_CLIENT_ALREADY_REGISTERED = 0x19ec
Global Const $ERROR_LOG_CLIENT_NOT_REGISTERED = 0x19ed
Global Const $ERROR_LOG_FULL_HANDLER_IN_PROGRESS = 0x19ee
Global Const $ERROR_LOG_CONTAINER_READ_FAILED = 0x19ef
Global Const $ERROR_LOG_CONTAINER_WRITE_FAILED = 0x19f0
Global Const $ERROR_LOG_CONTAINER_OPEN_FAILED = 0x19f1
Global Const $ERROR_LOG_CONTAINER_STATE_INVALID = 0x19f2
Global Const $ERROR_LOG_STATE_INVALID = 0x19f3
Global Const $ERROR_LOG_PINNED = 0x19f4
Global Const $ERROR_LOG_METADATA_FLUSH_FAILED = 0x19f5
Global Const $ERROR_LOG_INCONSISTENT_SECURITY = 0x19f6
Global Const $ERROR_LOG_APPENDED_FLUSH_FAILED = 0x19f7
Global Const $ERROR_LOG_PINNED_RESERVATION = 0x19f8
Global Const $ERROR_INVALID_TRANSACTION = 0x1a2c
Global Const $ERROR_TRANSACTION_NOT_ACTIVE = 0x1a2d
Global Const $ERROR_TRANSACTION_REQUEST_NOT_VALID = 0x1a2e
Global Const $ERROR_TRANSACTION_NOT_REQUESTED = 0x1a2f
Global Const $ERROR_TRANSACTION_ALREADY_ABORTED = 0x1a30
Global Const $ERROR_TRANSACTION_ALREADY_COMMITTED = 0x1a31
Global Const $ERROR_TM_INITIALIZATION_FAILED = 0x1a32
Global Const $ERROR_RESOURCEMANAGER_READ_ONLY = 0x1a33
Global Const $ERROR_TRANSACTION_NOT_JOINED = 0x1a34
Global Const $ERROR_TRANSACTION_SUPERIOR_EXISTS = 0x1a35
Global Const $ERROR_CRM_PROTOCOL_ALREADY_EXISTS = 0x1a36
Global Const $ERROR_TRANSACTION_PROPAGATION_FAILED = 0x1a37
Global Const $ERROR_CRM_PROTOCOL_NOT_FOUND = 0x1a38
Global Const $ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER = 0x1a39
Global Const $ERROR_CURRENT_TRANSACTION_NOT_VALID = 0x1a3a
Global Const $ERROR_TRANSACTION_NOT_FOUND = 0x1a3b
Global Const $ERROR_RESOURCEMANAGER_NOT_FOUND = 0x1a3c
Global Const $ERROR_ENLISTMENT_NOT_FOUND = 0x1a3d
Global Const $ERROR_TRANSACTIONMANAGER_NOT_FOUND = 0x1a3e
Global Const $ERROR_TRANSACTIONMANAGER_NOT_ONLINE = 0x1a3f
Global Const $ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = 0x1a40
Global Const $ERROR_TRANSACTION_NOT_ROOT = 0x1a41
Global Const $ERROR_TRANSACTION_OBJECT_EXPIRED = 0x1a42
Global Const $ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED = 0x1a43
Global Const $ERROR_TRANSACTION_RECORD_TOO_LONG = 0x1a44
Global Const $ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED = 0x1a45
Global Const $ERROR_TRANSACTION_INTEGRITY_VIOLATED = 0x1a46
Global Const $ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH = 0x1a47
Global Const $ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = 0x1a48
Global Const $ERROR_TRANSACTION_MUST_WRITETHROUGH = 0x1a49
Global Const $ERROR_TRANSACTION_NO_SUPERIOR = 0x1a4a
Global Const $ERROR_TRANSACTIONAL_CONFLICT = 0x1a90
Global Const $ERROR_RM_NOT_ACTIVE = 0x1a91
Global Const $ERROR_RM_METADATA_CORRUPT = 0x1a92
Global Const $ERROR_DIRECTORY_NOT_RM = 0x1a93
Global Const $ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE = 0x1a95
Global Const $ERROR_LOG_RESIZE_INVALID_SIZE = 0x1a96
Global Const $ERROR_OBJECT_NO_LONGER_EXISTS = 0x1a97
Global Const $ERROR_STREAM_MINIVERSION_NOT_FOUND = 0x1a98
Global Const $ERROR_STREAM_MINIVERSION_NOT_VALID = 0x1a99
Global Const $ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = 0x1a9a
Global Const $ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = 0x1a9b
Global Const $ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS = 0x1a9c
Global Const $ERROR_REMOTE_FILE_VERSION_MISMATCH = 0x1a9e
Global Const $ERROR_HANDLE_NO_LONGER_VALID = 0x1a9f
Global Const $ERROR_NO_TXF_METADATA = 0x1aa0
Global Const $ERROR_LOG_CORRUPTION_DETECTED = 0x1aa1
Global Const $ERROR_CANT_RECOVER_WITH_HANDLE_OPEN = 0x1aa2
Global Const $ERROR_RM_DISCONNECTED = 0x1aa3
Global Const $ERROR_ENLISTMENT_NOT_SUPERIOR = 0x1aa4
Global Const $ERROR_RECOVERY_NOT_NEEDED = 0x1aa5
Global Const $ERROR_RM_ALREADY_STARTED = 0x1aa6
Global Const $ERROR_FILE_IDENTITY_NOT_PERSISTENT = 0x1aa7
Global Const $ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = 0x1aa8
Global Const $ERROR_CANT_CROSS_RM_BOUNDARY = 0x1aa9
Global Const $ERROR_TXF_DIR_NOT_EMPTY = 0x1aaa
Global Const $ERROR_INDOUBT_TRANSACTIONS_EXIST = 0x1aab
Global Const $ERROR_TM_VOLATILE = 0x1aac
Global Const $ERROR_ROLLBACK_TIMER_EXPIRED = 0x1aad
Global Const $ERROR_TXF_ATTRIBUTE_CORRUPT = 0x1aae
Global Const $ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION = 0x1aaf
Global Const $ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED = 0x1ab0
Global Const $ERROR_LOG_GROWTH_FAILED = 0x1ab1
Global Const $ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = 0x1ab2
Global Const $ERROR_TXF_METADATA_ALREADY_PRESENT = 0x1ab3
Global Const $ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = 0x1ab4
Global Const $ERROR_TRANSACTION_REQUIRED_PROMOTION = 0x1ab5
Global Const $ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION = 0x1ab6
Global Const $ERROR_TRANSACTIONS_NOT_FROZEN = 0x1ab7
Global Const $ERROR_TRANSACTION_FREEZE_IN_PROGRESS = 0x1ab8
Global Const $ERROR_NOT_SNAPSHOT_VOLUME = 0x1ab9
Global Const $ERROR_NO_SAVEPOINT_WITH_OPEN_FILES = 0x1aba
Global Const $ERROR_DATA_LOST_REPAIR = 0x1abb
Global Const $ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION = 0x1abc
Global Const $ERROR_TM_IDENTITY_MISMATCH = 0x1abd
Global Const $ERROR_FLOATED_SECTION = 0x1abe
Global Const $ERROR_CANNOT_ACCEPT_TRANSACTED_WORK = 0x1abf
Global Const $ERROR_CANNOT_ABORT_TRANSACTIONS = 0x1ac0
Global Const $ERROR_BAD_CLUSTERS = 0x1ac1
Global Const $ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = 0x1ac2
Global Const $ERROR_VOLUME_DIRTY = 0x1ac3
Global Const $ERROR_NO_LINK_TRACKING_IN_TRANSACTION = 0x1ac4
Global Const $ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = 0x1ac5
Global Const $ERROR_EXPIRED_HANDLE = 0x1ac6
Global Const $ERROR_TRANSACTION_NOT_ENLISTED = 0x1ac7
Global Const $ERROR_CTX_WINSTATION_NAME_INVALID = 0x1b59
Global Const $ERROR_CTX_INVALID_PD = 0x1b5a
Global Const $ERROR_CTX_PD_NOT_FOUND = 0x1b5b
Global Const $ERROR_CTX_WD_NOT_FOUND = 0x1b5c
Global Const $ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY = 0x1b5d
Global Const $ERROR_CTX_SERVICE_NAME_COLLISION = 0x1b5e
Global Const $ERROR_CTX_CLOSE_PENDING = 0x1b5f
Global Const $ERROR_CTX_NO_OUTBUF = 0x1b60
Global Const $ERROR_CTX_MODEM_INF_NOT_FOUND = 0x1b61
Global Const $ERROR_CTX_INVALID_MODEMNAME = 0x1b62
Global Const $ERROR_CTX_MODEM_RESPONSE_ERROR = 0x1b63
Global Const $ERROR_CTX_MODEM_RESPONSE_TIMEOUT = 0x1b64
Global Const $ERROR_CTX_MODEM_RESPONSE_NO_CARRIER = 0x1b65
Global Const $ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE = 0x1b66
Global Const $ERROR_CTX_MODEM_RESPONSE_BUSY = 0x1b67
Global Const $ERROR_CTX_MODEM_RESPONSE_VOICE = 0x1b68
Global Const $ERROR_CTX_TD_ERROR = 0x1b69
Global Const $ERROR_CTX_WINSTATION_NOT_FOUND = 0x1b6e
Global Const $ERROR_CTX_WINSTATION_ALREADY_EXISTS = 0x1b6f
Global Const $ERROR_CTX_WINSTATION_BUSY = 0x1b70
Global Const $ERROR_CTX_BAD_VIDEO_MODE = 0x1b71
Global Const $ERROR_CTX_GRAPHICS_INVALID = 0x1b7b
Global Const $ERROR_CTX_LOGON_DISABLED = 0x1b7d
Global Const $ERROR_CTX_NOT_CONSOLE = 0x1b7e
Global Const $ERROR_CTX_CLIENT_QUERY_TIMEOUT = 0x1b80
Global Const $ERROR_CTX_CONSOLE_DISCONNECT = 0x1b81
Global Const $ERROR_CTX_CONSOLE_CONNECT = 0x1b82
Global Const $ERROR_CTX_SHADOW_DENIED = 0x1b84
Global Const $ERROR_CTX_WINSTATION_ACCESS_DENIED = 0x1b85
Global Const $ERROR_CTX_INVALID_WD = 0x1b89
Global Const $ERROR_CTX_SHADOW_INVALID = 0x1b8a
Global Const $ERROR_CTX_SHADOW_DISABLED = 0x1b8b
Global Const $ERROR_CTX_CLIENT_LICENSE_IN_USE = 0x1b8c
Global Const $ERROR_CTX_CLIENT_LICENSE_NOT_SET = 0x1b8d
Global Const $ERROR_CTX_LICENSE_NOT_AVAILABLE = 0x1b8e
Global Const $ERROR_CTX_LICENSE_CLIENT_INVALID = 0x1b8f
Global Const $ERROR_CTX_LICENSE_EXPIRED = 0x1b90
Global Const $ERROR_CTX_SHADOW_NOT_RUNNING = 0x1b91
Global Const $ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE = 0x1b92
Global Const $ERROR_ACTIVATION_COUNT_EXCEEDED = 0x1b93
Global Const $ERROR_CTX_WINSTATIONS_DISABLED = 0x1b94
Global Const $ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED = 0x1b95
Global Const $ERROR_CTX_SESSION_IN_USE = 0x1b96
Global Const $ERROR_CTX_NO_FORCE_LOGOFF = 0x1b97
Global Const $ERROR_CTX_ACCOUNT_RESTRICTION = 0x1b98
Global Const $ERROR_RDP_PROTOCOL_ERROR = 0x1b99
Global Const $ERROR_CTX_CDM_CONNECT = 0x1b9a
Global Const $ERROR_CTX_CDM_DISCONNECT = 0x1b9b
Global Const $ERROR_CTX_SECURITY_LAYER_ERROR = 0x1b9c
Global Const $ERROR_TS_INCOMPATIBLE_SESSIONS = 0x1b9d
Global Const $FRS_ERR_INVALID_API_SEQUENCE = 0x1f41
Global Const $FRS_ERR_STARTING_SERVICE = 0x1f42
Global Const $FRS_ERR_STOPPING_SERVICE = 0x1f43
Global Const $FRS_ERR_INTERNAL_API = 0x1f44
Global Const $FRS_ERR_INTERNAL = 0x1f45
Global Const $FRS_ERR_SERVICE_COMM = 0x1f46
Global Const $FRS_ERR_INSUFFICIENT_PRIV = 0x1f47
Global Const $FRS_ERR_AUTHENTICATION = 0x1f48
Global Const $FRS_ERR_PARENT_INSUFFICIENT_PRIV = 0x1f49
Global Const $FRS_ERR_PARENT_AUTHENTICATION = 0x1f4a
Global Const $FRS_ERR_CHILD_TO_PARENT_COMM = 0x1f4b
Global Const $FRS_ERR_PARENT_TO_CHILD_COMM = 0x1f4c
Global Const $FRS_ERR_SYSVOL_POPULATE = 0x1f4d
Global Const $FRS_ERR_SYSVOL_POPULATE_TIMEOUT = 0x1f4e
Global Const $FRS_ERR_SYSVOL_IS_BUSY = 0x1f4f
Global Const $FRS_ERR_SYSVOL_DEMOTE = 0x1f50
Global Const $FRS_ERR_INVALID_SERVICE_PARAMETER = 0x1f51
Global Const $ERROR_DS_NOT_INSTALLED = 0x2008
Global Const $ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY = 0x2009
Global Const $ERROR_DS_NO_ATTRIBUTE_OR_VALUE = 0x200a
Global Const $ERROR_DS_INVALID_ATTRIBUTE_SYNTAX = 0x200b
Global Const $ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED = 0x200c
Global Const $ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS = 0x200d
Global Const $ERROR_DS_BUSY = 0x200e
Global Const $ERROR_DS_UNAVAILABLE = 0x200f
Global Const $ERROR_DS_NO_RIDS_ALLOCATED = 0x2010
Global Const $ERROR_DS_NO_MORE_RIDS = 0x2011
Global Const $ERROR_DS_INCORRECT_ROLE_OWNER = 0x2012
Global Const $ERROR_DS_RIDMGR_INIT_ERROR = 0x2013
Global Const $ERROR_DS_OBJ_CLASS_VIOLATION = 0x2014
Global Const $ERROR_DS_CANT_ON_NON_LEAF = 0x2015
Global Const $ERROR_DS_CANT_ON_RDN = 0x2016
Global Const $ERROR_DS_CANT_MOD_OBJ_CLASS = 0x2017
Global Const $ERROR_DS_CROSS_DOM_MOVE_ERROR = 0x2018
Global Const $ERROR_DS_GC_NOT_AVAILABLE = 0x2019
Global Const $ERROR_SHARED_POLICY = 0x201a
Global Const $ERROR_POLICY_OBJECT_NOT_FOUND = 0x201b
Global Const $ERROR_POLICY_ONLY_IN_DS = 0x201c
Global Const $ERROR_PROMOTION_ACTIVE = 0x201d
Global Const $ERROR_NO_PROMOTION_ACTIVE = 0x201e
Global Const $ERROR_DS_OPERATIONS_ERROR = 0x2020
Global Const $ERROR_DS_PROTOCOL_ERROR = 0x2021
Global Const $ERROR_DS_TIMELIMIT_EXCEEDED = 0x2022
Global Const $ERROR_DS_SIZELIMIT_EXCEEDED = 0x2023
Global Const $ERROR_DS_ADMIN_LIMIT_EXCEEDED = 0x2024
Global Const $ERROR_DS_COMPARE_FALSE = 0x2025
Global Const $ERROR_DS_COMPARE_TRUE = 0x2026
Global Const $ERROR_DS_AUTH_METHOD_NOT_SUPPORTED = 0x2027
Global Const $ERROR_DS_STRONG_AUTH_REQUIRED = 0x2028
Global Const $ERROR_DS_INAPPROPRIATE_AUTH = 0x2029
Global Const $ERROR_DS_AUTH_UNKNOWN = 0x202a
Global Const $ERROR_DS_REFERRAL = 0x202b
Global Const $ERROR_DS_UNAVAILABLE_CRIT_EXTENSION = 0x202c
Global Const $ERROR_DS_CONFIDENTIALITY_REQUIRED = 0x202d
Global Const $ERROR_DS_INAPPROPRIATE_MATCHING = 0x202e
Global Const $ERROR_DS_CONSTRAINT_VIOLATION = 0x202f
Global Const $ERROR_DS_NO_SUCH_OBJECT = 0x2030
Global Const $ERROR_DS_ALIAS_PROBLEM = 0x2031
Global Const $ERROR_DS_INVALID_DN_SYNTAX = 0x2032
Global Const $ERROR_DS_IS_LEAF = 0x2033
Global Const $ERROR_DS_ALIAS_DEREF_PROBLEM = 0x2034
Global Const $ERROR_DS_UNWILLING_TO_PERFORM = 0x2035
Global Const $ERROR_DS_LOOP_DETECT = 0x2036
Global Const $ERROR_DS_NAMING_VIOLATION = 0x2037
Global Const $ERROR_DS_OBJECT_RESULTS_TOO_LARGE = 0x2038
Global Const $ERROR_DS_AFFECTS_MULTIPLE_DSAS = 0x2039
Global Const $ERROR_DS_SERVER_DOWN = 0x203a
Global Const $ERROR_DS_LOCAL_ERROR = 0x203b
Global Const $ERROR_DS_ENCODING_ERROR = 0x203c
Global Const $ERROR_DS_DECODING_ERROR = 0x203d
Global Const $ERROR_DS_FILTER_UNKNOWN = 0x203e
Global Const $ERROR_DS_PARAM_ERROR = 0x203f
Global Const $ERROR_DS_NOT_SUPPORTED = 0x2040
Global Const $ERROR_DS_NO_RESULTS_RETURNED = 0x2041
Global Const $ERROR_DS_CONTROL_NOT_FOUND = 0x2042
Global Const $ERROR_DS_CLIENT_LOOP = 0x2043
Global Const $ERROR_DS_REFERRAL_LIMIT_EXCEEDED = 0x2044
Global Const $ERROR_DS_SORT_CONTROL_MISSING = 0x2045
Global Const $ERROR_DS_OFFSET_RANGE_ERROR = 0x2046
Global Const $ERROR_DS_ROOT_MUST_BE_NC = 0x206d
Global Const $ERROR_DS_ADD_REPLICA_INHIBITED = 0x206e
Global Const $ERROR_DS_ATT_NOT_DEF_IN_SCHEMA = 0x206f
Global Const $ERROR_DS_MAX_OBJ_SIZE_EXCEEDED = 0x2070
Global Const $ERROR_DS_OBJ_STRING_NAME_EXISTS = 0x2071
Global Const $ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA = 0x2072
Global Const $ERROR_DS_RDN_DOESNT_MATCH_SCHEMA = 0x2073
Global Const $ERROR_DS_NO_REQUESTED_ATTS_FOUND = 0x2074
Global Const $ERROR_DS_USER_BUFFER_TO_SMALL = 0x2075
Global Const $ERROR_DS_ATT_IS_NOT_ON_OBJ = 0x2076
Global Const $ERROR_DS_ILLEGAL_MOD_OPERATION = 0x2077
Global Const $ERROR_DS_OBJ_TOO_LARGE = 0x2078
Global Const $ERROR_DS_BAD_INSTANCE_TYPE = 0x2079
Global Const $ERROR_DS_MASTERDSA_REQUIRED = 0x207a
Global Const $ERROR_DS_OBJECT_CLASS_REQUIRED = 0x207b
Global Const $ERROR_DS_MISSING_REQUIRED_ATT = 0x207c
Global Const $ERROR_DS_ATT_NOT_DEF_FOR_CLASS = 0x207d
Global Const $ERROR_DS_ATT_ALREADY_EXISTS = 0x207e
Global Const $ERROR_DS_CANT_ADD_ATT_VALUES = 0x2080
Global Const $ERROR_DS_SINGLE_VALUE_CONSTRAINT = 0x2081
Global Const $ERROR_DS_RANGE_CONSTRAINT = 0x2082
Global Const $ERROR_DS_ATT_VAL_ALREADY_EXISTS = 0x2083
Global Const $ERROR_DS_CANT_REM_MISSING_ATT = 0x2084
Global Const $ERROR_DS_CANT_REM_MISSING_ATT_VAL = 0x2085
Global Const $ERROR_DS_ROOT_CANT_BE_SUBREF = 0x2086
Global Const $ERROR_DS_NO_CHAINING = 0x2087
Global Const $ERROR_DS_NO_CHAINED_EVAL = 0x2088
Global Const $ERROR_DS_NO_PARENT_OBJECT = 0x2089
Global Const $ERROR_DS_PARENT_IS_AN_ALIAS = 0x208a
Global Const $ERROR_DS_CANT_MIX_MASTER_AND_REPS = 0x208b
Global Const $ERROR_DS_CHILDREN_EXIST = 0x208c
Global Const $ERROR_DS_OBJ_NOT_FOUND = 0x208d
Global Const $ERROR_DS_ALIASED_OBJ_MISSING = 0x208e
Global Const $ERROR_DS_BAD_NAME_SYNTAX = 0x208f
Global Const $ERROR_DS_ALIAS_POINTS_TO_ALIAS = 0x2090
Global Const $ERROR_DS_CANT_DEREF_ALIAS = 0x2091
Global Const $ERROR_DS_OUT_OF_SCOPE = 0x2092
Global Const $ERROR_DS_OBJECT_BEING_REMOVED = 0x2093
Global Const $ERROR_DS_CANT_DELETE_DSA_OBJ = 0x2094
Global Const $ERROR_DS_GENERIC_ERROR = 0x2095
Global Const $ERROR_DS_DSA_MUST_BE_INT_MASTER = 0x2096
Global Const $ERROR_DS_CLASS_NOT_DSA = 0x2097
Global Const $ERROR_DS_INSUFF_ACCESS_RIGHTS = 0x2098
Global Const $ERROR_DS_ILLEGAL_SUPERIOR = 0x2099
Global Const $ERROR_DS_ATTRIBUTE_OWNED_BY_SAM = 0x209a
Global Const $ERROR_DS_NAME_TOO_MANY_PARTS = 0x209b
Global Const $ERROR_DS_NAME_TOO_LONG = 0x209c
Global Const $ERROR_DS_NAME_VALUE_TOO_LONG = 0x209d
Global Const $ERROR_DS_NAME_UNPARSEABLE = 0x209e
Global Const $ERROR_DS_NAME_TYPE_UNKNOWN = 0x209f
Global Const $ERROR_DS_NOT_AN_OBJECT = 0x20a0
Global Const $ERROR_DS_SEC_DESC_TOO_SHORT = 0x20a1
Global Const $ERROR_DS_SEC_DESC_INVALID = 0x20a2
Global Const $ERROR_DS_NO_DELETED_NAME = 0x20a3
Global Const $ERROR_DS_SUBREF_MUST_HAVE_PARENT = 0x20a4
Global Const $ERROR_DS_NCNAME_MUST_BE_NC = 0x20a5
Global Const $ERROR_DS_CANT_ADD_SYSTEM_ONLY = 0x20a6
Global Const $ERROR_DS_CLASS_MUST_BE_CONCRETE = 0x20a7
Global Const $ERROR_DS_INVALID_DMD = 0x20a8
Global Const $ERROR_DS_OBJ_GUID_EXISTS = 0x20a9
Global Const $ERROR_DS_NOT_ON_BACKLINK = 0x20aa
Global Const $ERROR_DS_NO_CROSSREF_FOR_NC = 0x20ab
Global Const $ERROR_DS_SHUTTING_DOWN = 0x20ac
Global Const $ERROR_DS_UNKNOWN_OPERATION = 0x20ad
Global Const $ERROR_DS_INVALID_ROLE_OWNER = 0x20ae
Global Const $ERROR_DS_COULDNT_CONTACT_FSMO = 0x20af
Global Const $ERROR_DS_CROSS_NC_DN_RENAME = 0x20b0
Global Const $ERROR_DS_CANT_MOD_SYSTEM_ONLY = 0x20b1
Global Const $ERROR_DS_REPLICATOR_ONLY = 0x20b2
Global Const $ERROR_DS_OBJ_CLASS_NOT_DEFINED = 0x20b3
Global Const $ERROR_DS_OBJ_CLASS_NOT_SUBCLASS = 0x20b4
Global Const $ERROR_DS_NAME_REFERENCE_INVALID = 0x20b5
Global Const $ERROR_DS_CROSS_REF_EXISTS = 0x20b6
Global Const $ERROR_DS_CANT_DEL_MASTER_CROSSREF = 0x20b7
Global Const $ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD = 0x20b8
Global Const $ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX = 0x20b9
Global Const $ERROR_DS_DUP_RDN = 0x20ba
Global Const $ERROR_DS_DUP_OID = 0x20bb
Global Const $ERROR_DS_DUP_MAPI_ID = 0x20bc
Global Const $ERROR_DS_DUP_SCHEMA_ID_GUID = 0x20bd
Global Const $ERROR_DS_DUP_LDAP_DISPLAY_NAME = 0x20be
Global Const $ERROR_DS_SEMANTIC_ATT_TEST = 0x20bf
Global Const $ERROR_DS_SYNTAX_MISMATCH = 0x20c0
Global Const $ERROR_DS_EXISTS_IN_MUST_HAVE = 0x20c1
Global Const $ERROR_DS_EXISTS_IN_MAY_HAVE = 0x20c2
Global Const $ERROR_DS_NONEXISTENT_MAY_HAVE = 0x20c3
Global Const $ERROR_DS_NONEXISTENT_MUST_HAVE = 0x20c4
Global Const $ERROR_DS_AUX_CLS_TEST_FAIL = 0x20c5
Global Const $ERROR_DS_NONEXISTENT_POSS_SUP = 0x20c6
Global Const $ERROR_DS_SUB_CLS_TEST_FAIL = 0x20c7
Global Const $ERROR_DS_BAD_RDN_ATT_ID_SYNTAX = 0x20c8
Global Const $ERROR_DS_EXISTS_IN_AUX_CLS = 0x20c9
Global Const $ERROR_DS_EXISTS_IN_SUB_CLS = 0x20ca
Global Const $ERROR_DS_EXISTS_IN_POSS_SUP = 0x20cb
Global Const $ERROR_DS_RECALCSCHEMA_FAILED = 0x20cc
Global Const $ERROR_DS_TREE_DELETE_NOT_FINISHED = 0x20cd
Global Const $ERROR_DS_CANT_DELETE = 0x20ce
Global Const $ERROR_DS_ATT_SCHEMA_REQ_ID = 0x20cf
Global Const $ERROR_DS_BAD_ATT_SCHEMA_SYNTAX = 0x20d0
Global Const $ERROR_DS_CANT_CACHE_ATT = 0x20d1
Global Const $ERROR_DS_CANT_CACHE_CLASS = 0x20d2
Global Const $ERROR_DS_CANT_REMOVE_ATT_CACHE = 0x20d3
Global Const $ERROR_DS_CANT_REMOVE_CLASS_CACHE = 0x20d4
Global Const $ERROR_DS_CANT_RETRIEVE_DN = 0x20d5
Global Const $ERROR_DS_MISSING_SUPREF = 0x20d6
Global Const $ERROR_DS_CANT_RETRIEVE_INSTANCE = 0x20d7
Global Const $ERROR_DS_CODE_INCONSISTENCY = 0x20d8
Global Const $ERROR_DS_DATABASE_ERROR = 0x20d9
Global Const $ERROR_DS_GOVERNSID_MISSING = 0x20da
Global Const $ERROR_DS_MISSING_EXPECTED_ATT = 0x20db
Global Const $ERROR_DS_NCNAME_MISSING_CR_REF = 0x20dc
Global Const $ERROR_DS_SECURITY_CHECKING_ERROR = 0x20dd
Global Const $ERROR_DS_SCHEMA_NOT_LOADED = 0x20de
Global Const $ERROR_DS_SCHEMA_ALLOC_FAILED = 0x20df
Global Const $ERROR_DS_ATT_SCHEMA_REQ_SYNTAX = 0x20e0
Global Const $ERROR_DS_GCVERIFY_ERROR = 0x20e1
Global Const $ERROR_DS_DRA_SCHEMA_MISMATCH = 0x20e2
Global Const $ERROR_DS_CANT_FIND_DSA_OBJ = 0x20e3
Global Const $ERROR_DS_CANT_FIND_EXPECTED_NC = 0x20e4
Global Const $ERROR_DS_CANT_FIND_NC_IN_CACHE = 0x20e5
Global Const $ERROR_DS_CANT_RETRIEVE_CHILD = 0x20e6
Global Const $ERROR_DS_SECURITY_ILLEGAL_MODIFY = 0x20e7
Global Const $ERROR_DS_CANT_REPLACE_HIDDEN_REC = 0x20e8
Global Const $ERROR_DS_BAD_HIERARCHY_FILE = 0x20e9
Global Const $ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED = 0x20ea
Global Const $ERROR_DS_CONFIG_PARAM_MISSING = 0x20eb
Global Const $ERROR_DS_COUNTING_AB_INDICES_FAILED = 0x20ec
Global Const $ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED = 0x20ed
Global Const $ERROR_DS_INTERNAL_FAILURE = 0x20ee
Global Const $ERROR_DS_UNKNOWN_ERROR = 0x20ef
Global Const $ERROR_DS_ROOT_REQUIRES_CLASS_TOP = 0x20f0
Global Const $ERROR_DS_REFUSING_FSMO_ROLES = 0x20f1
Global Const $ERROR_DS_MISSING_FSMO_SETTINGS = 0x20f2
Global Const $ERROR_DS_UNABLE_TO_SURRENDER_ROLES = 0x20f3
Global Const $ERROR_DS_DRA_GENERIC = 0x20f4
Global Const $ERROR_DS_DRA_INVALID_PARAMETER = 0x20f5
Global Const $ERROR_DS_DRA_BUSY = 0x20f6
Global Const $ERROR_DS_DRA_BAD_DN = 0x20f7
Global Const $ERROR_DS_DRA_BAD_NC = 0x20f8
Global Const $ERROR_DS_DRA_DN_EXISTS = 0x20f9
Global Const $ERROR_DS_DRA_INTERNAL_ERROR = 0x20fa
Global Const $ERROR_DS_DRA_INCONSISTENT_DIT = 0x20fb
Global Const $ERROR_DS_DRA_CONNECTION_FAILED = 0x20fc
Global Const $ERROR_DS_DRA_BAD_INSTANCE_TYPE = 0x20fd
Global Const $ERROR_DS_DRA_OUT_OF_MEM = 0x20fe
Global Const $ERROR_DS_DRA_MAIL_PROBLEM = 0x20ff
Global Const $ERROR_DS_DRA_REF_ALREADY_EXISTS = 0x2100
Global Const $ERROR_DS_DRA_REF_NOT_FOUND = 0x2101
Global Const $ERROR_DS_DRA_OBJ_IS_REP_SOURCE = 0x2102
Global Const $ERROR_DS_DRA_DB_ERROR = 0x2103
Global Const $ERROR_DS_DRA_NO_REPLICA = 0x2104
Global Const $ERROR_DS_DRA_ACCESS_DENIED = 0x2105
Global Const $ERROR_DS_DRA_NOT_SUPPORTED = 0x2106
Global Const $ERROR_DS_DRA_RPC_CANCELLED = 0x2107
Global Const $ERROR_DS_DRA_SOURCE_DISABLED = 0x2108
Global Const $ERROR_DS_DRA_SINK_DISABLED = 0x2109
Global Const $ERROR_DS_DRA_NAME_COLLISION = 0x210a
Global Const $ERROR_DS_DRA_SOURCE_REINSTALLED = 0x210b
Global Const $ERROR_DS_DRA_MISSING_PARENT = 0x210c
Global Const $ERROR_DS_DRA_PREEMPTED = 0x210d
Global Const $ERROR_DS_DRA_ABANDON_SYNC = 0x210e
Global Const $ERROR_DS_DRA_SHUTDOWN = 0x210f
Global Const $ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET = 0x2110
Global Const $ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA = 0x2111
Global Const $ERROR_DS_DRA_EXTN_CONNECTION_FAILED = 0x2112
Global Const $ERROR_DS_INSTALL_SCHEMA_MISMATCH = 0x2113
Global Const $ERROR_DS_DUP_LINK_ID = 0x2114
Global Const $ERROR_DS_NAME_ERROR_RESOLVING = 0x2115
Global Const $ERROR_DS_NAME_ERROR_NOT_FOUND = 0x2116
Global Const $ERROR_DS_NAME_ERROR_NOT_UNIQUE = 0x2117
Global Const $ERROR_DS_NAME_ERROR_NO_MAPPING = 0x2118
Global Const $ERROR_DS_NAME_ERROR_DOMAIN_ONLY = 0x2119
Global Const $ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = 0x211a
Global Const $ERROR_DS_CONSTRUCTED_ATT_MOD = 0x211b
Global Const $ERROR_DS_WRONG_OM_OBJ_CLASS = 0x211c
Global Const $ERROR_DS_DRA_REPL_PENDING = 0x211d
Global Const $ERROR_DS_DS_REQUIRED = 0x211e
Global Const $ERROR_DS_INVALID_LDAP_DISPLAY_NAME = 0x211f
Global Const $ERROR_DS_NON_BASE_SEARCH = 0x2120
Global Const $ERROR_DS_CANT_RETRIEVE_ATTS = 0x2121
Global Const $ERROR_DS_BACKLINK_WITHOUT_LINK = 0x2122
Global Const $ERROR_DS_EPOCH_MISMATCH = 0x2123
Global Const $ERROR_DS_SRC_NAME_MISMATCH = 0x2124
Global Const $ERROR_DS_SRC_AND_DST_NC_IDENTICAL = 0x2125
Global Const $ERROR_DS_DST_NC_MISMATCH = 0x2126
Global Const $ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC = 0x2127
Global Const $ERROR_DS_SRC_GUID_MISMATCH = 0x2128
Global Const $ERROR_DS_CANT_MOVE_DELETED_OBJECT = 0x2129
Global Const $ERROR_DS_PDC_OPERATION_IN_PROGRESS = 0x212a
Global Const $ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD = 0x212b
Global Const $ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION = 0x212c
Global Const $ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS = 0x212d
Global Const $ERROR_DS_NC_MUST_HAVE_NC_PARENT = 0x212e
Global Const $ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE = 0x212f
Global Const $ERROR_DS_DST_DOMAIN_NOT_NATIVE = 0x2130
Global Const $ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER = 0x2131
Global Const $ERROR_DS_CANT_MOVE_ACCOUNT_GROUP = 0x2132
Global Const $ERROR_DS_CANT_MOVE_RESOURCE_GROUP = 0x2133
Global Const $ERROR_DS_INVALID_SEARCH_FLAG = 0x2134
Global Const $ERROR_DS_NO_TREE_DELETE_ABOVE_NC = 0x2135
Global Const $ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE = 0x2136
Global Const $ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE = 0x2137
Global Const $ERROR_DS_SAM_INIT_FAILURE = 0x2138
Global Const $ERROR_DS_SENSITIVE_GROUP_VIOLATION = 0x2139
Global Const $ERROR_DS_CANT_MOD_PRIMARYGROUPID = 0x213a
Global Const $ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD = 0x213b
Global Const $ERROR_DS_NONSAFE_SCHEMA_CHANGE = 0x213c
Global Const $ERROR_DS_SCHEMA_UPDATE_DISALLOWED = 0x213d
Global Const $ERROR_DS_CANT_CREATE_UNDER_SCHEMA = 0x213e
Global Const $ERROR_DS_INSTALL_NO_SRC_SCH_VERSION = 0x213f
Global Const $ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE = 0x2140
Global Const $ERROR_DS_INVALID_GROUP_TYPE = 0x2141
Global Const $ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = 0x2142
Global Const $ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = 0x2143
Global Const $ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = 0x2144
Global Const $ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = 0x2145
Global Const $ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = 0x2146
Global Const $ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = 0x2147
Global Const $ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = 0x2148
Global Const $ERROR_DS_HAVE_PRIMARY_MEMBERS = 0x2149
Global Const $ERROR_DS_STRING_SD_CONVERSION_FAILED = 0x214a
Global Const $ERROR_DS_NAMING_MASTER_GC = 0x214b
Global Const $ERROR_DS_DNS_LOOKUP_FAILURE = 0x214c
Global Const $ERROR_DS_COULDNT_UPDATE_SPNS = 0x214d
Global Const $ERROR_DS_CANT_RETRIEVE_SD = 0x214e
Global Const $ERROR_DS_KEY_NOT_UNIQUE = 0x214f
Global Const $ERROR_DS_WRONG_LINKED_ATT_SYNTAX = 0x2150
Global Const $ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD = 0x2151
Global Const $ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY = 0x2152
Global Const $ERROR_DS_CANT_START = 0x2153
Global Const $ERROR_DS_INIT_FAILURE = 0x2154
Global Const $ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION = 0x2155
Global Const $ERROR_DS_SOURCE_DOMAIN_IN_FOREST = 0x2156
Global Const $ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST = 0x2157
Global Const $ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED = 0x2158
Global Const $ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN = 0x2159
Global Const $ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER = 0x215a
Global Const $ERROR_DS_SRC_SID_EXISTS_IN_FOREST = 0x215b
Global Const $ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH = 0x215c
Global Const $ERROR_SAM_INIT_FAILURE = 0x215d
Global Const $ERROR_DS_DRA_SCHEMA_INFO_SHIP = 0x215e
Global Const $ERROR_DS_DRA_SCHEMA_CONFLICT = 0x215f
Global Const $ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT = 0x2160
Global Const $ERROR_DS_DRA_OBJ_NC_MISMATCH = 0x2161
Global Const $ERROR_DS_NC_STILL_HAS_DSAS = 0x2162
Global Const $ERROR_DS_GC_REQUIRED = 0x2163
Global Const $ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = 0x2164
Global Const $ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS = 0x2165
Global Const $ERROR_DS_CANT_ADD_TO_GC = 0x2166
Global Const $ERROR_DS_NO_CHECKPOINT_WITH_PDC = 0x2167
Global Const $ERROR_DS_SOURCE_AUDITING_NOT_ENABLED = 0x2168
Global Const $ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC = 0x2169
Global Const $ERROR_DS_INVALID_NAME_FOR_SPN = 0x216a
Global Const $ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS = 0x216b
Global Const $ERROR_DS_UNICODEPWD_NOT_IN_QUOTES = 0x216c
Global Const $ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = 0x216d
Global Const $ERROR_DS_MUST_BE_RUN_ON_DST_DC = 0x216e
Global Const $ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER = 0x216f
Global Const $ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ = 0x2170
Global Const $ERROR_DS_INIT_FAILURE_CONSOLE = 0x2171
Global Const $ERROR_DS_SAM_INIT_FAILURE_CONSOLE = 0x2172
Global Const $ERROR_DS_FOREST_VERSION_TOO_HIGH = 0x2173
Global Const $ERROR_DS_DOMAIN_VERSION_TOO_HIGH = 0x2174
Global Const $ERROR_DS_FOREST_VERSION_TOO_LOW = 0x2175
Global Const $ERROR_DS_DOMAIN_VERSION_TOO_LOW = 0x2176
Global Const $ERROR_DS_INCOMPATIBLE_VERSION = 0x2177
Global Const $ERROR_DS_LOW_DSA_VERSION = 0x2178
Global Const $ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN = 0x2179
Global Const $ERROR_DS_NOT_SUPPORTED_SORT_ORDER = 0x217a
Global Const $ERROR_DS_NAME_NOT_UNIQUE = 0x217b
Global Const $ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 = 0x217c
Global Const $ERROR_DS_OUT_OF_VERSION_STORE = 0x217d
Global Const $ERROR_DS_INCOMPATIBLE_CONTROLS_USED = 0x217e
Global Const $ERROR_DS_NO_REF_DOMAIN = 0x217f
Global Const $ERROR_DS_RESERVED_LINK_ID = 0x2180
Global Const $ERROR_DS_LINK_ID_NOT_AVAILABLE = 0x2181
Global Const $ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = 0x2182
Global Const $ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE = 0x2183
Global Const $ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC = 0x2184
Global Const $ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG = 0x2185
Global Const $ERROR_DS_MODIFYDN_WRONG_GRANDPARENT = 0x2186
Global Const $ERROR_DS_NAME_ERROR_TRUST_REFERRAL = 0x2187
Global Const $ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER = 0x2188
Global Const $ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD = 0x2189
Global Const $ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 = 0x218a
Global Const $ERROR_DS_THREAD_LIMIT_EXCEEDED = 0x218b
Global Const $ERROR_DS_NOT_CLOSEST = 0x218c
Global Const $ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF = 0x218d
Global Const $ERROR_DS_SINGLE_USER_MODE_FAILED = 0x218e
Global Const $ERROR_DS_NTDSCRIPT_SYNTAX_ERROR = 0x218f
Global Const $ERROR_DS_NTDSCRIPT_PROCESS_ERROR = 0x2190
Global Const $ERROR_DS_DIFFERENT_REPL_EPOCHS = 0x2191
Global Const $ERROR_DS_DRS_EXTENSIONS_CHANGED = 0x2192
Global Const $ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR = 0x2193
Global Const $ERROR_DS_NO_MSDS_INTID = 0x2194
Global Const $ERROR_DS_DUP_MSDS_INTID = 0x2195
Global Const $ERROR_DS_EXISTS_IN_RDNATTID = 0x2196
Global Const $ERROR_DS_AUTHORIZATION_FAILED = 0x2197
Global Const $ERROR_DS_INVALID_SCRIPT = 0x2198
Global Const $ERROR_DS_REMOTE_CROSSREF_OP_FAILED = 0x2199
Global Const $ERROR_DS_CROSS_REF_BUSY = 0x219a
Global Const $ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN = 0x219b
Global Const $ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC = 0x219c
Global Const $ERROR_DS_DUPLICATE_ID_FOUND = 0x219d
Global Const $ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT = 0x219e
Global Const $ERROR_DS_GROUP_CONVERSION_ERROR = 0x219f
Global Const $ERROR_DS_CANT_MOVE_APP_BASIC_GROUP = 0x21a0
Global Const $ERROR_DS_CANT_MOVE_APP_QUERY_GROUP = 0x21a1
Global Const $ERROR_DS_ROLE_NOT_VERIFIED = 0x21a2
Global Const $ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL = 0x21a3
Global Const $ERROR_DS_DOMAIN_RENAME_IN_PROGRESS = 0x21a4
Global Const $ERROR_DS_EXISTING_AD_CHILD_NC = 0x21a5
Global Const $ERROR_DS_REPL_LIFETIME_EXCEEDED = 0x21a6
Global Const $ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER = 0x21a7
Global Const $ERROR_DS_LDAP_SEND_QUEUE_FULL = 0x21a8
Global Const $ERROR_DS_DRA_OUT_SCHEDULE_WINDOW = 0x21a9
Global Const $ERROR_DS_POLICY_NOT_KNOWN = 0x21aa
Global Const $ERROR_NO_SITE_SETTINGS_OBJECT = 0x21ab
Global Const $ERROR_NO_SECRETS = 0x21ac
Global Const $ERROR_NO_WRITABLE_DC_FOUND = 0x21ad
Global Const $ERROR_DS_NO_SERVER_OBJECT = 0x21ae
Global Const $ERROR_DS_NO_NTDSA_OBJECT = 0x21af
Global Const $ERROR_DS_NON_ASQ_SEARCH = 0x21b0
Global Const $ERROR_DS_AUDIT_FAILURE = 0x21b1
Global Const $ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE = 0x21b2
Global Const $ERROR_DS_INVALID_SEARCH_FLAG_TUPLE = 0x21b3
Global Const $ERROR_DS_HIERARCHY_TABLE_TOO_DEEP = 0x21b4
Global Const $ERROR_DS_DRA_CORRUPT_UTD_VECTOR = 0x21b5
Global Const $ERROR_DS_DRA_SECRETS_DENIED = 0x21b6
Global Const $ERROR_DS_RESERVED_MAPI_ID = 0x21b7
Global Const $ERROR_DS_MAPI_ID_NOT_AVAILABLE = 0x21b8
Global Const $ERROR_DS_DRA_MISSING_KRBTGT_SECRET = 0x21b9
Global Const $ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST = 0x21ba
Global Const $ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST = 0x21bb
Global Const $ERROR_INVALID_USER_PRINCIPAL_NAME = 0x21bc
Global Const $ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = 0x21bd
Global Const $ERROR_DS_OID_NOT_FOUND = 0x21be
Global Const $DNS_ERROR_RCODE_FORMAT_ERROR = 0x2329
Global Const $DNS_ERROR_RCODE_SERVER_FAILURE = 0x232a
Global Const $DNS_ERROR_RCODE_NAME_ERROR = 0x232b
Global Const $DNS_ERROR_RCODE_NOT_IMPLEMENTED = 0x232c
Global Const $DNS_ERROR_RCODE_REFUSED = 0x232d
Global Const $DNS_ERROR_RCODE_YXDOMAIN = 0x232e
Global Const $DNS_ERROR_RCODE_YXRRSET = 0x232f
Global Const $DNS_ERROR_RCODE_NXRRSET = 0x2330
Global Const $DNS_ERROR_RCODE_NOTAUTH = 0x2331
Global Const $DNS_ERROR_RCODE_NOTZONE = 0x2332
Global Const $DNS_ERROR_RCODE_BADSIG = 0x2338
Global Const $DNS_ERROR_RCODE_BADKEY = 0x2339
Global Const $DNS_ERROR_RCODE_BADTIME = 0x233a
Global Const $DNS_INFO_NO_RECORDS = 0x251d
Global Const $DNS_ERROR_BAD_PACKET = 0x251e
Global Const $DNS_ERROR_NO_PACKET = 0x251f
Global Const $DNS_ERROR_RCODE = 0x2520
Global Const $DNS_ERROR_UNSECURE_PACKET = 0x2521
Global Const $DNS_ERROR_INVALID_TYPE = 0x254f
Global Const $DNS_ERROR_INVALID_IP_ADDRESS = 0x2550
Global Const $DNS_ERROR_INVALID_PROPERTY = 0x2551
Global Const $DNS_ERROR_TRY_AGAIN_LATER = 0x2552
Global Const $DNS_ERROR_NOT_UNIQUE = 0x2553
Global Const $DNS_ERROR_NON_RFC_NAME = 0x2554
Global Const $DNS_STATUS_FQDN = 0x2555
Global Const $DNS_STATUS_DOTTED_NAME = 0x2556
Global Const $DNS_STATUS_SINGLE_PART_NAME = 0x2557
Global Const $DNS_ERROR_INVALID_NAME_CHAR = 0x2558
Global Const $DNS_ERROR_NUMERIC_NAME = 0x2559
Global Const $DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER = 0x255a
Global Const $DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION = 0x255b
Global Const $DNS_ERROR_CANNOT_FIND_ROOT_HINTS = 0x255c
Global Const $DNS_ERROR_INCONSISTENT_ROOT_HINTS = 0x255d
Global Const $DNS_ERROR_DWORD_VALUE_TOO_SMALL = 0x255e
Global Const $DNS_ERROR_DWORD_VALUE_TOO_LARGE = 0x255f
Global Const $DNS_ERROR_BACKGROUND_LOADING = 0x2560
Global Const $DNS_ERROR_NOT_ALLOWED_ON_RODC = 0x2561
Global Const $DNS_ERROR_NOT_ALLOWED_UNDER_DNAME = 0x2562
Global Const $DNS_ERROR_DELEGATION_REQUIRED = 0x2563
Global Const $DNS_ERROR_ZONE_DOES_NOT_EXIST = 0x2581
Global Const $DNS_ERROR_NO_ZONE_INFO = 0x2582
Global Const $DNS_ERROR_INVALID_ZONE_OPERATION = 0x2583
Global Const $DNS_ERROR_ZONE_CONFIGURATION_ERROR = 0x2584
Global Const $DNS_ERROR_ZONE_HAS_NO_SOA_RECORD = 0x2585
Global Const $DNS_ERROR_ZONE_HAS_NO_NS_RECORDS = 0x2586
Global Const $DNS_ERROR_ZONE_LOCKED = 0x2587
Global Const $DNS_ERROR_ZONE_CREATION_FAILED = 0x2588
Global Const $DNS_ERROR_ZONE_ALREADY_EXISTS = 0x2589
Global Const $DNS_ERROR_AUTOZONE_ALREADY_EXISTS = 0x258a
Global Const $DNS_ERROR_INVALID_ZONE_TYPE = 0x258b
Global Const $DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP = 0x258c
Global Const $DNS_ERROR_ZONE_NOT_SECONDARY = 0x258d
Global Const $DNS_ERROR_NEED_SECONDARY_ADDRESSES = 0x258e
Global Const $DNS_ERROR_WINS_INIT_FAILED = 0x258f
Global Const $DNS_ERROR_NEED_WINS_SERVERS = 0x2590
Global Const $DNS_ERROR_NBSTAT_INIT_FAILED = 0x2591
Global Const $DNS_ERROR_SOA_DELETE_INVALID = 0x2592
Global Const $DNS_ERROR_FORWARDER_ALREADY_EXISTS = 0x2593
Global Const $DNS_ERROR_ZONE_REQUIRES_MASTER_IP = 0x2594
Global Const $DNS_ERROR_ZONE_IS_SHUTDOWN = 0x2595
Global Const $DNS_ERROR_PRIMARY_REQUIRES_DATAFILE = 0x25b3
Global Const $DNS_ERROR_INVALID_DATAFILE_NAME = 0x25b4
Global Const $DNS_ERROR_DATAFILE_OPEN_FAILURE = 0x25b5
Global Const $DNS_ERROR_FILE_WRITEBACK_FAILED = 0x25b6
Global Const $DNS_ERROR_DATAFILE_PARSING = 0x25b7
Global Const $DNS_ERROR_RECORD_DOES_NOT_EXIST = 0x25e5
Global Const $DNS_ERROR_RECORD_FORMAT = 0x25e6
Global Const $DNS_ERROR_NODE_CREATION_FAILED = 0x25e7
Global Const $DNS_ERROR_UNKNOWN_RECORD_TYPE = 0x25e8
Global Const $DNS_ERROR_RECORD_TIMED_OUT = 0x25e9
Global Const $DNS_ERROR_NAME_NOT_IN_ZONE = 0x25ea
Global Const $DNS_ERROR_CNAME_LOOP = 0x25eb
Global Const $DNS_ERROR_NODE_IS_CNAME = 0x25ec
Global Const $DNS_ERROR_CNAME_COLLISION = 0x25ed
Global Const $DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT = 0x25ee
Global Const $DNS_ERROR_RECORD_ALREADY_EXISTS = 0x25ef
Global Const $DNS_ERROR_SECONDARY_DATA = 0x25f0
Global Const $DNS_ERROR_NO_CREATE_CACHE_DATA = 0x25f1
Global Const $DNS_ERROR_NAME_DOES_NOT_EXIST = 0x25f2
Global Const $DNS_WARNING_PTR_CREATE_FAILED = 0x25f3
Global Const $DNS_WARNING_DOMAIN_UNDELETED = 0x25f4
Global Const $DNS_ERROR_DS_UNAVAILABLE = 0x25f5
Global Const $DNS_ERROR_DS_ZONE_ALREADY_EXISTS = 0x25f6
Global Const $DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE = 0x25f7
Global Const $DNS_ERROR_NODE_IS_DNAME = 0x25f8
Global Const $DNS_ERROR_DNAME_COLLISION = 0x25f9
Global Const $DNS_ERROR_ALIAS_LOOP = 0x25fa
Global Const $DNS_INFO_AXFR_COMPLETE = 0x2617
Global Const $DNS_ERROR_AXFR = 0x2618
Global Const $DNS_INFO_ADDED_LOCAL_WINS = 0x2619
Global Const $DNS_STATUS_CONTINUE_NEEDED = 0x2649
Global Const $DNS_ERROR_NO_TCPIP = 0x267b
Global Const $DNS_ERROR_NO_DNS_SERVERS = 0x267c
Global Const $DNS_ERROR_DP_DOES_NOT_EXIST = 0x26ad
Global Const $DNS_ERROR_DP_ALREADY_EXISTS = 0x26ae
Global Const $DNS_ERROR_DP_NOT_ENLISTED = 0x26af
Global Const $DNS_ERROR_DP_ALREADY_ENLISTED = 0x26b0
Global Const $DNS_ERROR_DP_NOT_AVAILABLE = 0x26b1
Global Const $DNS_ERROR_DP_FSMO_ERROR = 0x26b2
Global Const $WSAEINTR = 0x2714
Global Const $WSAEBADF = 0x2719
Global Const $WSAEACCES = 0x271d
Global Const $WSAEFAULT = 0x271e
Global Const $WSAEINVAL = 0x2726
Global Const $WSAEMFILE = 0x2728
Global Const $WSAEWOULDBLOCK = 0x2733
Global Const $WSAEINPROGRESS = 0x2734
Global Const $WSAEALREADY = 0x2735
Global Const $WSAENOTSOCK = 0x2736
Global Const $WSAEDESTADDRREQ = 0x2737
Global Const $WSAEMSGSIZE = 0x2738
Global Const $WSAEPROTOTYPE = 0x2739
Global Const $WSAENOPROTOOPT = 0x273a
Global Const $WSAEPROTONOSUPPORT = 0x273b
Global Const $WSAESOCKTNOSUPPORT = 0x273c
Global Const $WSAEOPNOTSUPP = 0x273d
Global Const $WSAEPFNOSUPPORT = 0x273e
Global Const $WSAEAFNOSUPPORT = 0x273f
Global Const $WSAEADDRINUSE = 0x2740
Global Const $WSAEADDRNOTAVAIL = 0x2741
Global Const $WSAENETDOWN = 0x2742
Global Const $WSAENETUNREACH = 0x2743
Global Const $WSAENETRESET = 0x2744
Global Const $WSAECONNABORTED = 0x2745
Global Const $WSAECONNRESET = 0x2746
Global Const $WSAENOBUFS = 0x2747
Global Const $WSAEISCONN = 0x2748
Global Const $WSAENOTCONN = 0x2749
Global Const $WSAESHUTDOWN = 0x274a
Global Const $WSAETOOMANYREFS = 0x274b
Global Const $WSAETIMEDOUT = 0x274c
Global Const $WSAECONNREFUSED = 0x274d
Global Const $WSAELOOP = 0x274e
Global Const $WSAENAMETOOLONG = 0x274f
Global Const $WSAEHOSTDOWN = 0x2750
Global Const $WSAEHOSTUNREACH = 0x2751
Global Const $WSAENOTEMPTY = 0x2752
Global Const $WSAEPROCLIM = 0x2753
Global Const $WSAEUSERS = 0x2754
Global Const $WSAEDQUOT = 0x2755
Global Const $WSAESTALE = 0x2756
Global Const $WSAEREMOTE = 0x2757
Global Const $WSASYSNOTREADY = 0x276b
Global Const $WSAVERNOTSUPPORTED = 0x276c
Global Const $WSANOTINITIALISED = 0x276d
Global Const $WSAEDISCON = 0x2775
Global Const $WSAENOMORE = 0x2776
Global Const $WSAECANCELLED = 0x2777
Global Const $WSAEINVALIDPROCTABLE = 0x2778
Global Const $WSAEINVALIDPROVIDER = 0x2779
Global Const $WSAEPROVIDERFAILEDINIT = 0x277a
Global Const $WSASYSCALLFAILURE = 0x277b
Global Const $WSASERVICE_NOT_FOUND = 0x277c
Global Const $WSATYPE_NOT_FOUND = 0x277d
Global Const $WSA_E_NO_MORE = 0x277e
Global Const $WSA_E_CANCELLED = 0x277f
Global Const $WSAEREFUSED = 0x2780
Global Const $WSAHOST_NOT_FOUND = 0x2af9
Global Const $WSATRY_AGAIN = 0x2afa
Global Const $WSANO_RECOVERY = 0x2afb
Global Const $WSANO_DATA = 0x2afc
Global Const $WSA_QOS_RECEIVERS = 0x2afd
Global Const $WSA_QOS_SENDERS = 0x2afe
Global Const $WSA_QOS_NO_SENDERS = 0x2aff
Global Const $WSA_QOS_NO_RECEIVERS = 0x2b00
Global Const $WSA_QOS_REQUEST_CONFIRMED = 0x2b01
Global Const $WSA_QOS_ADMISSION_FAILURE = 0x2b02
Global Const $WSA_QOS_POLICY_FAILURE = 0x2b03
Global Const $WSA_QOS_BAD_STYLE = 0x2b04
Global Const $WSA_QOS_BAD_OBJECT = 0x2b05
Global Const $WSA_QOS_TRAFFIC_CTRL_ERROR = 0x2b06
Global Const $WSA_QOS_GENERIC_ERROR = 0x2b07
Global Const $WSA_QOS_ESERVICETYPE = 0x2b08
Global Const $WSA_QOS_EFLOWSPEC = 0x2b09
Global Const $WSA_QOS_EPROVSPECBUF = 0x2b0a
Global Const $WSA_QOS_EFILTERSTYLE = 0x2b0b
Global Const $WSA_QOS_EFILTERTYPE = 0x2b0c
Global Const $WSA_QOS_EFILTERCOUNT = 0x2b0d
Global Const $WSA_QOS_EOBJLENGTH = 0x2b0e
Global Const $WSA_QOS_EFLOWCOUNT = 0x2b0f
Global Const $WSA_QOS_EUNKOWNPSOBJ = 0x2b10
Global Const $WSA_QOS_EPOLICYOBJ = 0x2b11
Global Const $WSA_QOS_EFLOWDESC = 0x2b12
Global Const $WSA_QOS_EPSFLOWSPEC = 0x2b13
Global Const $WSA_QOS_EPSFILTERSPEC = 0x2b14
Global Const $WSA_QOS_ESDMODEOBJ = 0x2b15
Global Const $WSA_QOS_ESHAPERATEOBJ = 0x2b16
Global Const $WSA_QOS_RESERVED_PETYPE = 0x2b17
Global Const $WSA_SECURE_HOST_NOT_FOUND = 0x2b18
Global Const $WSA_IPSEC_NAME_POLICY_ERROR = 0x2b19
Global Const $ERROR_IPSEC_QM_POLICY_EXISTS = 0x32c8
Global Const $ERROR_IPSEC_QM_POLICY_NOT_FOUND = 0x32c9
Global Const $ERROR_IPSEC_QM_POLICY_IN_USE = 0x32ca
Global Const $ERROR_IPSEC_MM_POLICY_EXISTS = 0x32cb
Global Const $ERROR_IPSEC_MM_POLICY_NOT_FOUND = 0x32cc
Global Const $ERROR_IPSEC_MM_POLICY_IN_USE = 0x32cd
Global Const $ERROR_IPSEC_MM_FILTER_EXISTS = 0x32ce
Global Const $ERROR_IPSEC_MM_FILTER_NOT_FOUND = 0x32cf
Global Const $ERROR_IPSEC_TRANSPORT_FILTER_EXISTS = 0x32d0
Global Const $ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND = 0x32d1
Global Const $ERROR_IPSEC_MM_AUTH_EXISTS = 0x32d2
Global Const $ERROR_IPSEC_MM_AUTH_NOT_FOUND = 0x32d3
Global Const $ERROR_IPSEC_MM_AUTH_IN_USE = 0x32d4
Global Const $ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND = 0x32d5
Global Const $ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND = 0x32d6
Global Const $ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND = 0x32d7
Global Const $ERROR_IPSEC_TUNNEL_FILTER_EXISTS = 0x32d8
Global Const $ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND = 0x32d9
Global Const $ERROR_IPSEC_MM_FILTER_PENDING_DELETION = 0x32da
Global Const $ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION = 0x32db
Global Const $ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION = 0x32dc
Global Const $ERROR_IPSEC_MM_POLICY_PENDING_DELETION = 0x32dd
Global Const $ERROR_IPSEC_MM_AUTH_PENDING_DELETION = 0x32de
Global Const $ERROR_IPSEC_QM_POLICY_PENDING_DELETION = 0x32df
Global Const $WARNING_IPSEC_MM_POLICY_PRUNED = 0x32e0
Global Const $WARNING_IPSEC_QM_POLICY_PRUNED = 0x32e1
Global Const $ERROR_IPSEC_IKE_NEG_STATUS_BEGIN = 0x35e8
Global Const $ERROR_IPSEC_IKE_AUTH_FAIL = 0x35e9
Global Const $ERROR_IPSEC_IKE_ATTRIB_FAIL = 0x35ea
Global Const $ERROR_IPSEC_IKE_NEGOTIATION_PENDING = 0x35eb
Global Const $ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR = 0x35ec
Global Const $ERROR_IPSEC_IKE_TIMED_OUT = 0x35ed
Global Const $ERROR_IPSEC_IKE_NO_CERT = 0x35ee
Global Const $ERROR_IPSEC_IKE_SA_DELETED = 0x35ef
Global Const $ERROR_IPSEC_IKE_SA_REAPED = 0x35f0
Global Const $ERROR_IPSEC_IKE_MM_ACQUIRE_DROP = 0x35f1
Global Const $ERROR_IPSEC_IKE_QM_ACQUIRE_DROP = 0x35f2
Global Const $ERROR_IPSEC_IKE_QUEUE_DROP_MM = 0x35f3
Global Const $ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM = 0x35f4
Global Const $ERROR_IPSEC_IKE_DROP_NO_RESPONSE = 0x35f5
Global Const $ERROR_IPSEC_IKE_MM_DELAY_DROP = 0x35f6
Global Const $ERROR_IPSEC_IKE_QM_DELAY_DROP = 0x35f7
Global Const $ERROR_IPSEC_IKE_ERROR = 0x35f8
Global Const $ERROR_IPSEC_IKE_CRL_FAILED = 0x35f9
Global Const $ERROR_IPSEC_IKE_INVALID_KEY_USAGE = 0x35fa
Global Const $ERROR_IPSEC_IKE_INVALID_CERT_TYPE = 0x35fb
Global Const $ERROR_IPSEC_IKE_NO_PRIVATE_KEY = 0x35fc
Global Const $ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY = 0x35fd
Global Const $ERROR_IPSEC_IKE_DH_FAIL = 0x35fe
Global Const $ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED = 0x35ff
Global Const $ERROR_IPSEC_IKE_INVALID_HEADER = 0x3600
Global Const $ERROR_IPSEC_IKE_NO_POLICY = 0x3601
Global Const $ERROR_IPSEC_IKE_INVALID_SIGNATURE = 0x3602
Global Const $ERROR_IPSEC_IKE_KERBEROS_ERROR = 0x3603
Global Const $ERROR_IPSEC_IKE_NO_PUBLIC_KEY = 0x3604
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR = 0x3605
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_SA = 0x3606
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_PROP = 0x3607
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_TRANS = 0x3608
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_KE = 0x3609
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_ID = 0x360a
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_CERT = 0x360b
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ = 0x360c
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_HASH = 0x360d
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_SIG = 0x360e
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_NONCE = 0x360f
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY = 0x3610
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_DELETE = 0x3611
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR = 0x3612
Global Const $ERROR_IPSEC_IKE_INVALID_PAYLOAD = 0x3613
Global Const $ERROR_IPSEC_IKE_LOAD_SOFT_SA = 0x3614
Global Const $ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN = 0x3615
Global Const $ERROR_IPSEC_IKE_INVALID_COOKIE = 0x3616
Global Const $ERROR_IPSEC_IKE_NO_PEER_CERT = 0x3617
Global Const $ERROR_IPSEC_IKE_PEER_CRL_FAILED = 0x3618
Global Const $ERROR_IPSEC_IKE_POLICY_CHANGE = 0x3619
Global Const $ERROR_IPSEC_IKE_NO_MM_POLICY = 0x361a
Global Const $ERROR_IPSEC_IKE_NOTCBPRIV = 0x361b
Global Const $ERROR_IPSEC_IKE_SECLOADFAIL = 0x361c
Global Const $ERROR_IPSEC_IKE_FAILSSPINIT = 0x361d
Global Const $ERROR_IPSEC_IKE_FAILQUERYSSP = 0x361e
Global Const $ERROR_IPSEC_IKE_SRVACQFAIL = 0x361f
Global Const $ERROR_IPSEC_IKE_SRVQUERYCRED = 0x3620
Global Const $ERROR_IPSEC_IKE_GETSPIFAIL = 0x3621
Global Const $ERROR_IPSEC_IKE_INVALID_FILTER = 0x3622
Global Const $ERROR_IPSEC_IKE_OUT_OF_MEMORY = 0x3623
Global Const $ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED = 0x3624
Global Const $ERROR_IPSEC_IKE_INVALID_POLICY = 0x3625
Global Const $ERROR_IPSEC_IKE_UNKNOWN_DOI = 0x3626
Global Const $ERROR_IPSEC_IKE_INVALID_SITUATION = 0x3627
Global Const $ERROR_IPSEC_IKE_DH_FAILURE = 0x3628
Global Const $ERROR_IPSEC_IKE_INVALID_GROUP = 0x3629
Global Const $ERROR_IPSEC_IKE_ENCRYPT = 0x362a
Global Const $ERROR_IPSEC_IKE_DECRYPT = 0x362b
Global Const $ERROR_IPSEC_IKE_POLICY_MATCH = 0x362c
Global Const $ERROR_IPSEC_IKE_UNSUPPORTED_ID = 0x362d
Global Const $ERROR_IPSEC_IKE_INVALID_HASH = 0x362e
Global Const $ERROR_IPSEC_IKE_INVALID_HASH_ALG = 0x362f
Global Const $ERROR_IPSEC_IKE_INVALID_HASH_SIZE = 0x3630
Global Const $ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG = 0x3631
Global Const $ERROR_IPSEC_IKE_INVALID_AUTH_ALG = 0x3632
Global Const $ERROR_IPSEC_IKE_INVALID_SIG = 0x3633
Global Const $ERROR_IPSEC_IKE_LOAD_FAILED = 0x3634
Global Const $ERROR_IPSEC_IKE_RPC_DELETE = 0x3635
Global Const $ERROR_IPSEC_IKE_BENIGN_REINIT = 0x3636
Global Const $ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY = 0x3637
Global Const $ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION = 0x3638
Global Const $ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN = 0x3639
Global Const $ERROR_IPSEC_IKE_MM_LIMIT = 0x363a
Global Const $ERROR_IPSEC_IKE_NEGOTIATION_DISABLED = 0x363b
Global Const $ERROR_IPSEC_IKE_QM_LIMIT = 0x363c
Global Const $ERROR_IPSEC_IKE_MM_EXPIRED = 0x363d
Global Const $ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID = 0x363e
Global Const $ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH = 0x363f
Global Const $ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID = 0x3640
Global Const $ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD = 0x3641
Global Const $ERROR_IPSEC_IKE_DOS_COOKIE_SENT = 0x3642
Global Const $ERROR_IPSEC_IKE_SHUTTING_DOWN = 0x3643
Global Const $ERROR_IPSEC_IKE_CGA_AUTH_FAILED = 0x3644
Global Const $ERROR_IPSEC_IKE_PROCESS_ERR_NATOA = 0x3645
Global Const $ERROR_IPSEC_IKE_INVALID_MM_FOR_QM = 0x3646
Global Const $ERROR_IPSEC_IKE_QM_EXPIRED = 0x3647
Global Const $ERROR_IPSEC_IKE_TOO_MANY_FILTERS = 0x3648
Global Const $ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL = 0x364a
Global Const $ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE = 0x364b
Global Const $ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING = 0x364c
Global Const $ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING = 0x364d
Global Const $ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS = 0x364e
Global Const $ERROR_IPSEC_IKE_RATELIMIT_DROP = 0x364f
Global Const $ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE = 0x3650
Global Const $ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE = 0x3651
Global Const $ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END = 0x3655
Global Const $ERROR_IPSEC_BAD_SPI = 0x3656
Global Const $ERROR_IPSEC_SA_LIFETIME_EXPIRED = 0x3657
Global Const $ERROR_IPSEC_WRONG_SA = 0x3658
Global Const $ERROR_IPSEC_REPLAY_CHECK_FAILED = 0x3659
Global Const $ERROR_IPSEC_INVALID_PACKET = 0x365a
Global Const $ERROR_IPSEC_INTEGRITY_CHECK_FAILED = 0x365b
Global Const $ERROR_IPSEC_CLEAR_TEXT_DROP = 0x365c
Global Const $ERROR_IPSEC_AUTH_FIREWALL_DROP = 0x365d
Global Const $ERROR_IPSEC_THROTTLE_DROP = 0x365e
Global Const $ERROR_IPSEC_DOSP_BLOCK = 0x3665
Global Const $ERROR_IPSEC_DOSP_RECEIVED_MULTICAST = 0x3666
Global Const $ERROR_IPSEC_DOSP_INVALID_PACKET = 0x3667
Global Const $ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED = 0x3668
Global Const $ERROR_IPSEC_DOSP_MAX_ENTRIES = 0x3669
Global Const $ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = 0x366a
Global Const $ERROR_IPSEC_DOSP_NOT_INSTALLED = 0x366b
Global Const $ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = 0x366c
Global Const $ERROR_SXS_SECTION_NOT_FOUND = 0x36b0
Global Const $ERROR_SXS_CANT_GEN_ACTCTX = 0x36b1
Global Const $ERROR_SXS_INVALID_ACTCTXDATA_FORMAT = 0x36b2
Global Const $ERROR_SXS_ASSEMBLY_NOT_FOUND = 0x36b3
Global Const $ERROR_SXS_MANIFEST_FORMAT_ERROR = 0x36b4
Global Const $ERROR_SXS_MANIFEST_PARSE_ERROR = 0x36b5
Global Const $ERROR_SXS_ACTIVATION_CONTEXT_DISABLED = 0x36b6
Global Const $ERROR_SXS_KEY_NOT_FOUND = 0x36b7
Global Const $ERROR_SXS_VERSION_CONFLICT = 0x36b8
Global Const $ERROR_SXS_WRONG_SECTION_TYPE = 0x36b9
Global Const $ERROR_SXS_THREAD_QUERIES_DISABLED = 0x36ba
Global Const $ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET = 0x36bb
Global Const $ERROR_SXS_UNKNOWN_ENCODING_GROUP = 0x36bc
Global Const $ERROR_SXS_UNKNOWN_ENCODING = 0x36bd
Global Const $ERROR_SXS_INVALID_XML_NAMESPACE_URI = 0x36be
Global Const $ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED = 0x36bf
Global Const $ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED = 0x36c0
Global Const $ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE = 0x36c1
Global Const $ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE = 0x36c2
Global Const $ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE = 0x36c3
Global Const $ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT = 0x36c4
Global Const $ERROR_SXS_DUPLICATE_DLL_NAME = 0x36c5
Global Const $ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME = 0x36c6
Global Const $ERROR_SXS_DUPLICATE_CLSID = 0x36c7
Global Const $ERROR_SXS_DUPLICATE_IID = 0x36c8
Global Const $ERROR_SXS_DUPLICATE_TLBID = 0x36c9
Global Const $ERROR_SXS_DUPLICATE_PROGID = 0x36ca
Global Const $ERROR_SXS_DUPLICATE_ASSEMBLY_NAME = 0x36cb
Global Const $ERROR_SXS_FILE_HASH_MISMATCH = 0x36cc
Global Const $ERROR_SXS_POLICY_PARSE_ERROR = 0x36cd
Global Const $ERROR_SXS_XML_E_MISSINGQUOTE = 0x36ce
Global Const $ERROR_SXS_XML_E_COMMENTSYNTAX = 0x36cf
Global Const $ERROR_SXS_XML_E_BADSTARTNAMECHAR = 0x36d0
Global Const $ERROR_SXS_XML_E_BADNAMECHAR = 0x36d1
Global Const $ERROR_SXS_XML_E_BADCHARINSTRING = 0x36d2
Global Const $ERROR_SXS_XML_E_XMLDECLSYNTAX = 0x36d3
Global Const $ERROR_SXS_XML_E_BADCHARDATA = 0x36d4
Global Const $ERROR_SXS_XML_E_MISSINGWHITESPACE = 0x36d5
Global Const $ERROR_SXS_XML_E_EXPECTINGTAGEND = 0x36d6
Global Const $ERROR_SXS_XML_E_MISSINGSEMICOLON = 0x36d7
Global Const $ERROR_SXS_XML_E_UNBALANCEDPAREN = 0x36d8
Global Const $ERROR_SXS_XML_E_INTERNALERROR = 0x36d9
Global Const $ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE = 0x36da
Global Const $ERROR_SXS_XML_E_INCOMPLETE_ENCODING = 0x36db
Global Const $ERROR_SXS_XML_E_MISSING_PAREN = 0x36dc
Global Const $ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE = 0x36dd
Global Const $ERROR_SXS_XML_E_MULTIPLE_COLONS = 0x36de
Global Const $ERROR_SXS_XML_E_INVALID_DECIMAL = 0x36df
Global Const $ERROR_SXS_XML_E_INVALID_HEXIDECIMAL = 0x36e0
Global Const $ERROR_SXS_XML_E_INVALID_UNICODE = 0x36e1
Global Const $ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK = 0x36e2
Global Const $ERROR_SXS_XML_E_UNEXPECTEDENDTAG = 0x36e3
Global Const $ERROR_SXS_XML_E_UNCLOSEDTAG = 0x36e4
Global Const $ERROR_SXS_XML_E_DUPLICATEATTRIBUTE = 0x36e5
Global Const $ERROR_SXS_XML_E_MULTIPLEROOTS = 0x36e6
Global Const $ERROR_SXS_XML_E_INVALIDATROOTLEVEL = 0x36e7
Global Const $ERROR_SXS_XML_E_BADXMLDECL = 0x36e8
Global Const $ERROR_SXS_XML_E_MISSINGROOT = 0x36e9
Global Const $ERROR_SXS_XML_E_UNEXPECTEDEOF = 0x36ea
Global Const $ERROR_SXS_XML_E_BADPEREFINSUBSET = 0x36eb
Global Const $ERROR_SXS_XML_E_UNCLOSEDSTARTTAG = 0x36ec
Global Const $ERROR_SXS_XML_E_UNCLOSEDENDTAG = 0x36ed
Global Const $ERROR_SXS_XML_E_UNCLOSEDSTRING = 0x36ee
Global Const $ERROR_SXS_XML_E_UNCLOSEDCOMMENT = 0x36ef
Global Const $ERROR_SXS_XML_E_UNCLOSEDDECL = 0x36f0
Global Const $ERROR_SXS_XML_E_UNCLOSEDCDATA = 0x36f1
Global Const $ERROR_SXS_XML_E_RESERVEDNAMESPACE = 0x36f2
Global Const $ERROR_SXS_XML_E_INVALIDENCODING = 0x36f3
Global Const $ERROR_SXS_XML_E_INVALIDSWITCH = 0x36f4
Global Const $ERROR_SXS_XML_E_BADXMLCASE = 0x36f5
Global Const $ERROR_SXS_XML_E_INVALID_STANDALONE = 0x36f6
Global Const $ERROR_SXS_XML_E_UNEXPECTED_STANDALONE = 0x36f7
Global Const $ERROR_SXS_XML_E_INVALID_VERSION = 0x36f8
Global Const $ERROR_SXS_XML_E_MISSINGEQUALS = 0x36f9
Global Const $ERROR_SXS_PROTECTION_RECOVERY_FAILED = 0x36fa
Global Const $ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT = 0x36fb
Global Const $ERROR_SXS_PROTECTION_CATALOG_NOT_VALID = 0x36fc
Global Const $ERROR_SXS_UNTRANSLATABLE_HRESULT = 0x36fd
Global Const $ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING = 0x36fe
Global Const $ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE = 0x36ff
Global Const $ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME = 0x3700
Global Const $ERROR_SXS_ASSEMBLY_MISSING = 0x3701
Global Const $ERROR_SXS_CORRUPT_ACTIVATION_STACK = 0x3702
Global Const $ERROR_SXS_CORRUPTION = 0x3703
Global Const $ERROR_SXS_EARLY_DEACTIVATION = 0x3704
Global Const $ERROR_SXS_INVALID_DEACTIVATION = 0x3705
Global Const $ERROR_SXS_MULTIPLE_DEACTIVATION = 0x3706
Global Const $ERROR_SXS_PROCESS_TERMINATION_REQUESTED = 0x3707
Global Const $ERROR_SXS_RELEASE_ACTIVATION_CONTEXT = 0x3708
Global Const $ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = 0x3709
Global Const $ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = 0x370a
Global Const $ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = 0x370b
Global Const $ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = 0x370c
Global Const $ERROR_SXS_IDENTITY_PARSE_ERROR = 0x370d
Global Const $ERROR_MALFORMED_SUBSTITUTION_STRING = 0x370e
Global Const $ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN = 0x370f
Global Const $ERROR_UNMAPPED_SUBSTITUTION_STRING = 0x3710
Global Const $ERROR_SXS_ASSEMBLY_NOT_LOCKED = 0x3711
Global Const $ERROR_SXS_COMPONENT_STORE_CORRUPT = 0x3712
Global Const $ERROR_ADVANCED_INSTALLER_FAILED = 0x3713
Global Const $ERROR_XML_ENCODING_MISMATCH = 0x3714
Global Const $ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = 0x3715
Global Const $ERROR_SXS_IDENTITIES_DIFFERENT = 0x3716
Global Const $ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = 0x3717
Global Const $ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY = 0x3718
Global Const $ERROR_SXS_MANIFEST_TOO_BIG = 0x3719
Global Const $ERROR_SXS_SETTING_NOT_REGISTERED = 0x371a
Global Const $ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE = 0x371b
Global Const $ERROR_SMI_PRIMITIVE_INSTALLER_FAILED = 0x371c
Global Const $ERROR_GENERIC_COMMAND_FAILED = 0x371d
Global Const $ERROR_SXS_FILE_HASH_MISSING = 0x371e
Global Const $ERROR_EVT_INVALID_CHANNEL_PATH = 0x3a98
Global Const $ERROR_EVT_INVALID_QUERY = 0x3a99
Global Const $ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND = 0x3a9a
Global Const $ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND = 0x3a9b
Global Const $ERROR_EVT_INVALID_PUBLISHER_NAME = 0x3a9c
Global Const $ERROR_EVT_INVALID_EVENT_DATA = 0x3a9d
Global Const $ERROR_EVT_CHANNEL_NOT_FOUND = 0x3a9f
Global Const $ERROR_EVT_MALFORMED_XML_TEXT = 0x3aa0
Global Const $ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL = 0x3aa1
Global Const $ERROR_EVT_CONFIGURATION_ERROR = 0x3aa2
Global Const $ERROR_EVT_QUERY_RESULT_STALE = 0x3aa3
Global Const $ERROR_EVT_QUERY_RESULT_INVALID_POSITION = 0x3aa4
Global Const $ERROR_EVT_NON_VALIDATING_MSXML = 0x3aa5
Global Const $ERROR_EVT_FILTER_ALREADYSCOPED = 0x3aa6
Global Const $ERROR_EVT_FILTER_NOTELTSET = 0x3aa7
Global Const $ERROR_EVT_FILTER_INVARG = 0x3aa8
Global Const $ERROR_EVT_FILTER_INVTEST = 0x3aa9
Global Const $ERROR_EVT_FILTER_INVTYPE = 0x3aaa
Global Const $ERROR_EVT_FILTER_PARSEERR = 0x3aab
Global Const $ERROR_EVT_FILTER_UNSUPPORTEDOP = 0x3aac
Global Const $ERROR_EVT_FILTER_UNEXPECTEDTOKEN = 0x3aad
Global Const $ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL = 0x3aae
Global Const $ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE = 0x3aaf
Global Const $ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE = 0x3ab0
Global Const $ERROR_EVT_CHANNEL_CANNOT_ACTIVATE = 0x3ab1
Global Const $ERROR_EVT_FILTER_TOO_COMPLEX = 0x3ab2
Global Const $ERROR_EVT_MESSAGE_NOT_FOUND = 0x3ab3
Global Const $ERROR_EVT_MESSAGE_ID_NOT_FOUND = 0x3ab4
Global Const $ERROR_EVT_UNRESOLVED_VALUE_INSERT = 0x3ab5
Global Const $ERROR_EVT_UNRESOLVED_PARAMETER_INSERT = 0x3ab6
Global Const $ERROR_EVT_MAX_INSERTS_REACHED = 0x3ab7
Global Const $ERROR_EVT_EVENT_DEFINITION_NOT_FOUND = 0x3ab8
Global Const $ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND = 0x3ab9
Global Const $ERROR_EVT_VERSION_TOO_OLD = 0x3aba
Global Const $ERROR_EVT_VERSION_TOO_NEW = 0x3abb
Global Const $ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY = 0x3abc
Global Const $ERROR_EVT_PUBLISHER_DISABLED = 0x3abd
Global Const $ERROR_EVT_FILTER_OUT_OF_RANGE = 0x3abe
Global Const $ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE = 0x3ae8
Global Const $ERROR_EC_LOG_DISABLED = 0x3ae9
Global Const $ERROR_EC_CIRCULAR_FORWARDING = 0x3aea
Global Const $ERROR_EC_CREDSTORE_FULL = 0x3aeb
Global Const $ERROR_EC_CRED_NOT_FOUND = 0x3aec
Global Const $ERROR_EC_NO_ACTIVE_CHANNEL = 0x3aed
Global Const $ERROR_MUI_FILE_NOT_FOUND = 0x3afc
Global Const $ERROR_MUI_INVALID_FILE = 0x3afd
Global Const $ERROR_MUI_INVALID_RC_CONFIG = 0x3afe
Global Const $ERROR_MUI_INVALID_LOCALE_NAME = 0x3aff
Global Const $ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME = 0x3b00
Global Const $ERROR_MUI_FILE_NOT_LOADED = 0x3b01
Global Const $ERROR_RESOURCE_ENUM_USER_STOP = 0x3b02
Global Const $ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED = 0x3b03
Global Const $ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME = 0x3b04
Global Const $ERROR_MCA_INVALID_CAPABILITIES_STRING = 0x3b60
Global Const $ERROR_MCA_INVALID_VCP_VERSION = 0x3b61
Global Const $ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION = 0x3b62
Global Const $ERROR_MCA_MCCS_VERSION_MISMATCH = 0x3b63
Global Const $ERROR_MCA_UNSUPPORTED_MCCS_VERSION = 0x3b64
Global Const $ERROR_MCA_INTERNAL_ERROR = 0x3b65
Global Const $ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = 0x3b66
Global Const $ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE = 0x3b67
Global Const $ERROR_AMBIGUOUS_SYSTEM_DEVICE = 0x3b92
Global Const $ERROR_SYSTEM_DEVICE_NOT_FOUND = 0x3bc3
Global Const $ERROR_HASH_NOT_SUPPORTED = 0x3bc4
Global Const $ERROR_HASH_NOT_PRESENT = 0x3bc5
#Region Global Variables and Constants
    Global $_g_arraydisplay_hlistview
    Global $_g_arraydisplay_itranspose
    Global $_g_arraydisplay_idisplayrow
    Global $_g_arraydisplay_aarray
    Global $_g_arraydisplay_idims
    Global $_g_arraydisplay_nrows
    Global $_g_arraydisplay_ncols
    Global $_g_arraydisplay_iitem_start
    Global $_g_arraydisplay_iitem_end
    Global $_g_arraydisplay_isubitem_start
    Global $_g_arraydisplay_isubitem_end
    Global $_g_arraydisplay_aindex
    Global $_g_arraydisplay_aindexes[0x1]
    Global $_g_arraydisplay_isortdir
    Global $_g_arraydisplay_asheader
    Global $_g_arraydisplay_anumericsort
    Global $arraydisplay_rowprefix = "#"
    Global $arraydisplay_numericsort = "*"
    Global Const $ARRAYDISPLAY_COLALIGNLEFT = 0x0
    Global Const $ARRAYDISPLAY_TRANSPOSE = 0x1
    Global Const $ARRAYDISPLAY_COLALIGNRIGHT = 0x2
    Global Const $ARRAYDISPLAY_COLALIGNCENTER = 0x4
    Global Const $ARRAYDISPLAY_VERBOSE = 0x8
    Global Const $ARRAYDISPLAY_NOROW = 0x40
    Global Const $ARRAYDISPLAY_CHECKERROR = 0x80
    Global Const $_ARRAYCONSTANT_TAGLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
Func __ArrayDisplay_Share(Const ByRef $AARRAY, $STITLE = Default, $SARRAYRANGE = Default, $IFLAGS = Default, $VUSER_SEPARATOR = Default, $SHEADER = Default, $IMAX_COLWIDTH = Default, $HUSER_FUNCTION = Default, $BDEBUG = True, Const $_ISCRIPTLINENUMBER = @ScriptLineNumber, Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    Local $smsgboxtitle = (($BDEBUG) ? ("_DebugArrayDisplay") : ("_ArrayDisplay"))
    If $STITLE = Default Then $STITLE = $smsgboxtitle
    If $SARRAYRANGE = Default Then $SARRAYRANGE = ''
    If $IFLAGS = Default Then $IFLAGS = 0x0
    If $VUSER_SEPARATOR = Default Then $VUSER_SEPARATOR = ''
    If $SHEADER = Default Then $SHEADER = ''
    If $IMAX_COLWIDTH = Default Then $IMAX_COLWIDTH = 0x15e
    If $IMAX_COLWIDTH > 0xfff Then $IMAX_COLWIDTH = 0xfff
    If $HUSER_FUNCTION = Default Then $HUSER_FUNCTION = 0x0
    $_g_arraydisplay_itranspose = BitAND($IFLAGS, $ARRAYDISPLAY_TRANSPOSE)
    Local $icolalign = BitAND($IFLAGS, 0x6)
    Local $iverbose = Int(BitAND($IFLAGS, $ARRAYDISPLAY_VERBOSE))
    $_g_arraydisplay_idisplayrow = Int(BitAND($IFLAGS, $ARRAYDISPLAY_NOROW) = 0x0)
    Local $ibuttonborder = (($BDEBUG) ? (0x28) : (0x14))
    #Region Check valid array
        Local $smsg = '', $iret = 0x1
        Local $ftimer = 0x0
        If IsArray($AARRAY) Then
            $_g_arraydisplay_aarray = $AARRAY
            $_g_arraydisplay_idims = UBound($_g_arraydisplay_aarray, $UBOUND_DIMENSIONS)
            If $_g_arraydisplay_idims = 0x1 Then $_g_arraydisplay_itranspose = 0x0
            $_g_arraydisplay_nrows = UBound($_g_arraydisplay_aarray, $UBOUND_ROWS)
            $_g_arraydisplay_ncols = ($_g_arraydisplay_idims = 0x2) ? UBound($_g_arraydisplay_aarray, $UBOUND_COLUMNS) : 0x1
            Dim $_g_arraydisplay_anumericsort[$_g_arraydisplay_ncols]
            If $_g_arraydisplay_idims > 0x2 Then
                $smsg = "Larger than 2D array passed to function"
                $iret = 0x2
            EndIf
            If $_ICALLERERROR Then
                If $BDEBUG Then
                    If IsDeclared("__g_sReportCallBack_DebugReport_Debug") Then
                        $smsg = "@@ Debug( " & $_ISCRIPTLINENUMBER & ") : @error = " & $_ICALLERERROR & " in " & $smsgboxtitle & "( '" & $STITLE & "' )"
                        Execute("$__g_sReportCallBack_DebugReport_Debug(""" & $smsg & """)")
                    EndIf
                    $iret = 0x3
                ElseIf BitAND($IFLAGS, $ARRAYDISPLAY_CHECKERROR) Then
                    $smsg = "@error = " & $_ICALLERERROR & " when calling the function"
                    If $_ISCRIPTLINENUMBER > 0x0 Then $smsg &= " at line " & $_ISCRIPTLINENUMBER
                    $iret = 0x3
                EndIf
            EndIf
        Else
            $smsg = "No array variable passed to function"
        EndIf
        If $smsg Then
            If $iverbose And MsgBox($MB_SYSTEMMODAL + $MB_ICONERROR + $MB_YESNO, $smsgboxtitle & "() Error: " & $STITLE, $smsg & @CRLF & @CRLF & "Exit the script?") = $IDYES Then
                Exit
            Else
                Return SetError($iret, 0x0, 0x0)
            EndIf
        EndIf
    #EndRegion Check valid array
    #Region Check array range
        Local $icw_colwidth = Number($VUSER_SEPARATOR)
        Local $scurr_separator = Opt("GUIDataSeparatorChar")
        If $VUSER_SEPARATOR = '' Then $VUSER_SEPARATOR = $scurr_separator
        $_g_arraydisplay_iitem_start = 0x0
        $_g_arraydisplay_iitem_end = $_g_arraydisplay_nrows + -1
        $_g_arraydisplay_isubitem_start = 0x0
        $_g_arraydisplay_isubitem_end = (($_g_arraydisplay_idims = 0x2) ? ($_g_arraydisplay_ncols + -1) : (0x0))
        Local $avrangesplit
        If $SARRAYRANGE Then
            Local $vtmp, $aarray_range = StringRegExp($SARRAYRANGE & "||", "(?U)(.*)\\|", $STR_REGEXPARRAYGLOBALMATCH)
            If $aarray_range[0x0] Then
                $avrangesplit = StringSplit($aarray_range[0x0], ":")
                If @error Then
                    $_g_arraydisplay_iitem_end = Number($aarray_range[0x0])
                Else
                    $_g_arraydisplay_iitem_start = Number($avrangesplit[0x1])
                    If $avrangesplit[0x2] <> '' Then
                        $_g_arraydisplay_iitem_end = Number($avrangesplit[0x2])
                    EndIf
                EndIf
            EndIf
            If $_g_arraydisplay_iitem_start < 0x0 Then $_g_arraydisplay_iitem_start = 0x0
            If $_g_arraydisplay_iitem_end >= $_g_arraydisplay_nrows Then $_g_arraydisplay_iitem_end = $_g_arraydisplay_nrows + -1
            If ($_g_arraydisplay_iitem_start > $_g_arraydisplay_iitem_end) And ($_g_arraydisplay_iitem_end > 0x0) Then
                $vtmp = $_g_arraydisplay_iitem_start
                $_g_arraydisplay_iitem_start = $_g_arraydisplay_iitem_end
                $_g_arraydisplay_iitem_end = $vtmp
            EndIf
            If $_g_arraydisplay_idims = 0x2 And $aarray_range[0x1] Then
                $avrangesplit = StringSplit($aarray_range[0x1], ":")
                If @error Then
                    $_g_arraydisplay_isubitem_end = Number($aarray_range[0x1])
                Else
                    $_g_arraydisplay_isubitem_start = Number($avrangesplit[0x1])
                    If $avrangesplit[0x2] <> '' Then
                        $_g_arraydisplay_isubitem_end = Number($avrangesplit[0x2])
                    EndIf
                EndIf
                If $_g_arraydisplay_isubitem_start > $_g_arraydisplay_isubitem_end Then
                    $vtmp = $_g_arraydisplay_isubitem_start
                    $_g_arraydisplay_isubitem_start = $_g_arraydisplay_isubitem_end
                    $_g_arraydisplay_isubitem_end = $vtmp
                EndIf
                If $_g_arraydisplay_isubitem_start < 0x0 Then $_g_arraydisplay_isubitem_start = 0x0
                If $_g_arraydisplay_isubitem_end >= $_g_arraydisplay_ncols Then $_g_arraydisplay_isubitem_end = $_g_arraydisplay_ncols + -1
            EndIf
        EndIf
        Local $sdisplaydata = "[" & $_g_arraydisplay_nrows & "]"
        If $_g_arraydisplay_idims = 0x2 Then
            $sdisplaydata &= " [" & $_g_arraydisplay_ncols & "]"
        EndIf
        Local $stipdata = ''
        If $SARRAYRANGE Then
            If $stipdata Then $stipdata &= " - "
            $stipdata &= "Range set " & $SARRAYRANGE
        EndIf
        If $_g_arraydisplay_itranspose Then
            If $stipdata Then $stipdata &= " - "
            $stipdata &= "Transposed"
        EndIf
        If $SARRAYRANGE Or $_g_arraydisplay_itranspose Then $_g_arraydisplay_aarray = __arraydisplay_createsubarray()
    #EndRegion Check array range
    #Region Check custom header
        $_g_arraydisplay_asheader = StringSplit($SHEADER, $scurr_separator, $STR_NOCOUNT)
        If UBound($_g_arraydisplay_asheader) = 0x0 Then Dim $_g_arraydisplay_asheader[0x1] = ['']
        $SHEADER = "Row"
        Local $iindex = $_g_arraydisplay_isubitem_start
        If $_g_arraydisplay_itranspose Then
            $SHEADER = "Row"
            For $j = 0x0 To $_g_arraydisplay_ncols + -1
                $SHEADER &= $scurr_separator & $arraydisplay_rowprefix & " " & $j + $_g_arraydisplay_isubitem_start
            Next
        Else
            If $_g_arraydisplay_asheader[0x0] Then
                For $iindex = $_g_arraydisplay_isubitem_start To $_g_arraydisplay_isubitem_end
                    If $iindex >= UBound($_g_arraydisplay_asheader) Then ExitLoop
                    If StringRight($_g_arraydisplay_asheader[$iindex], 0x1) = $arraydisplay_numericsort Then
                        $_g_arraydisplay_asheader[$iindex] = StringTrimRight($_g_arraydisplay_asheader[$iindex], 0x1)
                        $_g_arraydisplay_anumericsort[$iindex - $_g_arraydisplay_isubitem_start] = 0x1
                    EndIf
                    $SHEADER &= $scurr_separator & $_g_arraydisplay_asheader[$iindex]
                Next
            EndIf
            For $j = $iindex To $_g_arraydisplay_isubitem_end
                $SHEADER &= $scurr_separator & "Col " & $j
            Next
        EndIf
        If Not $_g_arraydisplay_idisplayrow Then $SHEADER = StringTrimLeft($SHEADER, 0x4)
    #EndRegion Check custom header
    #Region Generate Sort index for columns
        __arraydisplay_sortindexes(0x0, + -1)
        Local $htimer = TimerInit()
        __arraydisplay_sortindexes(0x1, 0x1)
        $ftimer = TimerDiff($htimer)
        If $ftimer * $_g_arraydisplay_ncols < 0x3e8 Then
            __arraydisplay_sortindexes(0x2, $_g_arraydisplay_ncols)
            If $BDEBUG Then ConsoleWrite("Sorting all indexes = " & TimerDiff($htimer) & @CRLF & @CRLF)
        Else
            If $BDEBUG Then ConsoleWrite("Sorting one index = " & TimerDiff($htimer) & @CRLF)
        EndIf
    #EndRegion Generate Sort index for columns
    #Region GUI and Listview generation
        If $iverbose And ($_g_arraydisplay_nrows * $_g_arraydisplay_ncols) > 0x3e8 Then
            SplashTextOn($smsgboxtitle, "Preparing display" & @CRLF & @CRLF & "Please be patient", 0x12c, 0x64)
        EndIf
        Local Const $_ARRAYCONSTANT_GUI_DOCKBOTTOM = 0x40
        Local Const $_ARRAYCONSTANT_GUI_DOCKBORDERS = 0x66
        Local Const $_ARRAYCONSTANT_GUI_DOCKHEIGHT = 0x200
        Local Const $_ARRAYCONSTANT_GUI_DOCKLEFT = 0x2
        Local Const $_ARRAYCONSTANT_GUI_DOCKRIGHT = 0x4
        Local Const $_ARRAYCONSTANT_GUI_DOCKHCENTER = 0x8
        Local Const $_ARRAYCONSTANT_GUI_EVENT_CLOSE = + -3
        Local Const $_ARRAYCONSTANT_GUI_EVENT_ARRAY = 0x1
        Local Const $_ARRAYCONSTANT_GUI_FOCUS = 0x100
        Local Const $_ARRAYCONSTANT_SS_CENTER = 0x1
        Local Const $_ARRAYCONSTANT_SS_CENTERIMAGE = 0x200
        Local Const $_ARRAYCONSTANT_LVM_GETITEMRECT = (0x1000 + 0xe)
        Local Const $_ARRAYCONSTANT_LVM_GETITEMSTATE = (0x1000 + 0x2c)
        Local Const $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT = (0x1000 + 0x32)
        Local Const $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE = (0x1000 + 0x36)
        Local Const $_ARRAYCONSTANT_LVS_EX_GRIDLINES = 0x1
        Local Const $_ARRAYCONSTANT_LVIS_SELECTED = 0x2
        Local Const $_ARRAYCONSTANT_LVS_SHOWSELALWAYS = 0x8
        Local Const $_ARRAYCONSTANT_LVS_OWNERDATA = 0x1000
        Local Const $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT = 0x20
        Local Const $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER = 0x10000
        Local Const $_ARRAYCONSTANT_WS_EX_CLIENTEDGE = 0x200
        Local Const $_ARRAYCONSTANT_WS_MAXIMIZEBOX = 0x10000
        Local Const $_ARRAYCONSTANT_WS_MINIMIZEBOX = 0x20000
        Local Const $_ARRAYCONSTANT_WS_SIZEBOX = 0x40000
        Local $icoordmode = Opt("GUICoordMode", 0x1)
        Local $iorgwidth = 0xd2, $iheight = 0xc8, $iminsize = 0xfa
        Local $hgui = GUICreate($STITLE, $iorgwidth, $iheight, Default, Default, BitOR($_ARRAYCONSTANT_WS_SIZEBOX, $_ARRAYCONSTANT_WS_MINIMIZEBOX, $_ARRAYCONSTANT_WS_MAXIMIZEBOX))
        Local $aiguisize = WinGetClientSize($hgui)
        Local $idlistview = GUICtrlCreateListView($SHEADER, 0x0, 0x0, $aiguisize[0x0], $aiguisize[0x1] - $ibuttonborder, BitOR($_ARRAYCONSTANT_LVS_SHOWSELALWAYS, $_ARRAYCONSTANT_LVS_OWNERDATA))
        $_g_arraydisplay_hlistview = GUICtrlGetHandle($idlistview)
        GUICtrlSendMsg($idlistview, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_GRIDLINES, $_ARRAYCONSTANT_LVS_EX_GRIDLINES)
        GUICtrlSendMsg($idlistview, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT)
        GUICtrlSendMsg($idlistview, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER, $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER)
        GUICtrlSendMsg($idlistview, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE)
        Local $hheader = HWnd(GUICtrlSendMsg($idlistview, (0x1000 + 0x1f), 0x0, 0x0))
        GUICtrlSetResizing($idlistview, $_ARRAYCONSTANT_GUI_DOCKBORDERS)
        Local $icolfill = $_g_arraydisplay_ncols + $_g_arraydisplay_idisplayrow
        If $icolalign Then
            For $i = 0x0 To $icolfill + -1
                __ArrayDisplay_JustifyColumn($idlistview, $i, $icolalign / 0x2)
            Next
        EndIf
        GUICtrlSendMsg($idlistview, (0x1000 + 0x2f), $_g_arraydisplay_nrows, 0x0)
        Local $trect = DllStructCreate("struct; long Left;long Top;long Right;long Bottom; endstruct")
        DllCall("user32.dll", "struct*", "SendMessageW", "hwnd", $_g_arraydisplay_hlistview, "uint", $_ARRAYCONSTANT_LVM_GETITEMRECT, "wparam", 0x0, "struct*", $trect)
        Local $aiwin_pos = WinGetPos($hgui)
        Local $ailv_pos = ControlGetPos($hgui, '', $idlistview)
        $iheight = (($_g_arraydisplay_nrows + 0x3) * (DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top"))) + $aiwin_pos[0x3] - $ailv_pos[0x3]
        If $iheight > @DesktopHeight + -100 Then
            $iheight = @DesktopHeight + -100
        ElseIf $iheight < $iminsize Then
            $iheight = $iminsize
        EndIf
        If $iverbose Then SplashOff()
        $_g_arraydisplay_isortdir = 0x400
        Local $icolumn = 0x0, $icolumnprev = + -1
        If $_g_arraydisplay_idisplayrow Then
            $icolumnprev = $icolumn
            __arraydisplay_headersetitemformat($hheader, $icolumn, 0x4000 + $_g_arraydisplay_isortdir + $icolalign / 0x2)
        EndIf
        $_g_arraydisplay_aindex = $_g_arraydisplay_aindexes[0x0]
    #EndRegion GUI and Listview generation
    Local $p__arraydisplay_notifyhandler = DllCallbackGetPtr(DllCallbackRegister("__ArrayDisplay_NotifyHandler", "lresult", "hwnd;uint;wparam;lparam;uint_ptr;dword_ptr"))
    DllCall("comctl32.dll", "bool", "SetWindowSubclass", "hwnd", $hgui, "ptr", $p__arraydisplay_notifyhandler, "uint_ptr", 0x0, "dword_ptr", 0x0)
    #Region Adjust dialog width
        Local $iwidth = 0x28, $icolwidth = 0x0, $aicolwidth[$icolfill], $imin_colwidth = 0x37
        Local $icolwidthheader
        For $i = 0x0 To $icolfill + -1
            GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, + -1)
            $icolwidth = GUICtrlSendMsg($idlistview, (0x1000 + 0x1d), $i, 0x0)
            If $SHEADER <> '' Then
                If $icolwidth = 0x0 Then ExitLoop
                GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, + -2)
                $icolwidthheader = GUICtrlSendMsg($idlistview, (0x1000 + 0x1d), $i, 0x0)
                If $icolwidth < $imin_colwidth And $icolwidthheader < $imin_colwidth Then
                    GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $imin_colwidth)
                    $icolwidth = $imin_colwidth
                ElseIf $icolwidthheader < $icolwidth Then
                    GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $icolwidth)
                Else
                    $icolwidth = $icolwidthheader
                EndIf
            Else
                If $icolwidth < $imin_colwidth Then
                    GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $imin_colwidth)
                    $icolwidth = $imin_colwidth
                EndIf
            EndIf
            $iwidth += $icolwidth
            $aicolwidth[$i] = $icolwidth
        Next
        If $iwidth > @DesktopWidth + -100 Then
            $iwidth = 0x28
            For $i = 0x0 To $icolfill + -1
                If $aicolwidth[$i] > $IMAX_COLWIDTH Then
                    GUICtrlSendMsg($idlistview, (0x1000 + 0x1e), $i, $IMAX_COLWIDTH)
                    $iwidth += $IMAX_COLWIDTH
                Else
                    $iwidth += $aicolwidth[$i]
                EndIf
                If $i < 0x14 And $BDEBUG Then ConsoleWrite("@@ Debug(" & @ScriptLineNumber & ") : $iWidth = " & $iwidth & " $i = " & $i & @CRLF)
            Next
        EndIf
        If $iwidth > @DesktopWidth + -100 Then
            $iwidth = @DesktopWidth + -100
        ElseIf $iwidth < $iminsize Then
            $iwidth = $iminsize
        EndIf
    #EndRegion Adjust dialog width
    Local $iscrollbarsize = 0x0
    If $iheight = (@DesktopHeight + -100) Then $iscrollbarsize = 0xf
    WinMove($hgui, '', (@DesktopWidth - $iwidth + $iscrollbarsize) / 0x2, (@DesktopHeight - $iheight) / 0x2, $iwidth + $iscrollbarsize, $iheight)
    $aiguisize = WinGetClientSize($hgui)
    GUICtrlSetPos($idlistview, 0x0, 0x0, $iwidth, $aiguisize[0x1] - $ibuttonborder)
    #Region Create bottom infos
        Local $ibuttonwidth_1 = $aiguisize[0x0] / 0x2
        Local $ibuttonwidth_2 = $aiguisize[0x0] / 0x3
        Local $idcopy_id = 0x270f, $idcopy_data = 0x1869f, $iddata_label = 0x1869f, $iduser_func = 0x1869f, $idexit_script = 0x1869f
        If $BDEBUG Then
            $idcopy_id = GUICtrlCreateButton("Copy Data && Hdr/Row", 0x0, $aiguisize[0x1] - $ibuttonborder, $ibuttonwidth_1, 0x14)
            $idcopy_data = GUICtrlCreateButton("Copy Data Only", $ibuttonwidth_1, $aiguisize[0x1] - $ibuttonborder, $ibuttonwidth_1, 0x14)
            Local $ibuttonwidth_var = $ibuttonwidth_1
            Local $ioffset = $ibuttonwidth_1
            If IsFunc($HUSER_FUNCTION) Then
                $iduser_func = GUICtrlCreateButton("Run User Func", $ibuttonwidth_2, $aiguisize[0x1] + -20, $ibuttonwidth_2, 0x14)
                $ibuttonwidth_var = $ibuttonwidth_2
                $ioffset = $ibuttonwidth_2 * 0x2
            EndIf
            $idexit_script = GUICtrlCreateButton("Exit Script", $ioffset, $aiguisize[0x1] + -20, $ibuttonwidth_var, 0x14)
            $iddata_label = GUICtrlCreateLabel($sdisplaydata, 0x0, $aiguisize[0x1] + -20, $ibuttonwidth_var, 0x12, BitOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
        Else
            $iddata_label = GUICtrlCreateLabel($sdisplaydata, 0x0, $aiguisize[0x1] + -20, $aiguisize[0x0], 0x12, BitOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
        EndIf
        If $_g_arraydisplay_itranspose Or $SARRAYRANGE Then
            GUICtrlSetColor($iddata_label, 0xff0000)
            GUICtrlSetTip($iddata_label, $stipdata)
        EndIf
        GUICtrlSetResizing($idcopy_id, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
        GUICtrlSetResizing($idcopy_data, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
        GUICtrlSetResizing($iddata_label, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
        GUICtrlSetResizing($iduser_func, $_ARRAYCONSTANT_GUI_DOCKHCENTER + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
        GUICtrlSetResizing($idexit_script, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
    #EndRegion Create bottom infos
    GUISetState(@SW_SHOW, $hgui)
    If $ftimer > 0x3e8 And Not $SARRAYRANGE Then
        Beep(0x2ee, 0xfa)
        ToolTip("Sorting Action can take as long as " & Ceiling($ftimer / 0x3e8) & " sec" & @CRLF & @CRLF & "Please be patient when you click to sort a column", 0x32, 0x32, $smsgboxtitle, $TIP_WARNINGICON, $TIP_BALLOON)
        Sleep(0xbb8)
        ToolTip('')
    EndIf
    #Region GUI Handling events
        Local $ioneventmode = Opt("GUIOnEventMode", 0x0), $amsg
        While 0x1
            $amsg = GUIGetMsg($_ARRAYCONSTANT_GUI_EVENT_ARRAY)
            If $amsg[0x1] = $hgui Then
                Switch $amsg[0x0]
                Case $_ARRAYCONSTANT_GUI_EVENT_CLOSE
                    ExitLoop
                Case $idcopy_id, $idcopy_data
                    Local $isel_count = GUICtrlSendMsg($idlistview, $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT, 0x0, 0x0)
                    If $iverbose And (Not $isel_count) And ($_g_arraydisplay_iitem_end - $_g_arraydisplay_iitem_start) * ($_g_arraydisplay_isubitem_end - $_g_arraydisplay_isubitem_start) > 0x2710 Then
                        SplashTextOn($smsgboxtitle, "Copying data" & @CRLF & @CRLF & "Please be patient", 0x12c, 0x64)
                    EndIf
                    Local $sclip = '', $sitem, $asplit, $ifirstcol = 0x0
                    If $amsg[0x0] = $idcopy_data And $_g_arraydisplay_idisplayrow Then $ifirstcol = 0x1
                    For $i = 0x0 To GUICtrlSendMsg($idlistview, 0x1004, 0x0, 0x0) + -1
                        If $isel_count And Not (GUICtrlSendMsg($idlistview, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0x0) Then
                            ContinueLoop
                        EndIf
                        $sitem = __arraydisplay_getitemtextstringselected($idlistview, $i, $ifirstcol)
                        If $amsg[0x0] = $idcopy_id And Not $_g_arraydisplay_idisplayrow Then
                            $sitem = $arraydisplay_rowprefix & " " & ($i + $_g_arraydisplay_iitem_start) & $scurr_separator & $sitem
                        EndIf
                        If $icw_colwidth Then
                            $asplit = StringSplit($sitem, $scurr_separator)
                            $sitem = ''
                            For $j = 0x1 To $asplit[0x0]
                                $sitem &= StringFormat("%-" & $icw_colwidth + 0x1 & "s", StringLeft($asplit[$j], $icw_colwidth))
                            Next
                        Else
                            $sitem = StringReplace($sitem, $scurr_separator, $VUSER_SEPARATOR)
                        EndIf
                        $sclip &= $sitem & @CRLF
                    Next
                    $sitem = $SHEADER
                    If $amsg[0x0] = $idcopy_id Then
                        $sitem = $SHEADER
                        If Not $_g_arraydisplay_idisplayrow Then
                            $sitem = "Row" & $scurr_separator & $sitem
                        EndIf
                        If $icw_colwidth Then
                            $asplit = StringSplit($sitem, $scurr_separator)
                            $sitem = ''
                            For $j = 0x1 To $asplit[0x0]
                                $sitem &= StringFormat("%-" & $icw_colwidth + 0x1 & "s", StringLeft($asplit[$j], $icw_colwidth))
                            Next
                        Else
                            $sitem = StringReplace($sitem, $scurr_separator, $VUSER_SEPARATOR)
                        EndIf
                        $sclip = $sitem & @CRLF & $sclip
                    EndIf
                    ClipPut($sclip)
                    SplashOff()
                    GUICtrlSetState($idlistview, $_ARRAYCONSTANT_GUI_FOCUS)
                Case $idlistview
                    $icolumn = GUICtrlGetState($idlistview)
                    If Not IsArray($_g_arraydisplay_aindexes[$icolumn + Not $_g_arraydisplay_idisplayrow]) Then
                        __arraydisplay_sortindexes($icolumn + Not $_g_arraydisplay_idisplayrow)
                    EndIf
                    If $icolumn <> $icolumnprev Then
                        __arraydisplay_headersetitemformat($hheader, $icolumnprev, 0x4000 + $icolalign / 0x2)
                        If $_g_arraydisplay_idisplayrow And $icolumn = 0x0 Then
                            $_g_arraydisplay_aindex = $_g_arraydisplay_aindexes[0x0]
                        Else
                            $_g_arraydisplay_aindex = $_g_arraydisplay_aindexes[$icolumn + Not $_g_arraydisplay_idisplayrow]
                        EndIf
                    EndIf
                    $_g_arraydisplay_isortdir = ($icolumn = $icolumnprev) ? $_g_arraydisplay_isortdir = 0x400  ? 0x200  : 0x400  : 0x400
                    __arraydisplay_headersetitemformat($hheader, $icolumn, 0x4000 + $_g_arraydisplay_isortdir + $icolalign / 0x2)
                    GUICtrlSendMsg($idlistview, (0x1000 + 0x8c), $icolumn, 0x0)
                    GUICtrlSendMsg($idlistview, (0x1000 + 0x2f), $_g_arraydisplay_nrows, 0x0)
                    $icolumnprev = $icolumn
                Case $iduser_func
                    Local $aiselitems[0x1] = [0x0]
                    For $i = 0x0 To GUICtrlSendMsg($idlistview, 0x1004, 0x0, 0x0) + -1
                        If (GUICtrlSendMsg($idlistview, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0x0) Then
                            $aiselitems[0x0]+= 0x1
                            ReDim $aiselitems[$aiselitems[0x0] + 0x1]
                            $aiselitems[$aiselitems[0x0]] = $i + $_g_arraydisplay_iitem_start
                        EndIf
                    Next
                    $HUSER_FUNCTION($_g_arraydisplay_aarray, $aiselitems)
                    GUICtrlSetState($idlistview, $_ARRAYCONSTANT_GUI_FOCUS)
                Case $idexit_script
                    GUIDelete($hgui)
                    Exit
                EndSwitch
            EndIf
        WEnd
    #EndRegion GUI Handling events
    DllCall("comctl32.dll", "bool", "RemoveWindowSubclass", "hwnd", $hgui, "ptr", $p__arraydisplay_notifyhandler, "uint_ptr", 0x0)
    $_g_arraydisplay_aindex = 0x0
    Dim $_g_arraydisplay_aindexes[0x1]
    GUIDelete($hgui)
    Opt("GUICoordMode", $icoordmode)
    Opt("GUIOnEventMode", $ioneventmode)
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, 0x1)
EndFunc    ; -> __ArrayDisplay_Share

Func __arraydisplay_notifyhandler($hwnd, $imsg, $wparam, $lparam, $isubclassid, $pdata)
    If $imsg <> 0x4e Then Return DllCall("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)[0x0]
    Local Static $tagnmhdr = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
    Local Static $tagnmlvdispinfo = $tagnmhdr & ";" & $_ARRAYCONSTANT_TAGLVITEM
    Local $tnmlvdispinfo = DllStructCreate($tagnmlvdispinfo, $lparam)
    Switch HWnd(DllStructGetData($tnmlvdispinfo, "hWndFrom"))
    Case $_g_arraydisplay_hlistview
        Switch DllStructGetData($tnmlvdispinfo, "Code")
        Case + -177
            Local Static $ttext = DllStructCreate("wchar[4096]"), $ptext = DllStructGetPtr($ttext)
            Local $iitem = DllStructGetData($tnmlvdispinfo, "Item")
            Local $irow = ($_g_arraydisplay_isortdir = 0x400) ? $_g_arraydisplay_aindex[$iitem] : $_g_arraydisplay_aindex[$_g_arraydisplay_nrows + -1 - $iitem]
            Local $icol = DllStructGetData($tnmlvdispinfo, "SubItem")
            Local $stemp
            If $_g_arraydisplay_idisplayrow = 0x0 Then
                If $_g_arraydisplay_idims = 0x2 Then
                    $stemp = $_g_arraydisplay_aarray[$irow][$icol]
                Else
                    $stemp = $_g_arraydisplay_aarray[$irow]
                EndIf
                Switch VarGetType($stemp)
                Case "Array"
                    $stemp = "{Array}"
                Case "Map"
                    $stemp = "{Map}"
                EndSwitch
                If StringLen($stemp) > 0xfff Then $stemp = StringLeft($stemp, 0xfff)
                DllStructSetData($ttext, 0x1, $stemp)
                DllStructSetData($tnmlvdispinfo, "Text", $ptext)
            Else
                If $icol = 0x0 Then
                    If $_g_arraydisplay_itranspose Then
                        Local $scaptioncplt = ''
                        If $irow + $_g_arraydisplay_iitem_start < UBound($_g_arraydisplay_asheader) And StringStripWS($_g_arraydisplay_asheader[$irow + $_g_arraydisplay_iitem_start], 0x1 + 0x2) <> '' Then
                            $scaptioncplt = " (" & StringStripWS($_g_arraydisplay_asheader[$irow + $_g_arraydisplay_iitem_start], 0x1 + 0x2)
                            If StringRight($scaptioncplt, 0x1) = $arraydisplay_numericsort Then $scaptioncplt = StringTrimRight($scaptioncplt, 0x1)
                            $scaptioncplt &= ")"
                        EndIf
                        DllStructSetData($ttext, 0x1, "Col " & ($irow + $_g_arraydisplay_iitem_start) & $scaptioncplt)
                    Else
                        DllStructSetData($ttext, 0x1, $arraydisplay_rowprefix & " " & $irow + $_g_arraydisplay_iitem_start)
                    EndIf
                    DllStructSetData($tnmlvdispinfo, "Text", $ptext)
                Else
                    If $_g_arraydisplay_idims = 0x2 Then
                        $stemp = $_g_arraydisplay_aarray[$irow][$icol + -1]
                    Else
                        $stemp = $_g_arraydisplay_aarray[$irow]
                    EndIf
                    Switch VarGetType($stemp)
                    Case "Array"
                        $stemp = "{Array}"
                    Case "Map"
                        $stemp = "{Map}"
                    EndSwitch
                    If StringLen($stemp) > 0xfff Then $stemp = StringLeft($stemp, 0xfff)
                    DllStructSetData($ttext, 0x1, $stemp)
                    DllStructSetData($tnmlvdispinfo, "Text", $ptext)
                EndIf
            EndIf
            Return
        EndSwitch
    EndSwitch
    Return DllCall("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)[0x0]
    #forceref $iSubclassId, $pData
EndFunc    ; -> __arraydisplay_notifyhandler

Func __arraydisplay_sortindexes($icolstart, $icolend = $icolstart)
    Dim $_g_arraydisplay_aindex[$_g_arraydisplay_nrows]
    If $icolend = + -1 Then
        Dim $_g_arraydisplay_aindexes[$_g_arraydisplay_ncols + $_g_arraydisplay_idisplayrow + 0x1]
        For $i = 0x0 To $_g_arraydisplay_nrows + -1
            $_g_arraydisplay_aindex[$i] = $i
        Next
        $_g_arraydisplay_aindexes[0x0] = $_g_arraydisplay_aindex
    EndIf
    If $icolstart = + -1 Then
        $icolstart = 0x1
        $icolend = $_g_arraydisplay_ncols
    EndIf
    If $icolstart Then
        Local $tindex
        For $i = $icolstart To $icolend
            $tindex = __arraydisplay_getsortcolstruct($_g_arraydisplay_aarray, $i + -1)
            For $j = 0x0 To $_g_arraydisplay_nrows + -1
                $_g_arraydisplay_aindex[$j] = DllStructGetData($tindex, 0x1, $j + 0x1)
            Next
            $_g_arraydisplay_aindexes[$i] = $_g_arraydisplay_aindex
        Next
    EndIf
EndFunc    ; -> __arraydisplay_sortindexes

Func __arraydisplay_getsortcolstruct(Const ByRef $AARRAY, $icol)
    If UBound($AARRAY, $UBOUND_DIMENSIONS) < 0x1 Or UBound($AARRAY, $UBOUND_DIMENSIONS) > 0x2 Then
        Return SetError(0x6, 0x0, 0x0)
    EndIf
    Return __arraydisplay_sortarraystruct($AARRAY, $icol)
EndFunc    ; -> __arraydisplay_getsortcolstruct

Func __arraydisplay_sortarraystruct(Const ByRef $AARRAY, $icol)
    Local $idims = UBound($AARRAY, $UBOUND_DIMENSIONS)
    Local $tindex = DllStructCreate("uint[" & $_g_arraydisplay_nrows & "]")
    Local $pindex = DllStructGetPtr($tindex)
    Static $hdll = DllOpen("kernel32.dll")
    Static $hdllcomp = DllOpen("shlwapi.dll")
    Local $lo, $hi, $mi, $r, $nval1, $nval2
    For $i = 0x1 To $_g_arraydisplay_nrows + -1
        $lo = 0x0
        $hi = $i + -1
        Do
            $mi = Int(($lo + $hi) / 0x2)
            If Not $_g_arraydisplay_itranspose And $_g_arraydisplay_anumericsort[$icol] Then
                If $idims = 0x1 Then
                    $nval1 = Number($AARRAY[$i])
                    $nval2 = Number($AARRAY[DllStructGetData($tindex, 0x1, $mi + 0x1)])
                Else
                    $nval1 = Number($AARRAY[$i][$icol])
                    $nval2 = Number($AARRAY[DllStructGetData($tindex, 0x1, $mi + 0x1)][$icol])
                EndIf
                $r = $nval1 < $nval2  ? + -1  : $nval1 > $nval2  ? 0x1  : 0x0
            Else
                If $idims = 0x1 Then
                    $r = DllCall($hdllcomp, "int", "StrCmpLogicalW", "wstr", $AARRAY[$i], "wstr", $AARRAY[DllStructGetData($tindex, 0x1, $mi + 0x1)])[0x0]
                Else
                    $r = DllCall($hdllcomp, "int", "StrCmpLogicalW", "wstr", $AARRAY[$i][$icol], "wstr", $AARRAY[DllStructGetData($tindex, 0x1, $mi + 0x1)][$icol])[0x0]
                EndIf
            EndIf
            Switch $r
            Case + -1
                $hi = $mi + -1
            Case 0x1
                $lo = $mi + 0x1
            Case 0x0
                ExitLoop
            EndSwitch
        Until $lo > $hi
        DllCall($hdll, "none", "RtlMoveMemory", "struct*", $pindex + ($mi + 0x1) * 0x4, "struct*", $pindex + $mi * 0x4, "ulong_ptr", ($i - $mi) * 0x4)
        DllStructSetData($tindex, 0x1, $i, $mi + 0x1 + ($lo = $mi + 0x1))
    Next
    Return $tindex
EndFunc    ; -> __arraydisplay_sortarraystruct

Func __arraydisplay_createsubarray()
    Local $nrows = $_g_arraydisplay_iitem_end - $_g_arraydisplay_iitem_start + 0x1
    Local $ncols = $_g_arraydisplay_isubitem_end - $_g_arraydisplay_isubitem_start + 0x1
    Local $irow = + -1, $icol, $itemp, $atemp
    If $_g_arraydisplay_itranspose Then
        Dim $atemp[$ncols][$nrows]
        For $i = $_g_arraydisplay_iitem_start To $_g_arraydisplay_iitem_end
            $irow += 0x1
            $icol = + -1
            For $j = $_g_arraydisplay_isubitem_start To $_g_arraydisplay_isubitem_end
                $icol += 0x1
                $atemp[$icol][$irow] = $_g_arraydisplay_aarray[$i][$j]
            Next
        Next
        $itemp = $_g_arraydisplay_iitem_start
        $_g_arraydisplay_iitem_start = $_g_arraydisplay_isubitem_start
        $_g_arraydisplay_isubitem_start = $itemp
        $itemp = $_g_arraydisplay_iitem_end
        $_g_arraydisplay_iitem_end = $_g_arraydisplay_isubitem_end
        $_g_arraydisplay_isubitem_end = $itemp
        $_g_arraydisplay_nrows = $ncols
        $_g_arraydisplay_ncols = $nrows
    Else
        If $_g_arraydisplay_idims = 0x1 Then
            Dim $atemp[$nrows]
            For $i = $_g_arraydisplay_iitem_start To $_g_arraydisplay_iitem_end
                $irow += 0x1
                $atemp[$irow] = $_g_arraydisplay_aarray[$i]
            Next
        Else
            Dim $atemp[$nrows][$ncols]
            For $i = $_g_arraydisplay_iitem_start To $_g_arraydisplay_iitem_end
                $irow += 0x1
                $icol = + -1
                For $j = $_g_arraydisplay_isubitem_start To $_g_arraydisplay_isubitem_end
                    $icol += 0x1
                    $atemp[$irow][$icol] = $_g_arraydisplay_aarray[$i][$j]
                Next
            Next
            $_g_arraydisplay_ncols = $ncols
        EndIf
        $_g_arraydisplay_nrows = $nrows
    EndIf
    Return $atemp
EndFunc    ; -> __arraydisplay_createsubarray

Func __arraydisplay_headersetitemformat($hwnd, $iindex, $iformat)
    Local Static $thditem = DllStructCreate("uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State")
    DllStructSetData($thditem, "Mask", 0x4)
    DllStructSetData($thditem, "Fmt", $iformat)
    Local $aresult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", 0x120c, "wparam", $iindex, "struct*", $thditem)
    Return $aresult[0x0] <> 0x0
EndFunc    ; -> __arraydisplay_headersetitemformat

Func __ArrayDisplay_GetItemText($idlistview, $iindex, $isubitem = 0x0)
    Local $tbuffer = DllStructCreate("wchar Text[4096]")
    Local $pbuffer = DllStructGetPtr($tbuffer)
    Local $titem = DllStructCreate($_ARRAYCONSTANT_TAGLVITEM)
    DllStructSetData($titem, "SubItem", $isubitem)
    DllStructSetData($titem, "TextMax", 0x1000)
    DllStructSetData($titem, "Text", $pbuffer)
    If IsHWnd($idlistview) Then
        DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $idlistview, "uint", 0x1073, "wparam", $iindex, "struct*", $titem)
    Else
        Local $pitem = DllStructGetPtr($titem)
        GUICtrlSendMsg($idlistview, 0x1073, $iindex, $pitem)
    EndIf
    Return DllStructGetData($tbuffer, "Text")
EndFunc    ; -> __ArrayDisplay_GetItemText

Func __arraydisplay_getitemtextstringselected($idlistview, $iitem, $ifirstcol)
    Local $srow = '', $sseparatorchar = Opt("GUIDataSeparatorChar")
    Local $iselected = $iitem
    Local $hheader = HWnd(GUICtrlSendMsg($idlistview, 0x101f, 0x0, 0x0))
    Local $ncol = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hheader, "uint", 0x1200, "wparam", 0x0, "lparam", 0x0)[0x0]
    For $x = $ifirstcol To $ncol + -1
        $srow &= __ArrayDisplay_GetItemText($idlistview, $iselected, $x) & $sseparatorchar
    Next
    Return StringTrimRight($srow, 0x1)
EndFunc    ; -> __arraydisplay_getitemtextstringselected

Func __ArrayDisplay_JustifyColumn($idlistview, $iindex, $ialign = + -1)
    Local $tcolumn = DllStructCreate("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
    If $ialign < 0x0 Or $ialign > 0x2 Then $ialign = 0x0
    DllStructSetData($tcolumn, "Mask", 0x1)
    DllStructSetData($tcolumn, "Fmt", $ialign)
    Local $pcolumn = DllStructGetPtr($tcolumn)
    Local $iret = GUICtrlSendMsg($idlistview, 0x1060, $iindex, $pcolumn)
    Return $iret <> 0x0
EndFunc    ; -> __ArrayDisplay_JustifyColumn

Global Enum $ARRAYFILL_FORCE_DEFAULT, $ARRAYFILL_FORCE_SINGLEITEM, $ARRAYFILL_FORCE_INT, $ARRAYFILL_FORCE_NUMBER, $ARRAYFILL_FORCE_PTR, $ARRAYFILL_FORCE_HWND, $ARRAYFILL_FORCE_STRING, $ARRAYFILL_FORCE_BOOLEAN
Global Enum $ARRAYUNIQUE_NOCOUNT, $ARRAYUNIQUE_COUNT
Global Enum $ARRAYUNIQUE_AUTO, $ARRAYUNIQUE_FORCE32, $ARRAYUNIQUE_FORCE64, $ARRAYUNIQUE_MATCH, $ARRAYUNIQUE_DISTINCT
Func _ArrayAdd(ByRef $AARRAY, $vvalue, $istart = 0x0, $sdelim_item = "|", $sdelim_row = @CRLF, $iforce = $ARRAYFILL_FORCE_DEFAULT)
    If $istart = Default Then $istart = 0x0
    If $sdelim_item = Default Then $sdelim_item = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $iforce = Default Then $iforce = $ARRAYFILL_FORCE_DEFAULT
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS)
    Local $hdatatype = 0x0
    Switch $iforce
    Case $ARRAYFILL_FORCE_INT
        $hdatatype = Int
    Case $ARRAYFILL_FORCE_NUMBER
        $hdatatype = Number
    Case $ARRAYFILL_FORCE_PTR
        $hdatatype = Ptr
    Case $ARRAYFILL_FORCE_HWND
        $hdatatype = HWnd
    Case $ARRAYFILL_FORCE_STRING
        $hdatatype = String
    Case $ARRAYFILL_FORCE_BOOLEAN
        $hdatatype = "Boolean"
    EndSwitch
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        If $iforce = $ARRAYFILL_FORCE_SINGLEITEM Then
            ReDim $AARRAY[$idim_1 + 0x1]
            $AARRAY[$idim_1] = $vvalue
            Return $idim_1
        EndIf
        If IsArray($vvalue) Then
            If UBound($vvalue, $UBOUND_DIMENSIONS) <> 0x1 Then Return SetError(0x5, 0x0, + -1)
            $hdatatype = 0x0
        Else
            Local $atmp = StringSplit($vvalue, $sdelim_item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
            If UBound($atmp, $UBOUND_ROWS) = 0x1 Then
                $atmp[0x0] = $vvalue
            EndIf
            $vvalue = $atmp
        EndIf
        Local $iadd = UBound($vvalue, $UBOUND_ROWS)
        ReDim $AARRAY[$idim_1 + $iadd]
        For $i = 0x0 To $iadd + -1
            If String($hdatatype) = "Boolean" Then
                Switch $vvalue[$i]
                Case "True", "1"
                    $AARRAY[$idim_1 + $i] = True
                Case "False", "0", ''
                    $AARRAY[$idim_1 + $i] = False
                EndSwitch
            ElseIf IsFunc($hdatatype) Then
                $AARRAY[$idim_1 + $i] = $hdatatype($vvalue[$i])
            Else
                $AARRAY[$idim_1 + $i] = $vvalue[$i]
            EndIf
        Next
        Return $idim_1 + $iadd + -1
    Case 0x2
        Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS)
        If $istart < 0x0 Or $istart > $idim_2 + -1 Then Return SetError(0x4, 0x0, + -1)
        Local $ivaldim_1, $ivaldim_2 = 0x0, $icolcount
        If IsArray($vvalue) Then
            If UBound($vvalue, $UBOUND_DIMENSIONS) <> 0x2 Then Return SetError(0x5, 0x0, + -1)
            $ivaldim_1 = UBound($vvalue, $UBOUND_ROWS)
            $ivaldim_2 = UBound($vvalue, $UBOUND_COLUMNS)
            $hdatatype = 0x0
        Else
            Local $asplit_1 = StringSplit($vvalue, $sdelim_row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
            $ivaldim_1 = UBound($asplit_1, $UBOUND_ROWS)
            Local $atmp[$ivaldim_1][0x0], $asplit_2
            For $i = 0x0 To $ivaldim_1 + -1
                $asplit_2 = StringSplit($asplit_1[$i], $sdelim_item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
                $icolcount = UBound($asplit_2)
                If $icolcount > $ivaldim_2 Then
                    $ivaldim_2 = $icolcount
                    ReDim $atmp[$ivaldim_1][$ivaldim_2]
                EndIf
                For $j = 0x0 To $icolcount + -1
                    $atmp[$i][$j] = $asplit_2[$j]
                Next
            Next
            $vvalue = $atmp
        EndIf
        If UBound($vvalue, $UBOUND_COLUMNS) + $istart > UBound($AARRAY, $UBOUND_COLUMNS) Then Return SetError(0x3, 0x0, + -1)
        ReDim $AARRAY[$idim_1 + $ivaldim_1][$idim_2]
        For $iwriteto_index = 0x0 To $ivaldim_1 + -1
            For $j = 0x0 To $idim_2 + -1
                If $j < $istart Then
                    $AARRAY[$iwriteto_index + $idim_1][$j] = ''
                ElseIf $j - $istart > $ivaldim_2 + -1 Then
                    $AARRAY[$iwriteto_index + $idim_1][$j] = ''
                Else
                    If String($hdatatype) = "Boolean" Then
                        Switch $vvalue[$iwriteto_index][$j - $istart]
                        Case "True", "1"
                            $AARRAY[$iwriteto_index + $idim_1][$j] = True
                        Case "False", "0", ''
                            $AARRAY[$iwriteto_index + $idim_1][$j] = False
                        EndSwitch
                    ElseIf IsFunc($hdatatype) Then
                        $AARRAY[$iwriteto_index + $idim_1][$j] = $hdatatype($vvalue[$iwriteto_index][$j - $istart])
                    Else
                        $AARRAY[$iwriteto_index + $idim_1][$j] = $vvalue[$iwriteto_index][$j - $istart]
                    EndIf
                EndIf
            Next
        Next
    Case Else
        Return SetError(0x2, 0x0, + -1)
    EndSwitch
    Return UBound($AARRAY, $UBOUND_ROWS) + -1
EndFunc    ; -> _ArrayAdd

Func _ArrayBinarySearch(Const ByRef $AARRAY, $vvalue, $istart = 0x0, $IEND = 0x0, $icolumn = 0x0)
    If $istart = Default Then $istart = 0x0
    If $IEND = Default Then $IEND = 0x0
    If $icolumn = Default Then $icolumn = 0x0
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS)
    If $idim_1 = 0x0 Then Return SetError(0x6, 0x0, + -1)
    If $IEND < 0x1 Or $IEND > $idim_1 + -1 Then $IEND = $idim_1 + -1
    If $istart < 0x0 Then $istart = 0x0
    If $istart > $IEND Then Return SetError(0x4, 0x0, + -1)
    Local $imid = Int(($IEND + $istart) / 0x2)
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        If $AARRAY[$istart] > $vvalue Or $AARRAY[$IEND] < $vvalue Then Return SetError(0x2, 0x0, + -1)
        While $istart <= $imid And $vvalue <> $AARRAY[$imid]
            If $vvalue < $AARRAY[$imid] Then
                $IEND = $imid + -1
            Else
                $istart = $imid + 0x1
            EndIf
            $imid = Int(($IEND + $istart) / 0x2)
        WEnd
        If $istart > $IEND Then Return SetError(0x3, 0x0, + -1)
    Case 0x2
        Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS) + -1
        If $icolumn < 0x0 Or $icolumn > $idim_2 Then Return SetError(0x7, 0x0, + -1)
        If $AARRAY[$istart][$icolumn] > $vvalue Or $AARRAY[$IEND][$icolumn] < $vvalue Then Return SetError(0x2, 0x0, + -1)
        While $istart <= $imid And $vvalue <> $AARRAY[$imid][$icolumn]
            If $vvalue < $AARRAY[$imid][$icolumn] Then
                $IEND = $imid + -1
            Else
                $istart = $imid + 0x1
            EndIf
            $imid = Int(($IEND + $istart) / 0x2)
        WEnd
        If $istart > $IEND Then Return SetError(0x3, 0x0, + -1)
    Case Else
        Return SetError(0x5, 0x0, + -1)
    EndSwitch
    Return $imid
EndFunc    ; -> _ArrayBinarySearch

Func _ArrayColDelete(ByRef $AARRAY, $icolumn, $bconvert = False)
    If $bconvert = Default Then $bconvert = False
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS)
    If UBound($AARRAY, $UBOUND_DIMENSIONS) <> 0x2 Then Return SetError(0x2, 0x0, + -1)
    Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS)
    Switch $idim_2
    Case 0x2
        If $icolumn < 0x0 Or $icolumn > 0x1 Then Return SetError(0x3, 0x0, + -1)
        If $bconvert Then
            Local $atemparray[$idim_1]
            For $i = 0x0 To $idim_1 + -1
                $atemparray[$i] = $AARRAY[$i][(Not $icolumn)]
            Next
            $AARRAY = $atemparray
        Else
            ContinueCase
        EndIf
    Case Else
        If $icolumn < 0x0 Or $icolumn > $idim_2 + -1 Then Return SetError(0x3, 0x0, + -1)
        For $i = 0x0 To $idim_1 + -1
            For $j = $icolumn To $idim_2 + -2
                $AARRAY[$i][$j] = $AARRAY[$i][$j + 0x1]
            Next
        Next
        ReDim $AARRAY[$idim_1][$idim_2 + -1]
    EndSwitch
    Return UBound($AARRAY, $UBOUND_COLUMNS)
EndFunc    ; -> _ArrayColDelete

Func _ArrayColInsert(ByRef $AARRAY, $icolumn)
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS)
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        Local $atemparray[$idim_1][0x2]
        Switch $icolumn
        Case 0x0, 0x1
            For $i = 0x0 To $idim_1 + -1
                $atemparray[$i][(Not $icolumn)] = $AARRAY[$i]
            Next
        Case Else
            Return SetError(0x3, 0x0, + -1)
        EndSwitch
        $AARRAY = $atemparray
    Case 0x2
        Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS)
        If $icolumn < 0x0 Or $icolumn > $idim_2 Then Return SetError(0x3, 0x0, + -1)
        ReDim $AARRAY[$idim_1][$idim_2 + 0x1]
        For $i = 0x0 To $idim_1 + -1
            For $j = $idim_2 To $icolumn + 0x1 Step + -1
                $AARRAY[$i][$j] = $AARRAY[$i][$j + -1]
            Next
            $AARRAY[$i][$icolumn] = ''
        Next
    Case Else
        Return SetError(0x2, 0x0, + -1)
    EndSwitch
    Return UBound($AARRAY, $UBOUND_COLUMNS)
EndFunc    ; -> _ArrayColInsert

Func _ArrayCombinations(Const ByRef $AARRAY, $ISET, $SDELIMITER = '')
    If $SDELIMITER = Default Then $SDELIMITER = ''
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($AARRAY, $UBOUND_DIMENSIONS) <> 0x1 Then Return SetError(0x2, 0x0, 0x0)
    Local $in = UBound($AARRAY)
    Local $ir = $ISET
    Local $aidx[$ir]
    For $i = 0x0 To $ir + -1
        $aidx[$i] = $i
    Next
    Local $itotal = __Array_Combinations($in, $ir)
    Local $ileft = $itotal
    Local $aresult[$itotal + 0x1]
    $aresult[0x0] = $itotal
    Local $icount = 0x1
    While $ileft > 0x0
        __Array_GetNext($in, $ir, $ileft, $itotal, $aidx)
        For $i = 0x0 To $ISET + -1
            $aresult[$icount]&= $AARRAY[$aidx[$i]] & $SDELIMITER
        Next
        If $SDELIMITER <> '' Then $aresult[$icount] = StringTrimRight($aresult[$icount], 0x1)
        $icount += 0x1
    WEnd
    Return $aresult
EndFunc    ; -> _ArrayCombinations

Func _ArrayConcatenate(ByRef $aarraytarget, Const ByRef $AARRAYSOURCE, $istart = 0x0)
    If $istart = Default Then $istart = 0x0
    If Not IsArray($aarraytarget) Then Return SetError(0x1, 0x0, + -1)
    If Not IsArray($AARRAYSOURCE) Then Return SetError(0x2, 0x0, + -1)
    Local $idim_total_tgt = UBound($aarraytarget, $UBOUND_DIMENSIONS)
    Local $idim_total_src = UBound($AARRAYSOURCE, $UBOUND_DIMENSIONS)
    Local $idim_1_tgt = UBound($aarraytarget, $UBOUND_ROWS)
    Local $idim_1_src = UBound($AARRAYSOURCE, $UBOUND_ROWS)
    If $istart < 0x0 Or $istart > $idim_1_src + -1 Then Return SetError(0x6, 0x0, + -1)
    Switch $idim_total_tgt
    Case 0x1
        If $idim_total_src <> 0x1 Then Return SetError(0x4, 0x0, + -1)
        ReDim $aarraytarget[$idim_1_tgt + $idim_1_src - $istart]
        For $i = $istart To $idim_1_src + -1
            $aarraytarget[$idim_1_tgt + $i - $istart] = $AARRAYSOURCE[$i]
        Next
    Case 0x2
        If $idim_total_src <> 0x2 Then Return SetError(0x4, 0x0, + -1)
        Local $idim_2_tgt = UBound($aarraytarget, $UBOUND_COLUMNS)
        If UBound($AARRAYSOURCE, $UBOUND_COLUMNS) <> $idim_2_tgt Then Return SetError(0x5, 0x0, + -1)
        ReDim $aarraytarget[$idim_1_tgt + $idim_1_src - $istart][$idim_2_tgt]
        For $i = $istart To $idim_1_src + -1
            For $j = 0x0 To $idim_2_tgt + -1
                $aarraytarget[$idim_1_tgt + $i - $istart][$j] = $AARRAYSOURCE[$i][$j]
            Next
        Next
    Case Else
        Return SetError(0x3, 0x0, + -1)
    EndSwitch
    Return UBound($aarraytarget, $UBOUND_ROWS)
EndFunc    ; -> _ArrayConcatenate

Func _ArrayDelete(ByRef $AARRAY, $vrange)
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS) + -1
    If IsArray($vrange) Then
        If UBound($vrange, $UBOUND_DIMENSIONS) <> 0x1 Or UBound($vrange, $UBOUND_ROWS) < 0x2 Then Return SetError(0x4, 0x0, + -1)
    Else
        Local $inumber, $asplit_1, $asplit_2
        $vrange = StringStripWS($vrange, 0x8)
        $asplit_1 = StringSplit($vrange, ";")
        $vrange = ''
        For $i = 0x1 To $asplit_1[0x0]
            If Not StringRegExp($asplit_1[$i], "^\\d+(-\\d+)?$") Then Return SetError(0x3, 0x0, + -1)
            $asplit_2 = StringSplit($asplit_1[$i], "-")
            Switch $asplit_2[0x0]
            Case 0x1
                $vrange &= $asplit_2[0x1] & ";"
            Case 0x2
                If Number($asplit_2[0x2]) >= Number($asplit_2[0x1]) Then
                    $inumber = $asplit_2[0x1] + -1
                    Do
                        $inumber += 0x1
                        $vrange &= $inumber & ";"
                    Until $inumber = $asplit_2[0x2]
                EndIf
            EndSwitch
        Next
        $vrange = StringSplit(StringTrimRight($vrange, 0x1), ";")
    EndIf
    For $i = 0x1 To $vrange[0x0]
        $vrange[$i] = Number($vrange[$i])
    Next
    If $vrange[0x1] < 0x0 Or $vrange[$vrange[0x0]] > $idim_1 Then Return SetError(0x5, 0x0, + -1)
    Local $icopyto_index = 0x0
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        For $i = 0x1 To $vrange[0x0]
            $AARRAY[$vrange[$i]] = ChrW(0xfab1)
        Next
        For $ireadfrom_index = 0x0 To $idim_1
            If $AARRAY[$ireadfrom_index] == ChrW(0xfab1) Then
                ContinueLoop
            Else
                If $ireadfrom_index <> $icopyto_index Then
                    $AARRAY[$icopyto_index] = $AARRAY[$ireadfrom_index]
                EndIf
                $icopyto_index += 0x1
            EndIf
        Next
        ReDim $AARRAY[$idim_1 - $vrange[0x0] + 0x1]
    Case 0x2
        Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS) + -1
        For $i = 0x1 To $vrange[0x0]
            $AARRAY[$vrange[$i]][0x0] = ChrW(0xfab1)
        Next
        For $ireadfrom_index = 0x0 To $idim_1
            If $AARRAY[$ireadfrom_index][0x0] == ChrW(0xfab1) Then
                ContinueLoop
            Else
                If $ireadfrom_index <> $icopyto_index Then
                    For $j = 0x0 To $idim_2
                        $AARRAY[$icopyto_index][$j] = $AARRAY[$ireadfrom_index][$j]
                    Next
                EndIf
                $icopyto_index += 0x1
            EndIf
        Next
        ReDim $AARRAY[$idim_1 - $vrange[0x0] + 0x1][$idim_2 + 0x1]
    Case Else
        Return SetError(0x2, 0x0, False)
    EndSwitch
    Return UBound($AARRAY, $UBOUND_ROWS)
EndFunc    ; -> _ArrayDelete

Func _ArrayDisplay(Const ByRef $AARRAY, $STITLE = Default, $SARRAYRANGE = Default, $IFLAGS = Default, $VUSER_SEPARATOR = Default, $SHEADER = Default, $IMAX_COLWIDTH = Default)
    #forceref $vUser_Separator
    Local $iret = __ArrayDisplay_Share($AARRAY, $STITLE, $SARRAYRANGE, $IFLAGS, Default, $SHEADER, $IMAX_COLWIDTH, 0x0, False)
    Return SetError(@error, @extended, $iret)
EndFunc    ; -> _ArrayDisplay

Func _ArrayExtract(Const ByRef $AARRAY, $ISTART_ROW = + -1, $IEND_ROW = + -1, $ISTART_COL = + -1, $IEND_COL = + -1)
    If $ISTART_ROW = Default Then $ISTART_ROW = + -1
    If $IEND_ROW = Default Then $IEND_ROW = + -1
    If $ISTART_COL = Default Then $ISTART_COL = + -1
    If $IEND_COL = Default Then $IEND_COL = + -1
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS) + -1
    If $IEND_ROW = + -1 Then $IEND_ROW = $idim_1
    If $ISTART_ROW = + -1 Then $ISTART_ROW = 0x0
    If $ISTART_ROW < + -1 Or $IEND_ROW < + -1 Then Return SetError(0x3, 0x0, + -1)
    If $ISTART_ROW > $idim_1 Or $IEND_ROW > $idim_1 Then Return SetError(0x3, 0x0, + -1)
    If $ISTART_ROW > $IEND_ROW Then Return SetError(0x4, 0x0, + -1)
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        Local $aretarray[$IEND_ROW - $ISTART_ROW + 0x1]
        For $i = 0x0 To $IEND_ROW - $ISTART_ROW
            $aretarray[$i] = $AARRAY[$i + $ISTART_ROW]
        Next
        Return $aretarray
    Case 0x2
        Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS) + -1
        If $IEND_COL = + -1 Then $IEND_COL = $idim_2
        If $ISTART_COL = + -1 Then $ISTART_COL = 0x0
        If $ISTART_COL < + -1 Or $IEND_COL < + -1 Then Return SetError(0x5, 0x0, + -1)
        If $ISTART_COL > $idim_2 Or $IEND_COL > $idim_2 Then Return SetError(0x5, 0x0, + -1)
        If $ISTART_COL > $IEND_COL Then Return SetError(0x6, 0x0, + -1)
        If $ISTART_COL = $IEND_COL Then
            Local $aretarray[$IEND_ROW - $ISTART_ROW + 0x1]
        Else
            Local $aretarray[$IEND_ROW - $ISTART_ROW + 0x1][$IEND_COL - $ISTART_COL + 0x1]
        EndIf
        For $i = 0x0 To $IEND_ROW - $ISTART_ROW
            For $j = 0x0 To $IEND_COL - $ISTART_COL
                If $ISTART_COL = $IEND_COL Then
                    $aretarray[$i] = $AARRAY[$i + $ISTART_ROW][$j + $ISTART_COL]
                Else
                    $aretarray[$i][$j] = $AARRAY[$i + $ISTART_ROW][$j + $ISTART_COL]
                EndIf
            Next
        Next
        Return $aretarray
    Case Else
        Return SetError(0x2, 0x0, + -1)
    EndSwitch
    Return 0x1
EndFunc    ; -> _ArrayExtract

Func _ArrayFindAll(Const ByRef $AARRAY, $vvalue, $istart = 0x0, $IEND = 0x0, $ICASE = 0x0, $ICOMPARE = 0x0, $isubitem = 0x0, $BROW = False)
    If $istart = Default Then $istart = 0x0
    If $IEND = Default Then $IEND = 0x0
    If $ICASE = Default Then $ICASE = 0x0
    If $ICOMPARE = Default Then $ICOMPARE = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If $BROW = Default Then $BROW = False
    $istart = _ArraySearch($AARRAY, $vvalue, $istart, $IEND, $ICASE, $ICOMPARE, 0x1, $isubitem, $BROW)
    If @error Then Return SetError(@error, 0x0, + -1)
    Local $iindex = 0x0, $avresult[UBound($AARRAY, ($BROW  ? $UBOUND_COLUMNS  : $UBOUND_ROWS))]
    Do
        $avresult[$iindex] = $istart
        $iindex += 0x1
        $istart = _ArraySearch($AARRAY, $vvalue, $istart + 0x1, $IEND, $ICASE, $ICOMPARE, 0x1, $isubitem, $BROW)
    Until @error
    ReDim $avresult[$iindex]
    Return $avresult
EndFunc    ; -> _ArrayFindAll

Func _arrayfromstring($sarraystr, $sdelim_col = "|", $sdelim_row = @CRLF, $bforce2d = False, $istripws = $STR_STRIPLEADING + $STR_STRIPTRAILING)
    If $sdelim_col = Default Then $sdelim_col = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $bforce2d = Default Then $bforce2d = False
    If $istripws = Default Then $istripws = $STR_STRIPLEADING + $STR_STRIPTRAILING
    Local $arow, $acol = StringSplit($sarraystr, $sdelim_row, $STR_ENTIRESPLIT + $STR_NOCOUNT)
    $arow = StringSplit($acol[0x0], $sdelim_col, $STR_ENTIRESPLIT + $STR_NOCOUNT)
    If UBound($acol) = 0x1 And Not $bforce2d Then
        For $m = 0x0 To UBound($arow) + -1
            $arow[$m] = ($istripws  ? StringStripWS($arow[$m], $istripws) : $arow[$m])
        Next
        Return $arow
    EndIf
    Local $aret[UBound($acol)][UBound($arow)]
    For $n = 0x0 To UBound($acol) + -1
        $arow = StringSplit($acol[$n], $sdelim_col, $STR_ENTIRESPLIT + $STR_NOCOUNT)
        If UBound($arow) > UBound($aret, 0x2) Then Return SetError(0x1)
        For $m = 0x0 To UBound($arow) + -1
            $aret[$n][$m] = ($istripws  ? StringStripWS($arow[$m], $istripws) : $arow[$m])
        Next
    Next
    Return $aret
EndFunc    ; -> _arrayfromstring

Func _ArrayInsert(ByRef $AARRAY, $vrange, $vvalue = '', $istart = 0x0, $sdelim_item = "|", $sdelim_row = @CRLF, $iforce = $ARRAYFILL_FORCE_DEFAULT)
    If $vvalue = Default Then $vvalue = ''
    If $istart = Default Then $istart = 0x0
    If $sdelim_item = Default Then $sdelim_item = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $iforce = Default Then $iforce = $ARRAYFILL_FORCE_DEFAULT
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS) + -1
    Local $hdatatype = 0x0
    Switch $iforce
    Case $ARRAYFILL_FORCE_INT
        $hdatatype = Int
    Case $ARRAYFILL_FORCE_NUMBER
        $hdatatype = Number
    Case $ARRAYFILL_FORCE_PTR
        $hdatatype = Ptr
    Case $ARRAYFILL_FORCE_HWND
        $hdatatype = HWnd
    Case $ARRAYFILL_FORCE_STRING
        $hdatatype = String
    EndSwitch
    Local $asplit_1, $asplit_2
    If IsArray($vrange) Then
        If UBound($vrange, $UBOUND_DIMENSIONS) <> 0x1 Or UBound($vrange, $UBOUND_ROWS) < 0x2 Then Return SetError(0x4, 0x0, + -1)
    Else
        Local $inumber
        $vrange = StringStripWS($vrange, 0x8)
        $asplit_1 = StringSplit($vrange, ";")
        $vrange = ''
        For $i = 0x1 To $asplit_1[0x0]
            If Not StringRegExp($asplit_1[$i], "^\\d+(-\\d+)?$") Then Return SetError(0x3, 0x0, + -1)
            $asplit_2 = StringSplit($asplit_1[$i], "-")
            Switch $asplit_2[0x0]
            Case 0x1
                $vrange &= $asplit_2[0x1] & ";"
            Case 0x2
                If Number($asplit_2[0x2]) >= Number($asplit_2[0x1]) Then
                    $inumber = $asplit_2[0x1] + -1
                    Do
                        $inumber += 0x1
                        $vrange &= $inumber & ";"
                    Until $inumber = $asplit_2[0x2]
                EndIf
            EndSwitch
        Next
        $vrange = StringSplit(StringTrimRight($vrange, 0x1), ";")
    EndIf
    For $i = 0x1 To $vrange[0x0]
        $vrange[$i] = Number($vrange[$i])
    Next
    If $vrange[0x1] < 0x0 Or $vrange[$vrange[0x0]] > $idim_1 Then Return SetError(0x5, 0x0, + -1)
    For $i = 0x2 To $vrange[0x0]
        If $vrange[$i] < $vrange[$i + -1] Then Return SetError(0x3, 0x0, + -1)
    Next
    Local $icopyto_index = $idim_1 + $vrange[0x0]
    Local $iinsertpoint_index = $vrange[0x0]
    Local $iinsert_index = $vrange[$iinsertpoint_index]
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        If $iforce = $ARRAYFILL_FORCE_SINGLEITEM Then
            ReDim $AARRAY[$idim_1 + $vrange[0x0] + 0x1]
            For $ireadfromindex = $idim_1 To 0x0 Step + -1
                $AARRAY[$icopyto_index] = $AARRAY[$ireadfromindex]
                $icopyto_index -= 0x1
                $iinsert_index = $vrange[$iinsertpoint_index]
                While $ireadfromindex = $iinsert_index
                    $AARRAY[$icopyto_index] = $vvalue
                    $icopyto_index -= 0x1
                    $iinsertpoint_index -= 0x1
                    If $iinsertpoint_index < 0x1 Then ExitLoop 0x2
                    $iinsert_index = $vrange[$iinsertpoint_index]
                WEnd
            Next
            Return $idim_1 + $vrange[0x0] + 0x1
        EndIf
        ReDim $AARRAY[$idim_1 + $vrange[0x0] + 0x1]
        If IsArray($vvalue) Then
            If UBound($vvalue, $UBOUND_DIMENSIONS) <> 0x1 Then Return SetError(0x5, 0x0, + -1)
            $hdatatype = 0x0
        Else
            Local $atmp = StringSplit($vvalue, $sdelim_item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
            If UBound($atmp, $UBOUND_ROWS) = 0x1 Then
                $atmp[0x0] = $vvalue
                $hdatatype = 0x0
            EndIf
            $vvalue = $atmp
        EndIf
        For $ireadfromindex = $idim_1 To 0x0 Step + -1
            $AARRAY[$icopyto_index] = $AARRAY[$ireadfromindex]
            $icopyto_index -= 0x1
            $iinsert_index = $vrange[$iinsertpoint_index]
            While $ireadfromindex = $iinsert_index
                If $iinsertpoint_index <= UBound($vvalue, $UBOUND_ROWS) Then
                    If IsFunc($hdatatype) Then
                        $AARRAY[$icopyto_index] = $hdatatype($vvalue[$iinsertpoint_index + -1])
                    Else
                        $AARRAY[$icopyto_index] = $vvalue[$iinsertpoint_index + -1]
                    EndIf
                Else
                    $AARRAY[$icopyto_index] = ''
                EndIf
                $icopyto_index -= 0x1
                $iinsertpoint_index -= 0x1
                If $iinsertpoint_index = 0x0 Then ExitLoop 0x2
                $iinsert_index = $vrange[$iinsertpoint_index]
            WEnd
        Next
    Case 0x2
        Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS)
        If $istart < 0x0 Or $istart > $idim_2 + -1 Then Return SetError(0x6, 0x0, + -1)
        Local $ivaldim_1, $ivaldim_2
        If IsArray($vvalue) Then
            If UBound($vvalue, $UBOUND_DIMENSIONS) <> 0x2 Then Return SetError(0x7, 0x0, + -1)
            $ivaldim_1 = UBound($vvalue, $UBOUND_ROWS)
            $ivaldim_2 = UBound($vvalue, $UBOUND_COLUMNS)
            $hdatatype = 0x0
        Else
            $asplit_1 = StringSplit($vvalue, $sdelim_row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
            $ivaldim_1 = UBound($asplit_1, $UBOUND_ROWS)
            StringReplace($asplit_1[0x0], $sdelim_item, '')
            $ivaldim_2 = @extended + 0x1
            Local $atmp[$ivaldim_1][$ivaldim_2]
            For $i = 0x0 To $ivaldim_1 + -1
                $asplit_2 = StringSplit($asplit_1[$i], $sdelim_item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
                For $j = 0x0 To $ivaldim_2 + -1
                    $atmp[$i][$j] = $asplit_2[$j]
                Next
            Next
            $vvalue = $atmp
        EndIf
        If UBound($vvalue, $UBOUND_COLUMNS) + $istart > UBound($AARRAY, $UBOUND_COLUMNS) Then Return SetError(0x8, 0x0, + -1)
        ReDim $AARRAY[$idim_1 + $vrange[0x0] + 0x1][$idim_2]
        For $ireadfromindex = $idim_1 To 0x0 Step + -1
            For $j = 0x0 To $idim_2 + -1
                $AARRAY[$icopyto_index][$j] = $AARRAY[$ireadfromindex][$j]
            Next
            $icopyto_index -= 0x1
            $iinsert_index = $vrange[$iinsertpoint_index]
            While $ireadfromindex = $iinsert_index
                For $j = 0x0 To $idim_2 + -1
                    If $j < $istart Then
                        $AARRAY[$icopyto_index][$j] = ''
                    ElseIf $j - $istart > $ivaldim_2 + -1 Then
                        $AARRAY[$icopyto_index][$j] = ''
                    Else
                        If $iinsertpoint_index + -1 < $ivaldim_1 Then
                            If IsFunc($hdatatype) Then
                                $AARRAY[$icopyto_index][$j] = $hdatatype($vvalue[$iinsertpoint_index + -1][$j - $istart])
                            Else
                                $AARRAY[$icopyto_index][$j] = $vvalue[$iinsertpoint_index + -1][$j - $istart]
                            EndIf
                        Else
                            $AARRAY[$icopyto_index][$j] = ''
                        EndIf
                    EndIf
                Next
                $icopyto_index -= 0x1
                $iinsertpoint_index -= 0x1
                If $iinsertpoint_index = 0x0 Then ExitLoop 0x2
                $iinsert_index = $vrange[$iinsertpoint_index]
            WEnd
        Next
    Case Else
        Return SetError(0x2, 0x0, + -1)
    EndSwitch
    Return UBound($AARRAY, $UBOUND_ROWS)
EndFunc    ; -> _ArrayInsert

Func _ArrayMax(Const ByRef $AARRAY, $ICOMPNUMERIC = 0x0, $istart = + -1, $IEND = + -1, $isubitem = 0x0)
    Local $iresult = _ArrayMaxIndex($AARRAY, $ICOMPNUMERIC, $istart, $IEND, $isubitem)
    If @error Then Return SetError(@error, 0x0, '')
    If UBound($AARRAY, $UBOUND_DIMENSIONS) = 0x1 Then
        Return $AARRAY[$iresult]
    Else
        Return $AARRAY[$iresult][$isubitem]
    EndIf
EndFunc    ; -> _ArrayMax

Func _ArrayMaxIndex(Const ByRef $AARRAY, $ICOMPNUMERIC = 0x0, $istart = + -1, $IEND = + -1, $isubitem = 0x0)
    If $ICOMPNUMERIC = Default Then $ICOMPNUMERIC = 0x0
    If $istart = Default Then $istart = + -1
    If $IEND = Default Then $IEND = + -1
    If $isubitem = Default Then $isubitem = 0x0
    Local $iret = __Array_MinMaxIndex($AARRAY, $ICOMPNUMERIC, $istart, $IEND, $isubitem, __Array_GreaterThan)
    Return SetError(@error, 0x0, $iret)
EndFunc    ; -> _ArrayMaxIndex

Func _ArrayMin(Const ByRef $AARRAY, $ICOMPNUMERIC = 0x0, $istart = + -1, $IEND = + -1, $isubitem = 0x0)
    Local $iresult = _ArrayMinIndex($AARRAY, $ICOMPNUMERIC, $istart, $IEND, $isubitem)
    If @error Then Return SetError(@error, 0x0, '')
    If UBound($AARRAY, $UBOUND_DIMENSIONS) = 0x1 Then
        Return $AARRAY[$iresult]
    Else
        Return $AARRAY[$iresult][$isubitem]
    EndIf
EndFunc    ; -> _ArrayMin

Func _ArrayMinIndex(Const ByRef $AARRAY, $ICOMPNUMERIC = 0x0, $istart = + -1, $IEND = + -1, $isubitem = 0x0)
    If $ICOMPNUMERIC = Default Then $ICOMPNUMERIC = 0x0
    If $istart = Default Then $istart = + -1
    If $IEND = Default Then $IEND = + -1
    If $isubitem = Default Then $isubitem = 0x0
    Local $iret = __Array_MinMaxIndex($AARRAY, $ICOMPNUMERIC, $istart, $IEND, $isubitem, __Array_LessThan)
    Return SetError(@error, 0x0, $iret)
EndFunc    ; -> _ArrayMinIndex

Func _ArrayPermute(ByRef $AARRAY, $SDELIMITER = '')
    If $SDELIMITER = Default Then $SDELIMITER = ''
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($AARRAY, $UBOUND_DIMENSIONS) <> 0x1 Then Return SetError(0x2, 0x0, 0x0)
    Local $isize = UBound($AARRAY), $ifactorial = 0x1, $aidx[$isize], $aresult[0x1], $icount = 0x1
    If UBound($AARRAY) Then
        For $i = 0x0 To $isize + -1
            $aidx[$i] = $i
        Next
        For $i = $isize To 0x1 Step + -1
            $ifactorial *= $i
        Next
        ReDim $aresult[$ifactorial + 0x1]
        $aresult[0x0] = $ifactorial
        __Array_ExeterInternal($AARRAY, 0x0, $isize, $SDELIMITER, $aidx, $aresult, $icount)
    Else
        $aresult[0x0] = 0x0
    EndIf
    Return $aresult
EndFunc    ; -> _ArrayPermute

Func _ArrayPop(ByRef $AARRAY)
    If (Not IsArray($AARRAY)) Then Return SetError(0x1, 0x0, '')
    If UBound($AARRAY, $UBOUND_DIMENSIONS) <> 0x1 Then Return SetError(0x2, 0x0, '')
    Local $iubound = UBound($AARRAY) + -1
    If $iubound = + -1 Then Return SetError(0x3, 0x0, '')
    Local $slastval = $AARRAY[$iubound]
    If $iubound > + -1 Then
        ReDim $AARRAY[$iubound]
    EndIf
    Return $slastval
EndFunc    ; -> _ArrayPop

Func _ArrayPush(ByRef $AARRAY, $vvalue, $idirection = 0x0)
    If $idirection = Default Then $idirection = 0x0
    If (Not IsArray($AARRAY)) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($AARRAY, $UBOUND_DIMENSIONS) <> 0x1 Then Return SetError(0x3, 0x0, 0x0)
    Local $iubound = UBound($AARRAY) + -1
    If IsArray($vvalue) Then
        Local $iubounds = UBound($vvalue)
        If ($iubounds + -1) > $iubound Then Return SetError(0x2, 0x0, 0x0)
        If $idirection Then
            For $i = $iubound To $iubounds Step + -1
                $AARRAY[$i] = $AARRAY[$i - $iubounds]
            Next
            For $i = 0x0 To $iubounds + -1
                $AARRAY[$i] = $vvalue[$i]
            Next
        Else
            For $i = 0x0 To $iubound - $iubounds
                $AARRAY[$i] = $AARRAY[$i + $iubounds]
            Next
            For $i = 0x0 To $iubounds + -1
                $AARRAY[$i + $iubound - $iubounds + 0x1] = $vvalue[$i]
            Next
        EndIf
    Else
        If $iubound > + -1 Then
            If $idirection Then
                For $i = $iubound To 0x1 Step + -1
                    $AARRAY[$i] = $AARRAY[$i + -1]
                Next
                $AARRAY[0x0] = $vvalue
            Else
                For $i = 0x0 To $iubound + -1
                    $AARRAY[$i] = $AARRAY[$i + 0x1]
                Next
                $AARRAY[$iubound] = $vvalue
            EndIf
        EndIf
    EndIf
    Return 0x1
EndFunc    ; -> _ArrayPush

Func _ArrayReverse(ByRef $AARRAY, $istart = 0x0, $IEND = 0x0)
    If $istart = Default Then $istart = 0x0
    If $IEND = Default Then $IEND = 0x0
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, 0x0)
    If UBound($AARRAY, $UBOUND_DIMENSIONS) <> 0x1 Then Return SetError(0x3, 0x0, 0x0)
    If Not UBound($AARRAY) Then Return SetError(0x4, 0x0, 0x0)
    Local $vtmp, $iubound = UBound($AARRAY) + -1
    If $IEND < 0x1 Or $IEND > $iubound Then $IEND = $iubound
    If $istart < 0x0 Then $istart = 0x0
    If $istart > $IEND Then Return SetError(0x2, 0x0, 0x0)
    For $i = $istart To Int(($istart + $IEND + -1) / 0x2)
        $vtmp = $AARRAY[$i]
        $AARRAY[$i] = $AARRAY[$IEND]
        $AARRAY[$IEND] = $vtmp
        $IEND -= 0x1
    Next
    Return 0x1
EndFunc    ; -> _ArrayReverse

Func _ArraySearch(Const ByRef $AARRAY, $vvalue, $istart = 0x0, $IEND = 0x0, $ICASE = 0x0, $ICOMPARE = 0x0, $IFORWARD = 0x1, $isubitem = + -1, $BROW = False)
    If $istart = Default Then $istart = 0x0
    If $IEND = Default Then $IEND = 0x0
    If $ICASE = Default Then $ICASE = 0x0
    If $ICOMPARE = Default Then $ICOMPARE = 0x0
    If $IFORWARD = Default Then $IFORWARD = 0x1
    If $isubitem = Default Then $isubitem = + -1
    If $BROW = Default Then $BROW = False
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY) + -1
    If $idim_1 = + -1 Then Return SetError(0x3, 0x0, + -1)
    Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS) + -1
    Local $bcomptype = False
    If $ICOMPARE = 0x2 Then
        $ICOMPARE = 0x0
        $bcomptype = True
    EndIf
    If $BROW Then
        If UBound($AARRAY, $UBOUND_DIMENSIONS) = 0x1 Then Return SetError(0x5, 0x0, + -1)
        If $IEND < 0x1 Or $IEND > $idim_2 Then $IEND = $idim_2
        If $istart < 0x0 Then $istart = 0x0
        If $istart > $IEND Then Return SetError(0x4, 0x0, + -1)
    Else
        If $IEND < 0x1 Or $IEND > $idim_1 Then $IEND = $idim_1
        If $istart < 0x0 Then $istart = 0x0
        If $istart > $IEND Then Return SetError(0x4, 0x0, + -1)
    EndIf
    Local $istep = 0x1
    If Not $IFORWARD Then
        Local $itmp = $istart
        $istart = $IEND
        $IEND = $itmp
        $istep = + -1
    EndIf
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        If Not $ICOMPARE Then
            If Not $ICASE Then
                For $i = $istart To $IEND Step $istep
                    If $bcomptype And VarGetType($AARRAY[$i]) <> VarGetType($vvalue) Then ContinueLoop
                    If $AARRAY[$i] = $vvalue Then Return $i
                Next
            Else
                For $i = $istart To $IEND Step $istep
                    If $bcomptype And VarGetType($AARRAY[$i]) <> VarGetType($vvalue) Then ContinueLoop
                    If $AARRAY[$i] == $vvalue Then Return $i
                Next
            EndIf
        Else
            For $i = $istart To $IEND Step $istep
                If $ICOMPARE = 0x3 Then
                    If StringRegExp($AARRAY[$i], $vvalue) Then Return $i
                Else
                    If StringInStr($AARRAY[$i], $vvalue, $ICASE) > 0x0 Then Return $i
                EndIf
            Next
        EndIf
    Case 0x2
        Local $idim_sub
        If $BROW Then
            $idim_sub = $idim_1
            If $isubitem > $idim_sub Then $isubitem = $idim_sub
            If $isubitem < 0x0 Then
                $isubitem = 0x0
            Else
                $idim_sub = $isubitem
            EndIf
        Else
            $idim_sub = $idim_2
            If $isubitem > $idim_sub Then $isubitem = $idim_sub
            If $isubitem < 0x0 Then
                $isubitem = 0x0
            Else
                $idim_sub = $isubitem
            EndIf
        EndIf
        For $j = $isubitem To $idim_sub
            If Not $ICOMPARE Then
                If Not $ICASE Then
                    For $i = $istart To $IEND Step $istep
                        If $BROW Then
                            If $bcomptype And VarGetType($AARRAY[$j][$i]) <> VarGetType($vvalue) Then ContinueLoop
                            If $AARRAY[$j][$i] = $vvalue Then Return $i
                        Else
                            If $bcomptype And VarGetType($AARRAY[$i][$j]) <> VarGetType($vvalue) Then ContinueLoop
                            If $AARRAY[$i][$j] = $vvalue Then Return $i
                        EndIf
                    Next
                Else
                    For $i = $istart To $IEND Step $istep
                        If $BROW Then
                            If $bcomptype And VarGetType($AARRAY[$j][$i]) <> VarGetType($vvalue) Then ContinueLoop
                            If $AARRAY[$j][$i] == $vvalue Then Return $i
                        Else
                            If $bcomptype And VarGetType($AARRAY[$i][$j]) <> VarGetType($vvalue) Then ContinueLoop
                            If $AARRAY[$i][$j] == $vvalue Then Return $i
                        EndIf
                    Next
                EndIf
            Else
                For $i = $istart To $IEND Step $istep
                    If $ICOMPARE = 0x3 Then
                        If $BROW Then
                            If StringRegExp($AARRAY[$j][$i], $vvalue) Then Return $i
                        Else
                            If StringRegExp($AARRAY[$i][$j], $vvalue) Then Return $i
                        EndIf
                    Else
                        If $BROW Then
                            If StringInStr($AARRAY[$j][$i], $vvalue, $ICASE) > 0x0 Then Return $i
                        Else
                            If StringInStr($AARRAY[$i][$j], $vvalue, $ICASE) > 0x0 Then Return $i
                        EndIf
                    EndIf
                Next
            EndIf
        Next
    Case Else
        Return SetError(0x2, 0x0, + -1)
    EndSwitch
    Return SetError(0x6, 0x0, + -1)
EndFunc    ; -> _ArraySearch

Func _ArrayShuffle(ByRef $AARRAY, $ISTART_ROW = 0x0, $IEND_ROW = 0x0, $icol = + -1)
    If $ISTART_ROW = Default Then $ISTART_ROW = 0x0
    If $IEND_ROW = Default Then $IEND_ROW = 0x0
    If $icol = Default Then $icol = + -1
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS)
    If $IEND_ROW = 0x0 Then $IEND_ROW = $idim_1 + -1
    If $ISTART_ROW < 0x0 Or $ISTART_ROW > $idim_1 + -1 Then Return SetError(0x3, 0x0, + -1)
    If $IEND_ROW < 0x1 Or $IEND_ROW > $idim_1 + -1 Then Return SetError(0x3, 0x0, + -1)
    If $ISTART_ROW > $IEND_ROW Then Return SetError(0x4, 0x0, + -1)
    Local $vtmp, $irand
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        For $i = $IEND_ROW To $ISTART_ROW + 0x1 Step + -1
            $irand = Random($ISTART_ROW, $i, 0x1)
            $vtmp = $AARRAY[$i]
            $AARRAY[$i] = $AARRAY[$irand]
            $AARRAY[$irand] = $vtmp
        Next
        Return 0x1
    Case 0x2
        Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS)
        If $icol < + -1 Or $icol > $idim_2 + -1 Then Return SetError(0x5, 0x0, + -1)
        Local $icol_start, $icol_end
        If $icol = + -1 Then
            $icol_start = 0x0
            $icol_end = $idim_2 + -1
        Else
            $icol_start = $icol
            $icol_end = $icol
        EndIf
        For $i = $IEND_ROW To $ISTART_ROW + 0x1 Step + -1
            $irand = Random($ISTART_ROW, $i, 0x1)
            For $j = $icol_start To $icol_end
                $vtmp = $AARRAY[$i][$j]
                $AARRAY[$i][$j] = $AARRAY[$irand][$j]
                $AARRAY[$irand][$j] = $vtmp
            Next
        Next
        Return 0x1
    Case Else
        Return SetError(0x2, 0x0, + -1)
    EndSwitch
EndFunc    ; -> _ArrayShuffle

Func _ArraySort(ByRef $AARRAY, $idescending = 0x0, $istart = 0x0, $IEND = 0x0, $isubitem = 0x0, $ipivot = 0x0)
    If $idescending = Default Then $idescending = 0x0
    If $istart = Default Then $istart = 0x0
    If $IEND = Default Then $IEND = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If $ipivot = Default Then $ipivot = 0x0
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, 0x0)
    Local $iubound = UBound($AARRAY) + -1
    If $iubound = + -1 Then Return SetError(0x5, 0x0, 0x0)
    If $IEND = Default Then $IEND = 0x0
    If $IEND < 0x1 Or $IEND > $iubound Or $IEND = Default Then $IEND = $iubound
    If $istart < 0x0 Or $istart = Default Then $istart = 0x0
    If $istart > $IEND Then Return SetError(0x2, 0x0, 0x0)
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        If $ipivot Then
            __ArrayDualPivotSort($AARRAY, $istart, $IEND)
        Else
            __ArrayQuickSort1D($AARRAY, $istart, $IEND)
        EndIf
        If $idescending Then _ArrayReverse($AARRAY, $istart, $IEND)
    Case 0x2
        If $ipivot Then Return SetError(0x6, 0x0, 0x0)
        Local $isubmax = UBound($AARRAY, $UBOUND_COLUMNS) + -1
        If $isubitem > $isubmax Then Return SetError(0x3, 0x0, 0x0)
        If $idescending Then
            $idescending = + -1
        Else
            $idescending = 0x1
        EndIf
        __ArrayQuickSort2D($AARRAY, $idescending, $istart, $IEND, $isubitem, $isubmax)
    Case Else
        Return SetError(0x4, 0x0, 0x0)
    EndSwitch
    Return 0x1
EndFunc    ; -> _ArraySort

Func __ArrayQuickSort1D(ByRef $AARRAY, Const ByRef $istart, Const ByRef $IEND)
    If $IEND <= $istart Then Return
    Local $vtmp
    If ($IEND - $istart) < 0xf Then
        Local $vcur
        For $i = $istart + 0x1 To $IEND
            $vtmp = $AARRAY[$i]
            If IsNumber($vtmp) Then
                For $j = $i + -1 To $istart Step + -1
                    $vcur = $AARRAY[$j]
                    If ($vtmp >= $vcur And IsNumber($vcur)) Or (Not IsNumber($vcur) And StringCompare($vtmp, $vcur) >= 0x0) Then ExitLoop
                    $AARRAY[$j + 0x1] = $vcur
                Next
            Else
                For $j = $i + -1 To $istart Step + -1
                    If (StringCompare($vtmp, $AARRAY[$j]) >= 0x0) Then ExitLoop
                    $AARRAY[$j + 0x1] = $AARRAY[$j]
                Next
            EndIf
            $AARRAY[$j + 0x1] = $vtmp
        Next
        Return
    EndIf
    Local $l = $istart, $r = $IEND, $vpivot = $AARRAY[Int(($istart + $IEND) / 0x2)], $bnum = IsNumber($vpivot)
    Do
        If $bnum Then
            While ($AARRAY[$l] < $vpivot And IsNumber($AARRAY[$l])) Or (Not IsNumber($AARRAY[$l]) And StringCompare($AARRAY[$l], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While ($AARRAY[$r] > $vpivot And IsNumber($AARRAY[$r])) Or (Not IsNumber($AARRAY[$r]) And StringCompare($AARRAY[$r], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        Else
            While (StringCompare($AARRAY[$l], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While (StringCompare($AARRAY[$r], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        EndIf
        If $l <= $r Then
            $vtmp = $AARRAY[$l]
            $AARRAY[$l] = $AARRAY[$r]
            $AARRAY[$r] = $vtmp
            $l += 0x1
            $r -= 0x1
        EndIf
    Until $l > $r
    __ArrayQuickSort1D($AARRAY, $istart, $r)
    __ArrayQuickSort1D($AARRAY, $l, $IEND)
EndFunc    ; -> __ArrayQuickSort1D

Func __ArrayQuickSort2D(ByRef $AARRAY, Const ByRef $istep, Const ByRef $istart, Const ByRef $IEND, Const ByRef $isubitem, Const ByRef $isubmax)
    If $IEND <= $istart Then Return
    Local $vtmp, $l = $istart, $r = $IEND, $vpivot = $AARRAY[Int(($istart + $IEND) / 0x2)][$isubitem], $bnum = IsNumber($vpivot)
    Do
        If $bnum Then
            While ($istep * ($AARRAY[$l][$isubitem] - $vpivot) < 0x0 And IsNumber($AARRAY[$l][$isubitem])) Or (Not IsNumber($AARRAY[$l][$isubitem]) And $istep * StringCompare($AARRAY[$l][$isubitem], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While ($istep * ($AARRAY[$r][$isubitem] - $vpivot) > 0x0 And IsNumber($AARRAY[$r][$isubitem])) Or (Not IsNumber($AARRAY[$r][$isubitem]) And $istep * StringCompare($AARRAY[$r][$isubitem], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        Else
            While ($istep * StringCompare($AARRAY[$l][$isubitem], $vpivot) < 0x0)
                $l += 0x1
            WEnd
            While ($istep * StringCompare($AARRAY[$r][$isubitem], $vpivot) > 0x0)
                $r -= 0x1
            WEnd
        EndIf
        If $l <= $r Then
            For $i = 0x0 To $isubmax
                $vtmp = $AARRAY[$l][$i]
                $AARRAY[$l][$i] = $AARRAY[$r][$i]
                $AARRAY[$r][$i] = $vtmp
            Next
            $l += 0x1
            $r -= 0x1
        EndIf
    Until $l > $r
    __ArrayQuickSort2D($AARRAY, $istep, $istart, $r, $isubitem, $isubmax)
    __ArrayQuickSort2D($AARRAY, $istep, $l, $IEND, $isubitem, $isubmax)
EndFunc    ; -> __ArrayQuickSort2D

Func __ArrayDualPivotSort(ByRef $AARRAY, $ipivot_left, $ipivot_right, $bleftmost = True)
    If $ipivot_left > $ipivot_right Then Return
    Local $ilength = $ipivot_right - $ipivot_left + 0x1
    Local $i, $j, $k, $iai, $iak, $ia1, $ia2, $ilast
    If $ilength < 0x2d Then
        If $bleftmost Then
            $i = $ipivot_left
            While $i < $ipivot_right
                $j = $i
                $iai = $AARRAY[$i + 0x1]
                While $iai < $AARRAY[$j]
                    $AARRAY[$j + 0x1] = $AARRAY[$j]
                    $j -= 0x1
                    If $j + 0x1 = $ipivot_left Then ExitLoop
                WEnd
                $AARRAY[$j + 0x1] = $iai
                $i += 0x1
            WEnd
        Else
            While 0x1
                If $ipivot_left >= $ipivot_right Then Return 0x1
                $ipivot_left += 0x1
                If $AARRAY[$ipivot_left] < $AARRAY[$ipivot_left + -1] Then ExitLoop
            WEnd
            While 0x1
                $k = $ipivot_left
                $ipivot_left += 0x1
                If $ipivot_left > $ipivot_right Then ExitLoop
                $ia1 = $AARRAY[$k]
                $ia2 = $AARRAY[$ipivot_left]
                If $ia1 < $ia2 Then
                    $ia2 = $ia1
                    $ia1 = $AARRAY[$ipivot_left]
                EndIf
                $k -= 0x1
                While $ia1 < $AARRAY[$k]
                    $AARRAY[$k + 0x2] = $AARRAY[$k]
                    $k -= 0x1
                WEnd
                $AARRAY[$k + 0x2] = $ia1
                While $ia2 < $AARRAY[$k]
                    $AARRAY[$k + 0x1] = $AARRAY[$k]
                    $k -= 0x1
                WEnd
                $AARRAY[$k + 0x1] = $ia2
                $ipivot_left += 0x1
            WEnd
            $ilast = $AARRAY[$ipivot_right]
            $ipivot_right -= 0x1
            While $ilast < $AARRAY[$ipivot_right]
                $AARRAY[$ipivot_right + 0x1] = $AARRAY[$ipivot_right]
                $ipivot_right -= 0x1
            WEnd
            $AARRAY[$ipivot_right + 0x1] = $ilast
        EndIf
        Return 0x1
    EndIf
    Local $iseventh = BitShift($ilength, 0x3) + BitShift($ilength, 0x6) + 0x1
    Local $ie1, $ie2, $ie3, $ie4, $ie5, $t
    $ie3 = Ceiling(($ipivot_left + $ipivot_right) / 0x2)
    $ie2 = $ie3 - $iseventh
    $ie1 = $ie2 - $iseventh
    $ie4 = $ie3 + $iseventh
    $ie5 = $ie4 + $iseventh
    If $AARRAY[$ie2] < $AARRAY[$ie1] Then
        $t = $AARRAY[$ie2]
        $AARRAY[$ie2] = $AARRAY[$ie1]
        $AARRAY[$ie1] = $t
    EndIf
    If $AARRAY[$ie3] < $AARRAY[$ie2] Then
        $t = $AARRAY[$ie3]
        $AARRAY[$ie3] = $AARRAY[$ie2]
        $AARRAY[$ie2] = $t
        If $t < $AARRAY[$ie1] Then
            $AARRAY[$ie2] = $AARRAY[$ie1]
            $AARRAY[$ie1] = $t
        EndIf
    EndIf
    If $AARRAY[$ie4] < $AARRAY[$ie3] Then
        $t = $AARRAY[$ie4]
        $AARRAY[$ie4] = $AARRAY[$ie3]
        $AARRAY[$ie3] = $t
        If $t < $AARRAY[$ie2] Then
            $AARRAY[$ie3] = $AARRAY[$ie2]
            $AARRAY[$ie2] = $t
            If $t < $AARRAY[$ie1] Then
                $AARRAY[$ie2] = $AARRAY[$ie1]
                $AARRAY[$ie1] = $t
            EndIf
        EndIf
    EndIf
    If $AARRAY[$ie5] < $AARRAY[$ie4] Then
        $t = $AARRAY[$ie5]
        $AARRAY[$ie5] = $AARRAY[$ie4]
        $AARRAY[$ie4] = $t
        If $t < $AARRAY[$ie3] Then
            $AARRAY[$ie4] = $AARRAY[$ie3]
            $AARRAY[$ie3] = $t
            If $t < $AARRAY[$ie2] Then
                $AARRAY[$ie3] = $AARRAY[$ie2]
                $AARRAY[$ie2] = $t
                If $t < $AARRAY[$ie1] Then
                    $AARRAY[$ie2] = $AARRAY[$ie1]
                    $AARRAY[$ie1] = $t
                EndIf
            EndIf
        EndIf
    EndIf
    Local $iless = $ipivot_left
    Local $igreater = $ipivot_right
    If (($AARRAY[$ie1] <> $AARRAY[$ie2]) And ($AARRAY[$ie2] <> $AARRAY[$ie3]) And ($AARRAY[$ie3] <> $AARRAY[$ie4]) And ($AARRAY[$ie4] <> $AARRAY[$ie5])) Then
        Local $ipivot_1 = $AARRAY[$ie2]
        Local $ipivot_2 = $AARRAY[$ie4]
        $AARRAY[$ie2] = $AARRAY[$ipivot_left]
        $AARRAY[$ie4] = $AARRAY[$ipivot_right]
        Do
            $iless += 0x1
        Until $AARRAY[$iless] >= $ipivot_1
        Do
            $igreater -= 0x1
        Until $AARRAY[$igreater] <= $ipivot_2
        $k = $iless
        While $k <= $igreater
            $iak = $AARRAY[$k]
            If $iak < $ipivot_1 Then
                $AARRAY[$k] = $AARRAY[$iless]
                $AARRAY[$iless] = $iak
                $iless += 0x1
            ElseIf $iak > $ipivot_2 Then
                While $AARRAY[$igreater] > $ipivot_2
                    $igreater -= 0x1
                    If $igreater + 0x1 = $k Then ExitLoop 0x2
                WEnd
                If $AARRAY[$igreater] < $ipivot_1 Then
                    $AARRAY[$k] = $AARRAY[$iless]
                    $AARRAY[$iless] = $AARRAY[$igreater]
                    $iless += 0x1
                Else
                    $AARRAY[$k] = $AARRAY[$igreater]
                EndIf
                $AARRAY[$igreater] = $iak
                $igreater -= 0x1
            EndIf
            $k += 0x1
        WEnd
        $AARRAY[$ipivot_left] = $AARRAY[$iless + -1]
        $AARRAY[$iless + -1] = $ipivot_1
        $AARRAY[$ipivot_right] = $AARRAY[$igreater + 0x1]
        $AARRAY[$igreater + 0x1] = $ipivot_2
        __ArrayDualPivotSort($AARRAY, $ipivot_left, $iless + -2, True)
        __ArrayDualPivotSort($AARRAY, $igreater + 0x2, $ipivot_right, False)
        If ($iless < $ie1) And ($ie5 < $igreater) Then
            While $AARRAY[$iless] = $ipivot_1
                $iless += 0x1
            WEnd
            While $AARRAY[$igreater] = $ipivot_2
                $igreater -= 0x1
            WEnd
            $k = $iless
            While $k <= $igreater
                $iak = $AARRAY[$k]
                If $iak = $ipivot_1 Then
                    $AARRAY[$k] = $AARRAY[$iless]
                    $AARRAY[$iless] = $iak
                    $iless += 0x1
                ElseIf $iak = $ipivot_2 Then
                    While $AARRAY[$igreater] = $ipivot_2
                        $igreater -= 0x1
                        If $igreater + 0x1 = $k Then ExitLoop 0x2
                    WEnd
                    If $AARRAY[$igreater] = $ipivot_1 Then
                        $AARRAY[$k] = $AARRAY[$iless]
                        $AARRAY[$iless] = $ipivot_1
                        $iless += 0x1
                    Else
                        $AARRAY[$k] = $AARRAY[$igreater]
                    EndIf
                    $AARRAY[$igreater] = $iak
                    $igreater -= 0x1
                EndIf
                $k += 0x1
            WEnd
        EndIf
        __ArrayDualPivotSort($AARRAY, $iless, $igreater, False)
    Else
        Local $ipivot = $AARRAY[$ie3]
        $k = $iless
        While $k <= $igreater
            If $AARRAY[$k] = $ipivot Then
                $k += 0x1
                ContinueLoop
            EndIf
            $iak = $AARRAY[$k]
            If $iak < $ipivot Then
                $AARRAY[$k] = $AARRAY[$iless]
                $AARRAY[$iless] = $iak
                $iless += 0x1
            Else
                While $AARRAY[$igreater] > $ipivot
                    $igreater -= 0x1
                WEnd
                If $AARRAY[$igreater] < $ipivot Then
                    $AARRAY[$k] = $AARRAY[$iless]
                    $AARRAY[$iless] = $AARRAY[$igreater]
                    $iless += 0x1
                Else
                    $AARRAY[$k] = $ipivot
                EndIf
                $AARRAY[$igreater] = $iak
                $igreater -= 0x1
            EndIf
            $k += 0x1
        WEnd
        __ArrayDualPivotSort($AARRAY, $ipivot_left, $iless + -1, True)
        __ArrayDualPivotSort($AARRAY, $igreater + 0x1, $ipivot_right, False)
    EndIf
EndFunc    ; -> __ArrayDualPivotSort

Func _ArraySwap(ByRef $AARRAY, $iindex_1, $iindex_2, $bcol = False, $istart = + -1, $IEND = + -1)
    If $bcol = Default Then $bcol = False
    If $istart = Default Then $istart = + -1
    If $IEND = Default Then $IEND = + -1
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS) + -1
    Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS) + -1
    If $idim_2 = + -1 Then
        $bcol = False
        $istart = + -1
        $IEND = + -1
    EndIf
    If $istart > $IEND Then Return SetError(0x5, 0x0, + -1)
    If $bcol Then
        If $iindex_1 < 0x0 Or $iindex_2 > $idim_2 Then Return SetError(0x3, 0x0, + -1)
        If $istart = + -1 Then $istart = 0x0
        If $IEND = + -1 Then $IEND = $idim_1
    Else
        If $iindex_1 < 0x0 Or $iindex_2 > $idim_1 Then Return SetError(0x3, 0x0, + -1)
        If $istart = + -1 Then $istart = 0x0
        If $IEND = + -1 Then $IEND = $idim_2
    EndIf
    Local $vtmp
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        $vtmp = $AARRAY[$iindex_1]
        $AARRAY[$iindex_1] = $AARRAY[$iindex_2]
        $AARRAY[$iindex_2] = $vtmp
    Case 0x2
        If $istart < + -1 Or $IEND < + -1 Then Return SetError(0x4, 0x0, + -1)
        If $bcol Then
            If $istart > $idim_1 Or $IEND > $idim_1 Then Return SetError(0x4, 0x0, + -1)
            For $j = $istart To $IEND
                $vtmp = $AARRAY[$j][$iindex_1]
                $AARRAY[$j][$iindex_1] = $AARRAY[$j][$iindex_2]
                $AARRAY[$j][$iindex_2] = $vtmp
            Next
        Else
            If $istart > $idim_2 Or $IEND > $idim_2 Then Return SetError(0x4, 0x0, + -1)
            For $j = $istart To $IEND
                $vtmp = $AARRAY[$iindex_1][$j]
                $AARRAY[$iindex_1][$j] = $AARRAY[$iindex_2][$j]
                $AARRAY[$iindex_2][$j] = $vtmp
            Next
        EndIf
    Case Else
        Return SetError(0x2, 0x0, + -1)
    EndSwitch
    Return 0x1
EndFunc    ; -> _ArraySwap

Func _ArrayToClip(Const ByRef $AARRAY, $sdelim_col = "|", $ISTART_ROW = + -1, $IEND_ROW = + -1, $sdelim_row = @CRLF, $ISTART_COL = + -1, $IEND_COL = + -1)
    Local $sresult = _ArrayToString($AARRAY, $sdelim_col, $ISTART_ROW, $IEND_ROW, $sdelim_row, $ISTART_COL, $IEND_COL)
    If @error Then Return SetError(@error, 0x0, 0x0)
    If ClipPut($sresult) Then Return 0x1
    Return SetError(+ -1, 0x0, 0x0)
EndFunc    ; -> _ArrayToClip

Func _ArrayToString(Const ByRef $AARRAY, $sdelim_col = "|", $ISTART_ROW = Default, $IEND_ROW = Default, $sdelim_row = @CRLF, $ISTART_COL = Default, $IEND_COL = Default)
    If $sdelim_col = Default Then $sdelim_col = "|"
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $ISTART_ROW = Default Then $ISTART_ROW = + -1
    If $IEND_ROW = Default Then $IEND_ROW = + -1
    If $ISTART_COL = Default Then $ISTART_COL = + -1
    If $IEND_COL = Default Then $IEND_COL = + -1
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS) + -1
    If $idim_1 = + -1 Then Return ''
    If $ISTART_ROW = + -1 Then $ISTART_ROW = 0x0
    If $IEND_ROW = + -1 Then $IEND_ROW = $idim_1
    If $ISTART_ROW < + -1 Or $IEND_ROW < + -1 Then Return SetError(0x3, 0x0, + -1)
    If $ISTART_ROW > $idim_1 Or $IEND_ROW > $idim_1 Then Return SetError(0x3, 0x0, '')
    If $ISTART_ROW > $IEND_ROW Then Return SetError(0x4, 0x0, + -1)
    Local $sret = ''
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        For $i = $ISTART_ROW To $IEND_ROW
            $sret &= $AARRAY[$i] & $sdelim_col
        Next
        Return StringTrimRight($sret, StringLen($sdelim_col))
    Case 0x2
        Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS) + -1
        If $idim_2 = + -1 Then Return ''
        If $ISTART_COL = + -1 Then $ISTART_COL = 0x0
        If $IEND_COL = + -1 Then $IEND_COL = $idim_2
        If $ISTART_COL < + -1 Or $IEND_COL < + -1 Then Return SetError(0x5, 0x0, + -1)
        If $ISTART_COL > $idim_2 Or $IEND_COL > $idim_2 Then Return SetError(0x5, 0x0, + -1)
        If $ISTART_COL > $IEND_COL Then Return SetError(0x6, 0x0, + -1)
        Local $idelimcollen = StringLen($sdelim_col)
        For $i = $ISTART_ROW To $IEND_ROW
            For $j = $ISTART_COL To $IEND_COL
                $sret &= $AARRAY[$i][$j] & $sdelim_col
            Next
            $sret = StringTrimRight($sret, $idelimcollen) & $sdelim_row
        Next
        Return StringTrimRight($sret, StringLen($sdelim_row))
    Case Else
        Return SetError(0x2, 0x0, + -1)
    EndSwitch
    Return 0x1
EndFunc    ; -> _ArrayToString

Func _ArrayTranspose(ByRef $AARRAY, $bforce1d = False)
    Local $atemp
    Switch $bforce1d
    Case Default
        $bforce1d = False
    Case True, False
    Case Else
        Return SetError(0x3, 0x0, 0x0)
    EndSwitch
    Switch UBound($AARRAY, 0x0)
    Case 0x0
        Return SetError(0x2, 0x0, 0x0)
    Case 0x1
        Local $atemp[0x1][UBound($AARRAY)]
        For $i = 0x0 To UBound($AARRAY) + -1
            $atemp[0x0][$i] = $AARRAY[$i]
        Next
        $AARRAY = $atemp
    Case 0x2
        Local $idim_1 = UBound($AARRAY, 0x1), $idim_2 = UBound($AARRAY, 0x2)
        If $idim_1 <> $idim_2 Then
            Local $atemp[$idim_2][$idim_1]
            For $i = 0x0 To $idim_1 + -1
                For $j = 0x0 To $idim_2 + -1
                    $atemp[$j][$i] = $AARRAY[$i][$j]
                Next
            Next
            $AARRAY = $atemp
        Else
            Local $velement
            For $i = 0x0 To $idim_1 + -1
                For $j = $i + 0x1 To $idim_2 + -1
                    $velement = $AARRAY[$i][$j]
                    $AARRAY[$i][$j] = $AARRAY[$j][$i]
                    $AARRAY[$j][$i] = $velement
                Next
            Next
        EndIf
        If $bforce1d = True And UBound($AARRAY, 0x2) = 0x1 Then
            $atemp = $AARRAY
            ReDim $AARRAY[UBound($atemp)]
            For $i = 0x0 To UBound($atemp) + -1
                $AARRAY[$i] = $atemp[$i][0x0]
            Next
        EndIf
    Case Else
        Return SetError(0x1, 0x0, 0x0)
    EndSwitch
    Return 0x1
EndFunc    ; -> _ArrayTranspose

Func _ArrayTrim(ByRef $AARRAY, $itrimnum, $idirection = 0x0, $istart = 0x0, $IEND = 0x0, $isubitem = 0x0)
    If $idirection = Default Then $idirection = 0x0
    If $istart = Default Then $istart = 0x0
    If $IEND = Default Then $IEND = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, 0x0)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS) + -1
    If $IEND = 0x0 Then $IEND = $idim_1
    If $istart > $IEND Then Return SetError(0x3, 0x0, + -1)
    If $istart < 0x0 Or $IEND < 0x0 Then Return SetError(0x3, 0x0, + -1)
    If $istart > $idim_1 Or $IEND > $idim_1 Then Return SetError(0x3, 0x0, + -1)
    If $istart > $IEND Then Return SetError(0x4, 0x0, + -1)
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        If $idirection Then
            For $i = $istart To $IEND
                $AARRAY[$i] = StringTrimRight($AARRAY[$i], $itrimnum)
            Next
        Else
            For $i = $istart To $IEND
                $AARRAY[$i] = StringTrimLeft($AARRAY[$i], $itrimnum)
            Next
        EndIf
    Case 0x2
        Local $idim_2 = UBound($AARRAY, $UBOUND_COLUMNS) + -1
        If $isubitem < 0x0 Or $isubitem > $idim_2 Then Return SetError(0x5, 0x0, + -1)
        If $idirection Then
            For $i = $istart To $IEND
                $AARRAY[$i][$isubitem] = StringTrimRight($AARRAY[$i][$isubitem], $itrimnum)
            Next
        Else
            For $i = $istart To $IEND
                $AARRAY[$i][$isubitem] = StringTrimLeft($AARRAY[$i][$isubitem], $itrimnum)
            Next
        EndIf
    Case Else
        Return SetError(0x2, 0x0, 0x0)
    EndSwitch
    Return 0x1
EndFunc    ; -> _ArrayTrim

Func _ArrayUnique(Const ByRef $AARRAY, $icolumn = 0x0, $IBASE = 0x0, $ICASE = 0x0, $icount = $ARRAYUNIQUE_COUNT, $IINTTYPE = $ARRAYUNIQUE_AUTO)
    If $icolumn = Default Then $icolumn = 0x0
    If $IBASE = Default Then $IBASE = 0x0
    If $ICASE = Default Then $ICASE = 0x0
    If $icount = Default Then $icount = $ARRAYUNIQUE_COUNT
    If $IINTTYPE = Default Then $IINTTYPE = $ARRAYUNIQUE_AUTO
    If UBound($AARRAY, $UBOUND_ROWS) = 0x0 Then Return SetError(0x1, 0x0, 0x0)
    Local $idims = UBound($AARRAY, $UBOUND_DIMENSIONS), $inumcolumns = UBound($AARRAY, $UBOUND_COLUMNS)
    If $idims > 0x2 Then Return SetError(0x2, 0x0, 0x0)
    If $IBASE < 0x0 Or $IBASE > 0x1 Or (Not IsInt($IBASE)) Then Return SetError(0x3, 0x0, 0x0)
    If $ICASE < 0x0 Or $ICASE > 0x1 Or (Not IsInt($ICASE)) Then Return SetError(0x3, 0x0, 0x0)
    If $icount < 0x0 Or $icount > 0x1 Or (Not IsInt($icount)) Then Return SetError(0x4, 0x0, 0x0)
    If $IINTTYPE < 0x0 Or $IINTTYPE > 0x4 Or (Not IsInt($IINTTYPE)) Then Return SetError(0x5, 0x0, 0x0)
    If $icolumn < 0x0 Or ($inumcolumns = 0x0 And $icolumn > 0x0) Or ($inumcolumns > 0x0 And $icolumn >= $inumcolumns) Then Return SetError(0x6, 0x0, 0x0)
    If $IINTTYPE = $ARRAYUNIQUE_AUTO Then
        Local $bint, $svartype
        If $idims = 0x1 Then
            $bint = IsInt($AARRAY[$IBASE])
            $svartype = VarGetType($AARRAY[$IBASE])
        Else
            $bint = IsInt($AARRAY[$IBASE][$icolumn])
            $svartype = VarGetType($AARRAY[$IBASE][$icolumn])
        EndIf
        If $bint And $svartype = "Int64" Then
            $IINTTYPE = $ARRAYUNIQUE_FORCE64
        Else
            $IINTTYPE = $ARRAYUNIQUE_FORCE32
        EndIf
    EndIf
    ObjEvent("AutoIt.Error", __ArrayUnique_AutoErrFunc)
    Local $odictionary = ObjCreate("Scripting.Dictionary")
    $odictionary.CompareMode = Number(Not $ICASE)
    Local $velem, $stype, $vkey, $bcomerror = False
    For $i = $IBASE To UBound($AARRAY) + -1
        If $idims = 0x1 Then
            $velem = $AARRAY[$i]
        Else
            $velem = $AARRAY[$i][$icolumn]
        EndIf
        Switch $IINTTYPE
        Case $ARRAYUNIQUE_FORCE32
            $odictionary.Item($velem)
            If @error Then
                $bcomerror = True
                ExitLoop
            EndIf
        Case $ARRAYUNIQUE_FORCE64
            $stype = VarGetType($velem)
            If $stype = "Int32" Then
                $bcomerror = True
                ExitLoop
            EndIf
            $vkey = "#" & $stype & "#" & String($velem)
            If Not $odictionary.Item($vkey) Then
                $odictionary($vkey) = $velem
            EndIf
        Case $ARRAYUNIQUE_MATCH
            $stype = VarGetType($velem)
            If StringLeft($stype, 0x3) = "Int" Then
                $vkey = "#Int#" & String($velem)
            Else
                $vkey = "#" & $stype & "#" & String($velem)
            EndIf
            If Not $odictionary.Item($vkey) Then
                $odictionary($vkey) = $velem
            EndIf
        Case $ARRAYUNIQUE_DISTINCT
            $vkey = "#" & VarGetType($velem) & "#" & String($velem)
            If Not $odictionary.Item($vkey) Then
                $odictionary($vkey) = $velem
            EndIf
        EndSwitch
    Next
    Local $avalues, $j = 0x0
    If $bcomerror Then
        Return SetError(0x7, 0x0, 0x0)
    ElseIf $IINTTYPE <> $ARRAYUNIQUE_FORCE32 Then
        Local $avalues[$odictionary.Count]
        For $vkey In $odictionary.Keys()
            $avalues[$j] = $odictionary($vkey)
            If StringLeft($vkey, 0x5) = "#Ptr#" Then
                $avalues[$j] = Ptr($avalues[$j])
            EndIf
            $j += 0x1
        Next
    Else
        $avalues = $odictionary.Keys()
    EndIf
    If $icount Then
        _ArrayInsert($avalues, 0x0, $odictionary.Count)
    EndIf
    Return $avalues
EndFunc    ; -> _ArrayUnique

Func _Array1DToHistogram($AARRAY, $isizing = 0x64)
    If UBound($AARRAY, 0x0) > 0x1 Then Return SetError(0x1, 0x0, '')
    $isizing = $isizing * 0x8
    Local $t, $n, $imin = 0x0, $imax = 0x0, $ioffset = 0x0
    For $i = 0x0 To UBound($AARRAY) + -1
        $t = $AARRAY[$i]
        $t = IsNumber($t) ? Round($t) : 0x0
        If $t < $imin Then $imin = $t
        If $t > $imax Then $imax = $t
    Next
    Local $irange = Int(Round(($imax - $imin) / 0x8)) * 0x8
    Local $ispaceratio = 0x4
    For $i = 0x0 To UBound($AARRAY) + -1
        $t = $AARRAY[$i]
        If $t Then
            $n = Abs(Round(($isizing * $t) / $irange) / 0x8)
            $AARRAY[$i] = ''
            If $t > 0x0 Then
                If $imin Then
                    $ioffset = Int(Abs(Round(($isizing * $imin) / $irange) / 0x8) / 0x8 * $ispaceratio)
                    $AARRAY[$i] = __Array_StringRepeat(ChrW(0x20), $ioffset)
                EndIf
            Else
                If $imin <> $t Then
                    $ioffset = Int(Abs(Round(($isizing * ($t - $imin)) / $irange) / 0x8) / 0x8 * $ispaceratio)
                    $AARRAY[$i] = __Array_StringRepeat(ChrW(0x20), $ioffset)
                EndIf
            EndIf
            $AARRAY[$i]&= __Array_StringRepeat(ChrW(0x2588), Int($n / 0x8))
            $n = Mod($n, 0x8)
            If $n > 0x0 Then $AARRAY[$i]&= ChrW(0x2588 + 0x8 - $n)
            $AARRAY[$i]&= " " & $t
        Else
            $AARRAY[$i] = ''
        EndIf
    Next
    Return $AARRAY
EndFunc    ; -> _Array1DToHistogram

Func _array2dcreate($acol0, $acol1)
    If (UBound($acol0, 0x0) <> 0x1) Or (UBound($acol1, 0x0) <> 0x1) Then Return SetError(0x1, 0x0, '')
    Local $nrows = UBound($acol0)
    If $nrows <> UBound($acol1) Then Return SetError(0x2, 0x0, '')
    Local $atmp[$nrows][0x2]
    For $i = 0x0 To $nrows + -1
        $atmp[$i][0x0] = $acol0[$i]
        $atmp[$i][0x1] = $acol1[$i]
    Next
    Return $atmp
EndFunc    ; -> _array2dcreate

Func __Array_StringRepeat($sstring, $irepeatcount)
    $irepeatcount = Int($irepeatcount)
    If StringLen($sstring) < 0x1 Or $irepeatcount <= 0x0 Then Return SetError(0x1, 0x0, '')
    Local $sresult = ''
    While $irepeatcount > 0x1
        If BitAND($irepeatcount, 0x1) Then $sresult &= $sstring
        $sstring &= $sstring
        $irepeatcount = BitShift($irepeatcount, 0x1)
    WEnd
    Return $sstring & $sresult
EndFunc    ; -> __Array_StringRepeat

Func __Array_ExeterInternal(ByRef $AARRAY, $istart, $isize, $SDELIMITER, ByRef $aidx, ByRef $aresult, ByRef $icount)
    If $istart == $isize + -1 Then
        For $i = 0x0 To $isize + -1
            $aresult[$icount]&= $AARRAY[$aidx[$i]] & $SDELIMITER
        Next
        If $SDELIMITER <> '' Then $aresult[$icount] = StringTrimRight($aresult[$icount], StringLen($SDELIMITER))
        $icount += 0x1
    Else
        Local $itemp
        For $i = $istart To $isize + -1
            $itemp = $aidx[$i]
            $aidx[$i] = $aidx[$istart]
            $aidx[$istart] = $itemp
            __Array_ExeterInternal($AARRAY, $istart + 0x1, $isize, $SDELIMITER, $aidx, $aresult, $icount)
            $aidx[$istart] = $aidx[$i]
            $aidx[$i] = $itemp
        Next
    EndIf
EndFunc    ; -> __Array_ExeterInternal

Func __Array_Combinations($in, $ir)
    Local $i_total = 0x1
    For $i = $ir To 0x1 Step + -1
        $i_total *= ($in / $i)
        $in -= 0x1
    Next
    Return Round($i_total)
EndFunc    ; -> __Array_Combinations

Func __Array_GetNext($in, $ir, ByRef $ileft, $itotal, ByRef $aidx)
    If $ileft == $itotal Then
        $ileft -= 0x1
        Return
    EndIf
    Local $i = $ir + -1
    While $aidx[$i] == $in - $ir + $i
        $i -= 0x1
    WEnd
    $aidx[$i]+= 0x1
    For $j = $i + 0x1 To $ir + -1
        $aidx[$j] = $aidx[$i] + $j - $i
    Next
    $ileft -= 0x1
EndFunc    ; -> __Array_GetNext

Func __Array_MinMaxIndex(Const ByRef $AARRAY, $ICOMPNUMERIC, $istart, $IEND, $isubitem, $FUCOMPARISON)
    If $ICOMPNUMERIC = Default Then $ICOMPNUMERIC = 0x0
    If $ICOMPNUMERIC <> 0x1 Then $ICOMPNUMERIC = 0x0
    If $istart = Default Then $istart = 0x0
    If $IEND = Default Then $IEND = 0x0
    If $isubitem = Default Then $isubitem = 0x0
    If Not IsArray($AARRAY) Then Return SetError(0x1, 0x0, + -1)
    Local $idim_1 = UBound($AARRAY, $UBOUND_ROWS) + -1
    If $idim_1 < 0x0 Then Return SetError(0x1, 0x0, + -1)
    If $IEND = + -1 Then $IEND = $idim_1
    If $istart = + -1 Then $istart = 0x0
    If $istart < + -1 Or $IEND < + -1 Then Return SetError(0x3, 0x0, + -1)
    If $istart > $idim_1 Or $IEND > $idim_1 Then Return SetError(0x3, 0x0, + -1)
    If $istart > $IEND Then Return SetError(0x4, 0x0, + -1)
    If $idim_1 < 0x0 Then Return SetError(0x5, 0x0, + -1)
    Local $imaxminindex = $istart
    Switch UBound($AARRAY, $UBOUND_DIMENSIONS)
    Case 0x1
        If $ICOMPNUMERIC Then
            For $i = $istart To $IEND
                If $FUCOMPARISON(Number($AARRAY[$i]), Number($AARRAY[$imaxminindex])) Then $imaxminindex = $i
            Next
        Else
            For $i = $istart To $IEND
                If $FUCOMPARISON($AARRAY[$i], $AARRAY[$imaxminindex]) Then $imaxminindex = $i
            Next
        EndIf
    Case 0x2
        If $isubitem < 0x0 Or $isubitem > UBound($AARRAY, $UBOUND_COLUMNS) + -1 Then Return SetError(0x6, 0x0, + -1)
        If $ICOMPNUMERIC Then
            For $i = $istart To $IEND
                If $FUCOMPARISON(Number($AARRAY[$i][$isubitem]), Number($AARRAY[$imaxminindex][$isubitem])) Then $imaxminindex = $i
            Next
        Else
            For $i = $istart To $IEND
                If $FUCOMPARISON($AARRAY[$i][$isubitem], $AARRAY[$imaxminindex][$isubitem]) Then $imaxminindex = $i
            Next
        EndIf
    Case Else
        Return SetError(0x2, 0x0, + -1)
    EndSwitch
    Return $imaxminindex
EndFunc    ; -> __Array_MinMaxIndex

Func __Array_GreaterThan($vvalue1, $vvalue2)
    Return $vvalue1 > $vvalue2
EndFunc    ; -> __Array_GreaterThan

Func __Array_LessThan($vvalue1, $vvalue2)
    Return $vvalue1 < $vvalue2
EndFunc    ; -> __Array_LessThan

Func __ArrayUnique_AutoErrFunc()
EndFunc    ; -> __ArrayUnique_AutoErrFunc

Global Const $EXITFATALCODES[0x51][0x2] = [[0x7ffff068, """EndWith"" missing ""With""."], [0x7ffff069, "Badly formatted ""Func"" statement."], [0x7ffff06a, """With"" missing ""EndWith""."], [0x7ffff06b, "Missing right bracket ')' in expression."], [0x7ffff06c, "Missing operator in expression."], [0x7ffff06d, "Unbalanced brackets in expression."], [0x7ffff06e, "Error in expression."], [0x7ffff06f, "Error parsing function call."], [0x7ffff070, "Incorrect number of parameters in function call."], [0x7ffff071, """ReDim"" used without an array variable."], [0x7ffff072, "Illegal text at the end of statement (one statement per line)."], [0x7ffff073, """If"" statement has no matching ""EndIf"" statement."], [0x7ffff074, """Else"" statement with no matching ""If"" statement."], [0x7ffff075, """EndIf"" statement with no matching ""If"" statement."], [0x7ffff076, "Too many ""Else"" statements for matching ""If"" statement."], [0x7ffff077, """While"" statement has no matching ""WEnd"" statement."], [0x7ffff078, """WEnd"" statement with no matching ""While"" statement."], [0x7ffff079, "Variable used without being declared."], [0x7ffff07a, "Array variable has incorrect number of subscripts or subscript dimension range exceeded."], [0x7ffff07b, "Variable subscript badly formatted."], [0x7ffff07c, "Subscript used on non-accessible variable."], [0x7ffff07d, "Too many subscripts used for an array."], [0x7ffff07e, "Missing subscript dimensions in ""Dim"" statement."], [0x7ffff07f, "No variable given for ""Dim"", ""Local"", ""Global"", ""Static"" or ""Const"" statement."], [0x7ffff080, "Expected a ""="" operator in assignment statement."], [0x7ffff081, "Invalid keyword at the start of this line."], [0x7ffff082, "Array maximum size exceeded."], [0x7ffff083, """Func"" statement has no matching ""EndFunc""."], [0x7ffff084, "Duplicate function name."], [0x7ffff085, "Unknown function name."], [0x7ffff086, "Unknown macro."], [0x7ffff088, "Unable to get a list of running processes."], [0x7ffff08a, "Invalid element in a DllStruct."], [0x7ffff08b, "Unknown option or bad parameter specified."], [0x7ffff08c, "Unable to load the internet libraries."], [0x7ffff08d, """Struct"" statement has no matching ""EndStruct""."], [0x7ffff08e, "Unable to open file, the maximum number of open files has been exceeded."], [0x7ffff08f, """ContinueLoop"" statement with no matching ""While"", ""Do"" or ""For"" statement."], [0x7ffff090, "Invalid file filter given."], [0x7ffff091, "Expected a variable in user function call."], [0x7ffff092, """Do"" statement has no matching ""Until"" statement."], [0x7ffff093, """Until"" statement with no matching ""Do"" statement."], [0x7ffff094, """For"" statement is badly formatted."], [0x7ffff095, """Next"" statement with no matching ""For"" statement."], [0x7ffff096, """ExitLoop/ContinueLoop"" statements only valid from inside a For/Do/While loop."], [0x7ffff097, """For"" statement has no matching ""Next"" statement."], [0x7ffff098, """Case"" statement with no matching ""Select"" or ""Switch"" statement."], [0x7ffff099, """EndSelect"" statement with no matching ""Select"" statement."], [0x7ffff09a, "Recursion level has been exceeded - AutoIt will quit to prevent stack overflow."], [0x7ffff09b, "Cannot make existing variables static."], [0x7ffff09c, "Cannot make static variables into regular variables."], [0x7ffff09d, "Badly formated Enum statement"], [0x7ffff09f, "This keyword cannot be used after a ""Then"" keyword."], [0x7ffff0a0, """Select"" statement is missing ""EndSelect"" or ""Case"" statement."], [0x7ffff0a1, """If"" statements must have a ""Then"" keyword."], [0x7ffff0a2, "Badly formated Struct statement."], [0x7ffff0a3, "Cannot assign values to constants."], [0x7ffff0a4, "Cannot make existing variables into constants."], [0x7ffff0a5, "Only Object-type variables allowed in a ""With"" statement."], [0x7ffff0a6, """long_ptr"", ""int_ptr"" and ""short_ptr"" DllCall() types have been deprecated.  Use ""long*"", ""int*"" and ""short*"" instead."], [0x7ffff0a7, "Object referenced outside a ""With"" statement."], [0x7ffff0a8, "Nested ""With"" statements are not allowed."], [0x7ffff0a9, "Variable must be of type ""Object""."], [0x7ffff0aa, "The requested action with this object has failed."], [0x7ffff0ab, "Variable appears more than once in function declaration."], [0x7ffff0ac, "ReDim array can not be initialized in this manner."], [0x7ffff0ad, "An array variable can not be used in this manner."], [0x7ffff0ae, "Can not redeclare a constant."], [0x7ffff0af, "Can not redeclare a parameter inside a user function."], [0x7ffff0b0, "Can pass constants by reference only to parameters with ""Const"" keyword."], [0x7ffff0b1, "Can not initialize a variable with itself."], [0x7ffff0b2, "Incorrect way to use this parameter."], [0x7ffff0b3, """EndSwitch"" statement with no matching ""Switch"" statement."], [0x7ffff0b4, """Switch"" statement is missing ""EndSwitch"" or ""Case"" statement."], [0x7ffff0b5, """ContinueCase"" statement with no matching ""Select"" or ""Switch"" statement."], [0x7ffff0b6, "Assert Failed!"], [0x7ffff0b8, "Obsolete function/parameter."], [0x7ffff0b9, "Invalid Exitcode (reserved for AutoIt internal use)."], [0x7ffff0ba, "Variable cannot be accessed in this manner."], [0x7ffff0bb, "Func reassign not allowed."], [0x7ffff0bc, "Func reassign on global level not allowed."]]
Global Const $EXITCODES[0x5][0x2] = [[$EXITCLOSE_NORMAL, "Natural closing."], [$EXITCLOSE_BYEXIT, "close by Exit function."], [$EXITCLOSE_BYCLICK, "close by clicking on exit of the systray."], [$EXITCLOSE_BYLOGOFF, "close by user logoff."], [$EXITCLOSE_BYSHUTDOWN, "close by Windows shutdown."]]
Func _formatautoitexitcode()
    For $i = 0x0 To UBound($EXITFATALCODES) + -1
        If @exitCode = $EXITFATALCODES[$i][0x0] Then Return $EXITFATALCODES[$i][0x1]
    Next
    Return "0x" & Hex(@exitCode)
EndFunc    ; -> _formatautoitexitcode

Func _formatautoitexitmethod()
    For $i = 0x0 To UBound($EXITCODES) + -1
        If @exitMethod = $EXITCODES[$i][0x0] Then Return $EXITCODES[$i][0x1]
    Next
    Return "0x" & Hex(@exitCode)
EndFunc    ; -> _formatautoitexitmethod

#Region Global Variables and Constants
    Global Const $FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x100
    Global Const $FORMAT_MESSAGE_IGNORE_INSERTS = 0x200
    Global Const $FORMAT_MESSAGE_FROM_STRING = 0x400
    Global Const $FORMAT_MESSAGE_FROM_HMODULE = 0x800
    Global Const $FORMAT_MESSAGE_FROM_SYSTEM = 0x1000
    Global Const $FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x2000
#EndRegion Global Variables and Constants
Func _WinAPI_Beep($ifreq = 0x1f4, $iduration = 0x3e8)
    Local $acall = DllCall("kernel32.dll", "bool", "Beep", "dword", $ifreq, "dword", $iduration)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _WinAPI_Beep

Func _WinAPI_FormatMessage($IFLAGS, $psource, $imessageid, $ilanguageid, ByRef $pbuffer, $isize, $varguments)
    Local $sbuffertype = "struct*"
    If IsString($pbuffer) Then $sbuffertype = "wstr"
    Local $acall = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", $IFLAGS, "struct*", $psource, "dword", $imessageid, "dword", $ilanguageid, $sbuffertype, $pbuffer, "dword", $isize, "ptr", $varguments)
    If @error Then Return SetError(@error, @extended, 0x0)
    If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
    If $sbuffertype = "wstr" Then $pbuffer = $acall[0x5]
    Return $acall[0x0]
EndFunc    ; -> _WinAPI_FormatMessage

Func _WinAPI_GetErrorMessage($icode, $ilanguage = 0x0, Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    Local $acall = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", BitOR($FORMAT_MESSAGE_FROM_SYSTEM, $FORMAT_MESSAGE_IGNORE_INSERTS), "ptr", 0x0, "dword", $icode, "dword", $ilanguage, "wstr", '', "dword", 0x1000, "ptr", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, StringRegExpReplace($acall[0x5], "[" & @LF & "," & @CR & "]*\\Z", ''))
EndFunc    ; -> _WinAPI_GetErrorMessage

Func _WinAPI_GetLastError(Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    Local $acall = DllCall("kernel32.dll", "dword", "GetLastError")
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, $acall[0x0])
EndFunc    ; -> _WinAPI_GetLastError

Func _WinAPI_GetLastErrorMessage(Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    Local $ilasterror = _WinAPI_GetLastError()
    Local $tbufferptr = DllStructCreate("ptr")
    Local $ncount = _WinAPI_FormatMessage(BitOR($FORMAT_MESSAGE_ALLOCATE_BUFFER, $FORMAT_MESSAGE_FROM_SYSTEM, $FORMAT_MESSAGE_IGNORE_INSERTS), 0x0, $ilasterror, 0x0, $tbufferptr, 0x0, 0x0)
    If @error Then Return SetError(- @error, @extended, '')
    Local $stext = ''
    Local $pbuffer = DllStructGetData($tbufferptr, 0x1)
    If $pbuffer Then
        If $ncount > 0x0 Then
            Local $tbuffer = DllStructCreate("wchar[" & ($ncount + 0x1) & "]", $pbuffer)
            $stext = DllStructGetData($tbuffer, 0x1)
            If StringRight($stext, 0x2) = @CRLF Then $stext = StringTrimRight($stext, 0x2)
        EndIf
        DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pbuffer)
    EndIf
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, $stext)
EndFunc    ; -> _WinAPI_GetLastErrorMessage

Func _WinAPI_MessageBeep($itype = 0x1)
    Local $isound
    Switch $itype
    Case 0x1
        $isound = 0x0
    Case 0x2
        $isound = 0x10
    Case 0x3
        $isound = 0x20
    Case 0x4
        $isound = 0x30
    Case 0x5
        $isound = 0x40
    Case Else
        $isound = + -1
    EndSwitch
    Local $acall = DllCall("user32.dll", "bool", "MessageBeep", "uint", $isound)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _WinAPI_MessageBeep

Func _WinAPI_MsgBox($IFLAGS, $STITLE, $stext)
    BlockInput(0x0)
    MsgBox($IFLAGS, $STITLE, $stext & "      ")
EndFunc    ; -> _WinAPI_MsgBox

Func _WinAPI_SetLastError($ierrorcode, Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    DllCall("kernel32.dll", "none", "SetLastError", "dword", $ierrorcode)
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, Null)
EndFunc    ; -> _WinAPI_SetLastError

Func _WinAPI_ShowError($stext, $bexit = True)
    BlockInput(0x0)
    MsgBox($MB_SYSTEMMODAL, "Error", $stext & "      ")
    If $bexit Then Exit
EndFunc    ; -> _WinAPI_ShowError

Func _WinAPI_ShowLastError($stext = '', $babort = False, $ilanguage = 0x0, Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    Local $serror
    Local $ilasterror = _WinAPI_GetLastError()
    While 0x1
        $serror = _WinAPI_GetErrorMessage($ilasterror, $ilanguage)
        If @error And $ilanguage Then
            $ilanguage = 0x0
        Else
            ExitLoop
        EndIf
    WEnd
    If StringStripWS($stext, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
        $stext &= @CRLF & @CRLF
    Else
        $stext = ''
    EndIf
    _WinAPI_MsgBox(BitOR(0x40000, BitShift(0x10, + -2 * (Not $ilasterror))), $ilasterror, $stext & $serror)
    If $ilasterror Then
        _WinAPI_SetLastError($ilasterror)
        If $babort Then
            Exit $ilasterror
        EndIf
    EndIf
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, 0x1)
EndFunc    ; -> _WinAPI_ShowLastError

Func _WinAPI_ShowMsg($stext)
    _WinAPI_MsgBox($MB_SYSTEMMODAL, "Information", $stext)
EndFunc    ; -> _WinAPI_ShowMsg

Func __COMErrorFormating(ByRef $ocomerror, $sprefix = @TAB)
    Local Const $STR_STRIPTRAILING = 0x2
    Local $serror = "COM Error encountered in " & @ScriptName & " (" & $ocomerror.Scriptline & ") :" & @CRLF & $sprefix & "Number        " & @TAB & "= 0x" & Hex($ocomerror.Number, 0x8) & " (" & $ocomerror.Number & ")" & @CRLF & $sprefix & "WinDescription" & @TAB & "= " & StringStripWS($ocomerror.WinDescription, $STR_STRIPTRAILING) & @CRLF & $sprefix & "Description   " & @TAB & "= " & StringStripWS($ocomerror.Description, $STR_STRIPTRAILING) & @CRLF & $sprefix & "Source        " & @TAB & "= " & $ocomerror.Source & @CRLF & $sprefix & "HelpFile      " & @TAB & "= " & $ocomerror.HelpFile & @CRLF & $sprefix & "HelpContext   " & @TAB & "= " & $ocomerror.HelpContext & @CRLF & $sprefix & "LastDllError  " & @TAB & "= " & $ocomerror.LastDllError & @CRLF & $sprefix & "Retcode       " & @TAB & "= 0x" & Hex($ocomerror.retcode)
    Return $serror
EndFunc    ; -> __COMErrorFormating

#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _Security__AdjustTokenPrivileges($htoken, $bdisableall, $tnewstate, $ibufferlen, $tprevstate = 0x0, $prequired = 0x0)
        Local $acall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $htoken, "bool", $bdisableall, "struct*", $tnewstate, "dword", $ibufferlen, "struct*", $tprevstate, "struct*", $prequired)
        If @error Then Return SetError(@error, @extended, False)
        Return Not ($acall[0x0] = 0x0)
    EndFunc    ; -> _Security__AdjustTokenPrivileges

    Func _Security__CreateProcessWithToken($htoken, $ilogonflags, $scommandline, $icreationflags, $scurdir, $tstartupinfo, $tprocess_information)
        Local $acall = DllCall("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $htoken, "dword", $ilogonflags, "ptr", 0x0, "wstr", $scommandline, "dword", $icreationflags, "struct*", 0x0, "wstr", $scurdir, "struct*", $tstartupinfo, "struct*", $tprocess_information)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
        Return True
    EndFunc    ; -> _Security__CreateProcessWithToken

    Func _Security__DuplicateTokenEx($hexistingtoken, $idesiredaccess, $iimpersonationlevel, $itokentype)
        Local $acall = DllCall("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $hexistingtoken, "dword", $idesiredaccess, "struct*", 0x0, "int", $iimpersonationlevel, "int", $itokentype, "handle*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x6]
    EndFunc    ; -> _Security__DuplicateTokenEx

    Func _Security__GetAccountSid($saccount, $ssystem = '')
        Local $aacct = _Security__LookupAccountName($saccount, $ssystem)
        If @error Then Return SetError(@error, @extended, 0x0)
        If IsArray($aacct) Then Return _Security__StringSidToSid($aacct[0x0])
        Return ''
    EndFunc    ; -> _Security__GetAccountSid

    Func _Security__GetLengthSid($psid)
        If Not _Security__IsValidSid($psid) Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $acall = DllCall("advapi32.dll", "dword", "GetLengthSid", "struct*", $psid)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _Security__GetLengthSid

    Func _Security__GetTokenInformation($htoken, $iclass)
        Local $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "int", $iclass, "struct*", 0x0, "dword", 0x0, "dword*", 0x0)
        If @error Or Not $acall[0x5] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $ilen = $acall[0x5]
        Local $tbuffer = DllStructCreate("byte[" & $ilen & "]")
        $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "int", $iclass, "struct*", $tbuffer, "dword", DllStructGetSize($tbuffer), "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tbuffer
    EndFunc    ; -> _Security__GetTokenInformation

    Func _Security__ImpersonateSelf($ilevel = $SECURITYIMPERSONATION)
        Local $acall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $ilevel)
        If @error Then Return SetError(@error, @extended, False)
        Return Not ($acall[0x0] = 0x0)
    EndFunc    ; -> _Security__ImpersonateSelf

    Func _Security__IsValidSid($psid)
        Local $acall = DllCall("advapi32.dll", "bool", "IsValidSid", "struct*", $psid)
        If @error Then Return SetError(@error, @extended, False)
        Return Not ($acall[0x0] = 0x0)
    EndFunc    ; -> _Security__IsValidSid

    Func _Security__LookupAccountName($saccount, $ssystem = '')
        Local $tdata = DllStructCreate("byte SID[256]")
        Local $acall = DllCall("advapi32.dll", "bool", "LookupAccountNameW", "wstr", $ssystem, "wstr", $saccount, "struct*", $tdata, "dword*", DllStructGetSize($tdata), "wstr", '', "dword*", DllStructGetSize($tdata), "int*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aacct[0x3]
        $aacct[0x0] = _Security__SidToStringSid(DllStructGetPtr($tdata, "SID"))
        $aacct[0x1] = $acall[0x5]
        $aacct[0x2] = $acall[0x7]
        Return $aacct
    EndFunc    ; -> _Security__LookupAccountName

    Func _Security__LookupAccountSid($vsid, $ssystem = '')
        Local $psid, $aacct[0x3]
        If IsString($vsid) Then
            $psid = _Security__StringSidToSid($vsid)
        Else
            $psid = $vsid
        EndIf
        If Not _Security__IsValidSid($psid) Then Return SetError(@error + 0x14, @extended, 0x0)
        If $ssystem = '' Then $ssystem = Null
        Local $acall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", "wstr", $ssystem, "struct*", $psid, "wstr", '', "dword*", 0x10000, "wstr", '', "dword*", 0x10000, "int*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aacct[0x3]
        $aacct[0x0] = $acall[0x3]
        $aacct[0x1] = $acall[0x5]
        $aacct[0x2] = $acall[0x7]
        Return $aacct
    EndFunc    ; -> _Security__LookupAccountSid

    Func _Security__LookupPrivilegeValue($ssystem, $sname)
        Local $acall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $ssystem, "wstr", $sname, "int64*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _Security__LookupPrivilegeValue

    Func _Security__OpenProcessToken($hprocess, $iaccess)
        Local $acall = DllCall("advapi32.dll", "bool", "OpenProcessToken", "handle", $hprocess, "dword", $iaccess, "handle*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _Security__OpenProcessToken

    Func _Security__OpenThreadToken($iaccess, $hthread = 0x0, $bopenasself = False)
        Local $acall
        If $hthread = 0x0 Then
            $acall = DllCall("kernel32.dll", "handle", "GetCurrentThread")
            If @error Then Return SetError(@error + 0x14, @extended, 0x0)
            $hthread = $acall[0x0]
        EndIf
        $acall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hthread, "dword", $iaccess, "bool", $bopenasself, "handle*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x4]
    EndFunc    ; -> _Security__OpenThreadToken

    Func _Security__OpenThreadTokenEx($iaccess, $hthread = 0x0, $bopenasself = False)
        Local $htoken = _Security__OpenThreadToken($iaccess, $hthread, $bopenasself)
        If $htoken = 0x0 Then
            Local Const $ERROR_NO_TOKEN = 0x3f0
            If _WinAPI_GetLastError() <> $ERROR_NO_TOKEN Then Return SetError(0x14, _WinAPI_GetLastError(), 0x0)
            If Not _Security__ImpersonateSelf() Then Return SetError(@error + 0xa, _WinAPI_GetLastError(), 0x0)
            $htoken = _Security__OpenThreadToken($iaccess, $hthread, $bopenasself)
            If $htoken = 0x0 Then Return SetError(@error, _WinAPI_GetLastError(), 0x0)
        EndIf
        Return $htoken
    EndFunc    ; -> _Security__OpenThreadTokenEx

    Func _Security__SetPrivilege($htoken, $sprivilege, $benable)
        Local $iluid = _Security__LookupPrivilegeValue('', $sprivilege)
        If $iluid = 0x0 Then Return SetError(@error + 0xa, @extended, False)
        Local Const $TAGTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
        Local $tcurrstate = DllStructCreate($TAGTOKEN_PRIVILEGES)
        Local $icurrstate = DllStructGetSize($tcurrstate)
        Local $tprevstate = DllStructCreate($TAGTOKEN_PRIVILEGES)
        Local $iprevstate = DllStructGetSize($tprevstate)
        Local $trequired = DllStructCreate("int Data")
        DllStructSetData($tcurrstate, "Count", 0x1)
        DllStructSetData($tcurrstate, "LUID", $iluid)
        If Not _Security__AdjustTokenPrivileges($htoken, False, $tcurrstate, $icurrstate, $tprevstate, $trequired) Then Return SetError(0x2, @error, False)
        DllStructSetData($tprevstate, "Count", 0x1)
        DllStructSetData($tprevstate, "LUID", $iluid)
        Local $iattributes = DllStructGetData($tprevstate, "Attributes")
        If $benable Then
            $iattributes = BitOR($iattributes, $SE_PRIVILEGE_ENABLED)
        Else
            $iattributes = BitAND($iattributes, BitNOT($SE_PRIVILEGE_ENABLED))
        EndIf
        DllStructSetData($tprevstate, "Attributes", $iattributes)
        If Not _Security__AdjustTokenPrivileges($htoken, False, $tprevstate, $iprevstate, $tcurrstate, $trequired) Then Return SetError(0x3, @error, False)
        Return True
    EndFunc    ; -> _Security__SetPrivilege

    Func _Security__SetTokenInformation($htoken, $itokeninformation, $vtokeninformation, $itokeninformationlength)
        Local $acall = DllCall("advapi32.dll", "bool", "SetTokenInformation", "handle", $htoken, "int", $itokeninformation, "struct*", $vtokeninformation, "dword", $itokeninformationlength)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
        Return True
    EndFunc    ; -> _Security__SetTokenInformation

    Func _Security__SidToStringSid($psid)
        If Not _Security__IsValidSid($psid) Then Return SetError(@error + 0xa, 0x0, '')
        Local $acall = DllCall("advapi32.dll", "bool", "ConvertSidToStringSidW", "struct*", $psid, "ptr*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Local $pstringsid = $acall[0x2]
        Local $alen = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $pstringsid)
        Local $ssid = DllStructGetData(DllStructCreate("wchar Text[" & $alen[0x0] + 0x1 & "]", $pstringsid), "Text")
        DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pstringsid)
        Return $ssid
    EndFunc    ; -> _Security__SidToStringSid

    Func _Security__SidTypeStr($itype)
        Switch $itype
        Case $SIDTYPEUSER
            Return "User"
        Case $SIDTYPEGROUP
            Return "Group"
        Case $SIDTYPEDOMAIN
            Return "Domain"
        Case $SIDTYPEALIAS
            Return "Alias"
        Case $SIDTYPEWELLKNOWNGROUP
            Return "Well Known Group"
        Case $SIDTYPEDELETEDACCOUNT
            Return "Deleted Account"
        Case $SIDTYPEINVALID
            Return "Invalid"
        Case $SIDTYPEUNKNOWN
            Return "Unknown Type"
        Case $SIDTYPECOMPUTER
            Return "Computer"
        Case $SIDTYPELABEL
            Return "A mandatory integrity label SID"
        Case Else
            Return "Unknown SID Type"
        EndSwitch
    EndFunc    ; -> _Security__SidTypeStr

    Func _Security__StringSidToSid($ssid)
        Local $acall = DllCall("advapi32.dll", "bool", "ConvertStringSidToSidW", "wstr", $ssid, "ptr*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $psid = $acall[0x2]
        Local $tbuffer = DllStructCreate("byte Data[" & _Security__GetLengthSid($psid) & "]", $psid)
        Local $tsid = DllStructCreate("byte Data[" & DllStructGetSize($tbuffer) & "]")
        DllStructSetData($tsid, "Data", DllStructGetData($tbuffer, "Data"))
        DllCall("kernel32.dll", "handle", "LocalFree", "handle", $psid)
        Return $tsid
    EndFunc    ; -> _Security__StringSidToSid

#EndRegion Public Functions
Global Const $TAGPOINT = "struct;long X;long Y;endstruct"
Global Const $TAGRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $TAGSIZE = "struct;long X;long Y;endstruct"
Global Const $TAGMARGINS = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
Global Const $TAGFILETIME = "struct;dword Lo;dword Hi;endstruct"
Global Const $TAGSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $TAGTIME_ZONE_INFORMATION = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
Global Const $tagnmhdr = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Global Const $TAGCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
Global Const $TAGNMCBEDRAGBEGIN = $tagnmhdr & ";int ItemID;wchar szText[260]"
Global Const $TAGNMCBEENDEDIT = $tagnmhdr & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
Global Const $TAGNMCOMBOBOXEX = $tagnmhdr & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" & "int SelectedImage;int OverlayImage;int Indent;lparam Param"
Global Const $TAGDTPRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" & "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" & "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
Global Const $TAGNMDATETIMECHANGE = $tagnmhdr & ";dword Flag;" & $TAGSYSTEMTIME
Global Const $TAGNMDATETIMEFORMAT = $tagnmhdr & ";ptr Format;" & $TAGSYSTEMTIME & ";ptr pDisplay;wchar Display[64]"
Global Const $TAGNMDATETIMEFORMATQUERY = $tagnmhdr & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
Global Const $TAGNMDATETIMEKEYDOWN = $tagnmhdr & ";int VirtKey;ptr Format;" & $TAGSYSTEMTIME
Global Const $TAGNMDATETIMESTRING = $tagnmhdr & ";ptr UserString;" & $TAGSYSTEMTIME & ";dword Flags"
Global Const $TAGEVENTLOGRECORD = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" & "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" & "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $TAGGDIP_EFFECTPARAMS_BLUR = "float Radius; bool ExpandEdge"
Global Const $TAGGDIP_EFFECTPARAMS_BRIGHTNESSCONTRAST = "int BrightnessLevel; int ContrastLevel"
Global Const $TAGGDIP_EFFECTPARAMS_COLORBALANCE = "int CyanRed; int MagentaGreen; int YellowBlue"
Global Const $TAGGDIP_EFFECTPARAMS_COLORCURVE = "int Adjustment; int Channel; int AdjustValue"
Global Const $TAGGDIP_EFFECTPARAMS_COLORLUT = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
Global Const $TAGGDIP_EFFECTPARAMS_HUESATURATIONLIGHTNESS = "int HueLevel; int SaturationLevel; int LightnessLevel"
Global Const $TAGGDIP_EFFECTPARAMS_LEVELS = "int Highlight; int Midtone; int Shadow"
Global Const $TAGGDIP_EFFECTPARAMS_REDEYECORRECTION = "uint NumberOfAreas; ptr Areas"
Global Const $TAGGDIP_EFFECTPARAMS_SHARPEN = "float Radius; float Amount"
Global Const $TAGGDIP_EFFECTPARAMS_TINT = "int Hue; int Amount"
Global Const $TAGGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $TAGGDIPCOLORMATRIX = "float m[25]"
Global Const $TAGGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $TAGGDIPENCODERPARAMS = "uint Count;" & $TAGGDIPENCODERPARAM
Global Const $TAGGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $TAGGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $TAGGDIPSTARTUPOUTPUT = "ptr HookProc;ptr UnhookProc"
Global Const $TAGGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $TAGGDIPPENCODERPARAMS = "uint Count;byte Params[1]"
Global Const $TAGHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $TAGNMHDDISPINFO = $tagnmhdr & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
Global Const $TAGNMHDFILTERBTNCLICK = $tagnmhdr & ";int Item;" & $TAGRECT
Global Const $TAGNMHEADER = $tagnmhdr & ";int Item;int Button;ptr pItem"
Global Const $TAGGETIPADDRESS = "byte Field4;byte Field3;byte Field2;byte Field1"
Global Const $TAGNMIPADDRESS = $tagnmhdr & ";int Field;int Value"
Global Const $TAGLVFINDINFO = "struct;uint Flags;ptr Text;lparam Param;" & $TAGPOINT & ";uint Direction;endstruct"
Global Const $TAGLVHITTESTINFO = $TAGPOINT & ";uint Flags;int Item;int SubItem;int iGroup"
Global Const $TAGLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Global Const $TAGNMLISTVIEW = $tagnmhdr & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" & "struct;long ActionX;long ActionY;endstruct;lparam Param"
Global Const $TAGNMLVCUSTOMDRAW = "struct;" & $tagnmhdr & ";dword dwDrawStage;handle hdc;" & $TAGRECT & ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" & ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" & "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
Global Const $tagnmlvdispinfo = $tagnmhdr & ";" & $TAGLVITEM
Global Const $TAGNMLVFINDITEM = $tagnmhdr & ";int Start;" & $TAGLVFINDINFO
Global Const $TAGNMLVGETINFOTIP = $tagnmhdr & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
Global Const $TAGNMITEMACTIVATE = $tagnmhdr & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" & $TAGPOINT & ";lparam lParam;uint KeyFlags"
Global Const $TAGNMLVKEYDOWN = $tagnmhdr & ";align 2;word VKey;uint Flags"
Global Const $TAGNMLVSCROLL = $tagnmhdr & ";int DX;int DY"
Global Const $TAGMCHITTESTINFO = "uint Size;" & $TAGPOINT & ";uint Hit;" & $TAGSYSTEMTIME & ";" & $TAGRECT & ";int iOffset;int iRow;int iCol"
Global Const $TAGMCMONTHRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short Span"
Global Const $TAGMCRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short MinSet;short MaxSet"
Global Const $TAGMCSELRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds"
Global Const $TAGNMDAYSTATE = $tagnmhdr & ";" & $TAGSYSTEMTIME & ";int DayState;ptr pDayState"
Global Const $TAGNMSELCHANGE = $tagnmhdr & ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" & "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
Global Const $TAGNMOBJECTNOTIFY = $tagnmhdr & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
Global Const $TAGNMTCKEYDOWN = $tagnmhdr & ";align 2;word VKey;uint Flags"
Global Const $TAGTVITEM = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" & "int Children;lparam Param;endstruct"
Global Const $TAGTVITEMEX = "struct;" & $TAGTVITEM & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
Global Const $TAGNMTREEVIEW = $tagnmhdr & ";uint Action;" & "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" & "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" & "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" & "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" & "struct;long PointX;long PointY;endstruct"
Global Const $TAGNMTVCUSTOMDRAW = "struct;" & $tagnmhdr & ";dword DrawStage;handle HDC;" & $TAGRECT & ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" & ";dword ClrText;dword ClrTextBk;int Level"
Global Const $TAGNMTVDISPINFO = $tagnmhdr & ";" & $TAGTVITEM
Global Const $TAGNMTVGETINFOTIP = $tagnmhdr & ";ptr Text;int TextMax;handle hItem;lparam lParam"
Global Const $TAGNMTVITEMCHANGE = $tagnmhdr & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
Global Const $TAGTVHITTESTINFO = $TAGPOINT & ";uint Flags;handle Item"
Global Const $TAGNMTVKEYDOWN = $tagnmhdr & ";align 2;word VKey;uint Flags"
Global Const $TAGNMMOUSE = $tagnmhdr & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $TAGPOINT & ";lparam HitInfo"
Global Const $TAGTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Global Const $TAGIMAGEINFO = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $TAGRECT
Global Const $TAGMENUINFO = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
Global Const $TAGMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $TAGREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVersion = "WIN_XP") ? ''  : ";" & $TAGRECT & ";uint uChevronState")
Global Const $TAGNMREBARAUTOBREAK = $tagnmhdr & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
Global Const $TAGNMRBAUTOSIZE = $tagnmhdr & ";bool fChanged;" & "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" & "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
Global Const $TAGNMREBAR = $tagnmhdr & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
Global Const $TAGNMREBARCHEVRON = $tagnmhdr & ";uint uBand;uint wID;lparam lParam;" & $TAGRECT & ";lparam lParamNM"
Global Const $TAGNMREBARCHILDSIZE = $tagnmhdr & ";uint uBand;uint wID;" & "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" & "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
Global Const $TAGCOLORSCHEME = "dword Size;dword BtnHighlight;dword BtnShadow"
Global Const $TAGNMTOOLBAR = $tagnmhdr & ";int iItem;" & "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" & ";int cchText;ptr pszText;" & $TAGRECT
Global Const $TAGNMTBHOTITEM = $tagnmhdr & ";int idOld;int idNew;dword dwFlags"
Global Const $TAGTBBUTTON = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
Global Const $TAGTBBUTTONINFO = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
Global Const $TAGNETRESOURCE = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
Global Const $TAGOVERLAPPED = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
Global Const $TAGOPENFILENAME = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" & "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" & "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" & "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
Global Const $TAGBITMAPINFOHEADER = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" & "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $TAGBITMAPINFO = $TAGBITMAPINFOHEADER & ";dword biRGBQuad[1]"
Global Const $TAGBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $TAGGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $TAGWINDOWPLACEMENT = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
Global Const $TAGWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $TAGSCROLLINFO = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
Global Const $TAGSCROLLBARINFO = "dword cbSize;" & $TAGRECT & ";int dxyLineButton;int xyThumbTop;" & "int xyThumbBottom;int reserved;dword rgstate[6]"
Global Const $TAGLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $TAGKBDLLHOOKSTRUCT = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
Global Const $TAGPROCESS_INFORMATION = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $TAGSTARTUPINFO = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" & "handle StdOutput;handle StdError"
Global Const $TAGSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $TAGWIN32_FIND_DATA = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword" & _
    " dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $TAGTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
#Region Functions list
#EndRegion Functions list
#Region Global Variables and Constants
    Global Const $TAGMEMMAP = "handle hProc;ulong_ptr Size;ptr Mem"
#EndRegion Global Variables and Constants
#Region Public Functions
    Func _MemFree(ByRef $tmemmap)
        Local $pmemory = DllStructGetData($tmemmap, "Mem")
        Local $hprocess = DllStructGetData($tmemmap, "hProc")
        Local $bresult = _MemVirtualFreeEx($hprocess, $pmemory, 0x0, $MEM_RELEASE)
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess)
        If @error Then Return SetError(@error, @extended, False)
        Return $bresult
    EndFunc    ; -> _MemFree

    Func _MemGlobalAlloc($ibytes, $IFLAGS = 0x0)
        Local $acall = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $IFLAGS, "ulong_ptr", $ibytes)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _MemGlobalAlloc

    Func _MemGlobalFree($hmemory)
        Local $acall = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hmemory)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _MemGlobalFree

    Func _MemGlobalLock($hmemory)
        Local $acall = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hmemory)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _MemGlobalLock

    Func _memglobalrealloc($hmemory, $ibytes, $IFLAGS = 0x0)
        Local $aresult = DllCall("kernel32.dll", "handle", "GlobalReAlloc", "handle", $hmemory, "ulong_ptr", $ibytes, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $aresult[0x0]
    EndFunc    ; -> _memglobalrealloc

    Func _MemGlobalSize($hmemory)
        Local $acall = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hmemory)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _MemGlobalSize

    Func _MemGlobalUnlock($hmemory)
        Local $acall = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hmemory)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _MemGlobalUnlock

    Func _MemInit($hwnd, $isize, ByRef $tmemmap)
        Local $acall = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "dword*", 0x0)
        If @error Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $iprocessid = $acall[0x2]
        If $iprocessid = 0x0 Then Return SetError(0x1, 0x0, 0x0)
        Local $iaccess = BitOR($PROCESS_VM_OPERATION, $PROCESS_VM_READ, $PROCESS_VM_WRITE)
        Local $hprocess = __Mem_OpenProcess($iaccess, False, $iprocessid, True)
        Local $ialloc = BitOR($MEM_RESERVE, $MEM_COMMIT)
        Local $pmemory = _MemVirtualAllocEx($hprocess, 0x0, $isize, $ialloc, $PAGE_READWRITE)
        If $pmemory = 0x0 Then Return SetError(0x2, 0x0, 0x0)
        $tmemmap = DllStructCreate($TAGMEMMAP)
        DllStructSetData($tmemmap, "hProc", $hprocess)
        DllStructSetData($tmemmap, "Size", $isize)
        DllStructSetData($tmemmap, "Mem", $pmemory)
        Return $pmemory
    EndFunc    ; -> _MemInit

    Func _MemMoveMemory($psource, $pdest, $ilength)
        DllCall("kernel32.dll", "none", "RtlMoveMemory", "struct*", $pdest, "struct*", $psource, "ulong_ptr", $ilength)
        If @error Then Return SetError(@error, @extended)
    EndFunc    ; -> _MemMoveMemory

    Func _MemRead(ByRef $tmemmap, $psrce, $pdest, $isize)
        Local $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", DllStructGetData($tmemmap, "hProc"), "ptr", $psrce, "struct*", $pdest, "ulong_ptr", $isize, "ulong_ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _MemRead

    Func _MemWrite(ByRef $tmemmap, $psrce, $pdest = 0x0, $isize = 0x0, $ssrce = "struct*")
        If $pdest = 0x0 Then $pdest = DllStructGetData($tmemmap, "Mem")
        If $isize = 0x0 Then $isize = DllStructGetData($tmemmap, "Size")
        Local $acall = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", DllStructGetData($tmemmap, "hProc"), "ptr", $pdest, $ssrce, $psrce, "ulong_ptr", $isize, "ulong_ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _MemWrite

    Func _MemVirtualAlloc($paddress, $isize, $iallocation, $iprotect)
        Local $acall = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $paddress, "ulong_ptr", $isize, "dword", $iallocation, "dword", $iprotect)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _MemVirtualAlloc

    Func _MemVirtualAllocEx($hprocess, $paddress, $isize, $iallocation, $iprotect)
        Local $acall = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $hprocess, "ptr", $paddress, "ulong_ptr", $isize, "dword", $iallocation, "dword", $iprotect)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _MemVirtualAllocEx

    Func _MemVirtualFree($paddress, $isize, $ifreetype)
        Local $acall = DllCall("kernel32.dll", "bool", "VirtualFree", "ptr", $paddress, "ulong_ptr", $isize, "dword", $ifreetype)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _MemVirtualFree

    Func _MemVirtualFreeEx($hprocess, $paddress, $isize, $ifreetype)
        Local $acall = DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $hprocess, "ptr", $paddress, "ulong_ptr", $isize, "dword", $ifreetype)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _MemVirtualFreeEx

#EndRegion Public Functions
#Region Internal Functions
    Func __Mem_OpenProcess($iaccess, $binherit, $ipid, $bdebugpriv = False)
        Local $acall = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $binherit, "dword", $ipid)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return $acall[0x0]
        If Not $bdebugpriv Then Return SetError(0x64, 0x0, 0x0)
        Local $htoken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
        If @error Then Return SetError(@error + 0xa, @extended, 0x0)
        _Security__SetPrivilege($htoken, $SE_DEBUG_NAME, True)
        Local $ierror = @error
        Local $iextended = @extended
        Local $iret = 0x0
        If Not @error Then
            $acall = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $binherit, "dword", $ipid)
            $ierror = @error
            $iextended = @extended
            If $acall[0x0] Then $iret = $acall[0x0]
            _Security__SetPrivilege($htoken, $SE_DEBUG_NAME, False)
            If @error Then
                $ierror = @error + 0x14
                $iextended = @extended
            EndIf
        Else
            $ierror = @error + 0x1e
        EndIf
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $htoken)
        Return SetError($ierror, $iextended, $iret)
    EndFunc    ; -> __Mem_OpenProcess

#EndRegion Internal Functions
Global Const $CF_TEXT = 0x1
Global Const $CF_BITMAP = 0x2
Global Const $CF_METAFILEPICT = 0x3
Global Const $CF_SYLK = 0x4
Global Const $CF_DIF = 0x5
Global Const $CF_TIFF = 0x6
Global Const $CF_OEMTEXT = 0x7
Global Const $CF_DIB = 0x8
Global Const $CF_PALETTE = 0x9
Global Const $CF_PENDATA = 0xa
Global Const $CF_RIFF = 0xb
Global Const $CF_WAVE = 0xc
Global Const $CF_UNICODETEXT = 0xd
Global Const $CF_ENHMETAFILE = 0xe
Global Const $CF_HDROP = 0xf
Global Const $CF_LOCALE = 0x10
Global Const $CF_DIBV5 = 0x11
Global Const $CF_OWNERDISPLAY = 0x80
Global Const $CF_DSPTEXT = 0x81
Global Const $CF_DSPBITMAP = 0x82
Global Const $CF_DSPMETAFILEPICT = 0x83
Global Const $CF_DSPENHMETAFILE = 0x8e
Global Const $CF_PRIVATEFIRST = 0x200
Global Const $CF_PRIVATELAST = 0x2ff
Global Const $CF_GDIOBJFIRST = 0x300
Global Const $CF_GDIOBJLAST = 0x3ff
Func _ClipBoard_ChangeChain($hremove, $hnewnext)
    DllCall("user32.dll", "bool", "ChangeClipboardChain", "hwnd", $hremove, "hwnd", $hnewnext)
    If @error Then Return SetError(@error, @extended)
EndFunc    ; -> _ClipBoard_ChangeChain

Func _ClipBoard_Close()
    Local $acall = DllCall("user32.dll", "bool", "CloseClipboard")
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_Close

Func _ClipBoard_CountFormats()
    Local $acall = DllCall("user32.dll", "int", "CountClipboardFormats")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_CountFormats

Func _ClipBoard_Empty()
    Local $acall = DllCall("user32.dll", "bool", "EmptyClipboard")
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_Empty

Func _ClipBoard_EnumFormats($iformat)
    Local $acall = DllCall("user32.dll", "uint", "EnumClipboardFormats", "uint", $iformat)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_EnumFormats

Func _ClipBoard_FormatStr($iformat)
    Local $aformat[0x12] = [0x11, "Text", "Bitmap", "Metafile Picture", "SYLK", "DIF", "TIFF", "OEM Text", "DIB", "Palette", "Pen Data", "RIFF", "WAVE", "Unicode Text", "Enhanced Metafile", "HDROP", "Locale", "DIB V5"]
    If $iformat >= 0x1 And $iformat <= 0x11 Then Return $aformat[$iformat]
    Switch $iformat
    Case $CF_OWNERDISPLAY
        Return "Owner Display"
    Case $CF_DSPTEXT
        Return "Private Text"
    Case $CF_DSPBITMAP
        Return "Private Bitmap"
    Case $CF_DSPMETAFILEPICT
        Return "Private Metafile Picture"
    Case $CF_DSPENHMETAFILE
        Return "Private Enhanced Metafile"
    Case Else
        Return _ClipBoard_GetFormatName($iformat)
    EndSwitch
EndFunc    ; -> _ClipBoard_FormatStr

Func _ClipBoard_GetData($iformat = 0x1)
    If Not _ClipBoard_IsFormatAvailable($iformat) Then Return SetError(+ -1, 0x0, 0x0)
    If Not _ClipBoard_Open(0x0) Then Return SetError(+ -2, 0x0, 0x0)
    Local $hmemory = _ClipBoard_GetDataEx($iformat)
    If $hmemory = 0x0 Then
        _ClipBoard_Close()
        Return SetError(+ -3, 0x0, 0x0)
    EndIf
    Local $pmemoryblock = _MemGlobalLock($hmemory)
    If $pmemoryblock = 0x0 Then
        _ClipBoard_Close()
        Return SetError(+ -4, 0x0, 0x0)
    EndIf
    Local $idatasize = _MemGlobalSize($hmemory)
    If $idatasize = 0x0 Then
        _MemGlobalUnlock($hmemory)
        _ClipBoard_Close()
        Return SetError(+ -5, 0x0, '')
    EndIf
    Local $tdata
    Switch $iformat
    Case $CF_TEXT, $CF_OEMTEXT
        $tdata = DllStructCreate("char[" & $idatasize & "]", $pmemoryblock)
    Case $CF_UNICODETEXT
        $idatasize = Round($idatasize / 0x2)
        $tdata = DllStructCreate("wchar[" & $idatasize & "]", $pmemoryblock)
    Case Else
        $tdata = DllStructCreate("byte[" & $idatasize & "]", $pmemoryblock)
    EndSwitch
    Local $vreturn = DllStructGetData($tdata, 0x1)
    _MemGlobalUnlock($hmemory)
    _ClipBoard_Close()
    Return SetExtended($idatasize, $vreturn)
EndFunc    ; -> _ClipBoard_GetData

Func _ClipBoard_GetDataEx($iformat = 0x1)
    Local $acall = DllCall("user32.dll", "handle", "GetClipboardData", "uint", $iformat)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_GetDataEx

Func _ClipBoard_GetFormatName($iformat)
    Local $acall = DllCall("user32.dll", "int", "GetClipboardFormatNameW", "uint", $iformat, "wstr", '', "int", 0x1000)
    If @error Then Return SetError(@error, @extended, '')
    Return $acall[0x2]
EndFunc    ; -> _ClipBoard_GetFormatName

Func _ClipBoard_GetOpenWindow()
    Local $acall = DllCall("user32.dll", "hwnd", "GetOpenClipboardWindow")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_GetOpenWindow

Func _ClipBoard_GetOwner()
    Local $acall = DllCall("user32.dll", "hwnd", "GetClipboardOwner")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_GetOwner

Func _ClipBoard_GetPriorityFormat($aformats)
    If Not IsArray($aformats) Then Return SetError(+ -1, 0x0, 0x0)
    If $aformats[0x0] <= 0x0 Then Return SetError(+ -2, 0x0, 0x0)
    Local $tdata = DllStructCreate("uint[" & $aformats[0x0] & "]")
    For $ii = 0x1 To $aformats[0x0]
        DllStructSetData($tdata, 0x1, $aformats[$ii], $ii)
    Next
    Local $acall = DllCall("user32.dll", "int", "GetPriorityClipboardFormat", "struct*", $tdata, "int", $aformats[0x0])
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_GetPriorityFormat

Func _ClipBoard_GetSequenceNumber()
    Local $acall = DllCall("user32.dll", "dword", "GetClipboardSequenceNumber")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_GetSequenceNumber

Func _ClipBoard_GetViewer()
    Local $acall = DllCall("user32.dll", "hwnd", "GetClipboardViewer")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_GetViewer

Func _ClipBoard_IsFormatAvailable($iformat)
    Local $acall = DllCall("user32.dll", "bool", "IsClipboardFormatAvailable", "uint", $iformat)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_IsFormatAvailable

Func _ClipBoard_Open($howner)
    Local $acall = DllCall("user32.dll", "bool", "OpenClipboard", "hwnd", $howner)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_Open

Func _ClipBoard_RegisterFormat($sformat)
    Local $acall = DllCall("user32.dll", "uint", "RegisterClipboardFormatW", "wstr", $sformat)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_RegisterFormat

Func _ClipBoard_SetData($vdata, $iformat = 0x1)
    Local $tdata, $hlock, $hmemory, $isize
    If IsNumber($vdata) And $vdata = 0x0 Then
        $hmemory = $vdata
    Else
        If IsBinary($vdata) Then
            $isize = BinaryLen($vdata)
        ElseIf IsString($vdata) Then
            $isize = StringLen($vdata)
        Else
            Return SetError(0x2, 0x0, 0x0)
        EndIf
        $isize += 0x1
        If $iformat = $CF_UNICODETEXT Then
            $hmemory = _MemGlobalAlloc($isize * 0x2, $GHND)
        Else
            $hmemory = _MemGlobalAlloc($isize, $GHND)
        EndIf
        If $hmemory = 0x0 Then Return SetError(+ -1, 0x0, 0x0)
        $hlock = _MemGlobalLock($hmemory)
        If $hlock = 0x0 Then Return SetError(+ -2, 0x0, 0x0)
        Switch $iformat
        Case $CF_TEXT, $CF_OEMTEXT
            $tdata = DllStructCreate("char[" & $isize & "]", $hlock)
        Case $CF_UNICODETEXT
            $tdata = DllStructCreate("wchar[" & $isize & "]", $hlock)
        Case Else
            $tdata = DllStructCreate("byte[" & $isize & "]", $hlock)
        EndSwitch
        DllStructSetData($tdata, 0x1, $vdata)
        _MemGlobalUnlock($hmemory)
    EndIf
    If Not _ClipBoard_Open(0x0) Then Return SetError(+ -5, 0x0, 0x0)
    If Not _ClipBoard_Empty() Then
        _ClipBoard_Close()
        Return SetError(+ -6, 0x0, 0x0)
    EndIf
    If Not _ClipBoard_SetDataEx($hmemory, $iformat) Then
        _ClipBoard_Close()
        Return SetError(+ -7, 0x0, 0x0)
    EndIf
    _ClipBoard_Close()
    Return $hmemory
EndFunc    ; -> _ClipBoard_SetData

Func _ClipBoard_SetDataEx(ByRef $hmemory, $iformat = 0x1)
    Local $acall = DllCall("user32.dll", "handle", "SetClipboardData", "uint", $iformat, "handle", $hmemory)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_SetDataEx

Func _ClipBoard_SetViewer($hviewer)
    Local $acall = DllCall("user32.dll", "hwnd", "SetClipboardViewer", "hwnd", $hviewer)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _ClipBoard_SetViewer

Global Const $__COLORCONSTANTS_HMAX = 0x168
Global Const $__COLORCONSTANTS_SLMAX = 0x64
Global Const $__COLORCONSTANTS_RGBMAX = 0xff
Func _ColorConvertHSLtoRGB($AARRAY)
    If UBound($AARRAY) <> 0x3 Or UBound($AARRAY, $UBOUND_DIMENSIONS) <> 0x1 Then Return SetError(0x1, 0x0, 0x0)
    Local $nr, $ng, $nb
    Local $nh = Number($AARRAY[0x0]) / $__COLORCONSTANTS_HMAX
    Local $ns = Number($AARRAY[0x1]) / $__COLORCONSTANTS_SLMAX
    Local $nl = Number($AARRAY[0x2]) / $__COLORCONSTANTS_SLMAX
    If $ns = 0x0 Then
        $nr = $nl
        $ng = $nl
        $nb = $nl
    Else
        Local $nvala, $nvalb
        If $nl <= 0.5 Then
            $nvalb = $nl * ($ns + 0x1)
        Else
            $nvalb = ($nl + $ns) - ($nl * $ns)
        EndIf
        $nvala = 0x2 * $nl - $nvalb
        $nr = __ColorConvertHueToRGB($nvala, $nvalb, $nh + 0x1 / 0x3)
        $ng = __ColorConvertHueToRGB($nvala, $nvalb, $nh)
        $nb = __ColorConvertHueToRGB($nvala, $nvalb, $nh + -1 / 0x3)
    EndIf
    $AARRAY[0x0] = $nr * $__COLORCONSTANTS_RGBMAX
    $AARRAY[0x1] = $ng * $__COLORCONSTANTS_RGBMAX
    $AARRAY[0x2] = $nb * $__COLORCONSTANTS_RGBMAX
    Return $AARRAY
EndFunc    ; -> _ColorConvertHSLtoRGB

Func __ColorConvertHueToRGB($na, $nb, $nh)
    If $nh < 0x0 Then $nh += 0x1
    If $nh > 0x1 Then $nh -= 0x1
    If (0x6 * $nh) < 0x1 Then Return $na + ($nb - $na) * 0x6 * $nh
    If (0x2 * $nh) < 0x1 Then Return $nb
    If (0x3 * $nh) < 0x2 Then Return $na + ($nb - $na) * 0x6 * (0x2 / 0x3 - $nh)
    Return $na
EndFunc    ; -> __ColorConvertHueToRGB

Func _ColorConvertRGBtoHSL($AARRAY)
    If UBound($AARRAY) <> 0x3 Or UBound($AARRAY, $UBOUND_DIMENSIONS) <> 0x1 Then Return SetError(0x1, 0x0, 0x0)
    Local $nh, $ns, $nl
    Local $nr = Number($AARRAY[0x0]) / $__COLORCONSTANTS_RGBMAX
    Local $ng = Number($AARRAY[0x1]) / $__COLORCONSTANTS_RGBMAX
    Local $nb = Number($AARRAY[0x2]) / $__COLORCONSTANTS_RGBMAX
    Local $nmax = $nr
    If $nmax < $ng Then $nmax = $ng
    If $nmax < $nb Then $nmax = $nb
    Local $nmin = $nr
    If $nmin > $ng Then $nmin = $ng
    If $nmin > $nb Then $nmin = $nb
    Local $nminmaxsum = ($nmax + $nmin)
    Local $nminmaxdiff = ($nmax - $nmin)
    $nl = $nminmaxsum / 0x2
    If $nminmaxdiff = 0x0 Then
        $nh = 0x0
        $ns = 0x0
    Else
        If $nl < 0.5 Then
            $ns = $nminmaxdiff / $nminmaxsum
        Else
            $ns = $nminmaxdiff / (0x2 - $nminmaxsum)
        EndIf
        Switch $nmax
        Case $nr
            $nh = ($ng - $nb) / (0x6 * $nminmaxdiff)
        Case $ng
            $nh = ($nb - $nr) / (0x6 * $nminmaxdiff) + 0x1 / 0x3
        Case $nb
            $nh = ($nr - $ng) / (0x6 * $nminmaxdiff) + 0x2 / 0x3
        EndSwitch
        If $nh < 0x0 Then $nh += 0x1
        If $nh > 0x1 Then $nh -= 0x1
    EndIf
    $AARRAY[0x0] = $nh * $__COLORCONSTANTS_HMAX
    $AARRAY[0x1] = $ns * $__COLORCONSTANTS_SLMAX
    $AARRAY[0x2] = $nl * $__COLORCONSTANTS_SLMAX
    Return $AARRAY
EndFunc    ; -> _ColorConvertRGBtoHSL

Func _ColorGetBlue($icolor)
    Return BitAND($icolor, 0xff)
EndFunc    ; -> _ColorGetBlue

Func _ColorGetGreen($icolor)
    Return BitAND(BitShift($icolor, 0x8), 0xff)
EndFunc    ; -> _ColorGetGreen

Func _ColorGetRed($icolor)
    Return BitAND(BitShift($icolor, 0x10), 0xff)
EndFunc    ; -> _ColorGetRed

Func _ColorGetCOLORREF($icolor, Const $_ICALLEREXTENDED = @extended)
    If BitAND($icolor, -16777216) Then Return SetError(0x1, 0x0, 0x0)
    Local $acolor[0x3]
    $acolor[0x2] = BitAND(BitShift($icolor, 0x10), 0xff)
    $acolor[0x1] = BitAND(BitShift($icolor, 0x8), 0xff)
    $acolor[0x0] = BitAND($icolor, 0xff)
    Return SetExtended($_ICALLEREXTENDED, $acolor)
EndFunc    ; -> _ColorGetCOLORREF

Func _ColorGetRGB($icolor, Const $_ICALLEREXTENDED = @extended)
    If BitAND($icolor, -16777216) Then Return SetError(0x1, 0x0, 0x0)
    Local $acolor[0x3]
    $acolor[0x0] = BitAND(BitShift($icolor, 0x10), 0xff)
    $acolor[0x1] = BitAND(BitShift($icolor, 0x8), 0xff)
    $acolor[0x2] = BitAND($icolor, 0xff)
    Return SetExtended($_ICALLEREXTENDED, $acolor)
EndFunc    ; -> _ColorGetRGB

Func _ColorSetCOLORREF($acolor, Const $_ICALLEREXTENDED = @extended)
    If UBound($acolor) <> 0x3 Then Return SetError(0x1, 0x0, + -1)
    Local $icolor = 0x0, $icolori
    For $i = 0x2 To 0x0 Step + -1
        $icolor = BitShift($icolor, + -8)
        $icolori = $acolor[$i]
        If $icolori < 0x0 Or $icolori > 0xff Then Return SetError(0x2, $i, + -1)
        $icolor += $icolori
    Next
    Return SetExtended($_ICALLEREXTENDED, $icolor)
EndFunc    ; -> _ColorSetCOLORREF

Func _ColorSetRGB($acolor, Const $_ICALLEREXTENDED = @extended)
    If UBound($acolor) <> 0x3 Then Return SetError(0x1, 0x0, + -1)
    Local $icolor = 0x0, $icolori
    For $i = 0x0 To 0x2
        $icolor = BitShift($icolor, + -8)
        $icolori = $acolor[$i]
        If $icolori < 0x0 Or $icolori > 0xff Then Return SetError(0x2, 0x0, + -1)
        $icolor += $icolori
    Next
    Return SetExtended($_ICALLEREXTENDED, $icolor)
EndFunc    ; -> _ColorSetRGB

Global Const $PROV_RSA_FULL = 0x1
Global Const $PROV_RSA_AES = 0x18
Global Const $CRYPT_VERIFYCONTEXT = -268435456
Global Const $HP_HASHSIZE = 0x4
Global Const $HP_HASHVAL = 0x2
Global Const $CRYPT_EXPORTABLE = 0x1
Global Const $CRYPT_USERDATA = 0x1
Global Const $KP_ALGID = 0x7
Global Const $CALG_MD2 = 0x8001
Global Const $CALG_MD4 = 0x8002
Global Const $CALG_MD5 = 0x8003
Global Const $CALG_SHA1 = 0x8004
Global Const $CALG_SHA_256 = 0x800c
Global Const $CALG_SHA_384 = 0x800d
Global Const $CALG_SHA_512 = 0x800e
Global Const $CALG_3DES = 0x6603
Global Const $CALG_AES_128 = 0x660e
Global Const $CALG_AES_192 = 0x660f
Global Const $CALG_AES_256 = 0x6610
Global Const $CALG_DES = 0x6601
Global Const $CALG_RC2 = 0x6602
Global Const $CALG_RC4 = 0x6801
Global Const $CALG_USERKEY = 0x0
Global $__g_acryptinternaldata[0x3]
Func _Crypt_Startup()
    If __Crypt_RefCount() = 0x0 Then
        Local $hadvapi32 = DllOpen("Advapi32.dll")
        If $hadvapi32 = + -1 Then Return SetError(0x3e9, 0x0, False)
        __Crypt_DllHandleSet($hadvapi32)
        Local $iproviderid = $PROV_RSA_AES
        Local $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptAcquireContext", "handle*", 0x0, "ptr", 0x0, "ptr", 0x0, "dword", $iproviderid, "dword", $CRYPT_VERIFYCONTEXT)
        If @error Or Not $acall[0x0] Then
            Local $ierror = @error + 0x3ea, $iextended = @extended
            If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
            DllClose(__Crypt_DllHandle())
            Return SetError($ierror, $iextended, False)
        Else
            __Crypt_ContextSet($acall[0x1])
        EndIf
    EndIf
    __Crypt_RefCountInc()
    Return True
EndFunc    ; -> _Crypt_Startup

Func _Crypt_Shutdown()
    __Crypt_RefCountDec()
    If __Crypt_RefCount() = 0x0 Then
        DllCall(__Crypt_DllHandle(), "bool", "CryptReleaseContext", "handle", __Crypt_Context(), "dword", 0x0)
        DllClose(__Crypt_DllHandle())
    EndIf
EndFunc    ; -> _Crypt_Shutdown

Func _Crypt_DeriveKey($vpassword, $ialgid, $ihashpasswordid = $CALG_MD5)
    Local $acall, $tbuff = 0x0, $hcrypthash = 0x0, $ierror = 0x0, $iextended = 0x0, $vreturn = 0x0
    _Crypt_Startup()
    If @error Then Return SetError(@error, @extended, + -1)
    Do
        $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptCreateHash", "handle", __Crypt_Context(), "uint", $ihashpasswordid, "ptr", 0x0, "dword", 0x0, "handle*", 0x0)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0xa
            $iextended = @extended
            If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
            $vreturn = + -1
            ExitLoop
        EndIf
        $hcrypthash = $acall[0x5]
        $tbuff = DllStructCreate("byte[" & BinaryLen($vpassword) & "]")
        DllStructSetData($tbuff, 0x1, $vpassword)
        $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptHashData", "handle", $hcrypthash, "struct*", $tbuff, "dword", DllStructGetSize($tbuff), "dword", $CRYPT_USERDATA)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x14
            $iextended = @extended
            If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
            $vreturn = + -1
            ExitLoop
        EndIf
        $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptDeriveKey", "handle", __Crypt_Context(), "uint", $ialgid, "handle", $hcrypthash, "dword", $CRYPT_EXPORTABLE, "handle*", 0x0)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x1e
            $iextended = @extended
            If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
            $vreturn = + -1
            ExitLoop
        EndIf
        $vreturn = $acall[0x5]
    Until True
    If $hcrypthash <> 0x0 Then DllCall(__Crypt_DllHandle(), "bool", "CryptDestroyHash", "handle", $hcrypthash)
    Return SetError($ierror, $iextended, $vreturn)
EndFunc    ; -> _Crypt_DeriveKey

Func _Crypt_DestroyKey($hcryptkey)
    Local $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptDestroyKey", "handle", $hcryptkey)
    Local $ierror = @error
    If $ierror Or Not $acall[0x0] Then
        Return SetError($ierror + 0xa, _WinAPI_GetLastError(), False)
    Else
        _Crypt_Shutdown()
        Return True
    EndIf
EndFunc    ; -> _Crypt_DestroyKey

Func _Crypt_EncryptData($vdata, $vcryptkey, $ialgid, $bfinal = True)
    Switch $ialgid
    Case $CALG_USERKEY
        Local $icalgused = __Crypt_GetCalgFromCryptKey($vcryptkey)
        If @error Then Return SetError(@error, @extended, + -1)
        If $icalgused = $CALG_RC4 Then ContinueCase
    Case $CALG_RC4
        If BinaryLen($vdata) = 0x0 Then Return SetError(0x0, 0x0, Binary(''))
    EndSwitch
    Local $ireqbuffsize = 0x0, $acall, $tbuff = 0x0, $ierror = 0x0, $iextended = 0x0, $vreturn = 0x0
    _Crypt_Startup()
    If @error Then Return SetError(@error, @extended, + -1)
    Do
        If $ialgid <> $CALG_USERKEY Then
            $vcryptkey = _Crypt_DeriveKey($vcryptkey, $ialgid)
            If @error Then
                $ierror = @error
                $iextended = @extended
                $vreturn = + -1
                ExitLoop
            EndIf
        EndIf
        $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptEncrypt", "handle", $vcryptkey, "handle", 0x0, "bool", $bfinal, "dword", 0x0, "ptr", 0x0, "dword*", BinaryLen($vdata), "dword", 0x0)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x32
            $iextended = @extended
            If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
            $vreturn = + -1
            ExitLoop
        EndIf
        $ireqbuffsize = $acall[0x6]
        $tbuff = DllStructCreate("byte[" & $ireqbuffsize + 0x1 & "]")
        DllStructSetData($tbuff, 0x1, $vdata)
        $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptEncrypt", "handle", $vcryptkey, "handle", 0x0, "bool", $bfinal, "dword", 0x0, "struct*", $tbuff, "dword*", BinaryLen($vdata), "dword", $ireqbuffsize)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x3c
            $iextended = @extended
            If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
            $vreturn = + -1
            ExitLoop
        EndIf
        $vreturn = BinaryMid(DllStructGetData($tbuff, 0x1), 0x1, $ireqbuffsize)
    Until True
    If $ialgid <> $CALG_USERKEY Then _Crypt_DestroyKey($vcryptkey)
    _Crypt_Shutdown()
    Return SetError($ierror, $iextended, $vreturn)
EndFunc    ; -> _Crypt_EncryptData

Func _Crypt_DecryptData($vdata, $vcryptkey, $ialgid, $bfinal = True)
    Switch $ialgid
    Case $CALG_USERKEY
        Local $icalgused = __Crypt_GetCalgFromCryptKey($vcryptkey)
        If @error Then Return SetError(@error, @extended, + -1)
        If $icalgused = $CALG_RC4 Then ContinueCase
    Case $CALG_RC4
        If BinaryLen($vdata) = 0x0 Then Return SetError(0x0, 0x0, Binary(''))
    EndSwitch
    Local $acall, $tbuff = 0x0, $ttempstruct = 0x0, $ierror = 0x0, $iextended = 0x0, $iplaintextsize = 0x0, $vreturn = 0x0
    _Crypt_Startup()
    If @error Then Return SetError(@error, @extended, + -1)
    Do
        If $ialgid <> $CALG_USERKEY Then
            $vcryptkey = _Crypt_DeriveKey($vcryptkey, $ialgid)
            If @error Then
                $ierror = @error
                $iextended = @extended
                $vreturn = + -1
                ExitLoop
            EndIf
        EndIf
        $tbuff = DllStructCreate("byte[" & BinaryLen($vdata) + 0x3e8 & "]")
        If BinaryLen($vdata) > 0x0 Then DllStructSetData($tbuff, 0x1, $vdata)
        $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptDecrypt", "handle", $vcryptkey, "handle", 0x0, "bool", $bfinal, "dword", 0x0, "struct*", $tbuff, "dword*", BinaryLen($vdata))
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x46
            $iextended = @extended
            If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
            $vreturn = + -1
            ExitLoop
        EndIf
        $iplaintextsize = $acall[0x6]
        $ttempstruct = DllStructCreate("byte[" & $iplaintextsize + 0x1 & "]", DllStructGetPtr($tbuff))
        $vreturn = BinaryMid(DllStructGetData($ttempstruct, 0x1), 0x1, $iplaintextsize)
    Until True
    If $ialgid <> $CALG_USERKEY Then _Crypt_DestroyKey($vcryptkey)
    _Crypt_Shutdown()
    Return SetError($ierror, $iextended, $vreturn)
EndFunc    ; -> _Crypt_DecryptData

Func _Crypt_HashData($vdata, $ialgid, $bfinal = True, $hcrypthash = 0x0)
    Local $acall, $tbuff = 0x0, $ierror = 0x0, $iextended = 0x0, $ihashsize = 0x0, $vreturn = 0x0
    _Crypt_Startup()
    If @error Then Return SetError(@error, @extended, + -1)
    Do
        If $hcrypthash = 0x0 Then
            $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptCreateHash", "handle", __Crypt_Context(), "uint", $ialgid, "ptr", 0x0, "dword", 0x0, "handle*", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0xa
                $iextended = @extended
                If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
                $vreturn = + -1
                ExitLoop
            EndIf
            $hcrypthash = $acall[0x5]
        EndIf
        $tbuff = DllStructCreate("byte[" & BinaryLen($vdata) & "]")
        DllStructSetData($tbuff, 0x1, $vdata)
        $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptHashData", "handle", $hcrypthash, "struct*", $tbuff, "dword", DllStructGetSize($tbuff), "dword", $CRYPT_USERDATA)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x14
            $iextended = @extended
            If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
            $vreturn = + -1
            ExitLoop
        EndIf
        If $bfinal Then
            $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptGetHashParam", "handle", $hcrypthash, "dword", $HP_HASHSIZE, "dword*", 0x0, "dword*", 0x4, "dword", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x1e
                $iextended = @extended
                If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
                $vreturn = + -1
                ExitLoop
            EndIf
            $ihashsize = $acall[0x3]
            $tbuff = DllStructCreate("byte[" & $ihashsize & "]")
            $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptGetHashParam", "handle", $hcrypthash, "dword", $HP_HASHVAL, "struct*", $tbuff, "dword*", $ihashsize, "dword", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x28
                $iextended = @extended
                If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
                $vreturn = + -1
                ExitLoop
            EndIf
            $vreturn = DllStructGetData($tbuff, 0x1)
        Else
            $vreturn = $hcrypthash
        EndIf
    Until True
    If $hcrypthash <> 0x0 And $bfinal Then DllCall(__Crypt_DllHandle(), "bool", "CryptDestroyHash", "handle", $hcrypthash)
    _Crypt_Shutdown()
    Return SetError($ierror, $iextended, $vreturn)
EndFunc    ; -> _Crypt_HashData

Func _Crypt_HashFile($sfilepath, $ialgid)
    Local $dtempdata = 0x0, $hfile = 0x0, $hhashobject = 0x0, $ierror = 0x0, $iextended = 0x0, $vreturn = 0x0
    _Crypt_Startup()
    If @error Then Return SetError(@error, @extended, + -1)
    Do
        $hfile = FileOpen($sfilepath, $FO_BINARY)
        If $hfile = + -1 Then
            $ierror = 0x1
            $iextended = _WinAPI_GetLastError()
            $vreturn = + -1
            ExitLoop
        EndIf
        Do
            $dtempdata = FileRead($hfile, 0x200 * 0x400)
            If @error Then
                $vreturn = _Crypt_HashData($dtempdata, $ialgid, True, $hhashobject)
                If @error Then
                    $ierror = @error
                    $iextended = @extended
                    $vreturn = + -1
                    ExitLoop 0x2
                EndIf
                ExitLoop 0x2
            Else
                $hhashobject = _Crypt_HashData($dtempdata, $ialgid, False, $hhashobject)
                If @error Then
                    $ierror = @error + 0x64
                    $iextended = @extended
                    $vreturn = + -1
                    ExitLoop 0x2
                EndIf
            EndIf
        Until False
    Until True
    _Crypt_Shutdown()
    If $hfile <> + -1 Then FileClose($hfile)
    Return SetError($ierror, $iextended, $vreturn)
EndFunc    ; -> _Crypt_HashFile

Func _Crypt_EncryptFile($ssourcefile, $sdestinationfile, $vcryptkey, $ialgid)
    Local $dtempdata = 0x0, $hinfile = 0x0, $houtfile = 0x0, $ierror = 0x0, $iextended = 0x0, $ifilesize = FileGetSize($ssourcefile), $iread = 0x0, $breturn = True
    _Crypt_Startup()
    If @error Then Return SetError(@error, @extended, + -1)
    Do
        If $ialgid <> $CALG_USERKEY Then
            $vcryptkey = _Crypt_DeriveKey($vcryptkey, $ialgid)
            If @error Then
                $ierror = @error
                $iextended = @extended
                $breturn = False
                ExitLoop
            EndIf
        EndIf
        $hinfile = FileOpen($ssourcefile, $FO_BINARY)
        If $hinfile = + -1 Then
            $ierror = 0x2
            $iextended = _WinAPI_GetLastError()
            $breturn = False
            ExitLoop
        EndIf
        $houtfile = FileOpen($sdestinationfile, $FO_OVERWRITE + $FO_CREATEPATH + $FO_BINARY)
        If $houtfile = + -1 Then
            $ierror = 0x3
            $iextended = _WinAPI_GetLastError()
            $breturn = False
            ExitLoop
        EndIf
        Do
            $dtempdata = FileRead($hinfile, 0x400 * 0x400)
            $iread += BinaryLen($dtempdata)
            If $iread = $ifilesize Then
                $dtempdata = _Crypt_EncryptData($dtempdata, $vcryptkey, $CALG_USERKEY, True)
                If @error Then
                    $ierror = @error + 0x190
                    $iextended = @extended
                    $breturn = False
                EndIf
                FileWrite($houtfile, $dtempdata)
                ExitLoop 0x2
            Else
                $dtempdata = _Crypt_EncryptData($dtempdata, $vcryptkey, $CALG_USERKEY, False)
                If @error Then
                    $ierror = @error + 0x1f4
                    $iextended = @extended
                    $breturn = False
                    ExitLoop 0x2
                EndIf
                FileWrite($houtfile, $dtempdata)
            EndIf
        Until False
    Until True
    If $ialgid <> $CALG_USERKEY Then _Crypt_DestroyKey($vcryptkey)
    _Crypt_Shutdown()
    If $hinfile <> + -1 Then FileClose($hinfile)
    If $houtfile <> + -1 Then FileClose($houtfile)
    Return SetError($ierror, $iextended, $breturn)
EndFunc    ; -> _Crypt_EncryptFile

Func _Crypt_DecryptFile($ssourcefile, $sdestinationfile, $vcryptkey, $ialgid)
    Local $dtempdata = 0x0, $hinfile = 0x0, $houtfile = 0x0, $ierror = 0x0, $iextended = 0x0, $ifilesize = FileGetSize($ssourcefile), $iread = 0x0, $breturn = True
    _Crypt_Startup()
    If @error Then Return SetError(@error, @extended, + -1)
    Do
        If $ialgid <> $CALG_USERKEY Then
            $vcryptkey = _Crypt_DeriveKey($vcryptkey, $ialgid)
            If @error Then
                $ierror = @error
                $iextended = @extended
                $breturn = False
                ExitLoop
            EndIf
        EndIf
        $hinfile = FileOpen($ssourcefile, $FO_BINARY)
        If $hinfile = + -1 Then
            $ierror = 0x2
            $iextended = _WinAPI_GetLastError()
            $breturn = False
            ExitLoop
        EndIf
        $houtfile = FileOpen($sdestinationfile, $FO_OVERWRITE + $FO_CREATEPATH + $FO_BINARY)
        If $houtfile = + -1 Then
            $ierror = 0x3
            $iextended = _WinAPI_GetLastError()
            $breturn = False
            ExitLoop
        EndIf
        Do
            $dtempdata = FileRead($hinfile, 0x400 * 0x400)
            $iread += BinaryLen($dtempdata)
            If $iread = $ifilesize Then
                $dtempdata = _Crypt_DecryptData($dtempdata, $vcryptkey, $CALG_USERKEY, True)
                If @error Then
                    $ierror = @error + 0x190
                    $iextended = @extended
                    $breturn = False
                EndIf
                FileWrite($houtfile, $dtempdata)
                ExitLoop 0x2
            Else
                $dtempdata = _Crypt_DecryptData($dtempdata, $vcryptkey, $CALG_USERKEY, False)
                If @error Then
                    $ierror = @error + 0x1f4
                    $iextended = @extended
                    $breturn = False
                    ExitLoop 0x2
                EndIf
                FileWrite($houtfile, $dtempdata)
            EndIf
        Until False
    Until True
    If $ialgid <> $CALG_USERKEY Then _Crypt_DestroyKey($vcryptkey)
    _Crypt_Shutdown()
    If $hinfile <> + -1 Then FileClose($hinfile)
    If $houtfile <> + -1 Then FileClose($houtfile)
    Return SetError($ierror, $iextended, $breturn)
EndFunc    ; -> _Crypt_DecryptFile

Func _Crypt_GenRandom($pbuffer, $isize)
    _Crypt_Startup()
    If @error Then Return SetError(@error, @extended, False)
    Local $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptGenRandom", "handle", __Crypt_Context(), "dword", $isize, "struct*", $pbuffer)
    Local $ierror = @error, $iextended = @extended
    If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
    _Crypt_Shutdown()
    If $ierror Or (Not $acall[0x0]) Then
        Return SetError($ierror + 0xa, $iextended, False)
    Else
        Return True
    EndIf
EndFunc    ; -> _Crypt_GenRandom

Func __Crypt_RefCount()
    Return $__g_acryptinternaldata[0x0]
EndFunc    ; -> __Crypt_RefCount

Func __Crypt_RefCountInc()
    $__g_acryptinternaldata[0x0]+= 0x1
EndFunc    ; -> __Crypt_RefCountInc

Func __Crypt_RefCountDec()
    If $__g_acryptinternaldata[0x0] > 0x0 Then $__g_acryptinternaldata[0x0]-= 0x1
EndFunc    ; -> __Crypt_RefCountDec

Func __Crypt_DllHandle()
    Return $__g_acryptinternaldata[0x1]
EndFunc    ; -> __Crypt_DllHandle

Func __Crypt_DllHandleSet($hadvapi32)
    $__g_acryptinternaldata[0x1] = $hadvapi32
EndFunc    ; -> __Crypt_DllHandleSet

Func __Crypt_Context()
    Return $__g_acryptinternaldata[0x2]
EndFunc    ; -> __Crypt_Context

Func __Crypt_ContextSet($hcryptcontext)
    $__g_acryptinternaldata[0x2] = $hcryptcontext
EndFunc    ; -> __Crypt_ContextSet

Func __Crypt_GetCalgFromCryptKey($vcryptkey)
    Local $talgid = DllStructCreate("uint")
    Local $acall = DllCall(__Crypt_DllHandle(), "bool", "CryptGetKeyParam", "handle", $vcryptkey, "dword", $KP_ALGID, "struct*", $talgid, "dword*", DllStructGetSize($talgid), "dword", 0x0)
    Local $ierror = @error, $iextended = @extended
    If Not $acall[0x0] Then $iextended = _WinAPI_GetLastError()
    If $ierror Or Not $acall[0x0] Then
        Return SetError($ierror + 0x50, $iextended, $CRYPT_USERDATA)
    Else
        Return DllStructGetData($talgid, 0x1)
    EndIf
EndFunc    ; -> __Crypt_GetCalgFromCryptKey

#Region Global Variables and Constants
    Global $__g_venum, $__g_vext = 0x0
    Global $__g_irgbmode = 0x1
    Global Const $TAGOSVERSIONINFO = "struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct"
    Global Const $IMAGE_BITMAP = 0x0
    Global Const $IMAGE_ICON = 0x1
    Global Const $IMAGE_CURSOR = 0x2
    Global Const $IMAGE_ENHMETAFILE = 0x3
    Global Const $LR_DEFAULTCOLOR = 0x0
    Global Const $LR_MONOCHROME = 0x1
    Global Const $LR_COLOR = 0x2
    Global Const $LR_COPYRETURNORG = 0x4
    Global Const $LR_COPYDELETEORG = 0x8
    Global Const $LR_LOADFROMFILE = 0x10
    Global Const $LR_LOADTRANSPARENT = 0x20
    Global Const $LR_DEFAULTSIZE = 0x40
    Global Const $LR_VGACOLOR = 0x80
    Global Const $LR_LOADMAP3DCOLORS = 0x1000
    Global Const $LR_CREATEDIBSECTION = 0x2000
    Global Const $LR_COPYFROMRESOURCE = 0x4000
    Global Const $LR_SHARED = 0x8000
    Global Const $__TAGCURSORINFO = "dword Size;dword Flags;handle hCursor;" & "struct;long X;long Y;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_CreateFile($sfilename, $icreation, $iaccess = 0x4, $ishare = 0x0, $iattributes = 0x0, $tsecurity = 0x0)
        Local $ida = 0x0, $ism = 0x0, $icd = 0x0, $ifa = 0x0
        If BitAND($iaccess, 0x1) <> 0x0 Then $ida = BitOR($ida, $GENERIC_EXECUTE)
        If BitAND($iaccess, 0x2) <> 0x0 Then $ida = BitOR($ida, $GENERIC_READ)
        If BitAND($iaccess, 0x4) <> 0x0 Then $ida = BitOR($ida, $GENERIC_WRITE)
        If BitAND($ishare, 0x1) <> 0x0 Then $ism = BitOR($ism, $FILE_SHARE_DELETE)
        If BitAND($ishare, 0x2) <> 0x0 Then $ism = BitOR($ism, $FILE_SHARE_READ)
        If BitAND($ishare, 0x4) <> 0x0 Then $ism = BitOR($ism, $FILE_SHARE_WRITE)
        Switch $icreation
        Case 0x0
            $icd = $CREATE_NEW
        Case 0x1
            $icd = $CREATE_ALWAYS
        Case 0x2
            $icd = $OPEN_EXISTING
        Case 0x3
            $icd = $OPEN_ALWAYS
        Case 0x4
            $icd = $TRUNCATE_EXISTING
        EndSwitch
        If BitAND($iattributes, 0x1) <> 0x0 Then $ifa = BitOR($ifa, $FILE_ATTRIBUTE_ARCHIVE)
        If BitAND($iattributes, 0x2) <> 0x0 Then $ifa = BitOR($ifa, $FILE_ATTRIBUTE_HIDDEN)
        If BitAND($iattributes, 0x4) <> 0x0 Then $ifa = BitOR($ifa, $FILE_ATTRIBUTE_READONLY)
        If BitAND($iattributes, 0x8) <> 0x0 Then $ifa = BitOR($ifa, $FILE_ATTRIBUTE_SYSTEM)
        Local $acall = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sfilename, "dword", $ida, "dword", $ism, "struct*", $tsecurity, "dword", $icd, "dword", $ifa, "ptr", 0x0)
        If @error Or ($acall[0x0] = Ptr(+ -1)) Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateFile

    Func _WinAPI_FreeLibrary($hmodule)
        Local $acall = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hmodule)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FreeLibrary

    Func _WinAPI_GetCursorInfo()
        Local $tcursor = DllStructCreate($__TAGCURSORINFO)
        Local $icursor = DllStructGetSize($tcursor)
        DllStructSetData($tcursor, "Size", $icursor)
        Local $acall = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tcursor)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $acursor[0x5]
        $acursor[0x0] = True
        $acursor[0x1] = DllStructGetData($tcursor, "Flags") <> 0x0
        $acursor[0x2] = DllStructGetData($tcursor, "hCursor")
        $acursor[0x3] = DllStructGetData($tcursor, "X")
        $acursor[0x4] = DllStructGetData($tcursor, "Y")
        Return $acursor
    EndFunc    ; -> _WinAPI_GetCursorInfo

    Func _WinAPI_GetDlgCtrlID($hwnd)
        Local $acall = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetDlgCtrlID

    Func _WinAPI_GetModuleHandle($smodulename)
        If $smodulename = '' Then $smodulename = Null
        Local $acall = DllCall("kernel32.dll", "handle", "GetModuleHandleW", "wstr", $smodulename)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetModuleHandle

    Func _WinAPI_GetString($pstring, $bunicode = True)
        Local $ilength = _WinAPI_StrLen($pstring, $bunicode)
        If @error Or Not $ilength Then Return SetError(@error + 0xa, @extended, '')
        Local $tstring = DllStructCreate(($bunicode  ? "wchar"  : "char") & "[" & ($ilength + 0x1) & "]", $pstring)
        If @error Then Return SetError(@error, @extended, '')
        Return SetExtended($ilength, DllStructGetData($tstring, 0x1))
    EndFunc    ; -> _WinAPI_GetString

    Func _WinAPI_GetVersion()
        Local $tosvi = DllStructCreate($TAGOSVERSIONINFO)
        DllStructSetData($tosvi, 0x1, DllStructGetSize($tosvi))
        Local $acall = DllCall("kernel32.dll", "bool", "GetVersionExW", "struct*", $tosvi)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return Number(DllStructGetData($tosvi, 0x2) & "." & DllStructGetData($tosvi, 0x3), $NUMBER_DOUBLE)
    EndFunc    ; -> _WinAPI_GetVersion

    Func _WinAPI_IsWow64Process($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", (_WinAPI_GetVersion() < 6  ? 0x400  : 0x1000), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, False)
        Local $acall = DllCall("kernel32.dll", "bool", "IsWow64Process", "handle", $hprocess[0x0], "bool*", 0x0)
        If __CheckErrorCloseHandle($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, False)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_IsWow64Process

    Func _WinAPI_LoadImage($hinstance, $simage, $itype, $ixdesired, $iydesired, $iload)
        Local $acall, $simagetype = "int"
        If IsString($simage) Then $simagetype = "wstr"
        $acall = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hinstance, $simagetype, $simage, "uint", $itype, "int", $ixdesired, "int", $iydesired, "uint", $iload)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LoadImage

    Func _WinAPI_LoadLibrary($sfilename)
        Local $acall = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sfilename)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LoadLibrary

    Func _WinAPI_PathIsDirectory($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsDirectoryW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsDirectory

    Func _WinAPI_ReadFile($hfile, $pbuffer, $itoread, ByRef $iread, $toverlapped = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $pbuffer, "dword", $itoread, "dword*", 0x0, "struct*", $toverlapped)
        If @error Then Return SetError(@error, @extended, False)
        $iread = $acall[0x4]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ReadFile

    Func _WinAPI_StrLen($pstring, $bunicode = True)
        Local $w = ''
        If $bunicode Then $w = "W"
        Local $acall = DllCall("kernel32.dll", "int", "lstrlen" & $w, "struct*", $pstring)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_StrLen

    Func _WinAPI_SwitchColor($icolor)
        If $icolor = + -1 Then Return $icolor
        Return BitOR(BitAND($icolor, 0xff00), BitShift(BitAND($icolor, 0xff), + -16), BitShift(BitAND($icolor, 0xff0000), 0x10))
    EndFunc    ; -> _WinAPI_SwitchColor

    Func _WinAPI_WriteFile($hfile, $pbuffer, $itowrite, ByRef $iwritten, $toverlapped = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hfile, "struct*", $pbuffer, "dword", $itowrite, "dword*", 0x0, "struct*", $toverlapped)
        If @error Then Return SetError(@error, @extended, False)
        $iwritten = $acall[0x4]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_WriteFile

#EndRegion Public Functions
#Region Internal Functions
    Func __CheckErrorArrayBounds(Const ByRef $ADATA, ByRef $istart, ByRef $IEND, $NDIM = 0x1, $IDIM = $UBOUND_DIMENSIONS)
        If Not IsArray($ADATA) Then Return SetError(0x1, 0x0, 0x1)
        If UBound($ADATA, $IDIM) <> $NDIM Then Return SetError(0x2, 0x0, 0x1)
        If $istart < 0x0 Then $istart = 0x0
        Local $iubound = UBound($ADATA) + -1
        If $IEND < 0x1 Or $IEND > $iubound Then $IEND = $iubound
        If $istart > $IEND Then Return SetError(0x4, 0x0, 0x1)
        Return 0x0
    EndFunc    ; -> __CheckErrorArrayBounds

    Func __CheckErrorCloseHandle($acall, $hfile, $blasterror = False, $icurerr = @error, $icurext = @extended)
        If Not $icurerr And Not $acall[0x0] Then $icurerr = 0xa
        Local $alasterror = DllCall("kernel32.dll", "dword", "GetLastError")
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
        If $icurerr Then DllCall("kernel32.dll", "none", "SetLastError", "dword", $alasterror[0x0])
        If $blasterror Then $icurext = $alasterror[0x0]
        Return SetError($icurerr, $icurext, $icurerr)
    EndFunc    ; -> __CheckErrorCloseHandle

    Func __dll($spath, $bpin = False)
        Local $acall = DllCall("kernel32.dll", "bool", "GetModuleHandleExW", "dword", ($bpin  ? 0x1  : 0x2), "wstr", $spath, "ptr*", 0x0)
        If Not $acall[0x3] Then
            $acall = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $spath)
            If @error Or Not $acall[0x0] Then Return 0x0
        EndIf
        Return 0x1
    EndFunc    ; -> __dll

    Func __EnumWindowsProc($hwnd, $BVISIBLE)
        Local $acall
        If $BVISIBLE Then
            $acall = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hwnd)
            If Not $acall[0x0] Then
                Return 0x1
            EndIf
        EndIf
        __Inc($__g_venum)
        $__g_venum[$__g_venum[0x0][0x0]][0x0] = $hwnd
        $acall = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hwnd, "wstr", '', "int", 0x1000)
        $__g_venum[$__g_venum[0x0][0x0]][0x1] = $acall[0x2]
        Return 0x1
    EndFunc    ; -> __EnumWindowsProc

    Func __FatalExit($icode, $stext = '')
        If $stext Then MsgBox($MB_SYSTEMMODAL, "AutoIt", $stext)
        DllCall("kernel32.dll", "none", "FatalExit", "int", $icode)
    EndFunc    ; -> __FatalExit

    Func __Inc(ByRef $ADATA, $iincrement = 0x64)
        Select
        Case UBound($ADATA, $UBOUND_COLUMNS)
            If $iincrement < 0x0 Then
                ReDim $ADATA[$ADATA[0x0][0x0] + 0x1][UBound($ADATA, $UBOUND_COLUMNS)]
            Else
                $ADATA[0x0][0x0]+= 0x1
                If $ADATA[0x0][0x0] > UBound($ADATA) + -1 Then
                    ReDim $ADATA[$ADATA[0x0][0x0] + $iincrement][UBound($ADATA, $UBOUND_COLUMNS)]
                EndIf
            EndIf
        Case UBound($ADATA, $UBOUND_ROWS)
            If $iincrement < 0x0 Then
                ReDim $ADATA[$ADATA[0x0] + 0x1]
            Else
                $ADATA[0x0]+= 0x1
                If $ADATA[0x0] > UBound($ADATA) + -1 Then
                    ReDim $ADATA[$ADATA[0x0] + $iincrement]
                EndIf
            EndIf
        Case Else
            Return 0x0
        EndSelect
        Return 0x1
    EndFunc    ; -> __Inc

    Func __rgb($icolor)
        If $__g_irgbmode Then
            $icolor = _WinAPI_SwitchColor($icolor)
        EndIf
        Return $icolor
    EndFunc    ; -> __rgb

#EndRegion Internal Functions
#Region Global Variables and Constants
    Global Const $DUPLICATE_CLOSE_SOURCE = 0x1
    Global Const $DUPLICATE_SAME_ACCESS = 0x2
    Global Const $OBJ_BITMAP = 0x7
    Global Const $OBJ_BRUSH = 0x2
    Global Const $OBJ_COLORSPACE = 0xe
    Global Const $OBJ_DC = 0x3
    Global Const $OBJ_ENHMETADC = 0xc
    Global Const $OBJ_ENHMETAFILE = 0xd
    Global Const $OBJ_EXTPEN = 0xb
    Global Const $OBJ_FONT = 0x6
    Global Const $OBJ_MEMDC = 0xa
    Global Const $OBJ_METADC = 0x4
    Global Const $OBJ_METAFILE = 0x9
    Global Const $OBJ_PAL = 0x5
    Global Const $OBJ_PEN = 0x1
    Global Const $OBJ_REGION = 0x8
    Global Const $NULL_BRUSH = 0x5
    Global Const $NULL_PEN = 0x8
    Global Const $BLACK_BRUSH = 0x4
    Global Const $DKGRAY_BRUSH = 0x3
    Global Const $DC_BRUSH = 0x12
    Global Const $GRAY_BRUSH = 0x2
    Global Const $HOLLOW_BRUSH = $NULL_BRUSH
    Global Const $LTGRAY_BRUSH = 0x1
    Global Const $WHITE_BRUSH = 0x0
    Global Const $BLACK_PEN = 0x7
    Global Const $DC_PEN = 0x13
    Global Const $WHITE_PEN = 0x6
    Global Const $ANSI_FIXED_FONT = 0xb
    Global Const $ANSI_VAR_FONT = 0xc
    Global Const $DEVICE_DEFAULT_FONT = 0xe
    Global Const $DEFAULT_GUI_FONT = 0x11
    Global Const $OEM_FIXED_FONT = 0xa
    Global Const $SYSTEM_FONT = 0xd
    Global Const $SYSTEM_FIXED_FONT = 0x10
    Global Const $DEFAULT_PALETTE = 0xf
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_CloseHandle($hobject)
        Local $acall = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hobject)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CloseHandle

    Func _WinAPI_DeleteObject($hobject)
        Local $acall = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hobject)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DeleteObject

    Func _WinAPI_DuplicateHandle($hsourceprocesshandle, $hsourcehandle, $htargetprocesshandle, $idesiredaccess, $iinherithandle, $ioptions)
        Local $acall = DllCall("kernel32.dll", "bool", "DuplicateHandle", "handle", $hsourceprocesshandle, "handle", $hsourcehandle, "handle", $htargetprocesshandle, "handle*", 0x0, "dword", $idesiredaccess, "bool", $iinherithandle, "dword", $ioptions)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x4]
    EndFunc    ; -> _WinAPI_DuplicateHandle

    Func _WinAPI_GetCurrentObject($hdc, $itype)
        Local $acall = DllCall("gdi32.dll", "handle", "GetCurrentObject", "handle", $hdc, "uint", $itype)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetCurrentObject

    Func _WinAPI_GetCurrentProcess()
        Local $acall = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetCurrentProcess

    Func _WinAPI_GetObject($hobject, $isize, $pobject)
        Local $acall = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hobject, "int", $isize, "struct*", $pobject)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetObject

    Func _WinAPI_GetObjectInfoByHandle($hobject)
        Local $tagpublic_object_basic_information = "ulong Attributes;ulong GrantedAcess;ulong HandleCount;ulong PointerCount;ulong Reserved[10]"
        Local $tpobi = DllStructCreate($tagpublic_object_basic_information)
        Local $acall = DllCall("ntdll.dll", "long", "ZwQueryObject", "handle", $hobject, "uint", 0x0, "struct*", $tpobi, "ulong", DllStructGetSize($tpobi), "ptr", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Local $aret[0x4]
        For $i = 0x0 To 0x3
            $aret[$i] = DllStructGetData($tpobi, $i + 0x1)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetObjectInfoByHandle

    Func _WinAPI_GetObjectNameByHandle($hobject)
        Local $tagunicode_string = "struct;ushort Length;ushort MaximumLength;ptr Buffer;endstruct"
        Local $tagpublic_object_type_information = "struct;" & $tagunicode_string & ";ulong Reserved[22];endstruct"
        Local $tpoti = DllStructCreate($tagpublic_object_type_information & ";byte[32]")
        Local $acall = DllCall("ntdll.dll", "long", "ZwQueryObject", "handle", $hobject, "uint", 0x2, "struct*", $tpoti, "ulong", DllStructGetSize($tpoti), "ulong*", 0x0)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Local $pdata = DllStructGetData($tpoti, 0x3)
        If Not $pdata Then Return SetError(0xb, 0x0, '')
        Return _WinAPI_GetString($pdata)
    EndFunc    ; -> _WinAPI_GetObjectNameByHandle

    Func _WinAPI_GetObjectType($hobject)
        Local $acall = DllCall("gdi32.dll", "dword", "GetObjectType", "handle", $hobject)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetObjectType

    Func _WinAPI_GetStdHandle($istdhandle)
        If $istdhandle < 0x0 Or $istdhandle > 0x2 Then Return SetError(0x2, 0x0, + -1)
        Local Const $AHANDLE[0x3] = [+ -10, + -11, + -12]
        Local $acall = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $AHANDLE[$istdhandle])
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetStdHandle

    Func _WinAPI_GetStockObject($iobject)
        Local $acall = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iobject)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetStockObject

    Func _WinAPI_SelectObject($hdc, $hgdiobj)
        Local $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $hgdiobj)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SelectObject

    Func _WinAPI_SetHandleInformation($hobject, $imask, $IFLAGS)
        Local $acall = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hobject, "dword", $imask, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetHandleInformation

#EndRegion Public Functions
#Region Global Variables and Constants
    Global Const $TAGNUMBERFMT = "uint NumDigits;uint LeadingZero;uint Grouping;ptr DecimalSep;ptr ThousandSep;uint NegativeOrder"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_CompareString($ilcid, $sstring1, $sstring2, $IFLAGS = 0x0)
        Local $acall = DllCall("kernel32.dll", "int", "CompareStringW", "dword", $ilcid, "dword", $IFLAGS, "wstr", $sstring1, "int", + -1, "wstr", $sstring2, "int", + -1)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CompareString

    Func _WinAPI_CreateNumberFormatInfo($inumdigits, $ileadingzero, $igrouping, $sdecimalsep, $sthousandsep, $inegativeorder)
        Local $tfmt = DllStructCreate($TAGNUMBERFMT & ";wchar[" & (StringLen($sdecimalsep) + 0x1) & "];wchar[" & (StringLen($sthousandsep) + 0x1) & "]")
        DllStructSetData($tfmt, 0x1, $inumdigits)
        DllStructSetData($tfmt, 0x2, $ileadingzero)
        DllStructSetData($tfmt, 0x3, $igrouping)
        DllStructSetData($tfmt, 0x4, DllStructGetPtr($tfmt, 0x7))
        DllStructSetData($tfmt, 0x5, DllStructGetPtr($tfmt, 0x8))
        DllStructSetData($tfmt, 0x6, $inegativeorder)
        DllStructSetData($tfmt, 0x7, $sdecimalsep)
        DllStructSetData($tfmt, 0x8, $sthousandsep)
        Return $tfmt
    EndFunc    ; -> _WinAPI_CreateNumberFormatInfo

    Func _WinAPI_EnumSystemGeoID()
        Local $henumproc = DllCallbackRegister("__EnumGeoIDProc", "bool", "long")
        Dim $__g_venum[0x65] = [0x0]
        Local $acall = DllCall("kernel32.dll", "bool", "EnumSystemGeoID", "dword", 0x10, "long", 0x0, "ptr", DllCallbackGetPtr($henumproc))
        If @error Or Not $acall[0x0] Or Not $__g_venum[0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumSystemGeoID

    Func _WinAPI_EnumSystemLocales($IFLAG)
        Local $henumproc = DllCallbackRegister("__EnumLocalesProc", "bool", "ptr")
        Dim $__g_venum[0x65] = [0x0]
        Local $acall = DllCall("kernel32.dll", "bool", "EnumSystemLocalesW", "ptr", DllCallbackGetPtr($henumproc), "dword", $IFLAG)
        If @error Or Not $acall[0x0] Or Not $__g_venum[0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumSystemLocales

    Func _WinAPI_EnumUILanguages($IFLAG = 0x0)
        Local $henumproc = DllCallbackRegister("__EnumUILanguagesProc", "bool", "ptr;long_ptr")
        Local $iid = 0x1
        If _WinAPI_GetVersion() >= 6 Then
            If BitAND($IFLAG, 0x8) Then
                $iid = 0x0
            EndIf
        Else
            $IFLAG = 0x0
        EndIf
        Dim $__g_venum[0x65] = [0x0]
        Local $acall = DllCall("kernel32.dll", "bool", "EnumUILanguagesW", "ptr", DllCallbackGetPtr($henumproc), "dword", $IFLAG, "long_ptr", $iid)
        If @error Or Not $acall[0x0] Or Not $__g_venum[0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumUILanguages

    Func _WinAPI_GetDateFormat($ilcid = 0x0, $tsystemtime = 0x0, $IFLAGS = 0x0, $sformat = '')
        If Not $ilcid Then $ilcid = 0x400
        If Not StringStripWS($sformat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sformat = Null
        Local $acall = DllCall("kernel32.dll", "int", "GetDateFormatW", "dword", $ilcid, "dword", $IFLAGS, "struct*", $tsystemtime, "wstr", $sformat, "wstr", '', "int", 0x800)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_GetDateFormat

    Func _WinAPI_GetDurationFormat($ilcid, $iduration, $sformat = '')
        If Not $ilcid Then $ilcid = 0x400
        Local $pst, $ival
        If IsDllStruct($iduration) Then
            $pst = DllStructGetPtr($iduration)
            $ival = 0x0
        Else
            $pst = 0x0
            $ival = $iduration
        EndIf
        If Not StringStripWS($sformat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sformat = Null
        Local $acall = DllCall("kernel32.dll", "int", "GetDurationFormat", "dword", $ilcid, "dword", 0x0, "ptr", $pst, "uint64", $ival, "wstr", $sformat, "wstr", '', "int", 0x800)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x6]
    EndFunc    ; -> _WinAPI_GetDurationFormat

    Func _WinAPI_GetGeoInfo($igeoid, $itype, $ilanguage = 0x0)
        Local $acall = DllCall("kernel32.dll", "int", "GetGeoInfoW", "long", $igeoid, "dword", $itype, "wstr", '', "int", 0x1000, "word", $ilanguage)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_GetGeoInfo

    Func _WinAPI_GetLocaleInfo($ilcid, $itype)
        Local $acall = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", $ilcid, "dword", $itype, "wstr", '', "int", 0x800)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_GetLocaleInfo

    Func _WinAPI_GetNumberFormat($ilcid, $snumber, $tnumberfmt = 0x0)
        If Not $ilcid Then $ilcid = 0x400
        Local $acall = DllCall("kernel32.dll", "int", "GetNumberFormatW", "dword", $ilcid, "dword", 0x0, "wstr", $snumber, "struct*", $tnumberfmt, "wstr", '', "int", 0x800)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_GetNumberFormat

    Func _WinAPI_GetSystemDefaultLangID()
        Local $acall = DllCall("kernel32.dll", "word", "GetSystemDefaultLangID")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetSystemDefaultLangID

    Func _WinAPI_GetSystemDefaultLCID()
        Local $acall = DllCall("kernel32.dll", "dword", "GetSystemDefaultLCID")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetSystemDefaultLCID

    Func _WinAPI_GetSystemDefaultUILanguage()
        Local $acall = DllCall("kernel32.dll", "word", "GetSystemDefaultUILanguage")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetSystemDefaultUILanguage

    Func _WinAPI_GetThreadLocale()
        Local $acall = DllCall("kernel32.dll", "dword", "GetThreadLocale")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetThreadLocale

    Func _WinAPI_GetThreadUILanguage()
        Local $acall = DllCall("kernel32.dll", "word", "GetThreadUILanguage")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetThreadUILanguage

    Func _WinAPI_GetTimeFormat($ilcid = 0x0, $tsystemtime = 0x0, $IFLAGS = 0x0, $sformat = '')
        If Not $ilcid Then $ilcid = 0x400
        If Not StringStripWS($sformat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sformat = Null
        Local $acall = DllCall("kernel32.dll", "int", "GetTimeFormatW", "dword", $ilcid, "dword", $IFLAGS, "struct*", $tsystemtime, "wstr", $sformat, "wstr", '', "int", 0x800)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_GetTimeFormat

    Func _WinAPI_GetUserDefaultLangID()
        Local $acall = DllCall("kernel32.dll", "word", "GetUserDefaultLangID")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetUserDefaultLangID

    Func _WinAPI_GetUserDefaultLCID()
        Local $acall = DllCall("kernel32.dll", "dword", "GetUserDefaultLCID")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetUserDefaultLCID

    Func _WinAPI_GetUserDefaultUILanguage()
        Local $acall = DllCall("kernel32.dll", "word", "GetUserDefaultUILanguage")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetUserDefaultUILanguage

    Func _WinAPI_GetUserGeoID()
        Local $acall = DllCall("kernel32.dll", "long", "GetUserGeoID", "uint", 0x10)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetUserGeoID

    Func _WinAPI_IsValidLocale($ilcid, $IFLAG = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "IsValidLocale", "dword", $ilcid, "dword", $IFLAG)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsValidLocale

    Func _WinAPI_SetLocaleInfo($ilcid, $itype, $sdata)
        Local $acall = DllCall("kernel32.dll", "bool", "SetLocaleInfoW", "dword", $ilcid, "dword", $itype, "wstr", $sdata)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetLocaleInfo

    Func _WinAPI_SetThreadLocale($ilcid)
        Local $acall = DllCall("kernel32.dll", "bool", "SetThreadLocale", "dword", $ilcid)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetThreadLocale

    Func _WinAPI_SetThreadUILanguage($ilanguage)
        Local $acall = DllCall("kernel32.dll", "word", "SetThreadUILanguage", "word", $ilanguage)
        If @error Then Return SetError(@error, @extended, False)
        Return ($acall[0x0] = $acall[0x1])
    EndFunc    ; -> _WinAPI_SetThreadUILanguage

    Func _WinAPI_SetUserGeoID($igeoid)
        Local $acall = DllCall("kernel32.dll", "bool", "SetUserGeoID", "long", $igeoid)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetUserGeoID

#EndRegion Public Functions
#Region Internal Functions
    Func __EnumGeoIDProc($iid)
        __Inc($__g_venum)
        $__g_venum[$__g_venum[0x0]] = $iid
        Return 0x1
    EndFunc    ; -> __EnumGeoIDProc

    Func __EnumLocalesProc($PLOCALE)
        __Inc($__g_venum)
        $__g_venum[$__g_venum[0x0]] = Dec(DllStructGetData(DllStructCreate("wchar[" & (_WinAPI_StrLen($PLOCALE) + 0x1) & "]", $PLOCALE), 0x1))
        Return 0x1
    EndFunc    ; -> __EnumLocalesProc

    Func __EnumUILanguagesProc($PLANGUAGE, $iid)
        __Inc($__g_venum)
        $__g_venum[$__g_venum[0x0]] = DllStructGetData(DllStructCreate("wchar[" & (_WinAPI_StrLen($PLANGUAGE) + 0x1) & "]", $PLANGUAGE), 0x1)
        If $iid Then
            $__g_venum[$__g_venum[0x0]] = Dec($__g_venum[$__g_venum[0x0]])
        EndIf
        Return 0x1
    EndFunc    ; -> __EnumUILanguagesProc

#EndRegion Internal Functions
Func _DateAdd($stype, $inumber, $sdate)
    Local $astimepart[0x4]
    Local $asdatepart[0x4]
    Local $ijuliandate
    $stype = StringLeft($stype, 0x1)
    If StringInStr("D,M,Y,w,h,n,s", $stype) = 0x0 Or $stype = '' Then
        Return SetError(0x1, 0x0, 0x0)
    EndIf
    If Not StringIsInt($inumber) Then
        Return SetError(0x2, 0x0, 0x0)
    EndIf
    If Not _DateIsValid($sdate) Then
        Return SetError(0x3, 0x0, 0x0)
    EndIf
    _DateTimeSplit($sdate, $asdatepart, $astimepart)
    If $stype = "d" Or $stype = "w" Then
        If $stype = "w" Then $inumber = $inumber * 0x7
        $ijuliandate = _DateToDayValue($asdatepart[0x1], $asdatepart[0x2], $asdatepart[0x3]) + $inumber
        _DayValueToDate($ijuliandate, $asdatepart[0x1], $asdatepart[0x2], $asdatepart[0x3])
    EndIf
    If $stype = "m" Then
        $asdatepart[0x2] = $asdatepart[0x2] + $inumber
        While $asdatepart[0x2] > 0xc
            $asdatepart[0x2] = $asdatepart[0x2] + -12
            $asdatepart[0x1] = $asdatepart[0x1] + 0x1
        WEnd
        While $asdatepart[0x2] < 0x1
            $asdatepart[0x2] = $asdatepart[0x2] + 0xc
            $asdatepart[0x1] = $asdatepart[0x1] + -1
        WEnd
    EndIf
    If $stype = "y" Then
        $asdatepart[0x1] = $asdatepart[0x1] + $inumber
    EndIf
    If $stype = "h" Or $stype = "n" Or $stype = "s" Then
        Local $itimeval = _TimeToTicks($astimepart[0x1], $astimepart[0x2], $astimepart[0x3]) / 0x3e8
        If $stype = "h" Then $itimeval = $itimeval + $inumber * 0xe10
        If $stype = "n" Then $itimeval = $itimeval + $inumber * 0x3c
        If $stype = "s" Then $itimeval = $itimeval + $inumber
        Local $iday2add = Int($itimeval / (0x18 * 0x3c * 0x3c))
        $itimeval = $itimeval - $iday2add * 0x18 * 0x3c * 0x3c
        If $itimeval < 0x0 Then
            $iday2add = $iday2add + -1
            $itimeval = $itimeval + 0x18 * 0x3c * 0x3c
        EndIf
        $ijuliandate = _DateToDayValue($asdatepart[0x1], $asdatepart[0x2], $asdatepart[0x3]) + $iday2add
        _DayValueToDate($ijuliandate, $asdatepart[0x1], $asdatepart[0x2], $asdatepart[0x3])
        _TicksToTime($itimeval * 0x3e8, $astimepart[0x1], $astimepart[0x2], $astimepart[0x3])
    EndIf
    Local $inumdays = _DaysInMonth($asdatepart[0x1])
    If $inumdays[$asdatepart[0x2]] < $asdatepart[0x3] Then $asdatepart[0x3] = $inumdays[$asdatepart[0x2]]
    $sdate = $asdatepart[0x1] & "/" & StringRight("0" & $asdatepart[0x2], 0x2) & "/" & StringRight("0" & $asdatepart[0x3], 0x2)
    If $astimepart[0x0] > 0x0 Then
        If $astimepart[0x0] > 0x2 Then
            $sdate = $sdate & " " & StringRight("0" & $astimepart[0x1], 0x2) & ":" & StringRight("0" & $astimepart[0x2], 0x2) & ":" & StringRight("0" & $astimepart[0x3], 0x2)
        Else
            $sdate = $sdate & " " & StringRight("0" & $astimepart[0x1], 0x2) & ":" & StringRight("0" & $astimepart[0x2], 0x2)
        EndIf
    EndIf
    Return $sdate
EndFunc    ; -> _DateAdd

Func _DateDayOfWeek($idaynum, $iformat = Default)
    Local Const $MONDAY_IS_NO1 = 0x80
    If $iformat = Default Then $iformat = 0x0
    $idaynum = Int($idaynum)
    If $idaynum < 0x1 Or $idaynum > 0x7 Then Return SetError(0x1, 0x0, '')
    Local $tsystemtime = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($tsystemtime, "Year", BitAND($iformat, $MONDAY_IS_NO1) ? 0x7d7  : 0x7d6)
    DllStructSetData($tsystemtime, "Month", 0x1)
    DllStructSetData($tsystemtime, "Day", $idaynum)
    Return _WinAPI_GetDateFormat(BitAND($iformat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT  : $LOCALE_INVARIANT, $tsystemtime, 0x0, BitAND($iformat, $DMW_SHORTNAME) ? "ddd"  : "dddd")
EndFunc    ; -> _DateDayOfWeek

Func _DateDaysInMonth($iyear, $imonthnum)
    $imonthnum = Int($imonthnum)
    $iyear = Int($iyear)
    Return __DateIsMonth($imonthnum) And __DateIsYear($iyear) ? _DaysInMonth($iyear)[$imonthnum] : SetError(0x1, 0x0, 0x0)
EndFunc    ; -> _DateDaysInMonth

Func _DateDiff($stype, $sstartdate, $senddate)
    $stype = StringLeft($stype, 0x1)
    If StringInStr("d,m,y,w,h,n,s", $stype) = 0x0 Or $stype = '' Then
        Return SetError(0x1, 0x0, 0x0)
    EndIf
    If Not _DateIsValid($sstartdate) Then
        Return SetError(0x2, 0x0, 0x0)
    EndIf
    If Not _DateIsValid($senddate) Then
        Return SetError(0x3, 0x0, 0x0)
    EndIf
    Local $asstartdatepart[0x4], $asstarttimepart[0x4], $asenddatepart[0x4], $asendtimepart[0x4]
    _DateTimeSplit($sstartdate, $asstartdatepart, $asstarttimepart)
    _DateTimeSplit($senddate, $asenddatepart, $asendtimepart)
    Local $adaysdiff = _DateToDayValue($asenddatepart[0x1], $asenddatepart[0x2], $asenddatepart[0x3]) - _DateToDayValue($asstartdatepart[0x1], $asstartdatepart[0x2], $asstartdatepart[0x3])
    Local $itimediff, $iyeardiff, $istarttimeinsecs, $iendtimeinsecs
    If $asstarttimepart[0x0] > 0x1 And $asendtimepart[0x0] > 0x1 Then
        $istarttimeinsecs = $asstarttimepart[0x1] * 0xe10 + $asstarttimepart[0x2] * 0x3c + $asstarttimepart[0x3]
        $iendtimeinsecs = $asendtimepart[0x1] * 0xe10 + $asendtimepart[0x2] * 0x3c + $asendtimepart[0x3]
        $itimediff = $iendtimeinsecs - $istarttimeinsecs
        If $itimediff < 0x0 Then
            $adaysdiff = $adaysdiff + -1
            $itimediff = $itimediff + 0x18 * 0x3c * 0x3c
        EndIf
    Else
        $itimediff = 0x0
    EndIf
    Select
    Case $stype = "d"
        Return $adaysdiff
    Case $stype = "m"
        $iyeardiff = $asenddatepart[0x1] - $asstartdatepart[0x1]
        Local $imonthdiff = $asenddatepart[0x2] - $asstartdatepart[0x2] + $iyeardiff * 0xc
        If $asenddatepart[0x3] < $asstartdatepart[0x3] Then $imonthdiff = $imonthdiff + -1
        $istarttimeinsecs = $asstarttimepart[0x1] * 0xe10 + $asstarttimepart[0x2] * 0x3c + $asstarttimepart[0x3]
        $iendtimeinsecs = $asendtimepart[0x1] * 0xe10 + $asendtimepart[0x2] * 0x3c + $asendtimepart[0x3]
        $itimediff = $iendtimeinsecs - $istarttimeinsecs
        If $asenddatepart[0x3] = $asstartdatepart[0x3] And $itimediff < 0x0 Then $imonthdiff = $imonthdiff + -1
        Return $imonthdiff
    Case $stype = "y"
        $iyeardiff = $asenddatepart[0x1] - $asstartdatepart[0x1]
        If $asenddatepart[0x2] < $asstartdatepart[0x2] Then $iyeardiff = $iyeardiff + -1
        If $asenddatepart[0x2] = $asstartdatepart[0x2] And $asenddatepart[0x3] < $asstartdatepart[0x3] Then $iyeardiff = $iyeardiff + -1
        $istarttimeinsecs = $asstarttimepart[0x1] * 0xe10 + $asstarttimepart[0x2] * 0x3c + $asstarttimepart[0x3]
        $iendtimeinsecs = $asendtimepart[0x1] * 0xe10 + $asendtimepart[0x2] * 0x3c + $asendtimepart[0x3]
        $itimediff = $iendtimeinsecs - $istarttimeinsecs
        If $asenddatepart[0x2] = $asstartdatepart[0x2] And $asenddatepart[0x3] = $asstartdatepart[0x3] And $itimediff < 0x0 Then $iyeardiff = $iyeardiff + -1
        Return $iyeardiff
    Case $stype = "w"
        Return Int($adaysdiff / 0x7)
    Case $stype = "h"
        Return $adaysdiff * 0x18 + Int($itimediff / 0xe10)
    Case $stype = "n"
        Return $adaysdiff * 0x18 * 0x3c + Int($itimediff / 0x3c)
    Case $stype = "s"
        Return $adaysdiff * 0x18 * 0x3c * 0x3c + $itimediff
    EndSelect
EndFunc    ; -> _DateDiff

Func _DateIsLeapYear($iyear)
    If StringIsInt($iyear) Then
        Select
        Case Mod($iyear, 0x4) = 0x0 And Mod($iyear, 0x64) <> 0x0
            Return 0x1
        Case Mod($iyear, 0x190) = 0x0
            Return 0x1
        Case Else
            Return 0x0
        EndSelect
    EndIf
    Return SetError(0x1, 0x0, 0x0)
EndFunc    ; -> _DateIsLeapYear

Func __DateIsMonth($inumber)
    $inumber = Int($inumber)
    Return $inumber >= 0x1 And $inumber <= 0xc
EndFunc    ; -> __DateIsMonth

Func _DateIsValid($sdate)
    Local $asdatepart[0x4], $astimepart[0x4]
    _DateTimeSplit($sdate, $asdatepart, $astimepart)
    If @error Then Return 0x0
    If Not StringIsInt($asdatepart[0x1]) Then Return 0x0
    If Not StringIsInt($asdatepart[0x2]) Then Return 0x0
    If Not StringIsInt($asdatepart[0x3]) Then Return 0x0
    $asdatepart[0x1] = Int($asdatepart[0x1])
    $asdatepart[0x2] = Int($asdatepart[0x2])
    $asdatepart[0x3] = Int($asdatepart[0x3])
    Local $inumdays = _DaysInMonth($asdatepart[0x1])
    If $asdatepart[0x1] < 0x3e8 Or $asdatepart[0x1] > 0xbb7 Then Return 0x0
    If $asdatepart[0x2] < 0x1 Or $asdatepart[0x2] > 0xc Then Return 0x0
    If $asdatepart[0x3] < 0x1 Or $asdatepart[0x3] > $inumdays[$asdatepart[0x2]] Then Return 0x0
    If $astimepart[0x0] < 0x1 Then Return 0x1
    If $astimepart[0x0] < 0x2 Then Return 0x0
    If $astimepart[0x0] = 0x2 Then $astimepart[0x3] = "00"
    If Not StringIsInt($astimepart[0x1]) Then Return 0x0
    If Not StringIsInt($astimepart[0x2]) Then Return 0x0
    If Not StringIsInt($astimepart[0x3]) Then Return 0x0
    $astimepart[0x1] = Int($astimepart[0x1])
    $astimepart[0x2] = Int($astimepart[0x2])
    $astimepart[0x3] = Int($astimepart[0x3])
    If $astimepart[0x1] < 0x0 Or $astimepart[0x1] > 0x17 Then Return 0x0
    If $astimepart[0x2] < 0x0 Or $astimepart[0x2] > 0x3b Then Return 0x0
    If $astimepart[0x3] < 0x0 Or $astimepart[0x3] > 0x3b Then Return 0x0
    Return 0x1
EndFunc    ; -> _DateIsValid

Func __DateIsYear($inumber)
    Return StringLen($inumber) = 0x4
EndFunc    ; -> __DateIsYear

Func _DateLastWeekdayNum($iweekdaynum)
    Select
    Case Not StringIsInt($iweekdaynum)
        Return SetError(0x1, 0x0, 0x0)
    Case $iweekdaynum < 0x1 Or $iweekdaynum > 0x7
        Return SetError(0x2, 0x0, 0x0)
    Case Else
        Local $ilastweekdaynum
        If $iweekdaynum = 0x1 Then
            $ilastweekdaynum = 0x7
        Else
            $ilastweekdaynum = $iweekdaynum + -1
        EndIf
        Return $ilastweekdaynum
    EndSelect
EndFunc    ; -> _DateLastWeekdayNum

Func _DateLastMonthNum($imonthnum)
    Select
    Case Not StringIsInt($imonthnum)
        Return SetError(0x1, 0x0, 0x0)
    Case Not __DateIsMonth($imonthnum)
        Return SetError(0x2, 0x0, 0x0)
    Case Else
        Local $ilastmonthnum
        If $imonthnum = 0x1 Then
            $ilastmonthnum = 0xc
        Else
            $ilastmonthnum = $imonthnum + -1
        EndIf
        $ilastmonthnum = StringFormat("%02d", $ilastmonthnum)
        Return $ilastmonthnum
    EndSelect
EndFunc    ; -> _DateLastMonthNum

Func _DateLastMonthYear($imonthnum, $iyear)
    Select
    Case Not StringIsInt($imonthnum) Or Not StringIsInt($iyear)
        Return SetError(0x1, 0x0, 0x0)
    Case Not __DateIsMonth($imonthnum)
        Return SetError(0x2, 0x0, 0x0)
    Case Else
        Local $ilastyear
        If $imonthnum = 0x1 Then
            $ilastyear = $iyear + -1
        Else
            $ilastyear = $iyear
        EndIf
        $ilastyear = StringFormat("%04d", $ilastyear)
        Return $ilastyear
    EndSelect
EndFunc    ; -> _DateLastMonthYear

Func _DateNextWeekdayNum($iweekdaynum)
    Select
    Case Not StringIsInt($iweekdaynum)
        Return SetError(0x1, 0x0, 0x0)
    Case $iweekdaynum < 0x1 Or $iweekdaynum > 0x7
        Return SetError(0x2, 0x0, 0x0)
    Case Else
        Local $inextweekdaynum
        If $iweekdaynum = 0x7 Then
            $inextweekdaynum = 0x1
        Else
            $inextweekdaynum = $iweekdaynum + 0x1
        EndIf
        Return $inextweekdaynum
    EndSelect
EndFunc    ; -> _DateNextWeekdayNum

Func _DateNextMonthNum($imonthnum)
    Select
    Case Not StringIsInt($imonthnum)
        Return SetError(0x1, 0x0, 0x0)
    Case Not __DateIsMonth($imonthnum)
        Return SetError(0x2, 0x0, 0x0)
    Case Else
        Local $inextmonthnum
        If $imonthnum = 0xc Then
            $inextmonthnum = 0x1
        Else
            $inextmonthnum = $imonthnum + 0x1
        EndIf
        $inextmonthnum = StringFormat("%02d", $inextmonthnum)
        Return $inextmonthnum
    EndSelect
EndFunc    ; -> _DateNextMonthNum

Func _DateNextMonthYear($imonthnum, $iyear)
    Select
    Case Not StringIsInt($imonthnum) Or Not StringIsInt($iyear)
        Return SetError(0x1, 0x0, 0x0)
    Case Not __DateIsMonth($imonthnum)
        Return SetError(0x2, 0x0, 0x0)
    Case Else
        Local $inextyear
        If $imonthnum = 0xc Then
            $inextyear = $iyear + 0x1
        Else
            $inextyear = $iyear
        EndIf
        $inextyear = StringFormat("%04d", $inextyear)
        Return $inextyear
    EndSelect
EndFunc    ; -> _DateNextMonthYear

Func _DateTimeFormat($sdate, $stype)
    Local $asdatepart[0x4], $astimepart[0x4]
    Local $stempdate = '', $stemptime = ''
    Local $sam, $spm, $stempstring = ''
    If Not _DateIsValid($sdate) Then
        Return SetError(0x1, 0x0, '')
    EndIf
    If $stype < 0x0 Or $stype > 0x5 Or Not IsInt($stype) Then
        Return SetError(0x2, 0x0, '')
    EndIf
    _DateTimeSplit($sdate, $asdatepart, $astimepart)
    Switch $stype
    Case 0x0
        $stempstring = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
        If Not @error And Not ($stempstring = '') Then
            $stempdate = $stempstring
        Else
            $stempdate = "M/d/yyyy"
        EndIf
        If $astimepart[0x0] > 0x1 Then
            $stempstring = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
            If Not @error And Not ($stempstring = '') Then
                $stemptime = $stempstring
            Else
                $stemptime = "h:mm:ss tt"
            EndIf
        EndIf
    Case 0x1
        $stempstring = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SLONGDATE)
        If Not @error And Not ($stempstring = '') Then
            $stempdate = $stempstring
        Else
            $stempdate = "dddd, MMMM dd, yyyy"
        EndIf
    Case 0x2
        $stempstring = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
        If Not @error And Not ($stempstring = '') Then
            $stempdate = $stempstring
        Else
            $stempdate = "M/d/yyyy"
        EndIf
    Case 0x3
        If $astimepart[0x0] > 0x1 Then
            $stempstring = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
            If Not @error And Not ($stempstring = '') Then
                $stemptime = $stempstring
            Else
                $stemptime = "h:mm:ss tt"
            EndIf
        EndIf
    Case 0x4
        If $astimepart[0x0] > 0x1 Then
            $stemptime = "hh:mm"
        EndIf
    Case 0x5
        If $astimepart[0x0] > 0x1 Then
            $stemptime = "hh:mm:ss"
        EndIf
    EndSwitch
    If $stempdate <> '' Then
        $stempstring = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SDATE)
        If Not @error And Not ($stempstring = '') Then
            $stempdate = StringReplace($stempdate, "/", $stempstring)
        EndIf
        Local $iwday = _DateToDayOfWeek($asdatepart[0x1], $asdatepart[0x2], $asdatepart[0x3])
        $asdatepart[0x3] = StringRight("0" & $asdatepart[0x3], 0x2)
        $asdatepart[0x2] = StringRight("0" & $asdatepart[0x2], 0x2)
        $stempdate = StringReplace($stempdate, "d", "@")
        $stempdate = StringReplace($stempdate, "m", "#")
        $stempdate = StringReplace($stempdate, "y", "&")
        $stempdate = StringReplace($stempdate, "@@@@", _DateDayOfWeek($iwday, 0x0))
        $stempdate = StringReplace($stempdate, "@@@", _DateDayOfWeek($iwday, 0x1))
        $stempdate = StringReplace($stempdate, "@@", $asdatepart[0x3])
        $stempdate = StringReplace($stempdate, "@", StringReplace(StringLeft($asdatepart[0x3], 0x1), "0", '') & StringRight($asdatepart[0x3], 0x1))
        $stempdate = StringReplace($stempdate, "####", _DateToMonth($asdatepart[0x2], 0x0))
        $stempdate = StringReplace($stempdate, "###", _DateToMonth($asdatepart[0x2], 0x1))
        $stempdate = StringReplace($stempdate, "##", $asdatepart[0x2])
        $stempdate = StringReplace($stempdate, "#", StringReplace(StringLeft($asdatepart[0x2], 0x1), "0", '') & StringRight($asdatepart[0x2], 0x1))
        $stempdate = StringReplace($stempdate, "&&&&", $asdatepart[0x1])
        $stempdate = StringReplace($stempdate, "&&", StringRight($asdatepart[0x1], 0x2))
    EndIf
    If $stemptime <> '' Then
        $stempstring = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S1159)
        If Not @error And Not ($stempstring = '') Then
            $sam = $stempstring
        Else
            $sam = "AM"
        EndIf
        $stempstring = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S2359)
        If Not @error And Not ($stempstring = '') Then
            $spm = $stempstring
        Else
            $spm = "PM"
        EndIf
        $stempstring = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIME)
        If Not @error And Not ($stempstring = '') Then
            $stemptime = StringReplace($stemptime, ":", $stempstring)
        EndIf
        If StringInStr($stemptime, "tt") Then
            If $astimepart[0x1] < 0xc Then
                $stemptime = StringReplace($stemptime, "tt", $sam)
                If $astimepart[0x1] = 0x0 Then $astimepart[0x1] = 0xc
            Else
                $stemptime = StringReplace($stemptime, "tt", $spm)
                If $astimepart[0x1] > 0xc Then $astimepart[0x1] = $astimepart[0x1] + -12
            EndIf
        EndIf
        $astimepart[0x1] = StringRight("0" & $astimepart[0x1], 0x2)
        $astimepart[0x2] = StringRight("0" & $astimepart[0x2], 0x2)
        $astimepart[0x3] = StringRight("0" & $astimepart[0x3], 0x2)
        $stemptime = StringReplace($stemptime, "hh", StringFormat("%02d", $astimepart[0x1]))
        $stemptime = StringReplace($stemptime, "h", StringReplace(StringLeft($astimepart[0x1], 0x1), "0", '') & StringRight($astimepart[0x1], 0x1))
        $stemptime = StringReplace($stemptime, "mm", StringFormat("%02d", $astimepart[0x2]))
        $stemptime = StringReplace($stemptime, "ss", StringFormat("%02d", $astimepart[0x3]))
        $stempdate = StringStripWS($stempdate & " " & $stemptime, $STR_STRIPLEADING + $STR_STRIPTRAILING)
    EndIf
    Return $stempdate
EndFunc    ; -> _DateTimeFormat

Func _DateTimeSplit($sdate, ByRef $adatepart, ByRef $atimepart)
    Local $sdatetime = StringSplit($sdate, " T")
    If $sdatetime[0x0] > 0x0 Then $adatepart = StringSplit($sdatetime[0x1], "/-.")
    Local $nfields = UBound($adatepart)
    If $nfields <> 0x4 Then Return SetError(0x1, 0x0, 0x0)
    If $sdatetime[0x0] > 0x1 Then
        $atimepart = StringSplit($sdatetime[0x2], ":")
        $nfields = UBound($atimepart)
        If ($nfields < 0x3) Or ($nfields > 0x4) Then Return SetError(0x2, 0x0, 0x0)
        If $nfields < 0x4 Then
            ReDim $atimepart[0x4]
            $atimepart[0x3] = 0x0
        EndIf
    Else
        Dim $atimepart[0x4]
    EndIf
    For $x = 0x1 To 0x3
        $adatepart[$x] = Int($adatepart[$x])
        $atimepart[$x] = Int($atimepart[$x])
    Next
    Return 0x1
EndFunc    ; -> _DateTimeSplit

Func _DateToDayOfWeek($iyear, $imonth, $iday)
    If Not _DateIsValid($iyear & "/" & $imonth & "/" & $iday) Then
        Return SetError(0x1, 0x0, '')
    EndIf
    Local $i_factora = Int((0xe - $imonth) / 0xc)
    Local $i_factory = $iyear - $i_factora
    Local $i_factorm = $imonth + (0xc * $i_factora) + -2
    Local $i_factord = Mod($iday + $i_factory + Int($i_factory / 0x4) - Int($i_factory / 0x64) + Int($i_factory / 0x190) + Int((0x1f * $i_factorm) / 0xc), 0x7)
    Return $i_factord + 0x1
EndFunc    ; -> _DateToDayOfWeek

Func _DateToDayOfWeekISO($iyear, $imonth, $iday)
    Local $idow = _DateToDayOfWeek($iyear, $imonth, $iday)
    If @error Then
        Return SetError(0x1, 0x0, '')
    EndIf
    If $idow >= 0x2 Then Return $idow + -1
    Return 0x7
EndFunc    ; -> _DateToDayOfWeekISO

Func _DateToDayValue($iyear, $imonth, $iday)
    If Not _DateIsValid(StringFormat("%04d/%02d/%02d", $iyear, $imonth, $iday)) Then
        Return SetError(0x1, 0x0, '')
    EndIf
    If $imonth < 0x3 Then
        $imonth = $imonth + 0xc
        $iyear = $iyear + -1
    EndIf
    Local $i_factora = Int($iyear / 0x64)
    Local $i_factorb = Int($i_factora / 0x4)
    Local $i_factorc = 0x2 - $i_factora + $i_factorb
    Local $i_factore = Int(0x5b5 * ($iyear + 0x126c) / 0x4)
    Local $i_factorf = Int(0x99 * ($imonth + 0x1) / 0x5)
    Local $ijuliandate = $i_factorc + $iday + $i_factore + $i_factorf + -1524.5
    Return $ijuliandate
EndFunc    ; -> _DateToDayValue

Func _DateToMonth($imonnum, $iformat = Default)
    If $iformat = Default Then $iformat = 0x0
    $imonnum = Int($imonnum)
    If Not __DateIsMonth($imonnum) Then Return SetError(0x1, 0x0, '')
    Local $tsystemtime = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($tsystemtime, "Year", @YEAR)
    DllStructSetData($tsystemtime, "Month", $imonnum)
    DllStructSetData($tsystemtime, "Day", 0x1)
    Return _WinAPI_GetDateFormat(BitAND($iformat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT  : $LOCALE_INVARIANT, $tsystemtime, 0x0, BitAND($iformat, $DMW_SHORTNAME) ? "MMM"  : "MMMM")
EndFunc    ; -> _DateToMonth

Func _DayValueToDate($ijuliandate, ByRef $iyear, ByRef $imonth, ByRef $iday)
    If $ijuliandate < 0x0 Or Not IsNumber($ijuliandate) Then
        Return SetError(0x1, 0x0, 0x0)
    EndIf
    Local $i_factorz = Int($ijuliandate + 0.5)
    Local $i_factorw = Int(($i_factorz + -1.86721625e+06) / 36524.25)
    Local $i_factorx = Int($i_factorw / 0x4)
    Local $i_factora = $i_factorz + 0x1 + $i_factorw - $i_factorx
    Local $i_factorb = $i_factora + 0x5f4
    Local $i_factorc = Int(($i_factorb + -122.1) / 365.25)
    Local $i_factord = Int(365.25 * $i_factorc)
    Local $i_factore = Int(($i_factorb - $i_factord) / 30.6001)
    Local $i_factorf = Int(30.6001 * $i_factore)
    $iday = $i_factorb - $i_factord - $i_factorf
    If $i_factore + -1 < 0xd Then
        $imonth = $i_factore + -1
    Else
        $imonth = $i_factore + -13
    EndIf
    If $imonth < 0x3 Then
        $iyear = $i_factorc + -4715
    Else
        $iyear = $i_factorc + -4716
    EndIf
    $iyear = StringFormat("%04d", $iyear)
    $imonth = StringFormat("%02d", $imonth)
    $iday = StringFormat("%02d", $iday)
    Return $iyear & "/" & $imonth & "/" & $iday
EndFunc    ; -> _DayValueToDate

Func _Date_JulianDayNo($iyear, $imonth, $iday)
    Local $sfulldate = StringFormat("%04d/%02d/%02d", $iyear, $imonth, $iday)
    If Not _DateIsValid($sfulldate) Then
        Return SetError(0x1, 0x0, '')
    EndIf
    Local $ijday = 0x0
    Local $aidaysinmonth = _DaysInMonth($iyear)
    For $icntr = 0x1 To $imonth + -1
        $ijday = $ijday + $aidaysinmonth[$icntr]
    Next
    $ijday = ($iyear * 0x3e8) + ($ijday + $iday)
    Return $ijday
EndFunc    ; -> _Date_JulianDayNo

Func _JulianToDate($ijday, $ssep = "/")
    Local $iyear = Int($ijday / 0x3e8)
    Local $idays = Mod($ijday, 0x3e8)
    Local $imaxdays = 0x16d
    If _DateIsLeapYear($iyear) Then $imaxdays = 0x16e
    If $idays > $imaxdays Then
        Return SetError(0x1, 0x0, '')
    EndIf
    Local $aidaysinmonth = _DaysInMonth($iyear)
    Local $imonth = 0x1
    While $idays > $aidaysinmonth[$imonth]
        $idays = $idays - $aidaysinmonth[$imonth]
        $imonth = $imonth + 0x1
    WEnd
    Return StringFormat("%04d%s%02d%s%02d", $iyear, $ssep, $imonth, $ssep, $idays)
EndFunc    ; -> _JulianToDate

Func _Now()
    Local $tlocaltime = _Date_Time_GetLocalTime()
    If @error Then Return SetError(@error, @extended, 0x0)
    Return _DateTimeFormat($tlocaltime.Year & "/" & $tlocaltime.Month & "/" & $tlocaltime.Day & " " & $tlocaltime.Hour & ":" & $tlocaltime.Minute & ":" & $tlocaltime.Second, 0x0)
EndFunc    ; -> _Now

Func _NowCalc()
    Local $tlocaltime = _Date_Time_GetLocalTime()
    If @error Then Return SetError(@error, @extended, '')
    Return $tlocaltime.Year & "/" & StringRight("00" & $tlocaltime.Month, 0x2) & "/" & StringRight("00" & $tlocaltime.Day, 0x2) & " " & StringRight("00" & $tlocaltime.Hour, 0x2) & ":" & StringRight("00" & $tlocaltime.Minute, 0x2) & ":" & StringRight("00" & $tlocaltime.Second, 0x2)
EndFunc    ; -> _NowCalc

Func _NowCalcDate()
    Local $tlocaltime = _Date_Time_GetLocalTime()
    If @error Then Return SetError(@error, @extended, '')
    Return $tlocaltime.Year & "/" & StringRight("00" & $tlocaltime.Month, 0x2) & "/" & StringRight("00" & $tlocaltime.Day, 0x2)
EndFunc    ; -> _NowCalcDate

Func _NowDate()
    Local $tlocaltime = _Date_Time_GetLocalTime()
    If @error Then Return SetError(@error, @extended, '')
    Return _DateTimeFormat($tlocaltime.Year & "/" & $tlocaltime.Month & "/" & $tlocaltime.Day, 0x0)
EndFunc    ; -> _NowDate

Func _NowTime($stype = 0x3)
    If $stype < 0x3 Or $stype > 0x5 Then $stype = 0x3
    Local $tlocaltime = _Date_Time_GetLocalTime()
    If @error Then Return SetError(@error, @extended, '')
    Return _DateTimeFormat($tlocaltime.Year & "/" & $tlocaltime.Month & "/" & $tlocaltime.Day & " " & $tlocaltime.Hour & ":" & $tlocaltime.Minute & ":" & $tlocaltime.Second, $stype)
EndFunc    ; -> _NowTime

Func _SetDate($iday, $imonth = 0x0, $iyear = 0x0)
    If $iyear = 0x0 Then $iyear = @YEAR
    If $imonth = 0x0 Then $imonth = @MON
    If Not _DateIsValid($iyear & "/" & $imonth & "/" & $iday) Then Return 0x1
    Local $tsystemtime = DllStructCreate($TAGSYSTEMTIME)
    DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tsystemtime)
    If @error Then Return SetError(@error, @extended, 0x0)
    DllStructSetData($tsystemtime, "Day", $iday)
    If $imonth > 0x0 Then DllStructSetData($tsystemtime, "Month", $imonth)
    If $iyear > 0x0 Then DllStructSetData($tsystemtime, "Year", $iyear)
    Local $ireturn = _Date_Time_SetLocalTime($tsystemtime)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return Int($ireturn)
EndFunc    ; -> _SetDate

Func _SetTime($ihour, $iminute, $isecond = 0x0, $imseconds = 0x0)
    If $ihour < 0x0 Or $ihour > 0x17 Then Return 0x1
    If $iminute < 0x0 Or $iminute > 0x3b Then Return 0x1
    If $isecond < 0x0 Or $isecond > 0x3b Then Return 0x1
    If $imseconds < 0x0 Or $imseconds > 0x3e7 Then Return 0x1
    Local $tsystemtime = DllStructCreate($TAGSYSTEMTIME)
    DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tsystemtime)
    If @error Then Return SetError(@error, @extended, 0x0)
    DllStructSetData($tsystemtime, "Hour", $ihour)
    DllStructSetData($tsystemtime, "Minute", $iminute)
    If $isecond > 0x0 Then DllStructSetData($tsystemtime, "Second", $isecond)
    If $imseconds > 0x0 Then DllStructSetData($tsystemtime, "MSeconds", $imseconds)
    Local $ireturn = _Date_Time_SetLocalTime($tsystemtime)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return Int($ireturn)
EndFunc    ; -> _SetTime

Func _TicksToTime($iticks, ByRef $ihours, ByRef $imins, ByRef $isecs)
    If Number($iticks) > 0x0 Then
        $iticks = Int($iticks / 0x3e8)
        $ihours = Int($iticks / 0xe10)
        $iticks = Mod($iticks, 0xe10)
        $imins = Int($iticks / 0x3c)
        $isecs = Mod($iticks, 0x3c)
        Return 0x1
    ElseIf Number($iticks) = 0x0 Then
        $ihours = 0x0
        $iticks = 0x0
        $imins = 0x0
        $isecs = 0x0
        Return 0x1
    Else
        Return SetError(0x1, 0x0, 0x0)
    EndIf
EndFunc    ; -> _TicksToTime

Func _TimeToTicks($ihours = Default, $imins = Default, $isecs = Default)
    If $ihours = Default Or $imins = Default Or $isecs = Default Then
        Local $tlocaltime = _Date_Time_GetLocalTime()
        If @error Then Return SetError(@error, @extended, 0x0)
        If $ihours = Default Then $ihours = $tlocaltime.Hour
        If $imins = Default Then $imins = $tlocaltime.Minute
        If $isecs = Default Then $isecs = $tlocaltime.Second
    EndIf
    If StringIsInt($ihours) And StringIsInt($imins) And StringIsInt($isecs) Then
        Local $iticks = 0x3e8 * ((0xe10 * $ihours) + (0x3c * $imins) + $isecs)
        Return $iticks
    Else
        Return SetError(0x1, 0x0, 0x0)
    EndIf
EndFunc    ; -> _TimeToTicks

Func _WeekNumberISO($iyear = Default, $imonth = Default, $iday = Default)
    If $iyear = Default Or $imonth = Default Or $iday = Default Then
        Local $tlocaltime = _Date_Time_GetLocalTime()
        If @error Then Return SetError(@error, @extended, 0x0)
        If $iyear = Default Then $iyear = $tlocaltime.Year
        If $imonth = Default Then $imonth = $tlocaltime.Month
        If $iday = Default Then $iday = $tlocaltime.Day
    EndIf
    If $iday > 0x1f Or $iday < 0x1 Then
        Return SetError(0x1, 0x0, + -1)
    ElseIf Not __DateIsMonth($imonth) Then
        Return SetError(0x2, 0x0, + -1)
    ElseIf $iyear < 0x1 Or $iyear > 0xbb7 Then
        Return SetError(0x3, 0x0, + -1)
    EndIf
    Local $idow = _DateToDayOfWeekISO($iyear, $imonth, $iday) + -1
    Local $idow0101 = _DateToDayOfWeekISO($iyear, 0x1, 0x1) + -1
    If ($imonth = 0x1 And 0x3 < $idow0101 And $idow0101 < 0x7 - ($iday + -1)) Then
        $idow = $idow0101 + -1
        $idow0101 = _DateToDayOfWeekISO($iyear + -1, 0x1, 0x1) + -1
        $imonth = 0xc
        $iday = 0x1f
        $iyear = $iyear + -1
    ElseIf ($imonth = 0xc And 0x1e - ($iday + -1) < _DateToDayOfWeekISO($iyear + 0x1, 0x1, 0x1) + -1 And _DateToDayOfWeekISO($iyear + 0x1, 0x1, 0x1) + -1 < 0x4) Then
        Return 0x1
    EndIf
    Return Int((_DateToDayOfWeekISO($iyear, 0x1, 0x1) + -1 < 0x4) + 0x4 * ($imonth + -1) + (0x2 * ($imonth + -1) + ($iday + -1) + $idow0101 - $idow + 0x6) * 0x24 / 0x100)
EndFunc    ; -> _WeekNumberISO

Func _WeekNumber($iyear = Default, $imonth = Default, $iday = Default, $iweekstart = 0x1)
    If $iyear = Default Or $imonth = Default Or $iday = Default Then
        Local $tlocaltime = _Date_Time_GetLocalTime()
        If @error Then Return SetError(@error, @extended, 0x0)
        If $iyear = Default Then $iyear = $tlocaltime.Year
        If $imonth = Default Then $imonth = $tlocaltime.Month
        If $iday = Default Then $iday = $tlocaltime.Day
    EndIf
    If $iweekstart = Default Then $iweekstart = 0x1
    If $iday > 0x1f Or $iday < 0x1 Then
        Return SetError(0x1, 0x0, + -1)
    ElseIf Not __DateIsMonth($imonth) Then
        Return SetError(0x3, 0x0, + -1)
    ElseIf $iyear < 0x1 Or $iyear > 0xbb7 Then
        Return SetError(0x4, 0x0, + -1)
    ElseIf $iweekstart < 0x1 Or $iweekstart > 0x2 Then
        Return SetError(0x2, 0x0, + -1)
    EndIf
    Local $istartweek1, $iendweek1
    Local $idow0101 = _DateToDayOfWeekISO($iyear, 0x1, 0x1)
    Local $idate = $iyear & "/" & $imonth & "/" & $iday
    If $iweekstart = 0x1 Then
        If $idow0101 = 0x6 Then
            $istartweek1 = 0x0
        Else
            $istartweek1 = + -1 * $idow0101 + -1
        EndIf
        $iendweek1 = $istartweek1 + 0x6
    Else
        $istartweek1 = $idow0101 * + -1
        $iendweek1 = $istartweek1 + 0x6
    EndIf
    Local $istartweek1ny
    Local $iendweek1date = _DateAdd("d", $iendweek1, $iyear & "/01/01")
    Local $idow0101ny = _DateToDayOfWeekISO($iyear + 0x1, 0x1, 0x1)
    If $iweekstart = 0x1 Then
        If $idow0101ny = 0x6 Then
            $istartweek1ny = 0x0
        Else
            $istartweek1ny = + -1 * $idow0101ny + -1
        EndIf
    Else
        $istartweek1ny = $idow0101ny * + -1
    EndIf
    Local $istartweek1dateny = _DateAdd("d", $istartweek1ny, $iyear + 0x1 & "/01/01")
    Local $icurrdatediff = _DateDiff("d", $iendweek1date, $idate) + -1
    Local $icurrdatediffny = _DateDiff("d", $istartweek1dateny, $idate)
    If $icurrdatediff >= 0x0 And $icurrdatediffny < 0x0 Then Return 0x2 + Int($icurrdatediff / 0x7)
    If $icurrdatediff < 0x0 Or $icurrdatediffny >= 0x0 Then Return 0x1
EndFunc    ; -> _WeekNumber

Func _DaysInMonth($iyear)
    Local $adays = [0xc, 0x1f, (_DateIsLeapYear($iyear) ? 0x1d  : 0x1c), 0x1f, 0x1e, 0x1f, 0x1e, 0x1f, 0x1f, 0x1e, 0x1f, 0x1e, 0x1f]
    Return $adays
EndFunc    ; -> _DaysInMonth

Func __Date_Time_CloneSystemTime($psystemtime)
    Local $tsystemtime1 = DllStructCreate($TAGSYSTEMTIME, $psystemtime)
    Local $tsystemtime2 = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($tsystemtime2, "Month", DllStructGetData($tsystemtime1, "Month"))
    DllStructSetData($tsystemtime2, "Day", DllStructGetData($tsystemtime1, "Day"))
    DllStructSetData($tsystemtime2, "Year", DllStructGetData($tsystemtime1, "Year"))
    DllStructSetData($tsystemtime2, "Hour", DllStructGetData($tsystemtime1, "Hour"))
    DllStructSetData($tsystemtime2, "Minute", DllStructGetData($tsystemtime1, "Minute"))
    DllStructSetData($tsystemtime2, "Second", DllStructGetData($tsystemtime1, "Second"))
    DllStructSetData($tsystemtime2, "MSeconds", DllStructGetData($tsystemtime1, "MSeconds"))
    DllStructSetData($tsystemtime2, "DOW", DllStructGetData($tsystemtime1, "DOW"))
    Return $tsystemtime2
EndFunc    ; -> __Date_Time_CloneSystemTime

Func _Date_Time_CompareFileTime($tfiletime1, $tfiletime2)
    Local $acall = DllCall("kernel32.dll", "long", "CompareFileTime", "struct*", $tfiletime1, "struct*", $tfiletime2)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _Date_Time_CompareFileTime

Func _Date_Time_DOSDateTimeToFileTime($ifatdate, $ifattime)
    Local $ttime = DllStructCreate($TAGFILETIME)
    Local $acall = DllCall("kernel32.dll", "bool", "DosDateTimeToFileTime", "word", $ifatdate, "word", $ifattime, "struct*", $ttime)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $ttime)
EndFunc    ; -> _Date_Time_DOSDateTimeToFileTime

Func _Date_Time_DOSDateToArray($idosdate)
    Local $adate[0x3]
    $adate[0x0] = BitAND($idosdate, 0x1f)
    $adate[0x1] = BitAND(BitShift($idosdate, 0x5), 0xf)
    $adate[0x2] = BitAND(BitShift($idosdate, 0x9), 0x3f) + 0x7bc
    Return $adate
EndFunc    ; -> _Date_Time_DOSDateToArray

Func _Date_Time_DOSDateTimeToArray($idosdate, $idostime)
    Local $adate[0x6]
    $adate[0x0] = BitAND($idosdate, 0x1f)
    $adate[0x1] = BitAND(BitShift($idosdate, 0x5), 0xf)
    $adate[0x2] = BitAND(BitShift($idosdate, 0x9), 0x3f) + 0x7bc
    $adate[0x5] = BitAND($idostime, 0x1f) * 0x2
    $adate[0x4] = BitAND(BitShift($idostime, 0x5), 0x3f)
    $adate[0x3] = BitAND(BitShift($idostime, 0xb), 0x1f)
    Return $adate
EndFunc    ; -> _Date_Time_DOSDateTimeToArray

Func _Date_Time_DOSDateTimeToStr($idosdate, $idostime)
    Local $adate = _Date_Time_DOSDateTimeToArray($idosdate, $idostime)
    Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $adate[0x0], $adate[0x1], $adate[0x2], $adate[0x3], $adate[0x4], $adate[0x5])
EndFunc    ; -> _Date_Time_DOSDateTimeToStr

Func _Date_Time_DOSDateToStr($idosdate)
    Local $adate = _Date_Time_DOSDateToArray($idosdate)
    Return StringFormat("%02d/%02d/%04d", $adate[0x0], $adate[0x1], $adate[0x2])
EndFunc    ; -> _Date_Time_DOSDateToStr

Func _Date_Time_DOSTimeToArray($idostime)
    Local $atime[0x3]
    $atime[0x2] = BitAND($idostime, 0x1f) * 0x2
    $atime[0x1] = BitAND(BitShift($idostime, 0x5), 0x3f)
    $atime[0x0] = BitAND(BitShift($idostime, 0xb), 0x1f)
    Return $atime
EndFunc    ; -> _Date_Time_DOSTimeToArray

Func _Date_Time_DOSTimeToStr($idostime)
    Local $atime = _Date_Time_DOSTimeToArray($idostime)
    Return StringFormat("%02d:%02d:%02d", $atime[0x0], $atime[0x1], $atime[0x2])
EndFunc    ; -> _Date_Time_DOSTimeToStr

Func _Date_Time_EncodeFileTime($imonth, $iday, $iyear, $ihour = 0x0, $iminute = 0x0, $isecond = 0x0, $imseconds = 0x0)
    Local $tsystemtime = _Date_Time_EncodeSystemTime($imonth, $iday, $iyear, $ihour, $iminute, $isecond, $imseconds)
    Return _Date_Time_SystemTimeToFileTime($tsystemtime)
EndFunc    ; -> _Date_Time_EncodeFileTime

Func _Date_Time_EncodeSystemTime($imonth, $iday, $iyear, $ihour = 0x0, $iminute = 0x0, $isecond = 0x0, $imseconds = 0x0)
    Local $tsystemtime = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($tsystemtime, "Month", $imonth)
    DllStructSetData($tsystemtime, "Day", $iday)
    DllStructSetData($tsystemtime, "Year", $iyear)
    DllStructSetData($tsystemtime, "Hour", $ihour)
    DllStructSetData($tsystemtime, "Minute", $iminute)
    DllStructSetData($tsystemtime, "Second", $isecond)
    DllStructSetData($tsystemtime, "MSeconds", $imseconds)
    Return $tsystemtime
EndFunc    ; -> _Date_Time_EncodeSystemTime

Func _Date_Time_FileTimeToArray(ByRef $tfiletime)
    If ((DllStructGetData($tfiletime, 0x1) + DllStructGetData($tfiletime, 0x2)) = 0x0) Then Return SetError(0xa, 0x0, 0x0)
    Local $tsystemtime = _Date_Time_FileTimeToSystemTime($tfiletime)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return _Date_Time_SystemTimeToArray($tsystemtime)
EndFunc    ; -> _Date_Time_FileTimeToArray

Func _Date_Time_FileTimeToStr(ByRef $tfiletime, $ifmt = 0x0)
    Local $adate = _Date_Time_FileTimeToArray($tfiletime)
    If @error Then Return SetError(@error, @extended, '')
    If $ifmt Then
        Return StringFormat("%04d/%02d/%02d %02d:%02d:%02d", $adate[0x2], $adate[0x0], $adate[0x1], $adate[0x3], $adate[0x4], $adate[0x5])
    Else
        Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $adate[0x0], $adate[0x1], $adate[0x2], $adate[0x3], $adate[0x4], $adate[0x5])
    EndIf
EndFunc    ; -> _Date_Time_FileTimeToStr

Func _Date_Time_FileTimeToDOSDateTime($tfiletime)
    Local $adate[0x2]
    Local $acall = DllCall("kernel32.dll", "bool", "FileTimeToDosDateTime", "struct*", $tfiletime, "word*", 0x0, "word*", 0x0)
    If @error Then Return SetError(@error, @extended, $adate)
    $adate[0x0] = $acall[0x2]
    $adate[0x1] = $acall[0x3]
    Return SetExtended($acall[0x0], $adate)
EndFunc    ; -> _Date_Time_FileTimeToDOSDateTime

Func _Date_Time_FileTimeToLocalFileTime($tfiletime)
    Local $tlocal = DllStructCreate($TAGFILETIME)
    Local $acall = DllCall("kernel32.dll", "bool", "FileTimeToLocalFileTime", "struct*", $tfiletime, "struct*", $tlocal)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $tlocal)
EndFunc    ; -> _Date_Time_FileTimeToLocalFileTime

Func _Date_Time_FileTimeToSystemTime($tfiletime)
    Local $tsysttime = DllStructCreate($TAGSYSTEMTIME)
    Local $acall = DllCall("kernel32.dll", "bool", "FileTimeToSystemTime", "struct*", $tfiletime, "struct*", $tsysttime)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $tsysttime)
EndFunc    ; -> _Date_Time_FileTimeToSystemTime

Func _Date_Time_GetFileTime($hfile)
    Local $adate[0x3]
    $adate[0x0] = DllStructCreate($TAGFILETIME)
    $adate[0x1] = DllStructCreate($TAGFILETIME)
    $adate[0x2] = DllStructCreate($TAGFILETIME)
    Local $acall = DllCall("kernel32.dll", "bool", "GetFileTime", "handle", $hfile, "struct*", $adate[0x0], "struct*", $adate[0x1], "struct*", $adate[0x2])
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $adate)
EndFunc    ; -> _Date_Time_GetFileTime

Func _Date_Time_GetLocalTime()
    Local $tlocaltime = DllStructCreate($TAGSYSTEMTIME)
    DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tlocaltime)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $tlocaltime
EndFunc    ; -> _Date_Time_GetLocalTime

Func _Date_Time_GetSystemTime()
    Local $tsysttime = DllStructCreate($TAGSYSTEMTIME)
    DllCall("kernel32.dll", "none", "GetSystemTime", "struct*", $tsysttime)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $tsysttime
EndFunc    ; -> _Date_Time_GetSystemTime

Func _Date_Time_GetSystemTimeAdjustment()
    Local $ainfo[0x3]
    Local $acall = DllCall("kernel32.dll", "bool", "GetSystemTimeAdjustment", "dword*", 0x0, "dword*", 0x0, "bool*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    $ainfo[0x0] = $acall[0x1]
    $ainfo[0x1] = $acall[0x2]
    $ainfo[0x2] = $acall[0x3] <> 0x0
    Return SetExtended($acall[0x0], $ainfo)
EndFunc    ; -> _Date_Time_GetSystemTimeAdjustment

Func _Date_Time_GetSystemTimeAsFileTime()
    Local $tfiletime = DllStructCreate($TAGFILETIME)
    DllCall("kernel32.dll", "none", "GetSystemTimeAsFileTime", "struct*", $tfiletime)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $tfiletime
EndFunc    ; -> _Date_Time_GetSystemTimeAsFileTime

Func _Date_Time_GetSystemTimes()
    Local $ainfo[0x3]
    $ainfo[0x0] = DllStructCreate($TAGFILETIME)
    $ainfo[0x1] = DllStructCreate($TAGFILETIME)
    $ainfo[0x2] = DllStructCreate($TAGFILETIME)
    Local $acall = DllCall("kernel32.dll", "bool", "GetSystemTimes", "struct*", $ainfo[0x0], "struct*", $ainfo[0x1], "struct*", $ainfo[0x2])
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $ainfo)
EndFunc    ; -> _Date_Time_GetSystemTimes

Func _Date_Time_GetTickCount()
    Local $acall = DllCall("kernel32.dll", "dword", "GetTickCount")
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _Date_Time_GetTickCount

Func _Date_Time_GetTimeZoneInformation()
    Local $ttimezone = DllStructCreate($TAGTIME_ZONE_INFORMATION)
    Local $acall = DllCall("kernel32.dll", "dword", "GetTimeZoneInformation", "struct*", $ttimezone)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = + -1 Then Return SetError(0xa, 0x0, 0x0)
    Local $ainfo[0x8]
    $ainfo[0x0] = $acall[0x0]
    $ainfo[0x1] = DllStructGetData($ttimezone, "Bias")
    $ainfo[0x2] = DllStructGetData($ttimezone, "StdName")
    $ainfo[0x3] = __Date_Time_CloneSystemTime(DllStructGetPtr($ttimezone, "StdDate"))
    $ainfo[0x4] = DllStructGetData($ttimezone, "StdBias")
    $ainfo[0x5] = DllStructGetData($ttimezone, "DayName")
    $ainfo[0x6] = __Date_Time_CloneSystemTime(DllStructGetPtr($ttimezone, "DayDate"))
    $ainfo[0x7] = DllStructGetData($ttimezone, "DayBias")
    Return $ainfo
EndFunc    ; -> _Date_Time_GetTimeZoneInformation

Func _Date_Time_LocalFileTimeToFileTime($tlocaltime)
    Local $tfiletime = DllStructCreate($TAGFILETIME)
    Local $acall = DllCall("kernel32.dll", "bool", "LocalFileTimeToFileTime", "struct*", $tlocaltime, "struct*", $tfiletime)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $tfiletime)
EndFunc    ; -> _Date_Time_LocalFileTimeToFileTime

Func _Date_Time_SetFileTime($hfile, $tcreatetime, $tlastaccess, $tlastwrite)
    Local $acall = DllCall("kernel32.dll", "bool", "SetFileTime", "handle", $hfile, "struct*", $tcreatetime, "struct*", $tlastaccess, "struct*", $tlastwrite)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _Date_Time_SetFileTime

Func _Date_Time_SetLocalTime($tsystemtime)
    Local $acall = DllCall("kernel32.dll", "bool", "SetLocalTime", "struct*", $tsystemtime)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
    $acall = DllCall("kernel32.dll", "bool", "SetLocalTime", "struct*", $tsystemtime)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _Date_Time_SetLocalTime

Func _Date_Time_SetSystemTime($tsystemtime)
    Local $acall = DllCall("kernel32.dll", "bool", "SetSystemTime", "struct*", $tsystemtime)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _Date_Time_SetSystemTime

Func _Date_Time_SetSystemTimeAdjustment($iadjustment, $bdisabled)
    Local $htoken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
    If @error Then Return SetError(@error + 0xa, @extended, False)
    _Security__SetPrivilege($htoken, $SE_SYSTEMTIME_NAME, True)
    Local $ierror = @error
    Local $ilasterror = @extended
    Local $bret = False
    If Not @error Then
        Local $acall = DllCall("kernel32.dll", "bool", "SetSystemTimeAdjustment", "dword", $iadjustment, "bool", $bdisabled)
        If @error Then
            $ierror = @error
            $ilasterror = @extended
        ElseIf $acall[0x0] Then
            $bret = True
        Else
            $ierror = 0x14
            $ilasterror = _WinAPI_GetLastError()
        EndIf
        _Security__SetPrivilege($htoken, $SE_SYSTEMTIME_NAME, False)
        If Not $ierror And @error Then $ierror = 0x16
    EndIf
    _WinAPI_CloseHandle($htoken)
    Return SetError($ierror, $ilasterror, $bret)
EndFunc    ; -> _Date_Time_SetSystemTimeAdjustment

Func _Date_Time_SetTimeZoneInformation($ibias, $sstdname, $tstddate, $istdbias, $sdayname, $tdaydate, $idaybias)
    Local $tzoneinfo = DllStructCreate($TAGTIME_ZONE_INFORMATION)
    DllStructSetData($tzoneinfo, "Bias", $ibias)
    DllStructSetData($tzoneinfo, "StdName", $sstdname)
    _MemMoveMemory($tstddate, DllStructGetPtr($tzoneinfo, "StdDate"), DllStructGetSize($tstddate))
    DllStructSetData($tzoneinfo, "StdBias", $istdbias)
    DllStructSetData($tzoneinfo, "DayName", $sdayname)
    _MemMoveMemory($tdaydate, DllStructGetPtr($tzoneinfo, "DayDate"), DllStructGetSize($tdaydate))
    DllStructSetData($tzoneinfo, "DayBias", $idaybias)
    Local $htoken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
    If @error Then Return SetError(@error + 0xa, @extended, False)
    _Security__SetPrivilege($htoken, $SE_TIME_ZONE_NAME, True)
    Local $ierror = @error
    Local $ilasterror = @extended
    Local $bret = False
    If Not @error Then
        Local $acall = DllCall("kernel32.dll", "bool", "SetTimeZoneInformation", "struct*", $tzoneinfo)
        If @error Then
            $ierror = @error
            $ilasterror = @extended
        ElseIf $acall[0x0] Then
            $ilasterror = 0x0
            $bret = True
        Else
            $ierror = 0x14
            $ilasterror = _WinAPI_GetLastError()
        EndIf
        _Security__SetPrivilege($htoken, $SE_TIME_ZONE_NAME, False)
        If Not $ierror And @error Then $ierror = 0x16
    EndIf
    _WinAPI_CloseHandle($htoken)
    Return SetError($ierror, $ilasterror, $bret)
EndFunc    ; -> _Date_Time_SetTimeZoneInformation

Func _Date_Time_SystemTimeToArray(ByRef $tsystemtime)
    Local $ainfo[0x8]
    $ainfo[0x0] = DllStructGetData($tsystemtime, "Month")
    $ainfo[0x1] = DllStructGetData($tsystemtime, "Day")
    $ainfo[0x2] = DllStructGetData($tsystemtime, "Year")
    $ainfo[0x3] = DllStructGetData($tsystemtime, "Hour")
    $ainfo[0x4] = DllStructGetData($tsystemtime, "Minute")
    $ainfo[0x5] = DllStructGetData($tsystemtime, "Second")
    $ainfo[0x6] = DllStructGetData($tsystemtime, "MSeconds")
    $ainfo[0x7] = DllStructGetData($tsystemtime, "DOW")
    Return $ainfo
EndFunc    ; -> _Date_Time_SystemTimeToArray

Func _Date_Time_SystemTimeToDateStr(ByRef $tsystemtime, $ifmt = 0x0)
    Local $ainfo = _Date_Time_SystemTimeToArray($tsystemtime)
    If @error Then Return SetError(@error, @extended, '')
    If $ifmt Then
        Return StringFormat("%04d/%02d/%02d", $ainfo[0x2], $ainfo[0x0], $ainfo[0x1])
    Else
        Return StringFormat("%02d/%02d/%04d", $ainfo[0x0], $ainfo[0x1], $ainfo[0x2])
    EndIf
EndFunc    ; -> _Date_Time_SystemTimeToDateStr

Func _Date_Time_SystemTimeToDateTimeStr(ByRef $tsystemtime, $ifmt = 0x0, $itype = 0x0)
    Local $sret
    Switch $ifmt
    Case 0x0
        $sret = _WinAPI_GetDateFormat($LOCALE_INVARIANT, $tsystemtime, 0x0, "MM/dd/yyyy ")
        $sret &= _WinAPI_GetTimeFormat($LOCALE_INVARIANT, $tsystemtime)
    Case 0x1
        $sret = _WinAPI_GetDateFormat($LOCALE_INVARIANT, $tsystemtime, 0x0, "yyyy/MM/dd ")
        $sret &= _WinAPI_GetTimeFormat($LOCALE_INVARIANT, $tsystemtime)
    Case 0x2
        Local $ttemp
        If $itype Then
            $ttemp = $tsystemtime
        Else
            $ttemp = _Date_Time_TzSpecificLocalTimeToSystemTime($tsystemtime)
        EndIf
        $sret = _WinAPI_GetDateFormat($LOCALE_INVARIANT, $ttemp, 0x0, "ddd, dd MMM yyyy") & " "
        $sret &= _WinAPI_GetTimeFormat($LOCALE_INVARIANT, $ttemp) & " GMT"
    Case 0x3
        Local $aflag = _Date_Time_GetTimeZoneInformation()
        Local $ibias = $aflag[0x1] + $aflag[0x7]
        $sret = _WinAPI_GetDateFormat($LOCALE_INVARIANT, $tsystemtime, 0x0, "yyyy-MM-dd") & "T"
        $sret &= _WinAPI_GetTimeFormat($LOCALE_INVARIANT, $tsystemtime)
        If $itype Then
            $sret &= "Z"
        Else
            If $ibias Then
                Local $is = Mod($ibias, 0x3c)
                Local $ih = (Abs($ibias) + $is) / 0x3c
                If $ibias < 0x0 Then
                    $sret &= "-"
                    $is = - $is
                Else
                    $sret &= "+"
                EndIf
                $sret &= StringFormat("%02d:%02d", $ih, $is)
            EndIf
        EndIf
    EndSwitch
    Return $sret
EndFunc    ; -> _Date_Time_SystemTimeToDateTimeStr

Func _Date_Time_SystemTimeToFileTime($tsystemtime)
    Local $tfiletime = DllStructCreate($TAGFILETIME)
    Local $acall = DllCall("kernel32.dll", "bool", "SystemTimeToFileTime", "struct*", $tsystemtime, "struct*", $tfiletime)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $tfiletime)
EndFunc    ; -> _Date_Time_SystemTimeToFileTime

Func _Date_Time_SystemTimeToTimeStr(ByRef $tsystemtime)
    Local $ainfo = _Date_Time_SystemTimeToArray($tsystemtime)
    Return StringFormat("%02d:%02d:%02d", $ainfo[0x3], $ainfo[0x4], $ainfo[0x5])
EndFunc    ; -> _Date_Time_SystemTimeToTimeStr

Func _Date_Time_SystemTimeToTzSpecificLocalTime($tutc, $ttimezone = 0x0)
    Local $tlocaltime = DllStructCreate($TAGSYSTEMTIME)
    Local $acall = DllCall("kernel32.dll", "bool", "SystemTimeToTzSpecificLocalTime", "struct*", $ttimezone, "struct*", $tutc, "struct*", $tlocaltime)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $tlocaltime)
EndFunc    ; -> _Date_Time_SystemTimeToTzSpecificLocalTime

Func _Date_Time_TzSpecificLocalTimeToSystemTime($tlocaltime, $ttimezone = 0x0)
    Local $tutc = DllStructCreate($TAGSYSTEMTIME)
    Local $acall = DllCall("kernel32.dll", "bool", "TzSpecificLocalTimeToSystemTime", "struct*", $ttimezone, "struct*", $tlocaltime, "struct*", $tutc)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $tutc)
EndFunc    ; -> _Date_Time_TzSpecificLocalTimeToSystemTime

Func _SendMessage($hwnd, $imsg, $wparam = 0x0, $lparam = 0x0, $ireturn = 0x0, $wparamtype = "wparam", $lparamtype = "lparam", $sreturntype = "lresult")
    Local $acall = DllCall("user32.dll", $sreturntype, "SendMessageW", "hwnd", $hwnd, "uint", $imsg, $wparamtype, $wparam, $lparamtype, $lparam)
    If @error Then Return SetError(@error, @extended, '')
    If $ireturn >= 0x0 And $ireturn <= 0x4 Then Return $acall[$ireturn]
    Return $acall
EndFunc    ; -> _SendMessage

Func _SendMessageA($hwnd, $imsg, $wparam = 0x0, $lparam = 0x0, $ireturn = 0x0, $wparamtype = "wparam", $lparamtype = "lparam", $sreturntype = "lresult")
    Local $acall = DllCall("user32.dll", $sreturntype, "SendMessageA", "hwnd", $hwnd, "uint", $imsg, $wparamtype, $wparam, $lparamtype, $lparam)
    If @error Then Return SetError(@error, @extended, '')
    If $ireturn >= 0x0 And $ireturn <= 0x4 Then Return $acall[$ireturn]
    Return $acall
EndFunc    ; -> _SendMessageA

Global Const $__G_SREPORTWINDOWTEXT_DEBUG = "Debug Window hidden text"
Global Const $__G_SREPORTCALLBACK_DEBUGREPORT_DEBUG = _DebugReport
Global $__g_sreporttitle_debug = "AutoIt Debug Report"
Global $__g_ireporttype_debug = 0x0
Global $__g_breportwindowwaitclose_debug = True, $__g_breportwindowclosed_debug = True
Global $__g_hreportedit_debug = 0x0
Global $__g_hreportnotepadedit_debug = 0x0
Global $__g_sreportcallback_debug
Global $__g_breporttimestamp_debug = False
Global $__g_bcomerrorexit_debug = False, $__g_ocomerror_debug = Null
Func _Assert($scondition, $bexit = True, $icode = 0x7fffffff, $sline = @ScriptLineNumber, Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    Local $bcondition = Execute($scondition)
    If Not $bcondition Then
        Local $soutput = "Assertion Failed (Line " & $sline & "): " & @CRLF & @CRLF & $scondition
        If _DebugOut(StringReplace($soutput, @CRLF, '')) = 0x0 Then
            MsgBox($MB_SYSTEMMODAL, "AutoIt Assert", $soutput)
        Else
            $bexit = False
        EndIf
        If $bexit Then Exit $icode
    EndIf
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, $bcondition)
EndFunc    ; -> _Assert

Func _DebugArrayDisplay(Const ByRef $AARRAY, $STITLE = Default, $SARRAYRANGE = Default, $IFLAGS = Default, $VUSER_SEPARATOR = Default, $SHEADER = Default, $IMAX_COLWIDTH = Default, $HUSER_FUNCTION = Default, Const $_ICALLERSCRIPTLINENUMBER = @ScriptLineNumber, Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    Local $iret = __ArrayDisplay_Share($AARRAY, $STITLE, $SARRAYRANGE, $IFLAGS, $VUSER_SEPARATOR, $SHEADER, $IMAX_COLWIDTH, $HUSER_FUNCTION, True, $_ICALLERSCRIPTLINENUMBER, $_ICALLERERROR, $_ICALLEREXTENDED)
    Return SetError(@error, @extended, $iret)
EndFunc    ; -> _DebugArrayDisplay

Func _DebugBugReportEnv(Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    Local $sautoitx64, $sadminmode, $scompiled, $sosservicepack, $smuilang, $skblayout, $scpuarch
    If @AutoItX64 Then $sautoitx64 = "/X64"
    If IsAdmin() Then $sadminmode = ", AdminMode"
    If @Compiled Then $scompiled = ", Compiled"
    If @OSServicePack Then $sosservicepack = "/" & StringReplace(@OSServicePack, "Service Pack ", "SP")
    If @OSLang <> @MUILang Then $smuilang = ", MUILang: " & @MUILang
    If @OSLang <> StringRight(@KBLayout, 0x4) Then $skblayout = ", Keyboard: " & @KBLayout
    If @OSArch <> @CPUArch Then $scpuarch = ", CPUArch: " & @CPUArch
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, "AutoIt: " & @AutoItVersion & $sautoitx64 & $sadminmode & $scompiled & ", OS: " & @OSVersion & $sosservicepack & "/" & @OSArch & ", OSLang: " & @OSLang & $smuilang & $skblayout & $scpuarch & @CRLF & "  Script: " & @ScriptFullPath)
EndFunc    ; -> _DebugBugReportEnv

Func _DebugCOMError($icomdebug = Default, $bexit = False)
    If $__g_ireporttype_debug <= 0x0 Or $__g_ireporttype_debug > 0x6 Then Return SetError(0x3, 0x0, 0x0)
    If $icomdebug = Default Then $icomdebug = 0x1
    If Not IsInt($icomdebug) Or $icomdebug < + -1 Or $icomdebug > 0x1 Then Return SetError(0x1, 0x0, 0x0)
    Switch $icomdebug
    Case + -1
        Return SetError(IsObj($__g_ocomerror_debug), $__g_bcomerrorexit_debug, 0x1)
    Case 0x0
        If $__g_ocomerror_debug = Null Then SetError(0x0, 0x3, 0x1)
        $__g_ocomerror_debug = Null
        $__g_bcomerrorexit_debug = False
        Return 0x1
    Case Else
        $__g_bcomerrorexit_debug = $bexit
        Local $vcomerrorchecking = ObjEvent("AutoIt.Error")
        If $vcomerrorchecking = '' Then
            $__g_ocomerror_debug = ObjEvent("AutoIt.Error", __Debug_COMErrorHandler)
            If @error Then Return SetError(0x4, @error, 0x0)
            Return SetError(0x0, 0x1, 0x1)
        ElseIf FuncName($vcomerrorchecking) = FuncName(__Debug_COMErrorHandler) Then
            Return SetError(0x0, 0x2, 0x1)
        Else
            Return SetError(0x2, 0x0, 0x0)
        EndIf
    EndSwitch
EndFunc    ; -> _DebugCOMError

Func _DebugOut(Const $soutput, Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    If $__g_ireporttype_debug <= 0x0 Or $__g_ireporttype_debug > 0x6 Then Return SetError(0x3, 0x0, 0x0)
    If IsNumber($soutput) = 0x0 And IsString($soutput) = 0x0 And IsBool($soutput) = 0x0 Then Return SetError(0x1, 0x0, 0x0)
    __Debug_ReportWrite($soutput & @CRLF)
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, 0x1)
EndFunc    ; -> _DebugOut

Func _DebugSetup(Const $STITLE = Default, $BBUGREPORTINFOS = Default, $VREPORTTYPE = Default, $SLOGFILE = Default, $BTIMESTAMP = False, Const $_ICALLERERROR = @error, $_ICALLEREXTENDED = @extended)
    If $__g_ireporttype_debug Then Return SetError($_ICALLERERROR + 0x3e8, $_ICALLEREXTENDED, $__g_ireporttype_debug)
    If $BBUGREPORTINFOS = Default Then $BBUGREPORTINFOS = False
    If $VREPORTTYPE = Default Then $VREPORTTYPE = 0x1
    If $SLOGFILE = Default Then $SLOGFILE = ''
    Switch $VREPORTTYPE
    Case 0x1
        #forceref __Debug_ReportWindowWrite
        $__g_sreportcallback_debug = "__Debug_ReportWindowWrite("
    Case 0x2
        $__g_sreportcallback_debug = "ConsoleWrite("
    Case 0x3
        $__g_sreportcallback_debug = "MsgBox(4096, '" & $__g_sreporttitle_debug & "',"
    Case 0x4
        $__g_sreportcallback_debug = "FileWrite('" & $SLOGFILE & "',"
    Case 0x5
        #forceref __Debug_ReportNotepadWrite
        $__g_sreportcallback_debug = "__Debug_ReportNotepadWrite("
    Case Else
        If Not IsString($VREPORTTYPE) Then Return SetError(0x2, 0x0, 0x0)
        If $VREPORTTYPE = '' Then Return SetError(0x3, 0x0, 0x0)
        $__g_sreportcallback_debug = $VREPORTTYPE & "("
        $VREPORTTYPE = 0x6
    EndSwitch
    If Not ($STITLE = Default) Then $__g_sreporttitle_debug = $STITLE
    $__g_ireporttype_debug = $VREPORTTYPE
    $__g_breporttimestamp_debug = $BTIMESTAMP
    OnAutoItExitRegister("__Debug_ReportClose")
    If $BBUGREPORTINFOS Then _DebugReport(_DebugBugReportEnv() & @CRLF & @CRLF)
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, $__g_ireporttype_debug)
EndFunc    ; -> _DebugSetup

Func _DebugReport($sdata, $blasterror = False, $bexit = False, Const $_ICALLERERROR = @error, $_ICALLEREXTENDED = @extended)
    If $__g_ireporttype_debug <= 0x0 Or $__g_ireporttype_debug > 0x6 Then Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, 0x0)
    Local $ilasterror = _WinAPI_GetLastError()
    __Debug_ReportWrite($sdata, $blasterror, $ilasterror)
    If $bexit Then Exit
    _WinAPI_SetLastError($ilasterror)
    If $blasterror Then $_ICALLEREXTENDED = $ilasterror
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, 0x1)
EndFunc    ; -> _DebugReport

Func _DebugReportEx($sdata, $blasterror = False, $bexit = False, Const $_ICALLERERROR = @error, $_ICALLEREXTENDED = @extended)
    If $__g_ireporttype_debug <= 0x0 Or $__g_ireporttype_debug > 0x6 Then Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, 0x0)
    Local $ilasterror = _WinAPI_GetLastError()
    If IsInt($_ICALLERERROR) Then
        Local $stemp = StringSplit($sdata, "|", $STR_ENTIRESPLIT + $STR_NOCOUNT)
        If UBound($stemp) > 0x1 Then
            If $bexit Then
                $sdata = "<<< "
            Else
                $sdata = ">>> "
            EndIf
            Switch $_ICALLERERROR
            Case 0x0
                $sdata &= "Bad return from " & $stemp[0x1] & " in " & $stemp[0x0] & ".dll"
            Case 0x1
                $sdata &= "Unable to open " & $stemp[0x0] & ".dll"
            Case 0x3
                $sdata &= "Unable to find " & $stemp[0x1] & " in " & $stemp[0x0] & ".dll"
            EndSwitch
            If Not $blasterror Then $sdata &= @CRLF
        EndIf
    EndIf
    __Debug_ReportWrite($sdata, $blasterror, $ilasterror)
    If $bexit Then Exit
    _WinAPI_SetLastError($ilasterror)
    If $blasterror Then $_ICALLEREXTENDED = $ilasterror
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, 0x1)
EndFunc    ; -> _DebugReportEx

Func _DebugReportVar($svarname, $vvar, $berrext = False, Const $IDEBUGLINENUMBER = @ScriptLineNumber, Const $_ICALLERERROR = @error, Const $_ICALLEREXTENDED = @extended)
    If $__g_ireporttype_debug <= 0x0 Or $__g_ireporttype_debug > 0x6 Then Return SetError($_ICALLERERROR, $_ICALLEREXTENDED, 0x0)
    Local $ilasterror = _WinAPI_GetLastError()
    If IsBool($vvar) And IsInt($berrext) Then
        If StringLeft($svarname, 0x1) = "$" Then $svarname = StringTrimLeft($svarname, 0x1)
        $vvar = Eval($svarname)
        $svarname = "???"
    EndIf
    Local $sdata = "@@ Debug(" & $IDEBUGLINENUMBER & ") : " & __Debug_DataType($vvar) & " -> " & $svarname
    If IsArray($vvar) Then
        Local $ndims = UBound($vvar, $UBOUND_DIMENSIONS)
        Local $nrows = UBound($vvar, $UBOUND_ROWS)
        Local $ncols = UBound($vvar, $UBOUND_COLUMNS)
        For $d = 0x1 To $ndims
            $sdata &= "[" & UBound($vvar, $d) & "]"
        Next
        If $ndims <= 0x3 Then
            For $r = 0x0 To $nrows + -1
                $sdata &= @CRLF & @TAB & "[" & $r & "] "
                If $ndims = 0x1 Then
                    $sdata &= __Debug_DataFormat($vvar[$r]) & @TAB
                ElseIf $ndims = 0x2 Then
                    For $c = 0x0 To $ncols + -1
                        $sdata &= __Debug_DataFormat($vvar[$r][$c]) & @TAB
                    Next
                Else
                    For $c = 0x0 To $ncols + -1
                        $sdata &= @CRLF & @TAB & "    " & "[" & $c & "] "
                        For $k = 0x0 To UBound($vvar, 0x3) + -1
                            $sdata &= __Debug_DataFormat($vvar[$r][$c][$k]) & @TAB
                        Next
                    Next
                EndIf
            Next
        EndIf
    ElseIf IsDllStruct($vvar) Or IsObj($vvar) Then
    Else
        $sdata &= " = " & __Debug_DataFormat($vvar)
    EndIf
    If $berrext Then $sdata &= @CRLF & @TAB & "@error=" & $_ICALLERERROR & " @extended=0x" & Hex($_ICALLEREXTENDED)
    __Debug_ReportWrite($sdata & @CRLF)
    _WinAPI_SetLastError($ilasterror)
    Return SetError($_ICALLERERROR, $_ICALLEREXTENDED)
EndFunc    ; -> _DebugReportVar

Func __Debug_COMErrorHandler($ocomerror)
    _DebugReport(__COMErrorFormating($ocomerror), False, $__g_bcomerrorexit_debug)
EndFunc    ; -> __Debug_COMErrorHandler

Func __Debug_DataFormat($vdata)
    Local $nlenmax = 0x19
    Local $struncated = ''
    If IsString($vdata) Then
        If StringLen($vdata) > $nlenmax Then
            $vdata = StringLeft($vdata, $nlenmax)
            $struncated = " ..."
        EndIf
        Return """" & $vdata & """" & $struncated
    ElseIf IsBinary($vdata) Then
        If BinaryLen($vdata) > $nlenmax Then
            $vdata = BinaryMid($vdata, 0x1, $nlenmax)
            $struncated = " ..."
        EndIf
        Return $vdata & $struncated
    ElseIf IsDllStruct($vdata) Or IsArray($vdata) Or IsMap($vdata) Or IsObj($vdata) Then
        Return __Debug_DataType($vdata)
    Else
        Return $vdata
    EndIf
EndFunc    ; -> __Debug_DataFormat

Func __Debug_DataType($vdata)
    Local $stype = VarGetType($vdata)
    Switch $stype
    Case "DllStruct"
        $stype &= ":" & DllStructGetSize($vdata)
    Case "Array"
        $stype &= " " & UBound($vdata, $UBOUND_DIMENSIONS) & "D"
    Case "Map"
        Local $amapkeys = MapKeys($vdata)
        $stype &= ":" & UBound($amapkeys)
    Case "String"
        $stype &= ":" & StringLen($vdata)
    Case "Binary"
        $stype &= ":" & BinaryLen($vdata)
    Case "Ptr"
        If IsHWnd($vdata) Then $stype = "Hwnd"
    EndSwitch
    Return "{" & $stype & "}"
EndFunc    ; -> __Debug_DataType

Func __Debug_ReportClose()
    If $__g_ireporttype_debug = 0x1 Then
        If Not $__g_breportwindowclosed_debug Then
            WinSetOnTop($__g_sreporttitle_debug, '', 0x1)
            _DebugReport(@CRLF & ">>>>>> Please close the ""Report Log Window"" to exit <<<<<<<" & @CRLF)
            __Debug_ReportWindowWaitClose()
        EndIf
    ElseIf $__g_ireporttype_debug = 0x6 Then
        Execute($__g_sreportcallback_debug & ")")
    EndIf
    $__g_ireporttype_debug = 0x0
EndFunc    ; -> __Debug_ReportClose

Func __Debug_ReportWindowCreate()
    Local $nold = Opt("WinDetectHiddenText", $OPT_MATCHSTART)
    Local $bexists = WinExists($__g_sreporttitle_debug, $__G_SREPORTWINDOWTEXT_DEBUG)
    If $bexists Then
        If $__g_hreportedit_debug = 0x0 Then
            $__g_hreportedit_debug = ControlGetHandle($__g_sreporttitle_debug, $__G_SREPORTWINDOWTEXT_DEBUG, "Edit1")
            $__g_breportwindowwaitclose_debug = False
        EndIf
    EndIf
    Opt("WinDetectHiddenText", $nold)
    $__g_breportwindowclosed_debug = False
    If Not $__g_breportwindowwaitclose_debug Then Return 0x0
    Local Const $WS_OVERLAPPEDWINDOW = 0xcf0000
    Local Const $WS_HSCROLL = 0x100000
    Local Const $WS_VSCROLL = 0x200000
    Local Const $ES_READONLY = 0x800
    Local Const $EM_LIMITTEXT = 0xc5
    Local Const $GUI_HIDE = 0x20
    Local $w = 0x244, $h = 0x17c
    GUICreate($__g_sreporttitle_debug, $w, $h, + -1, + -1, $WS_OVERLAPPEDWINDOW)
    Local $idlabelhidden = GUICtrlCreateLabel($__G_SREPORTWINDOWTEXT_DEBUG, 0x0, 0x0, 0x1, 0x1)
    GUICtrlSetState($idlabelhidden, $GUI_HIDE)
    Local $idedit = GUICtrlCreateEdit('', 0x4, 0x4, $w + -8, $h + -8, BitOR($WS_HSCROLL, $WS_VSCROLL, $ES_READONLY))
    $__g_hreportedit_debug = GUICtrlGetHandle($idedit)
    GUICtrlSetBkColor($idedit, 0xffffff)
    GUICtrlSendMsg($idedit, $EM_LIMITTEXT, 0x0, 0x0)
    GUISetState()
    $__g_breportwindowwaitclose_debug = True
    Return 0x1
EndFunc    ; -> __Debug_ReportWindowCreate

#Au3Stripper_Ignore_Funcs=__Debug_ReportWindowWrite
Func __Debug_ReportWindowWrite($sdata)
    If $__g_breportwindowclosed_debug Then __Debug_ReportWindowCreate()
    Local Const $WM_GETTEXTLENGTH = 0xe
    Local Const $EM_SETSEL = 0xb1
    Local Const $EM_REPLACESEL = 0xc2
    Local $nlen = _SendMessage($__g_hreportedit_debug, $WM_GETTEXTLENGTH, 0x0, 0x0, 0x0, "int", "int")
    _SendMessage($__g_hreportedit_debug, $EM_SETSEL, $nlen, $nlen, 0x0, "int", "int")
    _SendMessage($__g_hreportedit_debug, $EM_REPLACESEL, True, $sdata, 0x0, "int", "wstr")
EndFunc    ; -> __Debug_ReportWindowWrite

Func __Debug_ReportWindowWaitClose()
    If Not $__g_breportwindowwaitclose_debug Then Return 0x0
    Local $nold = Opt("WinDetectHiddenText", $OPT_MATCHSTART)
    Local $hwndreportwindow = WinGetHandle($__g_sreporttitle_debug, $__G_SREPORTWINDOWTEXT_DEBUG)
    Opt("WinDetectHiddenText", $nold)
    $nold = Opt("GUIOnEventMode", 0x0)
    Local Const $GUI_EVENT_CLOSE = + -3
    Local $amsg
    While WinExists(HWnd($hwndreportwindow))
        $amsg = GUIGetMsg(0x1)
        If $amsg[0x1] = $hwndreportwindow And $amsg[0x0] = $GUI_EVENT_CLOSE Then GUIDelete($hwndreportwindow)
    WEnd
    Opt("GUIOnEventMode", $nold)
    $__g_hreportedit_debug = 0x0
    $__g_breportwindowwaitclose_debug = True
    $__g_breportwindowclosed_debug = True
EndFunc    ; -> __Debug_ReportWindowWaitClose

Func __Debug_ReportNotepadCreate()
    Local $bexists = WinExists($__g_sreporttitle_debug)
    If $bexists Then
        If $__g_hreportedit_debug = 0x0 Then
            $__g_hreportedit_debug = WinGetHandle($__g_sreporttitle_debug)
            Return 0x0
        EndIf
    EndIf
    Local $pnotepad = Run("Notepad.exe")
    $__g_hreportedit_debug = WinWait("[CLASS:Notepad]")
    If $pnotepad <> WinGetProcess($__g_hreportedit_debug) Then
        Return SetError(0x3, 0x0, 0x0)
    EndIf
    WinActivate($__g_hreportedit_debug)
    WinSetTitle($__g_hreportedit_debug, '', String($__g_sreporttitle_debug))
    Return 0x1
EndFunc    ; -> __Debug_ReportNotepadCreate

#Au3Stripper_Ignore_Funcs=__Debug_ReportNotepadWrite
Func __Debug_ReportNotepadWrite($sdata)
    If $__g_hreportedit_debug = 0x0 Then __Debug_ReportNotepadCreate()
    ControlCommand($__g_hreportedit_debug, '', "Edit1", "EditPaste", String($sdata))
EndFunc    ; -> __Debug_ReportNotepadWrite

Func __Debug_ReportWrite($sdata, $blasterror = False, $ilasterror = 0x0)
    Local $serror = ''
    If $__g_breporttimestamp_debug And ($sdata <> '') Then $sdata = @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " " & $sdata
    If $blasterror Then
        $serror = " LastError = " & $ilasterror & " : (" & _WinAPI_GetLastErrorMessage() & ")" & @CRLF
    EndIf
    $sdata &= $serror
    $sdata = StringReplace($sdata, "'", "''")
    Local Static $serror_code = ">Error code:"
    If StringInStr($sdata, $serror_code) Then
        $sdata = StringReplace($sdata, $serror_code, @TAB & $serror_code)
        If (StringInStr($sdata, $serror_code & " 0") = 0x0) Then
            $sdata = StringReplace($sdata, $serror_code, $serror_code & @TAB & @TAB & @TAB & @TAB)
        EndIf
    EndIf
    Execute($__g_sreportcallback_debug & "'" & $sdata & "')")
    Return
EndFunc    ; -> __Debug_ReportWrite

#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_CharToOem($sstr)
        Local $acall, $sretstr = '', $nlen = StringLen($sstr) + 0x1, $istart = 0x1
        While $istart < $nlen
            $acall = DllCall("user32.dll", "bool", "CharToOemW", "wstr", StringMid($sstr, $istart, 0x10000), "wstr", '')
            If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
            $istart += 0x10000
            $sretstr &= $acall[0x2]
        WEnd
        Return $sretstr
    EndFunc    ; -> _WinAPI_CharToOem

    Func _WinAPI_ClientToScreen($hwnd, ByRef $tpoint)
        Local $acall = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hwnd, "struct*", $tpoint)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tpoint
    EndFunc    ; -> _WinAPI_ClientToScreen

    Func _WinAPI_DWordToFloat($ivalue)
        Local $tdword = DllStructCreate("dword")
        Local $tfloat = DllStructCreate("float", DllStructGetPtr($tdword))
        DllStructSetData($tdword, 0x1, $ivalue)
        Return DllStructGetData($tfloat, 0x1)
    EndFunc    ; -> _WinAPI_DWordToFloat

    Func _WinAPI_DWordToInt($ivalue)
        Local $tdata = DllStructCreate("int")
        DllStructSetData($tdata, 0x1, $ivalue)
        Return DllStructGetData($tdata, 0x1)
    EndFunc    ; -> _WinAPI_DWordToInt

    Func _WinAPI_FloatToDWord($ivalue)
        Local $tfloat = DllStructCreate("float")
        Local $tdword = DllStructCreate("dword", DllStructGetPtr($tfloat))
        DllStructSetData($tfloat, 0x1, $ivalue)
        Return DllStructGetData($tdword, 0x1)
    EndFunc    ; -> _WinAPI_FloatToDWord

    Func _WinAPI_FloatToInt($nfloat)
        Local $tfloat = DllStructCreate("float")
        Local $tint = DllStructCreate("int", DllStructGetPtr($tfloat))
        DllStructSetData($tfloat, 0x1, $nfloat)
        Return DllStructGetData($tint, 0x1)
    EndFunc    ; -> _WinAPI_FloatToInt

    Func _WinAPI_GetXYFromPoint(ByRef $tpoint, ByRef $ix, ByRef $iy)
        $ix = DllStructGetData($tpoint, "X")
        $iy = DllStructGetData($tpoint, "Y")
    EndFunc    ; -> _WinAPI_GetXYFromPoint

    Func _WinAPI_GUIDFromString($sguid)
        Local $tguid = DllStructCreate($TAGGUID)
        If Not _WinAPI_GUIDFromStringEx($sguid, $tguid) Then Return SetError(@error, @extended, 0x0)
        Return $tguid
    EndFunc    ; -> _WinAPI_GUIDFromString

    Func _WinAPI_GUIDFromStringEx($sguid, $tguid)
        Local $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
        If @error Then Return SetError(@error, @extended, False)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
        Return True
    EndFunc    ; -> _WinAPI_GUIDFromStringEx

    Func _WinAPI_HashData($pmemory, $isize, $ilength = 0x20)
        If ($ilength <= 0x0) Or ($ilength > 0x100) Then Return SetError(0xb, 0x0, 0x0)
        Local $tdata = DllStructCreate("byte[" & $ilength & "]")
        Local $acall = DllCall("shlwapi.dll", "uint", "HashData", "struct*", $pmemory, "dword", $isize, "struct*", $tdata, "dword", $ilength)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return DllStructGetData($tdata, 0x1)
    EndFunc    ; -> _WinAPI_HashData

    Func _WinAPI_HashString($sstring, $bcasesensitive = True, $ilength = 0x20)
        Local $ilengths = StringLen($sstring)
        If Not $ilengths Or ($ilength > 0x100) Then Return SetError(0xc, 0x0, 0x0)
        Local $tstring = DllStructCreate("wchar[" & ($ilengths + 0x1) & "]")
        If Not $bcasesensitive Then
            $sstring = StringLower($sstring)
        EndIf
        DllStructSetData($tstring, 0x1, $sstring)
        Local $shash = _WinAPI_HashData($tstring, 0x2 * $ilengths, $ilength)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $shash
    EndFunc    ; -> _WinAPI_HashString

    Func _WinAPI_HiByte($ivalue)
        Return BitAND(BitShift($ivalue, 0x8), 0xff)
    EndFunc    ; -> _WinAPI_HiByte

    Func _WinAPI_HiDWord($ivalue)
        Local $tint64 = DllStructCreate("int64")
        Local $tqword = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
        DllStructSetData($tint64, 0x1, $ivalue)
        Return DllStructGetData($tqword, 0x2)
    EndFunc    ; -> _WinAPI_HiDWord

    Func _WinAPI_HiWord($ilong)
        Return BitShift($ilong, 0x10)
    EndFunc    ; -> _WinAPI_HiWord

    Func _WinAPI_IntToDWord($ivalue)
        Local $tdata = DllStructCreate("dword")
        DllStructSetData($tdata, 0x1, $ivalue)
        Return DllStructGetData($tdata, 0x1)
    EndFunc    ; -> _WinAPI_IntToDWord

    Func _WinAPI_IntToFloat($iint)
        Local $tint = DllStructCreate("int")
        Local $tfloat = DllStructCreate("float", DllStructGetPtr($tint))
        DllStructSetData($tint, 0x1, $iint)
        Return DllStructGetData($tfloat, 0x1)
    EndFunc    ; -> _WinAPI_IntToFloat

    Func _WinAPI_LoByte($ivalue)
        Return BitAND($ivalue, 0xff)
    EndFunc    ; -> _WinAPI_LoByte

    Func _WinAPI_LoDWord($ivalue)
        Local $tint64 = DllStructCreate("int64")
        Local $tqword = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
        DllStructSetData($tint64, 0x1, $ivalue)
        Return DllStructGetData($tqword, 0x1)
    EndFunc    ; -> _WinAPI_LoDWord

    Func _WinAPI_LoWord($ilong)
        Return BitAND($ilong, 0xffff)
    EndFunc    ; -> _WinAPI_LoWord

    Func _WinAPI_LongMid($ivalue, $istart, $icount)
        Return BitAND(BitShift($ivalue, $istart), BitOR(BitShift(BitShift(0x7fffffff, 0x20 - ($icount + 0x1)), 0x1), BitShift(0x1, - ($icount + -1))))
    EndFunc    ; -> _WinAPI_LongMid

    Func _WinAPI_MAKELANGID($ilngidprimary, $ilngidsub)
        Return BitOR(BitShift($ilngidsub, + -10), $ilngidprimary)
    EndFunc    ; -> _WinAPI_MAKELANGID

    Func _WinAPI_MAKELCID($ilngid, $isortid)
        Return BitOR(BitShift($isortid, + -16), $ilngid)
    EndFunc    ; -> _WinAPI_MAKELCID

    Func _WinAPI_MakeLong($ilo, $ihi)
        Return BitOR(BitShift($ihi, + -16), BitAND($ilo, 0xffff))
    EndFunc    ; -> _WinAPI_MakeLong

    Func _WinAPI_MakeQWord($ilodword, $ihidword)
        Local $tint64 = DllStructCreate("uint64")
        Local $tdwords = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
        DllStructSetData($tdwords, 0x1, $ilodword)
        DllStructSetData($tdwords, 0x2, $ihidword)
        Return DllStructGetData($tint64, 0x1)
    EndFunc    ; -> _WinAPI_MakeQWord

    Func _WinAPI_MakeWord($ilo, $ihi)
        Local $tword = DllStructCreate("ushort")
        Local $tbyte = DllStructCreate("byte;byte", DllStructGetPtr($tword))
        DllStructSetData($tbyte, 0x1, $ihi)
        DllStructSetData($tbyte, 0x2, $ilo)
        Return DllStructGetData($tword, 0x1)
    EndFunc    ; -> _WinAPI_MakeWord

    Func _WinAPI_MultiByteToWideChar($vtext, $icodepage = 0x0, $IFLAGS = 0x0, $bretstring = False)
        Local $stexttype = ''
        If IsString($vtext) Then $stexttype = "str"
        If (IsDllStruct($vtext) Or IsPtr($vtext)) Then $stexttype = "struct*"
        If $stexttype = '' Then Return SetError(0x1, 0x0, 0x0)
        Local $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $IFLAGS, $stexttype, $vtext, "int", + -1, "ptr", 0x0, "int", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $iout = $acall[0x0]
        Local $tout = DllStructCreate("wchar[" & $iout & "]")
        $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $IFLAGS, $stexttype, $vtext, "int", + -1, "struct*", $tout, "int", $iout)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        If $bretstring Then Return DllStructGetData($tout, 0x1)
        Return $tout
    EndFunc    ; -> _WinAPI_MultiByteToWideChar

    Func _WinAPI_MultiByteToWideCharEx($stext, $ptext, $icodepage = 0x0, $IFLAGS = 0x0)
        Local $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $IFLAGS, "STR", $stext, "int", + -1, "struct*", $ptext, "int", (StringLen($stext) + 0x1) * 0x2)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MultiByteToWideCharEx

    Func _WinAPI_OemToChar($sstr)
        Local $acall, $sretstr = '', $nlen = StringLen($sstr) + 0x1, $istart = 0x1
        While $istart < $nlen
            $acall = DllCall("user32.dll", "bool", "OemToCharA", "str", StringMid($sstr, $istart, 0x10000), "str", '')
            If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
            $sretstr &= $acall[0x2]
            $istart += 0x10000
        WEnd
        Return $sretstr
    EndFunc    ; -> _WinAPI_OemToChar

    Func _WinAPI_PointFromRect(ByRef $trect, $bcenter = True)
        Local $ix1 = DllStructGetData($trect, "Left")
        Local $iy1 = DllStructGetData($trect, "Top")
        Local $ix2 = DllStructGetData($trect, "Right")
        Local $iy2 = DllStructGetData($trect, "Bottom")
        If $bcenter Then
            $ix1 = $ix1 + (($ix2 - $ix1) / 0x2)
            $iy1 = $iy1 + (($iy2 - $iy1) / 0x2)
        EndIf
        Local $tpoint = DllStructCreate($TAGPOINT)
        DllStructSetData($tpoint, "X", $ix1)
        DllStructSetData($tpoint, "Y", $iy1)
        Return $tpoint
    EndFunc    ; -> _WinAPI_PointFromRect

    Func _WinAPI_PrimaryLangId($ilngid)
        Return BitAND($ilngid, 0x3ff)
    EndFunc    ; -> _WinAPI_PrimaryLangId

    Func _WinAPI_ScreenToClient($hwnd, ByRef $tpoint)
        Local $acall = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hwnd, "struct*", $tpoint)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ScreenToClient

    Func _WinAPI_ShortToWord($ivalue)
        Return BitAND($ivalue, 0xffff)
    EndFunc    ; -> _WinAPI_ShortToWord

    Func _WinAPI_StrFormatByteSize($isize)
        Local $acall = DllCall("shlwapi.dll", "ptr", "StrFormatByteSizeW", "int64", $isize, "wstr", '', "uint", 0x400)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_StrFormatByteSize

    Func _WinAPI_StrFormatByteSizeEx($isize)
        Local $asymbol = DllCall("kernel32.dll", "int", "GetLocaleInfoW", "dword", 0x400, "dword", 0xf, "wstr", '', "int", 0x800)
        If @error Then Return SetError(@error + 0xa, @extended, '')
        Local $ssize = _WinAPI_StrFormatByteSize(0x0)
        If @error Then Return SetError(@error, @extended, '')
        Return StringReplace($ssize, "0", StringRegExpReplace(Number($isize), "(?<=\\d)(?=(\\d{3})+\\z)", $asymbol[0x3]))
    EndFunc    ; -> _WinAPI_StrFormatByteSizeEx

    Func _WinAPI_StrFormatKBSize($isize)
        Local $acall = DllCall("shlwapi.dll", "ptr", "StrFormatKBSizeW", "int64", $isize, "wstr", '', "uint", 0x400)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_StrFormatKBSize

    Func _WinAPI_StrFromTimeInterval($itime, $idigits = 0x7)
        Local $acall = DllCall("shlwapi.dll", "int", "StrFromTimeIntervalW", "wstr", '', "uint", 0x400, "dword", $itime, "int", $idigits)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return StringStripWS($acall[0x1], $STR_STRIPLEADING + $STR_STRIPTRAILING)
    EndFunc    ; -> _WinAPI_StrFromTimeInterval

    Func _WinAPI_StringFromGUID($tguid)
        Local $acall = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", '', "int", 0x28)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return SetExtended($acall[0x0], $acall[0x2])
    EndFunc    ; -> _WinAPI_StringFromGUID

    Func _WinAPI_SubLangId($ilngid)
        Return BitShift($ilngid, 0xa)
    EndFunc    ; -> _WinAPI_SubLangId

    Func _WinAPI_SwapDWord($ivalue)
        Local $tstruct1 = DllStructCreate("dword;dword")
        Local $tstruct2 = DllStructCreate("byte[4];byte[4]", DllStructGetPtr($tstruct1))
        DllStructSetData($tstruct1, 0x1, $ivalue)
        For $i = 0x1 To 0x4
            DllStructSetData($tstruct2, 0x2, DllStructGetData($tstruct2, 0x1, 0x5 - $i), $i)
        Next
        Return DllStructGetData($tstruct1, 0x2)
    EndFunc    ; -> _WinAPI_SwapDWord

    Func _WinAPI_SwapQWord($ivalue)
        Local $tstruct1 = DllStructCreate("int64;int64")
        Local $tstruct2 = DllStructCreate("byte[8];byte[8]", DllStructGetPtr($tstruct1))
        DllStructSetData($tstruct1, 0x1, $ivalue)
        For $i = 0x1 To 0x8
            DllStructSetData($tstruct2, 0x2, DllStructGetData($tstruct2, 0x1, 0x9 - $i), $i)
        Next
        Return DllStructGetData($tstruct1, 0x2)
    EndFunc    ; -> _WinAPI_SwapQWord

    Func _WinAPI_SwapWord($ivalue)
        Local $tstruct1 = DllStructCreate("word;word")
        Local $tstruct2 = DllStructCreate("byte[2];byte[2]", DllStructGetPtr($tstruct1))
        DllStructSetData($tstruct1, 0x1, $ivalue)
        For $i = 0x1 To 0x2
            DllStructSetData($tstruct2, 0x2, DllStructGetData($tstruct2, 0x1, 0x3 - $i), $i)
        Next
        Return DllStructGetData($tstruct1, 0x2)
    EndFunc    ; -> _WinAPI_SwapWord

    Func _WinAPI_WideCharToMultiByte($vunicode, $icodepage = 0x0, $bretnostruct = True, $bretbinary = False)
        Local $sunicodetype = "wstr"
        If Not IsString($vunicode) Then $sunicodetype = "struct*"
        Local $acall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0x0, $sunicodetype, $vunicode, "int", + -1, "ptr", 0x0, "int", 0x0, "ptr", 0x0, "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, '')
        Local $tmultibyte = DllStructCreate((($bretbinary) ? ("byte") : ("char")) & "[" & $acall[0x0] & "]")
        $acall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0x0, $sunicodetype, $vunicode, "int", + -1, "struct*", $tmultibyte, "int", $acall[0x0], "ptr", 0x0, "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        If $bretnostruct Then Return DllStructGetData($tmultibyte, 0x1)
        Return $tmultibyte
    EndFunc    ; -> _WinAPI_WideCharToMultiByte

    Func _WinAPI_WordToShort($ivalue)
        If BitAND($ivalue, 0x8000) Then
            Return BitOR($ivalue, -32768)
        EndIf
        Return BitAND($ivalue, 0x7fff)
    EndFunc    ; -> _WinAPI_WordToShort

#EndRegion Public Functions
#Region Global Variables and Constants
    Global $__g_hheap = 0x0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_CreateBuffer($ilength, $pbuffer = 0x0, $babort = True)
        $pbuffer = __HeapReAlloc($pbuffer, $ilength, 0x0, $babort)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $pbuffer
    EndFunc    ; -> _WinAPI_CreateBuffer

    Func _WinAPI_CreateBufferFromStruct($tstruct, $pbuffer = 0x0, $babort = True)
        If Not IsDllStruct($tstruct) Then Return SetError(0x1, 0x0, 0x0)
        $pbuffer = __HeapReAlloc($pbuffer, DllStructGetSize($tstruct), 0x0, $babort)
        If @error Then Return SetError(@error + 0x64, @extended, 0x0)
        _WinAPI_MoveMemory($pbuffer, $tstruct, DllStructGetSize($tstruct))
        Return $pbuffer
    EndFunc    ; -> _WinAPI_CreateBufferFromStruct

    Func _WinAPI_CreateString($sstring, $pstring = 0x0, $ilength = + -1, $bunicode = True, $babort = True)
        $ilength = Number($ilength)
        If $ilength >= 0x0 Then
            $sstring = StringLeft($sstring, $ilength)
        Else
            $ilength = StringLen($sstring)
        EndIf
        Local $isize = $ilength + 0x1
        If $bunicode Then
            $isize *= 0x2
        EndIf
        $pstring = __HeapReAlloc($pstring, $isize, 0x0, $babort)
        If @error Then Return SetError(@error, @extended, 0x0)
        DllStructSetData(DllStructCreate(($bunicode  ? "wchar"  : "char") & "[" & ($ilength + 0x1) & "]", $pstring), 0x1, $sstring)
        Return SetExtended($ilength, $pstring)
    EndFunc    ; -> _WinAPI_CreateString

    Func _WinAPI_EqualMemory($psource1, $psource2, $ilength)
        If _WinAPI_IsBadReadPtr($psource1, $ilength) Then Return SetError(0xb, @extended, 0x0)
        If _WinAPI_IsBadReadPtr($psource2, $ilength) Then Return SetError(0xc, @extended, 0x0)
        Local $acall = DllCall("ntdll.dll", "ulong_ptr", "RtlCompareMemory", "struct*", $psource1, "struct*", $psource2, "ulong_ptr", $ilength)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return Number($acall[0x0] = $ilength)
    EndFunc    ; -> _WinAPI_EqualMemory

    Func _WinAPI_FillMemory($pmemory, $ilength, $ivalue = 0x0)
        If _WinAPI_IsBadWritePtr($pmemory, $ilength) Then Return SetError(0xb, @extended, 0x0)
        DllCall("ntdll.dll", "none", "RtlFillMemory", "struct*", $pmemory, "ulong_ptr", $ilength, "byte", $ivalue)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_FillMemory

    Func _WinAPI_FreeMemory($pmemory)
        If Not __HeapFree($pmemory, 0x1) Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_FreeMemory

    Func _WinAPI_GetMemorySize($pmemory)
        Local $iresult = __HeapSize($pmemory, 0x1)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $iresult
    EndFunc    ; -> _WinAPI_GetMemorySize

    Func _WinAPI_GlobalMemoryStatus()
        Local Const $TAGMEMORYSTATUSEX = "dword Length;dword MemoryLoad;" & "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" & "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
        Local $tmem = DllStructCreate($TAGMEMORYSTATUSEX)
        DllStructSetData($tmem, 0x1, DllStructGetSize($tmem))
        Local $acall = DllCall("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $tmem)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $amem[0x7]
        $amem[0x0] = DllStructGetData($tmem, 0x2)
        $amem[0x1] = DllStructGetData($tmem, 0x3)
        $amem[0x2] = DllStructGetData($tmem, 0x4)
        $amem[0x3] = DllStructGetData($tmem, 0x5)
        $amem[0x4] = DllStructGetData($tmem, 0x6)
        $amem[0x5] = DllStructGetData($tmem, 0x7)
        $amem[0x6] = DllStructGetData($tmem, 0x8)
        Return $amem
    EndFunc    ; -> _WinAPI_GlobalMemoryStatus

    Func _WinAPI_IsBadCodePtr($paddress)
        Local $acall = DllCall("kernel32.dll", "bool", "IsBadCodePtr", "struct*", $paddress)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsBadCodePtr

    Func _WinAPI_IsBadReadPtr($paddress, $ilength)
        Local $acall = DllCall("kernel32.dll", "bool", "IsBadReadPtr", "struct*", $paddress, "uint_ptr", $ilength)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsBadReadPtr

    Func _WinAPI_IsBadStringPtr($paddress, $ilength)
        Local $acall = DllCall("kernel32.dll", "bool", "IsBadStringPtr", "struct*", $paddress, "uint_ptr", $ilength)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsBadStringPtr

    Func _WinAPI_IsBadWritePtr($paddress, $ilength)
        Local $acall = DllCall("kernel32.dll", "bool", "IsBadWritePtr", "struct*", $paddress, "uint_ptr", $ilength)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsBadWritePtr

    Func _WinAPI_IsMemory($pmemory)
        Local $bresult = __HeapValidate($pmemory)
        Return SetError(@error, @extended, $bresult)
    EndFunc    ; -> _WinAPI_IsMemory

    Func _WinAPI_LocalFree($hmemory)
        Local $acall = DllCall("kernel32.dll", "handle", "LocalFree", "handle", $hmemory)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LocalFree

    Func _WinAPI_MoveMemory($pdestination, $psource, $ilength)
        If _WinAPI_IsBadReadPtr($psource, $ilength) Then Return SetError(0xa, @extended, 0x0)
        If _WinAPI_IsBadWritePtr($pdestination, $ilength) Then Return SetError(0xb, @extended, 0x0)
        DllCall("ntdll.dll", "none", "RtlMoveMemory", "struct*", $pdestination, "struct*", $psource, "ulong_ptr", $ilength)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_MoveMemory

    Func _WinAPI_ReadProcessMemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iread)
        Local $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, "struct*", $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        $iread = $acall[0x5]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ReadProcessMemory

    Func _WinAPI_WriteProcessMemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iwritten, $sbuffertype = "ptr")
        Local $acall = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, $sbuffertype, $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        $iwritten = $acall[0x5]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_WriteProcessMemory

    Func _WinAPI_ZeroMemory($pmemory, $ilength)
        If _WinAPI_IsBadWritePtr($pmemory, $ilength) Then Return SetError(0xb, @extended, 0x0)
        DllCall("ntdll.dll", "none", "RtlZeroMemory", "struct*", $pmemory, "ulong_ptr", $ilength)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ZeroMemory

#EndRegion Public Functions
#Region Internal Functions
    Func __HeapAlloc($isize, $babort = False)
        Local $acall
        If Not $__g_hheap Then
            $acall = DllCall("kernel32.dll", "handle", "HeapCreate", "dword", 0x0, "ulong_ptr", 0x0, "ulong_ptr", 0x0)
            If @error Or Not $acall[0x0] Then __FatalExit(0x1, "Error allocating memory.")
            $__g_hheap = $acall[0x0]
        EndIf
        $acall = DllCall("kernel32.dll", "ptr", "HeapAlloc", "handle", $__g_hheap, "dword", 0x8, "ulong_ptr", $isize)
        If @error Or Not $acall[0x0] Then
            If $babort Then __FatalExit(0x1, "Error allocating memory.")
            Return SetError(@error + 0x1e, @extended, 0x0)
        EndIf
        Return $acall[0x0]
    EndFunc    ; -> __HeapAlloc

    Func __HeapFree(ByRef $pmemory, $bcheck = False, $icurerr = @error, $icurext = @extended)
        If $bcheck And (Not __HeapValidate($pmemory)) Then Return SetError(@error, @extended, 0x0)
        Local $acall = DllCall("kernel32.dll", "int", "HeapFree", "handle", $__g_hheap, "dword", 0x0, "ptr", $pmemory)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x28, @extended, 0x0)
        $pmemory = 0x0
        Return SetError($icurerr, $icurext, 0x1)
    EndFunc    ; -> __HeapFree

    Func __HeapReAlloc($pmemory, $isize, $bamount = False, $babort = False)
        Local $pret
        If __HeapValidate($pmemory) Then
            If $bamount And (__HeapSize($pmemory) >= $isize) Then Return SetExtended(0x1, Ptr($pmemory))
            Local $acall = DllCall("kernel32.dll", "ptr", "HeapReAlloc", "handle", $__g_hheap, "dword", 0x8, "ptr", $pmemory, "ulong_ptr", $isize)
            If @error Or Not $acall[0x0] Then
                If $babort Then __FatalExit(0x1, "Error allocating memory.")
                Return SetError(@error + 0x14, @extended, Ptr($pmemory))
            EndIf
            $pret = $acall[0x0]
        Else
            $pret = __HeapAlloc($isize, $babort)
            If @error Then Return SetError(@error, @extended, 0x0)
        EndIf
        Return $pret
    EndFunc    ; -> __HeapReAlloc

    Func __HeapSize($pmemory, $bcheck = False)
        If $bcheck And (Not __HeapValidate($pmemory)) Then Return SetError(@error, @extended, 0x0)
        Local $acall = DllCall("kernel32.dll", "ulong_ptr", "HeapSize", "handle", $__g_hheap, "dword", 0x0, "ptr", $pmemory)
        If @error Or ($acall[0x0] = Ptr(+ -1)) Then Return SetError(@error + 0x32, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> __HeapSize

    Func __HeapValidate($pmemory)
        If (Not $__g_hheap) Or (Not Ptr($pmemory)) Then Return SetError(0x9, 0x0, False)
        Local $acall = DllCall("kernel32.dll", "int", "HeapValidate", "handle", $__g_hheap, "dword", 0x0, "ptr", $pmemory)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> __HeapValidate

#EndRegion Internal Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_ArrayToStruct(Const ByRef $ADATA, $istart = 0x0, $IEND = + -1)
        If __CheckErrorArrayBounds($ADATA, $istart, $IEND) Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $tagstruct = ''
        For $i = $istart To $IEND
            $tagstruct &= "wchar[" & (StringLen($ADATA[$i]) + 0x1) & "];"
        Next
        Local $tdata = DllStructCreate($tagstruct & "wchar[1]")
        Local $icount = 0x1
        For $i = $istart To $IEND
            DllStructSetData($tdata, $icount, $ADATA[$i])
            $icount += 0x1
        Next
        DllStructSetData($tdata, $icount, ChrW(0x0))
        Return $tdata
    EndFunc    ; -> _WinAPI_ArrayToStruct

    Func _WinAPI_CreateMargins($ileftwidth, $irightwidth, $itopheight, $ibottomheight)
        Local $tmargins = DllStructCreate($TAGMARGINS)
        DllStructSetData($tmargins, 0x1, $ileftwidth)
        DllStructSetData($tmargins, 0x2, $irightwidth)
        DllStructSetData($tmargins, 0x3, $itopheight)
        DllStructSetData($tmargins, 0x4, $ibottomheight)
        Return $tmargins
    EndFunc    ; -> _WinAPI_CreateMargins

    Func _WinAPI_CreatePoint($ix, $iy)
        Local $tpoint = DllStructCreate($TAGPOINT)
        DllStructSetData($tpoint, 0x1, $ix)
        DllStructSetData($tpoint, 0x2, $iy)
        Return $tpoint
    EndFunc    ; -> _WinAPI_CreatePoint

    Func _WinAPI_CreateRect($ileft, $itop, $iright, $ibottom)
        Local $trect = DllStructCreate($TAGRECT)
        DllStructSetData($trect, 0x1, $ileft)
        DllStructSetData($trect, 0x2, $itop)
        DllStructSetData($trect, 0x3, $iright)
        DllStructSetData($trect, 0x4, $ibottom)
        Return $trect
    EndFunc    ; -> _WinAPI_CreateRect

    Func _WinAPI_CreateRectEx($ix, $iy, $iwidth, $iheight)
        Local $trect = DllStructCreate($TAGRECT)
        DllStructSetData($trect, 0x1, $ix)
        DllStructSetData($trect, 0x2, $iy)
        DllStructSetData($trect, 0x3, $ix + $iwidth)
        DllStructSetData($trect, 0x4, $iy + $iheight)
        Return $trect
    EndFunc    ; -> _WinAPI_CreateRectEx

    Func _WinAPI_CreateSize($iwidth, $iheight)
        Local $tsize = DllStructCreate($TAGSIZE)
        DllStructSetData($tsize, 0x1, $iwidth)
        DllStructSetData($tsize, 0x2, $iheight)
        Return $tsize
    EndFunc    ; -> _WinAPI_CreateSize

    Func _WinAPI_CopyStruct($tstruct, $sstruct = '')
        Local $isize = DllStructGetSize($tstruct)
        If Not $isize Then Return SetError(0x1, 0x0, 0x0)
        Local $tresult
        If Not StringStripWS($sstruct, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) Then
            $tresult = DllStructCreate("byte[" & $isize & "]")
        Else
            $tresult = DllStructCreate($sstruct)
        EndIf
        If DllStructGetSize($tresult) < $isize Then Return SetError(0x2, 0x0, 0x0)
        _WinAPI_MoveMemory($tresult, $tstruct, $isize)
        Return $tresult
    EndFunc    ; -> _WinAPI_CopyStruct

    Func _WinAPI_GetExtended()
        Return $__g_vext
    EndFunc    ; -> _WinAPI_GetExtended

    Func _WinAPI_GetMousePos($btoclient = False, $hwnd = 0x0)
        Local $imode = Opt("MouseCoordMode", 0x1)
        Local $apos = MouseGetPos()
        Opt("MouseCoordMode", $imode)
        Local $tpoint = DllStructCreate($TAGPOINT)
        DllStructSetData($tpoint, "X", $apos[0x0])
        DllStructSetData($tpoint, "Y", $apos[0x1])
        If $btoclient And Not _WinAPI_ScreenToClient($hwnd, $tpoint) Then Return SetError(@error + 0x14, @extended, 0x0)
        Return $tpoint
    EndFunc    ; -> _WinAPI_GetMousePos

    Func _WinAPI_GetMousePosX($btoclient = False, $hwnd = 0x0)
        Local $tpoint = _WinAPI_GetMousePos($btoclient, $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return DllStructGetData($tpoint, "X")
    EndFunc    ; -> _WinAPI_GetMousePosX

    Func _WinAPI_GetMousePosY($btoclient = False, $hwnd = 0x0)
        Local $tpoint = _WinAPI_GetMousePos($btoclient, $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return DllStructGetData($tpoint, "Y")
    EndFunc    ; -> _WinAPI_GetMousePosY

    Func _WinAPI_MulDiv($inumber, $inumerator, $idenominator)
        Local $acall = DllCall("kernel32.dll", "int", "MulDiv", "int", $inumber, "int", $inumerator, "int", $idenominator)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MulDiv

    Func _WinAPI_PlaySound($ssound, $IFLAGS = $SND_SYSTEM_NOSTOP, $hinstance = 0x0)
        Local $stypeofsound = "ptr"
        If $ssound Then
            If IsString($ssound) Then
                $stypeofsound = "wstr"
            EndIf
        Else
            $ssound = 0x0
            $IFLAGS = 0x0
        EndIf
        Local $acall = DllCall("winmm.dll", "bool", "PlaySoundW", $stypeofsound, $ssound, "handle", $hinstance, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PlaySound

    Func _WinAPI_StringLenA(Const ByRef $tstring)
        Local $acall = DllCall("kernel32.dll", "int", "lstrlenA", "struct*", $tstring)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_StringLenA

    Func _WinAPI_StringLenW(Const ByRef $tstring)
        Local $acall = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $tstring)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_StringLenW

    Func _WinAPI_StructToArray(ByRef $tstruct, $iitems = 0x0)
        Local $isize = 0x2 * Floor(DllStructGetSize($tstruct) / 0x2)
        Local $pstruct = DllStructGetPtr($tstruct)
        If Not $isize Or Not $pstruct Then Return SetError(0x1, 0x0, 0x0)
        Local $tdata, $ilength, $ioffset = 0x0
        Local $aret[0x65] = [0x0]
        While 0x1
            $ilength = _WinAPI_StrLen($pstruct + $ioffset)
            If Not $ilength Then
                ExitLoop
            EndIf
            If 0x2 * (0x1 + $ilength) + $ioffset > $isize Then Return SetError(0x3, 0x0, 0x0)
            $tdata = DllStructCreate("wchar[" & (0x1 + $ilength) & "]", $pstruct + $ioffset)
            If @error Then Return SetError(@error + 0xa, 0x0, 0x0)
            __Inc($aret)
            $aret[$aret[0x0]] = DllStructGetData($tdata, 0x1)
            If $aret[0x0] = $iitems Then
                ExitLoop
            EndIf
            $ioffset += 0x2 * (0x1 + $ilength)
            If $ioffset >= $isize Then Return SetError(0x3, 0x0, 0x0)
        WEnd
        If Not $aret[0x0] Then Return SetError(0x2, 0x0, 0x0)
        __Inc($aret, + -1)
        Return $aret
    EndFunc    ; -> _WinAPI_StructToArray

    Func _WinAPI_UnionStruct($tstruct1, $tstruct2, $sstruct = '')
        Local $asize[0x2] = [DllStructGetSize($tstruct1), DllStructGetSize($tstruct2)]
        If Not $asize[0x0] Or Not $asize[0x1] Then Return SetError(0x1, 0x0, 0x0)
        Local $tresult
        If Not StringStripWS($sstruct, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) Then
            $tresult = DllStructCreate("byte[" & ($asize[0x0] + $asize[0x1]) & "]")
        Else
            $tresult = DllStructCreate($sstruct)
        EndIf
        If DllStructGetSize($tresult) < ($asize[0x0] + $asize[0x1]) Then Return SetError(0x2, 0x0, 0x0)
        _WinAPI_MoveMemory($tresult, $tstruct1, $asize[0x0])
        _WinAPI_MoveMemory(DllStructGetPtr($tresult) + $asize[0x0], $tstruct2, $asize[0x1])
        Return $tresult
    EndFunc    ; -> _WinAPI_UnionStruct

#EndRegion Public Functions
#Region Global Variables and Constants
    Global Const $TAGBITMAP = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
    Global Const $TAGBITMAPV5HEADER = "struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPel" & _
        "sPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dw" & _
        "ord bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct"
    Global Const $TAGDIBSECTION = $TAGBITMAP & ";" & $TAGBITMAPINFOHEADER & ";dword dsBitfields[3];ptr dshSection;dword dsOffset"
    Global Const $TMPF_FIXED_PITCH = 0x1
    Global Const $TMPF_VECTOR = 0x2
    Global Const $TMPF_TRUETYPE = 0x4
    Global Const $TMPF_DEVICE = 0x8
    Global Const $__WINAPICONSTANT_FW_NORMAL = 0x190
    Global Const $__WINAPICONSTANT_DEFAULT_CHARSET = 0x1
    Global Const $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0x0
    Global Const $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0x0
    Global Const $__WINAPICONSTANT_DEFAULT_QUALITY = 0x0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_BitBlt($hdestdc, $ixdest, $iydest, $iwidth, $iheight, $hsrcdc, $ixsrc, $iysrc, $irop)
        Local $acall = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidth, "int", $iheight, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "dword", $irop)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BitBlt

    Func _WinAPI_CombineRgn($hrgndest, $hrgnsrc1, $hrgnsrc2, $icombinemode)
        Local $acall = DllCall("gdi32.dll", "int", "CombineRgn", "handle", $hrgndest, "handle", $hrgnsrc1, "handle", $hrgnsrc2, "int", $icombinemode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CombineRgn

    Func _WinAPI_CopyBitmap($hbitmap)
        $hbitmap = _WinAPI_CopyImage($hbitmap, 0x0, 0x0, 0x0, 0x2000)
        Return SetError(@error, @extended, $hbitmap)
    EndFunc    ; -> _WinAPI_CopyBitmap

    Func _WinAPI_CopyImage($himage, $itype = 0x0, $ixdesiredpixels = 0x0, $iydesiredpixels = 0x0, $IFLAGS = 0x0)
        Local $acall = DllCall("user32.dll", "handle", "CopyImage", "handle", $himage, "uint", $itype, "int", $ixdesiredpixels, "int", $iydesiredpixels, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CopyImage

    Func _WinAPI_CreateANDBitmap($hbitmap)
        Local $ierror = 0x0, $hdib = 0x0
        $hbitmap = _WinAPI_CopyBitmap($hbitmap)
        If Not $hbitmap Then Return SetError(@error + 0x14, @extended, 0x0)
        Do
            Local $atdib[0x2]
            $atdib[0x0] = DllStructCreate($TAGDIBSECTION)
            If (Not _WinAPI_GetObject($hbitmap, DllStructGetSize($atdib[0x0]), $atdib[0x0])) Or (DllStructGetData($atdib[0x0], "bmBitsPixel") <> 0x20) Or (DllStructGetData($atdib[0x0], "biCompression")) Then
                $ierror = 0xa
                ExitLoop
            EndIf
            $atdib[0x1] = DllStructCreate($TAGBITMAP)
            $hdib = _WinAPI_CreateDIB(DllStructGetData($atdib[0x0], "bmWidth"), DllStructGetData($atdib[0x0], "bmHeight"), 0x1)
            If Not _WinAPI_GetObject($hdib, DllStructGetSize($atdib[0x1]), $atdib[0x1]) Then
                $ierror = 0xb
                ExitLoop
            EndIf
            Local $acall = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", __ANDProc(), "ptr", 0x0, "uint", 0x0, "wparam", DllStructGetPtr($atdib[0x0]), "lparam", DllStructGetPtr($atdib[0x1]))
            If @error Then
                $ierror = @error
                ExitLoop
            EndIf
            If Not $acall[0x0] Then
                $ierror = 0xc
                ExitLoop
            EndIf
            $ierror = 0x0
        Until 0x1
        _WinAPI_DeleteObject($hbitmap)
        If $ierror Then
            If $hdib Then
                _WinAPI_DeleteObject($hdib)
            EndIf
            $hdib = 0x0
        EndIf
        Return SetError($ierror, 0x0, $hdib)
    EndFunc    ; -> _WinAPI_CreateANDBitmap

    Func _WinAPI_CreateBitmap($iwidth, $iheight, $iplanes = 0x1, $ibitsperpel = 0x1, $pbits = 0x0)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateBitmap", "int", $iwidth, "int", $iheight, "uint", $iplanes, "uint", $ibitsperpel, "struct*", $pbits)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateBitmap

    Func _WinAPI_CreateCompatibleBitmap($hdc, $iwidth, $iheight)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateCompatibleBitmap

    Func _WinAPI_CreateDIB($iwidth, $iheight, $ibitsperpel = 0x20, $tcolortable = 0x0, $icolorcount = 0x0)
        Local $argbq[0x2], $icolors, $tagrgbq
        Switch $ibitsperpel
        Case 0x1
            $icolors = 0x2
        Case 0x4
            $icolors = 0x10
        Case 0x8
            $icolors = 0x100
        Case Else
            $icolors = 0x0
        EndSwitch
        If $icolors Then
            If Not IsDllStruct($tcolortable) Then
                Switch $ibitsperpel
                Case 0x1
                    $argbq[0x0] = 0x0
                    $argbq[0x1] = 0xffffff
                    $tcolortable = _WinAPI_CreateDIBColorTable($argbq)
                Case Else
                EndSwitch
            Else
                If $icolors > $icolorcount Then
                    $icolors = $icolorcount
                EndIf
                If (Not $icolors) Or ((0x4 * $icolors) > DllStructGetSize($tcolortable)) Then
                    Return SetError(0x14, 0x0, 0x0)
                EndIf
            EndIf
            $tagrgbq = ";dword aRGBQuad[" & $icolors & "]"
        Else
            $tagrgbq = ''
        EndIf
        Local $tbitmapinfo = DllStructCreate($TAGBITMAPINFOHEADER & $tagrgbq)
        DllStructSetData($tbitmapinfo, "biSize", 0x28)
        DllStructSetData($tbitmapinfo, "biWidth", $iwidth)
        DllStructSetData($tbitmapinfo, "biHeight", $iheight)
        DllStructSetData($tbitmapinfo, "biPlanes", 0x1)
        DllStructSetData($tbitmapinfo, "biBitCount", $ibitsperpel)
        DllStructSetData($tbitmapinfo, "biCompression", 0x0)
        DllStructSetData($tbitmapinfo, "biSizeImage", 0x0)
        DllStructSetData($tbitmapinfo, "biXPelsPerMeter", 0x0)
        DllStructSetData($tbitmapinfo, "biYPelsPerMeter", 0x0)
        DllStructSetData($tbitmapinfo, "biClrUsed", $icolors)
        DllStructSetData($tbitmapinfo, "biClrImportant", 0x0)
        If $icolors Then
            If IsDllStruct($tcolortable) Then
                _WinAPI_MoveMemory(DllStructGetPtr($tbitmapinfo, "aRGBQuad"), $tcolortable, 0x4 * $icolors)
            Else
                _WinAPI_ZeroMemory(DllStructGetPtr($tbitmapinfo, "aRGBQuad"), 0x4 * $icolors)
            EndIf
        EndIf
        Local $hbitmap = _WinAPI_CreateDIBSection(0x0, $tbitmapinfo, 0x0, $__g_vext)
        If Not $hbitmap Then Return SetError(@error, @extended, 0x0)
        Return $hbitmap
    EndFunc    ; -> _WinAPI_CreateDIB

    Func _WinAPI_CreateDIBSection($hdc, $tbitmapinfo, $iusage, ByRef $pbits, $hsection = 0x0, $ioffset = 0x0)
        $pbits = 0x0
        Local $acall = DllCall("gdi32.dll", "handle", "CreateDIBSection", "handle", $hdc, "struct*", $tbitmapinfo, "uint", $iusage, "ptr*", 0x0, "handle", $hsection, "dword", $ioffset)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        $pbits = $acall[0x4]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateDIBSection

    Func _WinAPI_CreateDIBColorTable(Const ByRef $ACOLORTABLE, $istart = 0x0, $IEND = + -1)
        If __CheckErrorArrayBounds($ACOLORTABLE, $istart, $IEND) Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $tcolortable = DllStructCreate("dword[" & ($IEND - $istart + 0x1) & "]")
        Local $icount = 0x1
        For $i = $istart To $IEND
            DllStructSetData($tcolortable, 0x1, _WinAPI_SwitchColor(__rgb($ACOLORTABLE[$i])), $icount)
            $icount += 0x1
        Next
        Return $tcolortable
    EndFunc    ; -> _WinAPI_CreateDIBColorTable

    Func _WinAPI_CreateFont($iheight, $iwidth, $iescape = 0x0, $iorientn = 0x0, $iweight = $__WINAPICONSTANT_FW_NORMAL, $bitalic = False, $bunderline = False, $bstrikeout = False, $icharset = $__WINAPICONSTANT_DEFAULT_CHARSET, $ioutputprec = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS, $iclipprec = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS, $iquality = $__WINAPICONSTANT_DEFAULT_QUALITY, $ipitch = 0x0, $sface = "Arial")
        Local $acall = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iheight, "int", $iwidth, "int", $iescape, "int", $iorientn, "int", $iweight, "dword", $bitalic, "dword", $bunderline, "dword", $bstrikeout, "dword", $icharset, "dword", $ioutputprec, "dword", $iclipprec, "dword", $iquality, "dword", $ipitch, "wstr", $sface)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateFont

    Func _WinAPI_CreateFontIndirect($tlogfont)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tlogfont)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateFontIndirect

    Func _WinAPI_CreateRectRgn($ileftrect, $itoprect, $irightrect, $ibottomrect)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", $ileftrect, "int", $itoprect, "int", $irightrect, "int", $ibottomrect)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateRectRgn

    Func _WinAPI_CreateRoundRectRgn($ileftrect, $itoprect, $irightrect, $ibottomrect, $iwidthellipse, $iheightellipse)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $ileftrect, "int", $itoprect, "int", $irightrect, "int", $ibottomrect, "int", $iwidthellipse, "int", $iheightellipse)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateRoundRectRgn

    Func _WinAPI_CreateSolidBrush($icolor)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateSolidBrush", "INT", $icolor)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateSolidBrush

    Func _WinAPI_GetBitmapDimension($hbitmap)
        Local $tobj = DllStructCreate($TAGBITMAP)
        Local $acall = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return _WinAPI_CreateSize(DllStructGetData($tobj, "bmWidth"), DllStructGetData($tobj, "bmHeight"))
    EndFunc    ; -> _WinAPI_GetBitmapDimension

    Func _WinAPI_GetSysColorBrush($iindex)
        Local $acall = DllCall("user32.dll", "handle", "GetSysColorBrush", "int", $iindex)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetSysColorBrush

    Func _WinAPI_GetTextExtentPoint32($hdc, $stext)
        Local $tsize = DllStructCreate($TAGSIZE)
        Local $isize = StringLen($stext)
        Local $acall = DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hdc, "wstr", $stext, "int", $isize, "struct*", $tsize)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tsize
    EndFunc    ; -> _WinAPI_GetTextExtentPoint32

    Func _WinAPI_GetTextMetrics($hdc)
        Local $ttextmetric = DllStructCreate($TAGTEXTMETRIC)
        Local $acall = DllCall("gdi32.dll", "bool", "GetTextMetricsW", "handle", $hdc, "struct*", $ttextmetric)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $ttextmetric
    EndFunc    ; -> _WinAPI_GetTextMetrics

    Func _WinAPI_GetWindowRgn($hwnd, $hrgn)
        Local $acall = DllCall("user32.dll", "int", "GetWindowRgn", "hwnd", $hwnd, "handle", $hrgn)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetWindowRgn

    Func _WinAPI_IsAlphaBitmap($hbitmap)
        $hbitmap = _WinAPI_CopyBitmap($hbitmap)
        If Not $hbitmap Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $acall, $ierror = 0x0
        Do
            Local $tdib = DllStructCreate($TAGDIBSECTION)
            If (Not _WinAPI_GetObject($hbitmap, DllStructGetSize($tdib), $tdib)) Or (DllStructGetData($tdib, "bmBitsPixel") <> 0x20) Or (DllStructGetData($tdib, "biCompression")) Then
                $ierror = 0x1
                ExitLoop
            EndIf
            $acall = DllCall("user32.dll", "int", "CallWindowProc", "ptr", __AlphaProc(), "ptr", 0x0, "uint", 0x0, "struct*", $tdib, "ptr", 0x0)
            If @error Or ($acall[0x0] = + -1) Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
        Until 0x1
        _WinAPI_DeleteObject($hbitmap)
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsAlphaBitmap

    Func _WinAPI_PtInRect(ByRef $trect, ByRef $tpoint)
        Local $acall = DllCall("user32.dll", "bool", "PtInRect", "struct*", $trect, "struct", $tpoint)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PtInRect

    Func _WinAPI_RedrawWindow($hwnd, $trect = 0x0, $hregion = 0x0, $IFLAGS = 0x5)
        Local $acall = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hwnd, "struct*", $trect, "handle", $hregion, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RedrawWindow

    Func _WinAPI_SetWindowRgn($hwnd, $hrgn, $bredraw = True)
        Local $acall = DllCall("user32.dll", "int", "SetWindowRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $bredraw)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWindowRgn

#EndRegion Public Functions
#Region Embedded DLL Functions
    Func __AlphaProc()
        Static $pproc = 0x0
        If Not $pproc Then
            If @AutoItX64 Then
                $pproc = __Init(Binary("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883" & "7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB" & "034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B" & "6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24" & "287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080" & "7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB" & "034831C04883C438415F5DC3"))
            Else
                $pproc = __Init(Binary("0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D" & "1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407" & "B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302" & "83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00" & "007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000"))
            EndIf
        EndIf
        Return $pproc
    EndFunc    ; -> __AlphaProc

    Func __ANDProc()
        Static $pproc = 0x0
        If Not $pproc Then
            If @AutoItX64 Then
                $pproc = __Init(Binary("0x48894C240848895424104C894424184C894C2420554157415648C7C009000000" & "4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405" & "4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405" & "4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405" & "4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405" & "4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048" & "21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000" & "EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7" & "44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100" & "0048C74424380000000048C74424400000000048C744244800000000488BAC24" & "A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B" & "7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440" & "4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24" & "4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7" & "442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C" & "24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845" & "0048FF4424604883442458F871B948C74424380000000048C744244000000000" & "48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7" & "D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C" & "244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D" & "184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24" & "585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0" & "010000004863C0EB034831C04883C470415E415F5DC3"))
            Else
                $pproc = __Init(Binary("0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05" & "B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24" & "38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0" & "EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000" & "00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7" & "042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000" & "C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B" & "3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480" & "7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24" & "0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424" & "0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3" & "8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8" & "01000000EB0231C083C4205F5B5DC21000"))
            EndIf
        EndIf
        Return $pproc
    EndFunc    ; -> __ANDProc

    Func __XORProc()
        Static $pproc = 0x0
        If Not $pproc Then
            If @AutoItX64 Then
                $pproc = __Init(Binary("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074" & "054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0" & "4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C" & "3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405" & "4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C" & "897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB" & "034831C04883C438415F5DC3"))
            Else
                $pproc = __Init(Binary("0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074" & "0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB" & "5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B" & "6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303" & "895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D" & "C21000"))
            EndIf
        EndIf
        Return $pproc
    EndFunc    ; -> __XORProc

#EndRegion Embedded DLL Functions
#Region Internal Functions
    Func __Init($ddata)
        Local $ilength = BinaryLen($ddata)
        Local $acall = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", 0x0, "ulong_ptr", $ilength, "dword", 0x1000, "dword", 0x40)
        If @error Or Not $acall[0x0] Then __FatalExit(0x1, "Error allocating memory.")
        Local $tdata = DllStructCreate("byte[" & $ilength & "]", $acall[0x0])
        DllStructSetData($tdata, 0x1, $ddata)
        Return $acall[0x0]
    EndFunc    ; -> __Init

#EndRegion Internal Functions
#Region Global Variables and Constants
    Global Const $DI_MASK = 0x1
    Global Const $DI_IMAGE = 0x2
    Global Const $DI_NORMAL = 0x3
    Global Const $DI_COMPAT = 0x4
    Global Const $DI_DEFAULTSIZE = 0x8
    Global Const $DI_NOMIRROR = 0x10
    Global Const $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 0x1
    Global Const $DISPLAY_DEVICE_MULTI_DRIVER = 0x2
    Global Const $DISPLAY_DEVICE_PRIMARY_DEVICE = 0x4
    Global Const $DISPLAY_DEVICE_MIRRORING_DRIVER = 0x8
    Global Const $DISPLAY_DEVICE_VGA_COMPATIBLE = 0x10
    Global Const $DISPLAY_DEVICE_REMOVABLE = 0x20
    Global Const $DISPLAY_DEVICE_DISCONNECT = 0x2000000
    Global Const $DISPLAY_DEVICE_REMOTE = 0x4000000
    Global Const $DISPLAY_DEVICE_MODESPRUNED = 0x8000000
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_CreateCompatibleDC($hdc)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateCompatibleDC

    Func _WinAPI_DeleteDC($hdc)
        Local $acall = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DeleteDC

    Func _WinAPI_DrawEdge($hdc, $trect, $iedgetype, $IFLAGS)
        Local $acall = DllCall("user32.dll", "bool", "DrawEdge", "handle", $hdc, "struct*", $trect, "uint", $iedgetype, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DrawEdge

    Func _WinAPI_DrawFrameControl($hdc, $trect, $itype, $istate)
        Local $acall = DllCall("user32.dll", "bool", "DrawFrameControl", "handle", $hdc, "struct*", $trect, "uint", $itype, "uint", $istate)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DrawFrameControl

    Func _WinAPI_DrawIcon($hdc, $ix, $iy, $hicon)
        Local $acall = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hdc, "int", $ix, "int", $iy, "handle", $hicon)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DrawIcon

    Func _WinAPI_DrawIconEx($hdc, $ix, $iy, $hicon, $iwidth = 0x0, $iheight = 0x0, $istep = 0x0, $hbrush = 0x0, $IFLAGS = 0x3)
        Local $ioptions
        Switch $IFLAGS
        Case 0x1
            $ioptions = $DI_MASK
        Case 0x2
            $ioptions = $DI_IMAGE
        Case 0x3
            $ioptions = $DI_NORMAL
        Case 0x4
            $ioptions = $DI_COMPAT
        Case 0x5
            $ioptions = $DI_DEFAULTSIZE
        Case Else
            $ioptions = $DI_NOMIRROR
        EndSwitch
        Local $acall = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hdc, "int", $ix, "int", $iy, "handle", $hicon, "int", $iwidth, "int", $iheight, "uint", $istep, "handle", $hbrush, "uint", $ioptions)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DrawIconEx

    Func _WinAPI_DrawText($hdc, $stext, ByRef $trect, $IFLAGS)
        Local $acall = DllCall("user32.dll", "int", "DrawTextW", "handle", $hdc, "wstr", $stext, "int", + -1, "struct*", $trect, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DrawText

    Func _WinAPI_EnumDisplayDevices($SDEVICE, $IDEVNUM)
        Local $tname = 0x0, $IFLAGS = 0x0, $adevice[0x5]
        If $SDEVICE <> '' Then
            $tname = DllStructCreate("wchar Text[" & StringLen($SDEVICE) + 0x1 & "]")
            DllStructSetData($tname, "Text", $SDEVICE)
        EndIf
        Local Const $TAGDISPLAY_DEVICE = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
        Local $tdevice = DllStructCreate($TAGDISPLAY_DEVICE)
        Local $idevice = DllStructGetSize($tdevice)
        DllStructSetData($tdevice, "Size", $idevice)
        Local $acall = DllCall("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $tname, "dword", $IDEVNUM, "struct*", $tdevice, "dword", 0x1)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $in = DllStructGetData($tdevice, "Flags")
        If BitAND($in, $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x1)
        If BitAND($in, $DISPLAY_DEVICE_PRIMARY_DEVICE) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x2)
        If BitAND($in, $DISPLAY_DEVICE_MIRRORING_DRIVER) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x4)
        If BitAND($in, $DISPLAY_DEVICE_VGA_COMPATIBLE) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x8)
        If BitAND($in, $DISPLAY_DEVICE_REMOVABLE) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x10)
        If BitAND($in, $DISPLAY_DEVICE_MODESPRUNED) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x20)
        $adevice[0x0] = True
        $adevice[0x1] = DllStructGetData($tdevice, "Name")
        $adevice[0x2] = DllStructGetData($tdevice, "String")
        $adevice[0x3] = $IFLAGS
        $adevice[0x4] = DllStructGetData($tdevice, "ID")
        Return $adevice
    EndFunc    ; -> _WinAPI_EnumDisplayDevices

    Func _WinAPI_FillRect($hdc, $trect, $hbrush)
        Local $acall
        If IsPtr($hbrush) Then
            $acall = DllCall("user32.dll", "int", "FillRect", "handle", $hdc, "struct*", $trect, "handle", $hbrush)
        Else
            $acall = DllCall("user32.dll", "int", "FillRect", "handle", $hdc, "struct*", $trect, "dword_ptr", $hbrush)
        EndIf
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FillRect

    Func _WinAPI_FrameRect($hdc, $trect, $hbrush)
        Local $acall = DllCall("user32.dll", "int", "FrameRect", "handle", $hdc, "struct*", $trect, "handle", $hbrush)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FrameRect

    Func _WinAPI_GetBkMode($hdc)
        Local $acall = DllCall("gdi32.dll", "int", "GetBkMode", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetBkMode

    Func _WinAPI_GetDC($hwnd)
        Local $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetDC

    Func _WinAPI_GetDCEx($hwnd, $hrgn, $IFLAGS)
        Local $acall = DllCall("user32.dll", "handle", "GetDCEx", "hwnd", $hwnd, "handle", $hrgn, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetDCEx

    Func _WinAPI_GetDeviceCaps($hdc, $iindex)
        Local $acall = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hdc, "int", $iindex)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetDeviceCaps

    Func _WinAPI_GetTextColor($hdc)
        Local $acall = DllCall("gdi32.dll", "dword", "GetTextColor", "handle", $hdc)
        If @error Or ($acall[0x0] = -1) Then Return SetError(@error, @extended, + -1)
        Return __rgb($acall[0x0])
    EndFunc    ; -> _WinAPI_GetTextColor

    Func _WinAPI_GetWindowDC($hwnd)
        Local $acall = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetWindowDC

    Func _WinAPI_PrintWindow($hwnd, $hdc, $bclient = False)
        Local $acall = DllCall("user32.dll", "bool", "PrintWindow", "hwnd", $hwnd, "handle", $hdc, "uint", $bclient)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PrintWindow

    Func _WinAPI_ReleaseDC($hwnd, $hdc)
        Local $acall = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ReleaseDC

    Func _WinAPI_RestoreDC($hdc, $iid)
        Local $acall = DllCall("gdi32.dll", "bool", "RestoreDC", "handle", $hdc, "int", $iid)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RestoreDC

    Func _WinAPI_SaveDC($hdc)
        Local $acall = DllCall("gdi32.dll", "int", "SaveDC", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SaveDC

    Func _WinAPI_SetBkColor($hdc, $icolor)
        Local $acall = DllCall("gdi32.dll", "INT", "SetBkColor", "handle", $hdc, "INT", $icolor)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetBkColor

    Func _WinAPI_SetBkMode($hdc, $ibkmode)
        Local $acall = DllCall("gdi32.dll", "int", "SetBkMode", "handle", $hdc, "int", $ibkmode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetBkMode

    Func _WinAPI_SetTextColor($hdc, $icolor)
        Local $acall = DllCall("gdi32.dll", "INT", "SetTextColor", "handle", $hdc, "INT", $icolor)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetTextColor

    Func _WinAPI_TwipsPerPixelX()
        Local $hdc, $itwipsperpixelx
        $hdc = _WinAPI_GetDC(0x0)
        Local Const $__WINAPICONSTANT_LOGPIXELSX = 0x58
        $itwipsperpixelx = 0x5a0 / _WinAPI_GetDeviceCaps($hdc, $__WINAPICONSTANT_LOGPIXELSX)
        _WinAPI_ReleaseDC(0x0, $hdc)
        Return $itwipsperpixelx
    EndFunc    ; -> _WinAPI_TwipsPerPixelX

    Func _WinAPI_TwipsPerPixelY()
        Local $hdc, $itwipsperpixely
        $hdc = _WinAPI_GetDC(0x0)
        Local Const $__WINAPICONSTANT_LOGPIXELSY = 0x5a
        $itwipsperpixely = 0x5a0 / _WinAPI_GetDeviceCaps($hdc, $__WINAPICONSTANT_LOGPIXELSY)
        _WinAPI_ReleaseDC(0x0, $hdc)
        Return $itwipsperpixely
    EndFunc    ; -> _WinAPI_TwipsPerPixelY

#EndRegion Public Functions
#Region Internal Functions
#EndRegion Internal Functions
#Region Global Variables and Constants
    Global Const $IDC_UNKNOWN = 0x0
    Global Const $IDC_APPSTARTING = 0x7f8a
    Global Const $IDC_ARROW = 0x7f00
    Global Const $IDC_CROSS = 0x7f03
    Global Const $IDC_HAND = 0x7f89
    Global Const $IDC_HELP = 0x7f8b
    Global Const $IDC_IBEAM = 0x7f01
    Global Const $IDC_NO = 0x7f88
    Global Const $IDC_SIZEALL = 0x7f86
    Global Const $IDC_SIZENESW = 0x7f83
    Global Const $IDC_SIZENS = 0x7f85
    Global Const $IDC_SIZENWSE = 0x7f82
    Global Const $IDC_SIZEWE = 0x7f84
    Global Const $IDC_UPARROW = 0x7f04
    Global Const $IDC_WAIT = 0x7f02
    Global Const $IDI_APPLICATION = 0x7f00
    Global Const $IDI_ASTERISK = 0x7f04
    Global Const $IDI_EXCLAMATION = 0x7f03
    Global Const $IDI_HAND = 0x7f01
    Global Const $IDI_QUESTION = 0x7f02
    Global Const $IDI_WINLOGO = 0x7f05
    Global Const $IDI_SHIELD = 0x7f06
    Global Const $IDI_ERROR = $IDI_HAND
    Global Const $IDI_INFORMATION = $IDI_ASTERISK
    Global Const $IDI_WARNING = $IDI_EXCLAMATION
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Global Const $TAGICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
    Func _WinAPI_AddIconTransparency($hicon, $ipercent = 0x32, $bdelete = False)
        Local $tbitmap, $hdib = 0x0, $hresult = 0x0
        Local $ahbitmap[0x2]
        Local $ticoninfo = DllStructCreate($TAGICONINFO)
        Local $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        For $i = 0x0 To 0x1
            $ahbitmap[$i] = DllStructGetData($ticoninfo, $i + 0x4)
        Next
        Local $ierror = 0x0
        Do
            $hdib = _WinAPI_CopyBitmap($ahbitmap[0x1])
            If Not $hdib Then
                $ierror = 0x14
                ExitLoop
            EndIf
            $tbitmap = DllStructCreate($TAGBITMAP)
            If (Not _WinAPI_GetObject($hdib, DllStructGetSize($tbitmap), $tbitmap)) Or (DllStructGetData($tbitmap, "bmBitsPixel") <> 0x20) Then
                $ierror = 0x15
                ExitLoop
            EndIf
            $acall = DllCall("user32.dll", "lresult", "CallWindowProc", "PTR", __TransparencyProc(), "hwnd", 0x0, "uint", $ipercent, "wparam", DllStructGetPtr($tbitmap), "lparam", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            If $acall[0x0] = + -1 Then
                $hresult = _WinAPI_CreateEmptyIcon(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"))
            Else
                $hresult = _WinAPI_CreateIconIndirect($hdib, $ahbitmap[0x0])
            EndIf
            If Not $hresult Then $ierror = 0x16
        Until 0x1
        If $hdib Then
            _WinAPI_DeleteObject($hdib)
        EndIf
        For $i = 0x0 To 0x1
            If $ahbitmap[$i] Then
                _WinAPI_DeleteObject($ahbitmap[$i])
            EndIf
        Next
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        If $bdelete Then
            _WinAPI_DestroyIcon($hicon)
        EndIf
        Return $hresult
    EndFunc    ; -> _WinAPI_AddIconTransparency

    Func _WinAPI_CopyIcon($hicon)
        Local $acall = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hicon)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CopyIcon

    Func _WinAPI_Create32BitHICON($hicon, $bdelete = False)
        Local $ahbitmap[0x2], $hresult = 0x0
        Local $adib[0x2][0x2] = [[0x0, 0x0], [0x0, 0x0]]
        Local $ticoninfo = DllStructCreate($TAGICONINFO)
        Local $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        For $i = 0x0 To 0x1
            $ahbitmap[$i] = DllStructGetData($ticoninfo, $i + 0x4)
        Next
        If _WinAPI_IsAlphaBitmap($ahbitmap[0x1]) Then
            $adib[0x0][0x0] = _WinAPI_CreateANDBitmap($ahbitmap[0x1])
            If Not @error Then
                $hresult = _WinAPI_CreateIconIndirect($ahbitmap[0x1], $adib[0x0][0x0])
            EndIf
        Else
            Local $tsize = _WinAPI_GetBitmapDimension($ahbitmap[0x1])
            Local $asize[0x2]
            For $i = 0x0 To 0x1
                $asize[$i] = DllStructGetData($tsize, $i + 0x1)
            Next
            Local $hsrcdc = _WinAPI_CreateCompatibleDC(0x0)
            Local $hdstdc = _WinAPI_CreateCompatibleDC(0x0)
            Local $hsrcsv, $hdstsv
            For $i = 0x0 To 0x1
                $adib[$i][0x0] = _WinAPI_CreateDIB($asize[0x0], $asize[0x1])
                $adib[$i][0x1] = $__g_vext
                $hsrcsv = _WinAPI_SelectObject($hsrcdc, $ahbitmap[$i])
                $hdstsv = _WinAPI_SelectObject($hdstdc, $adib[$i][0x0])
                _WinAPI_BitBlt($hdstdc, 0x0, 0x0, $asize[0x0], $asize[0x1], $hsrcdc, 0x0, 0x0, 0xc000ca)
                _WinAPI_SelectObject($hsrcdc, $hsrcsv)
                _WinAPI_SelectObject($hdstdc, $hdstsv)
            Next
            _WinAPI_DeleteDC($hsrcdc)
            _WinAPI_DeleteDC($hdstdc)
            $acall = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", __XORProc(), "ptr", 0x0, "uint", $asize[0x0] * $asize[0x1] * 0x4, "wparam", $adib[0x0][0x1], "lparam", $adib[0x1][0x1])
            If Not @error And $acall[0x0] Then
                $hresult = _WinAPI_CreateIconIndirect($adib[0x1][0x0], $ahbitmap[0x0])
            EndIf
        EndIf
        For $i = 0x0 To 0x1
            _WinAPI_DeleteObject($ahbitmap[$i])
            If $adib[$i][0x0] Then
                _WinAPI_DeleteObject($adib[$i][0x0])
            EndIf
        Next
        If Not $hresult Then Return SetError(0xb, 0x0, 0x0)
        If $bdelete Then
            _WinAPI_DestroyIcon($hicon)
        EndIf
        Return $hresult
    EndFunc    ; -> _WinAPI_Create32BitHICON

    Func _WinAPI_CreateEmptyIcon($iwidth, $iheight, $ibitsperpel = 0x20)
        Local $hxor = _WinAPI_CreateDIB($iwidth, $iheight, $ibitsperpel)
        Local $hand = _WinAPI_CreateDIB($iwidth, $iheight, 0x1)
        Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
        Local $hsv = _WinAPI_SelectObject($hdc, $hand)
        Local $hbrush = _WinAPI_CreateSolidBrush(0xffffff)
        Local $trect = _WinAPI_CreateRect(0x0, 0x0, $iwidth, $iheight)
        _WinAPI_FillRect($hdc, $trect, $hbrush)
        _WinAPI_DeleteObject($hbrush)
        _WinAPI_SelectObject($hdc, $hsv)
        _WinAPI_DeleteDC($hdc)
        Local $hicon = _WinAPI_CreateIconIndirect($hxor, $hand)
        Local $ierror = @error
        If $hxor Then
            _WinAPI_DeleteObject($hxor)
        EndIf
        If $hand Then
            _WinAPI_DeleteObject($hand)
        EndIf
        If Not $hicon Then Return SetError($ierror + 0xa, 0x0, 0x0)
        Return $hicon
    EndFunc    ; -> _WinAPI_CreateEmptyIcon

    Func _WinAPI_CreateIcon($hinstance, $iwidth, $iheight, $iplanes, $ibitspixel, $pandbits, $pxorbits)
        Local $acall = DllCall("user32.dll", "handle", "CreateIcon", "handle", $hinstance, "int", $iwidth, "int", $iheight, "byte", $iplanes, "byte", $ibitspixel, "struct*", $pandbits, "struct*", $pxorbits)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateIcon

    Func _WinAPI_CreateIconFromResourceEx($pdata, $isize, $bicon = True, $ixdesiredpixels = 0x0, $iydesiredpixels = 0x0, $IFLAGS = 0x0)
        Local $acall = DllCall("user32.dll", "handle", "CreateIconFromResourceEx", "ptr", $pdata, "dword", $isize, "bool", $bicon, "dword", 0x30000, "int", $ixdesiredpixels, "int", $iydesiredpixels, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateIconFromResourceEx

    Func _WinAPI_CreateIconIndirect($hbitmap, $hmask, $ixhotspot = 0x0, $iyhotspot = 0x0, $bicon = True)
        Local $ticoninfo = DllStructCreate($TAGICONINFO)
        DllStructSetData($ticoninfo, 0x1, $bicon)
        DllStructSetData($ticoninfo, 0x2, $ixhotspot)
        DllStructSetData($ticoninfo, 0x3, $iyhotspot)
        DllStructSetData($ticoninfo, 0x4, $hmask)
        DllStructSetData($ticoninfo, 0x5, $hbitmap)
        Local $acall = DllCall("user32.dll", "handle", "CreateIconIndirect", "struct*", $ticoninfo)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateIconIndirect

    Func _WinAPI_DestroyIcon($hicon)
        Local $acall = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hicon)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DestroyIcon

    Func _WinAPI_ExtractIcon($sicon, $iindex, $bsmall = False)
        Local $plarge, $psmall, $tptr = DllStructCreate("ptr")
        If $bsmall Then
            $plarge = 0x0
            $psmall = DllStructGetPtr($tptr)
        Else
            $plarge = DllStructGetPtr($tptr)
            $psmall = 0x0
        EndIf
        DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sicon, "int", $iindex, "ptr", $plarge, "ptr", $psmall, "uint", 0x1)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return DllStructGetData($tptr, 0x1)
    EndFunc    ; -> _WinAPI_ExtractIcon

    Func _WinAPI_ExtractIconEx($sfilepath, $iindex, $palarge, $pasmall, $iicons)
        Local $acall = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sfilepath, "int", $iindex, "struct*", $palarge, "struct*", $pasmall, "uint", $iicons)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ExtractIconEx

    Func _WinAPI_FileIconInit($brestore = True)
        Local $acall = DllCall("shell32.dll", "int", 0x294, "int", $brestore)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_FileIconInit

    Func _WinAPI_GetIconDimension($hicon)
        Local $ticoninfo = DllStructCreate($TAGICONINFO)
        Local $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $tsize = _WinAPI_GetBitmapDimension(DllStructGetData($ticoninfo, 0x5))
        For $i = 0x4 To 0x5
            _WinAPI_DeleteObject(DllStructGetData($ticoninfo, $i))
        Next
        If Not IsDllStruct($tsize) Then Return SetError(0x14, 0x0, 0x0)
        Return $tsize
    EndFunc    ; -> _WinAPI_GetIconDimension

    Func _WinAPI_GetIconInfo($hicon)
        Local $tinfo = DllStructCreate($TAGICONINFO)
        Local $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $tinfo)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aicon[0x6]
        $aicon[0x0] = True
        $aicon[0x1] = DllStructGetData($tinfo, "Icon") <> 0x0
        $aicon[0x2] = DllStructGetData($tinfo, "XHotSpot")
        $aicon[0x3] = DllStructGetData($tinfo, "YHotSpot")
        $aicon[0x4] = DllStructGetData($tinfo, "hMask")
        $aicon[0x5] = DllStructGetData($tinfo, "hColor")
        Return $aicon
    EndFunc    ; -> _WinAPI_GetIconInfo

    Func _WinAPI_GetIconInfoEx($hicon)
        Local $tiiex = DllStructCreate("dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]")
        DllStructSetData($tiiex, 0x1, DllStructGetSize($tiiex))
        Local $acall = DllCall("user32.dll", "bool", "GetIconInfoExW", "handle", $hicon, "struct*", $tiiex)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x8]
        For $i = 0x0 To 0x7
            $aret[$i] = DllStructGetData($tiiex, $i + 0x2)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetIconInfoEx

    Func _WinAPI_LoadIcon($hinstance, $sname)
        Local $stypeofname = "int"
        If IsString($sname) Then
            $stypeofname = "wstr"
        EndIf
        Local $acall = DllCall("user32.dll", "handle", "LoadIconW", "handle", $hinstance, $stypeofname, $sname)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LoadIcon

    Func _WinAPI_LoadIconMetric($hinstance, $sname, $imetric)
        Local $stypeofname = "int"
        If IsString($sname) Then
            $stypeofname = "wstr"
        EndIf
        Local $acall = DllCall("comctl32.dll", "long", "LoadIconMetric", "handle", $hinstance, $stypeofname, $sname, "int", $imetric, "handle*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x4]
    EndFunc    ; -> _WinAPI_LoadIconMetric

    Func _WinAPI_LoadIconWithScaleDown($hinstance, $sname, $iwidth, $iheight)
        Local $stypeofname = "int"
        If IsString($sname) Then
            $stypeofname = "wstr"
        EndIf
        Local $acall = DllCall("comctl32.dll", "long", "LoadIconWithScaleDown", "handle", $hinstance, $stypeofname, $sname, "int", $iwidth, "int", $iheight, "handle*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_LoadIconWithScaleDown

    Func _WinAPI_LoadShell32Icon($iiconid)
        Local $ticons = DllStructCreate("ptr Data")
        Local $iicons = _WinAPI_ExtractIconEx("shell32.dll", $iiconid, 0x0, $ticons, 0x1)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $iicons <= 0x0 Then Return SetError(0xa, 0x0, 0x0)
        Return DllStructGetData($ticons, "Data")
    EndFunc    ; -> _WinAPI_LoadShell32Icon

    Func _WinAPI_LookupIconIdFromDirectoryEx($pdata, $bicon = True, $ixdesiredpixels = 0x0, $iydesiredpixels = 0x0, $IFLAGS = 0x0)
        Local $acall = DllCall("user32.dll", "int", "LookupIconIdFromDirectoryEx", "ptr", $pdata, "bool", $bicon, "int", $ixdesiredpixels, "int", $iydesiredpixels, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LookupIconIdFromDirectoryEx

    Func _WinAPI_MirrorIcon($hicon, $bdelete = False)
        If Not $bdelete Then
            $hicon = _WinAPI_CopyIcon($hicon)
        EndIf
        Local $acall = DllCall("comctl32.dll", "int", 0x19e, "ptr", 0x0, "ptr*", $hicon)
        If @error Or Not $acall[0x0] Then
            Local $ierror = @error + 0xa
            If $hicon And Not $bdelete Then
                _WinAPI_DestroyIcon($hicon)
            EndIf
            Return SetError($ierror, 0x0, 0x0)
        EndIf
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_MirrorIcon

#EndRegion Public Functions
#Region Embedded DLL Functions
    Func __TransparencyProc()
        Static $pproc = 0x0
        If Not $pproc Then
            If @AutoItX64 Then
                $pproc = __Init(Binary("0x48894C240848895424104C894424184C894C24205541574831C0505050505050" & "4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522" & "488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502" & "EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63" & "7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF" & "7D08C74424780000000048C74424280100000048C74424300000000048C74424" & "3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF" & "F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18" & "4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C" & "244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899" & "48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7" & "4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24" & "3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0" & "FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F" & "5DC3"))
            Else
                $pproc = __Init(Binary("0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24" & "28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021" & "C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24" & "2421DB7D08C744242400000000C7042401000000C744240400000000C7442408" & "000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B" & "6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24" & "100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058" & "8845008B6C240C807D00007407C7042400000000C74424040100000083442408" & "047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF" & "FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000"))
            EndIf
        EndIf
        Return $pproc
    EndFunc    ; -> __TransparencyProc

#EndRegion Embedded DLL Functions
#Region Global Variables and Constants
    Global $__g_vval
    Global Const $TAGVS_FIXEDFILEINFO = "dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dwo" & _
        "rd FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_BeginUpdateResource($sfilepath, $bdelete = False)
        Local $acall = DllCall("kernel32.dll", "handle", "BeginUpdateResourceW", "wstr", $sfilepath, "bool", $bdelete)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BeginUpdateResource

    Func _WinAPI_ClipCursor($trect)
        Local $acall = DllCall("user32.dll", "bool", "ClipCursor", "struct*", $trect)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ClipCursor

    Func _WinAPI_CopyCursor($hcursor)
        Return _WinAPI_CopyIcon($hcursor)
    EndFunc    ; -> _WinAPI_CopyCursor

    Func _WinAPI_CreateCaret($hwnd, $hbitmap, $iwidth = 0x0, $iheight = 0x0)
        Local $acall = DllCall("user32.dll", "bool", "CreateCaret", "hwnd", $hwnd, "handle", $hbitmap, "int", $iwidth, "int", $iheight)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateCaret

    Func _WinAPI_DestroyCaret()
        Local $acall = DllCall("user32.dll", "bool", "DestroyCaret")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DestroyCaret

    Func _WinAPI_DestroyCursor($hcursor)
        Local $acall = DllCall("user32.dll", "bool", "DestroyCursor", "handle", $hcursor)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DestroyCursor

    Func _WinAPI_EndUpdateResource($hupdate, $bdiscard = False)
        Local $acall = DllCall("kernel32.dll", "bool", "EndUpdateResourceW", "handle", $hupdate, "bool", $bdiscard)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_EndUpdateResource

    Func _WinAPI_EnumResourceLanguages($hmodule, $stype, $sname)
        Local $ilibrary = 0x0, $stypeoftype = "int", $stypeofname = "int"
        If IsString($hmodule) Then
            If StringStripWS($hmodule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
                $hmodule = _WinAPI_LoadLibraryEx($hmodule, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
                If Not $hmodule Then Return SetError(0x1, 0x0, 0x0)
                $ilibrary = 0x1
            Else
                $hmodule = 0x0
            EndIf
        EndIf
        If IsString($stype) Then
            $stypeoftype = "wstr"
        EndIf
        If IsString($sname) Then
            $stypeofname = "wstr"
        EndIf
        Dim $__g_venum[0x65] = [0x0]
        Local $henumproc = DllCallbackRegister("__EnumResLanguagesProc", "bool", "handle;ptr;ptr;word;long_ptr")
        Local $acall = DllCall("kernel32.dll", "bool", "EnumResourceLanguagesW", "handle", $hmodule, $stypeoftype, $stype, $stypeofname, $sname, "ptr", DllCallbackGetPtr($henumproc), "long_ptr", 0x0)
        If @error Or Not $acall[0x0] Or Not $__g_venum[0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        If $ilibrary Then
            _WinAPI_FreeLibrary($hmodule)
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumResourceLanguages

    Func _WinAPI_EnumResourceNames($hmodule, $stype)
        Local $acall, $henumproc, $ilibrary = 0x0, $stypeoftype = "int"
        If IsString($hmodule) Then
            If StringStripWS($hmodule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
                $hmodule = _WinAPI_LoadLibraryEx($hmodule, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
                If Not $hmodule Then Return SetError(0x1, 0x0, 0x0)
                $ilibrary = 0x1
            Else
                $hmodule = 0x0
            EndIf
        EndIf
        If IsString($stype) Then
            $stypeoftype = "wstr"
        EndIf
        Dim $__g_venum[0x65] = [0x0]
        $henumproc = DllCallbackRegister("__EnumResNamesProc", "bool", "handle;ptr;ptr;long_ptr")
        $acall = DllCall("kernel32.dll", "bool", "EnumResourceNamesW", "handle", $hmodule, $stypeoftype, $stype, "ptr", DllCallbackGetPtr($henumproc), "long_ptr", 0x0)
        If @error Or Not $acall[0x0] Or (Not $__g_venum[0x0]) Then
            $__g_venum = @error + 0xa
        EndIf
        If $ilibrary Then
            _WinAPI_FreeLibrary($hmodule)
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumResourceNames

    Func _WinAPI_EnumResourceTypes($hmodule)
        Local $ilibrary = 0x0
        If IsString($hmodule) Then
            If StringStripWS($hmodule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
                $hmodule = _WinAPI_LoadLibraryEx($hmodule, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
                If Not $hmodule Then Return SetError(0x1, 0x0, 0x0)
                $ilibrary = 0x1
            Else
                $hmodule = 0x0
            EndIf
        EndIf
        Dim $__g_venum[0x65] = [0x0]
        Local $henumproc = DllCallbackRegister("__EnumResTypesProc", "bool", "handle;ptr;long_ptr")
        Local $acall = DllCall("kernel32.dll", "bool", "EnumResourceTypesW", "handle", $hmodule, "ptr", DllCallbackGetPtr($henumproc), "long_ptr", 0x0)
        If @error Or Not $acall[0x0] Or (Not $__g_venum[0x0]) Then
            $__g_venum = @error + 0xa
        EndIf
        If $ilibrary Then
            _WinAPI_FreeLibrary($hmodule)
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumResourceTypes

    Func _WinAPI_FindResource($hinstance, $stype, $sname)
        Local $stypeoftype = "int", $stypeofname = "int"
        If IsString($stype) Then
            $stypeoftype = "wstr"
        EndIf
        If IsString($sname) Then
            $stypeofname = "wstr"
        EndIf
        Local $acall = DllCall("kernel32.dll", "handle", "FindResourceW", "handle", $hinstance, $stypeofname, $sname, $stypeoftype, $stype)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindResource

    Func _WinAPI_FindResourceEx($hinstance, $stype, $sname, $ilanguage)
        Local $stypeoftype = "int", $stypeofname = "int"
        If IsString($stype) Then
            $stypeoftype = "wstr"
        EndIf
        If IsString($sname) Then
            $stypeofname = "wstr"
        EndIf
        Local $acall = DllCall("kernel32.dll", "handle", "FindResourceExW", "handle", $hinstance, $stypeoftype, $stype, $stypeofname, $sname, "ushort", $ilanguage)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindResourceEx

    Func _WinAPI_FreeResource($hdata)
        Local $acall = DllCall("kernel32.dll", "bool", "FreeResource", "handle", $hdata)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FreeResource

    Func _WinAPI_GetCaretBlinkTime()
        Local $acall = DllCall("user32.dll", "uint", "GetCaretBlinkTime")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetCaretBlinkTime

    Func _WinAPI_GetCaretPos()
        Local $tpoint = DllStructCreate($TAGPOINT)
        Local $acall = DllCall("user32.dll", "bool", "GetCaretPos", "struct*", $tpoint)
        If @error Then Return SetError(@error, @extended, 0x0)
        If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
        Local $aret[0x2]
        For $i = 0x0 To 0x1
            $aret[$i] = DllStructGetData($tpoint, $i + 0x1)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetCaretPos

    Func _WinAPI_GetClipCursor()
        Local $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("user32.dll", "bool", "GetClipCursor", "struct*", $trect)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_GetClipCursor

    Func _WinAPI_GetCursor()
        Local $acall = DllCall("user32.dll", "handle", "GetCursor")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetCursor

    Func _WinAPI_GetFileVersionInfo($sfilepath, ByRef $pbuffer, $IFLAGS = 0x0)
        Local $acall
        If _WinAPI_GetVersion() >= 6 Then
            $acall = DllCall("version.dll", "dword", "GetFileVersionInfoSizeExW", "dword", BitAND($IFLAGS, 0x3), "wstr", $sfilepath, "ptr", 0x0)
        Else
            $acall = DllCall("version.dll", "dword", "GetFileVersionInfoSizeW", "wstr", $sfilepath, "ptr", 0x0)
        EndIf
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        $pbuffer = __HeapReAlloc($pbuffer, $acall[0x0], 0x1)
        If @error Then Return SetError(@error + 0x64, @extended, 0x0)
        Local $inbbyte = $acall[0x0]
        If _WinAPI_GetVersion() >= 6 Then
            $acall = DllCall("version.dll", "bool", "GetFileVersionInfoExW", "dword", BitAND($IFLAGS, 0x7), "wstr", $sfilepath, "dword", 0x0, "dword", $inbbyte, "ptr", $pbuffer)
        Else
            $acall = DllCall("version.dll", "bool", "GetFileVersionInfoW", "wstr", $sfilepath, "dword", 0x0, "dword", $inbbyte, "ptr", $pbuffer)
        EndIf
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $inbbyte
    EndFunc    ; -> _WinAPI_GetFileVersionInfo

    Func _WinAPI_HideCaret($hwnd)
        Local $acall = DllCall("user32.dll", "int", "HideCaret", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_HideCaret

    Func _WinAPI_LoadBitmap($hinstance, $sbitmap)
        Local $sbitmaptype = "int"
        If IsString($sbitmap) Then $sbitmaptype = "wstr"
        Local $acall = DllCall("user32.dll", "handle", "LoadBitmapW", "handle", $hinstance, $sbitmaptype, $sbitmap)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LoadBitmap

    Func _WinAPI_LoadCursor($hinstance, $sname)
        Local $stypeofname = "int"
        If IsString($sname) Then
            $stypeofname = "wstr"
        EndIf
        Local $acall = DllCall("user32.dll", "handle", "LoadCursorW", "handle", $hinstance, $stypeofname, $sname)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LoadCursor

    Func _WinAPI_LoadCursorFromFile($sfilepath)
        Local $acall = DllCall("user32.dll", "handle", "LoadCursorFromFileW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LoadCursorFromFile

    Func _WinAPI_LoadIndirectString($sstrin)
        Local $acall = DllCall("shlwapi.dll", "uint", "SHLoadIndirectString", "wstr", $sstrin, "wstr", '', "uint", 0x1000, "ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_LoadIndirectString

    Func _WinAPI_LoadString($hinstance, $istringid)
        Local $acall = DllCall("user32.dll", "int", "LoadStringW", "handle", $hinstance, "uint", $istringid, "wstr", '', "int", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return SetExtended($acall[0x0], $acall[0x3])
    EndFunc    ; -> _WinAPI_LoadString

    Func _WinAPI_LoadLibraryEx($sfilename, $IFLAGS = 0x0)
        Local $acall = DllCall("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $sfilename, "ptr", 0x0, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LoadLibraryEx

    Func _WinAPI_LoadResource($hinstance, $hresource)
        Local $acall = DllCall("kernel32.dll", "handle", "LoadResource", "handle", $hinstance, "handle", $hresource)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LoadResource

    Func _WinAPI_LoadStringEx($hmodule, $iid, $ilanguage = $LOCALE_USER_DEFAULT)
        Local $ilibrary = 0x0
        If IsString($hmodule) Then
            If StringStripWS($hmodule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
                $hmodule = _WinAPI_LoadLibraryEx($hmodule, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
                If Not $hmodule Then Return SetError(@error + 0x14, @extended, '')
                $ilibrary = 0x1
            Else
                $hmodule = 0x0
            EndIf
        EndIf
        Local $sresult = ''
        Local $pdata = __ResLoad($hmodule, 0x6, Floor($iid / 0x10) + 0x1, $ilanguage)
        If Not @error Then
            Local $ioffset = 0x0
            For $i = 0x0 To Mod($iid, 0x10) + -1
                $ioffset += 0x2 * (DllStructGetData(DllStructCreate("ushort", $pdata + $ioffset), 0x1) + 0x1)
            Next
            $sresult = DllStructGetData(DllStructCreate("ushort;wchar[" & DllStructGetData(DllStructCreate("ushort", $pdata + $ioffset), 0x1) & "]", $pdata + $ioffset), 0x2)
            If @error Then $sresult = ''
        Else
            Return SetError(0xa, 0x0, '')
        EndIf
        If $ilibrary Then
            _WinAPI_FreeLibrary($hmodule)
        EndIf
        Return SetError(Number(Not $sresult), 0x0, $sresult)
    EndFunc    ; -> _WinAPI_LoadStringEx

    Func _WinAPI_LockResource($hdata)
        Local $acall = DllCall("kernel32.dll", "ptr", "LockResource", "handle", $hdata)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LockResource

    Func _WinAPI_SetCaretBlinkTime($iduration)
        Local $iprev = _WinAPI_GetCaretBlinkTime()
        If Not $iprev Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $acall = DllCall("user32.dll", "bool", "SetCaretBlinkTime", "uint", $iduration)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $iprev
    EndFunc    ; -> _WinAPI_SetCaretBlinkTime

    Func _WinAPI_SetCaretPos($ix, $iy)
        Local $acall = DllCall("user32.dll", "int", "SetCaretPos", "int", $ix, "int", $iy)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetCaretPos

    Func _WinAPI_SetCursor($hcursor)
        Local $acall = DllCall("user32.dll", "handle", "SetCursor", "handle", $hcursor)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetCursor

    Func _WinAPI_SetSystemCursor($hcursor, $iid, $bcopy = False)
        If $bcopy Then
            $hcursor = _WinAPI_CopyCursor($hcursor)
        EndIf
        Local $acall = DllCall("user32.dll", "bool", "SetSystemCursor", "handle", $hcursor, "dword", $iid)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetSystemCursor

    Func _WinAPI_ShowCaret($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "ShowCaret", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShowCaret

    Func _WinAPI_ShowCursor($bshow)
        Local $acall = DllCall("user32.dll", "int", "ShowCursor", "bool", $bshow)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShowCursor

    Func _WinAPI_SizeOfResource($hinstance, $hresource)
        Local $acall = DllCall("kernel32.dll", "dword", "SizeofResource", "handle", $hinstance, "handle", $hresource)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SizeOfResource

    Func _WinAPI_UpdateResource($hupdate, $stype, $sname, $ilanguage, $pdata, $isize)
        Local $stypeoftype = "int", $stypeofname = "int"
        If IsString($stype) Then
            $stypeoftype = "wstr"
        EndIf
        If IsString($sname) Then
            $stypeofname = "wstr"
        EndIf
        Local $acall = DllCall("kernel32.dll", "bool", "UpdateResourceW", "handle", $hupdate, $stypeoftype, $stype, $stypeofname, $sname, "word", $ilanguage, "ptr", $pdata, "dword", $isize)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UpdateResource

    Func _WinAPI_VerQueryRoot($pdata)
        Local $acall = DllCall("version.dll", "bool", "VerQueryValueW", "ptr", $pdata, "wstr", "\\", "ptr*", 0x0, "uint*", 0x0)
        If @error Or Not $acall[0x0] Or Not $acall[0x4] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $tvffi = DllStructCreate($TAGVS_FIXEDFILEINFO)
        If Not _WinAPI_MoveMemory($tvffi, $acall[0x3], $acall[0x4]) Then Return SetError(@error + 0x14, @extended, 0x0)
        Return $tvffi
    EndFunc    ; -> _WinAPI_VerQueryRoot

    Func _WinAPI_VerQueryValue($pdata, $svalues = '')
        $svalues = StringRegExpReplace($svalues, "\\A[\\s\\|]*|[\\s\\|]*\\Z", '')
        If Not $svalues Then
            $svalues = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBui" & _
                "ld"
        EndIf
        $svalues = StringSplit($svalues, "|", $STR_NOCOUNT)
        Local $acall = DllCall("version.dll", "bool", "VerQueryValueW", "ptr", $pdata, "wstr", "\\VarFileInfo\\Translation", "ptr*", 0x0, "uint*", 0x0)
        If @error Or Not $acall[0x0] Or Not $acall[0x4] Then Return SetError(@error + 0xa, 0x0, 0x0)
        Local $ilength = Floor($acall[0x4] / 0x4)
        Local $tlang = DllStructCreate("dword[" & $ilength & "]", $acall[0x3])
        If @error Then Return SetError(@error + 0x14, 0x0, 0x0)
        Local $scp, $ainfo[0x65][UBound($svalues) + 0x1] = [[0x0]]
        For $i = 0x1 To $ilength
            __Inc($ainfo)
            $ainfo[$ainfo[0x0][0x0]][0x0] = _WinAPI_LoWord(DllStructGetData($tlang, 0x1, $i))
            $scp = Hex(_WinAPI_MakeLong(_WinAPI_HiWord(DllStructGetData($tlang, 0x1, $i)), _WinAPI_LoWord(DllStructGetData($tlang, 0x1, $i))), 0x8)
            For $j = 0x0 To UBound($svalues) + -1
                $acall = DllCall("version.dll", "bool", "VerQueryValueW", "ptr", $pdata, "wstr", "\\StringFileInfo\\" & $scp & "\\" & $svalues[$j], "ptr*", 0x0, "uint*", 0x0)
                If Not @error And $acall[0x0] And $acall[0x4] Then
                    $ainfo[$ainfo[0x0][0x0]][$j + 0x1] = DllStructGetData(DllStructCreate("wchar[" & $acall[0x4] & "]", $acall[0x3]), 0x1)
                Else
                    $ainfo[$ainfo[0x0][0x0]][$j + 0x1] = ''
                EndIf
            Next
        Next
        __Inc($ainfo, + -1)
        Return $ainfo
    EndFunc    ; -> _WinAPI_VerQueryValue

    Func _WinAPI_VerQueryValueEx($hmodule, $svalues = '', $ilanguage = 0x400)
        $__g_vval = StringRegExpReplace($svalues, "\\A[\\s\\|]*|[\\s\\|]*\\Z", '')
        If Not $__g_vval Then
            $__g_vval = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBui" & _
                "ld"
        EndIf
        $__g_vval = StringSplit($__g_vval, "|")
        If Not IsArray($__g_vval) Then Return SetError(0x1, 0x0, 0x0)
        Local $ilibrary = 0x0
        If IsString($hmodule) Then
            If StringStripWS($hmodule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
                $hmodule = _WinAPI_LoadLibraryEx($hmodule, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
                If Not $hmodule Then
                    Return SetError(@error + 0xa, @extended, 0x0)
                EndIf
                $ilibrary = 0x1
            Else
                $hmodule = 0x0
            EndIf
        EndIf
        Dim $__g_venum[0x65][$__g_vval[0x0] + 0x1] = [[0x0]]
        Local $henumproc = DllCallbackRegister("__EnumVerValuesProc", "bool", "ptr;ptr;ptr;word;long_ptr")
        Local $acall = DllCall("kernel32.dll", "bool", "EnumResourceLanguagesW", "handle", $hmodule, "int", 0x10, "int", 0x1, "ptr", DllCallbackGetPtr($henumproc), "long_ptr", $ilanguage)
        Do
            If @error Then
                $__g_venum = @error + 0x14
            Else
                If Not $acall[0x0] Then
                    Switch _WinAPI_GetLastError()
                    Case 0x0, 0x3b02
                        ExitLoop
                    Case Else
                        $__g_venum = 0x14
                    EndSwitch
                Else
                    ExitLoop
                EndIf
            EndIf
        Until 0x1
        If $ilibrary Then
            _WinAPI_FreeLibrary($hmodule)
        EndIf
        DllCallbackFree($henumproc)
        If Not $__g_venum[0x0][0x0] Then $__g_venum = 0xe6
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_VerQueryValueEx

#EndRegion Public Functions
#Region Internal Functions
    Func __EnumResLanguagesProc($hmodule, $itype, $INAME, $ilanguage, $lparam)
        #forceref $hModule, $iType, $iName, $lParam
        __Inc($__g_venum)
        $__g_venum[$__g_venum[0x0]] = $ilanguage
        Return 0x1
    EndFunc    ; -> __EnumResLanguagesProc

    Func __EnumResNamesProc($hmodule, $itype, $INAME, $lparam)
        #forceref $hModule, $iType, $lParam
        Local $ilength = _WinAPI_StrLen($INAME)
        __Inc($__g_venum)
        If $ilength Then
            $__g_venum[$__g_venum[0x0]] = DllStructGetData(DllStructCreate("wchar[" & ($ilength + 0x1) & "]", $INAME), 0x1)
        Else
            $__g_venum[$__g_venum[0x0]] = Number($INAME)
        EndIf
        Return 0x1
    EndFunc    ; -> __EnumResNamesProc

    Func __EnumResTypesProc($hmodule, $itype, $lparam)
        #forceref $hModule, $lParam
        Local $ilength = _WinAPI_StrLen($itype)
        __Inc($__g_venum)
        If $ilength Then
            $__g_venum[$__g_venum[0x0]] = DllStructGetData(DllStructCreate("wchar[" & ($ilength + 0x1) & "]", $itype), 0x1)
        Else
            $__g_venum[$__g_venum[0x0]] = Number($itype)
        EndIf
        Return 0x1
    EndFunc    ; -> __EnumResTypesProc

    Func __EnumVerValuesProc($hmodule, $itype, $INAME, $ilanguage, $IDEFAULT)
        Local $acall, $ienum = 0x1, $ierror = 0x0
        Switch $IDEFAULT
        Case + -1
        Case 0x400
            $ilanguage = 0x400
            $ienum = 0x0
        Case Else
            If $ilanguage <> $IDEFAULT Then
                Return 0x1
            EndIf
            $ienum = 0x0
        EndSwitch
        Do
            Local $pdata = __ResLoad($hmodule, $itype, $INAME, $ilanguage)
            If @error Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
            $acall = DllCall("version.dll", "bool", "VerQueryValueW", "ptr", $pdata, "wstr", "\\VarFileInfo\\Translation", "ptr*", 0x0, "uint*", 0x0)
            If @error Or Not $acall[0x0] Or Not $acall[0x4] Then
                $ierror = @error + 0x14
                ExitLoop
            EndIf
            Local $tdata = DllStructCreate("ushort;ushort", $acall[0x3])
            If @error Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
        Until 0x1
        If Not $ierror Then
            __Inc($__g_venum)
            $__g_venum[$__g_venum[0x0][0x0]][0x0] = DllStructGetData($tdata, 0x1)
            Local $scp = Hex(_WinAPI_MakeLong(DllStructGetData($tdata, 0x2), DllStructGetData($tdata, 0x1)), 0x8)
            For $i = 0x1 To $__g_vval[0x0]
                $acall = DllCall("version.dll", "bool", "VerQueryValueW", "ptr", $pdata, "wstr", "\\StringFileInfo\\" & $scp & "\\" & $__g_vval[$i], "ptr*", 0x0, "uint*", 0x0)
                If Not @error And $acall[0x0] And $acall[0x4] Then
                    $__g_venum[$__g_venum[0x0][0x0]][$i] = DllStructGetData(DllStructCreate("wchar[" & $acall[0x4] & "]", $acall[0x3]), 0x1)
                Else
                    $__g_venum[$__g_venum[0x0][0x0]][$i] = ''
                EndIf
            Next
        Else
            $__g_venum = @error + 0x28
        EndIf
        If $__g_venum Then Return SetError($ierror, 0x0, 0x0)
        Return $ienum
    EndFunc    ; -> __EnumVerValuesProc

    Func __ResLoad($hinstance, $stype, $sname, $ilanguage)
        Local $hinfo = _WinAPI_FindResourceEx($hinstance, $stype, $sname, $ilanguage)
        If Not $hinfo Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $isize = _WinAPI_SizeOfResource($hinstance, $hinfo)
        If Not $isize Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $hdata = _WinAPI_LoadResource($hinstance, $hinfo)
        If Not $hdata Then Return SetError(@error + 0x1e, @extended, 0x0)
        Local $pdata = _WinAPI_LockResource($hdata)
        If Not $pdata Then Return SetError(@error + 0x28, @extended, 0x0)
        Return SetExtended($isize, $pdata)
    EndFunc    ; -> __ResLoad

#EndRegion Internal Functions
#Region Global Variables and Constants
    Global $__g_ainprocess_winapi[0x40][0x2] = [[0x0, 0x0]]
    Global $__g_awinlist_winapi[0x40][0x2] = [[0x0, 0x0]]
    Global Const $GW_HWNDFIRST = 0x0
    Global Const $GW_HWNDLAST = 0x1
    Global Const $GW_HWNDNEXT = 0x2
    Global Const $GW_HWNDPREV = 0x3
    Global Const $GW_OWNER = 0x4
    Global Const $GW_CHILD = 0x5
    Global Const $GW_ENABLEDPOPUP = 0x6
    Global Const $GWL_WNDPROC = -4
    Global Const $GWL_HINSTANCE = -6
    Global Const $GWL_HWNDPARENT = -8
    Global Const $GWL_ID = -12
    Global Const $GWL_STYLE = -16
    Global Const $GWL_EXSTYLE = -20
    Global Const $GWL_USERDATA = -21
    Global Const $__WINAPICONSTANT_WM_SETFONT = 0x30
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_CreateWindowEx($iexstyle, $sclass, $sname, $istyle, $ix, $iy, $iwidth, $iheight, $hparent, $hmenu = 0x0, $hinstance = 0x0, $pparam = 0x0)
        If $hinstance = 0x0 Then $hinstance = _WinAPI_GetModuleHandle('')
        Local $acall = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iexstyle, "wstr", $sclass, "wstr", $sname, "dword", $istyle, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "hwnd", $hparent, "handle", $hmenu, "handle", $hinstance, "struct*", $pparam)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateWindowEx

    Func _WinAPI_GetClientRect($hwnd)
        Local $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hwnd, "struct*", $trect)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_GetClientRect

    Func _WinAPI_GetDesktopWindow()
        Local $acall = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetDesktopWindow

    Func _WinAPI_DestroyWindow($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DestroyWindow

    Func _WinAPI_EnableWindow($hwnd, $benable = True)
        Local $acall = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hwnd, "bool", $benable)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_EnableWindow

    Func _WinAPI_EnumWindows($BVISIBLE = True, $hwnd = Default)
        __WinAPI_EnumWindowsInit()
        If $hwnd = Default Then $hwnd = _WinAPI_GetDesktopWindow()
        __WinAPI_EnumWindowsChild($hwnd, $BVISIBLE)
        Return $__g_awinlist_winapi
    EndFunc    ; -> _WinAPI_EnumWindows

    Func _WinAPI_EnumWindowsPopup()
        __WinAPI_EnumWindowsInit()
        Local $hwnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
        Local $sclass
        While $hwnd <> 0x0
            If _WinAPI_IsWindowVisible($hwnd) Then
                $sclass = _WinAPI_GetClassName($hwnd)
                If $sclass = "#32768" Then
                    __WinAPI_EnumWindowsAdd($hwnd)
                ElseIf $sclass = "ToolbarWindow32" Then
                    __WinAPI_EnumWindowsAdd($hwnd)
                ElseIf $sclass = "ToolTips_Class32" Then
                    __WinAPI_EnumWindowsAdd($hwnd)
                ElseIf $sclass = "BaseBar" Then
                    __WinAPI_EnumWindowsChild($hwnd)
                EndIf
            EndIf
            $hwnd = _WinAPI_GetWindow($hwnd, $GW_HWNDNEXT)
        WEnd
        Return $__g_awinlist_winapi
    EndFunc    ; -> _WinAPI_EnumWindowsPopup

    Func _WinAPI_EnumWindowsTop()
        __WinAPI_EnumWindowsInit()
        Local $hwnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
        While $hwnd <> 0x0
            If _WinAPI_IsWindowVisible($hwnd) Then __WinAPI_EnumWindowsAdd($hwnd)
            $hwnd = _WinAPI_GetWindow($hwnd, $GW_HWNDNEXT)
        WEnd
        Return $__g_awinlist_winapi
    EndFunc    ; -> _WinAPI_EnumWindowsTop

    Func _WinAPI_GetClassName($hwnd)
        If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
        Local $acall = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hwnd, "wstr", '', "int", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return SetExtended($acall[0x0], $acall[0x2])
    EndFunc    ; -> _WinAPI_GetClassName

    Func _WinAPI_GetFocus()
        Local $acall = DllCall("user32.dll", "hwnd", "GetFocus")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetFocus

    Func _WinAPI_GetParent($hwnd)
        Local $acall = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetParent

    Func _WinAPI_GetSysColor($iindex)
        Local $acall = DllCall("user32.dll", "INT", "GetSysColor", "int", $iindex)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetSysColor

    Func _WinAPI_GetSystemMetrics($iindex)
        Local $acall = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iindex)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetSystemMetrics

    Func _WinAPI_GetWindow($hwnd, $icmd)
        Local $acall = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hwnd, "uint", $icmd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetWindow

    Func _WinAPI_GetWindowHeight($hwnd)
        Local $trect = _WinAPI_GetWindowRect($hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top")
    EndFunc    ; -> _WinAPI_GetWindowHeight

    Func _WinAPI_GetWindowLong($hwnd, $iindex)
        Local $sfuncname = "GetWindowLongW"
        If @AutoItX64 Then $sfuncname = "GetWindowLongPtrW"
        Local $acall = DllCall("user32.dll", "long_ptr", $sfuncname, "hwnd", $hwnd, "int", $iindex)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetWindowLong

    Func _WinAPI_GetWindowRect($hwnd)
        Local $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("user32.dll", "bool", "GetWindowRect", "hwnd", $hwnd, "struct*", $trect)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_GetWindowRect

    Func _WinAPI_GetWindowText($hwnd)
        Local $acall = DllCall("user32.dll", "int", "GetWindowTextW", "hwnd", $hwnd, "wstr", '', "int", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return SetExtended($acall[0x0], $acall[0x2])
    EndFunc    ; -> _WinAPI_GetWindowText

    Func _WinAPI_GetWindowThreadProcessId($hwnd, ByRef $ipid)
        Local $acall = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "dword*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        $ipid = $acall[0x2]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetWindowThreadProcessId

    Func _WinAPI_GetWindowWidth($hwnd)
        Local $trect = _WinAPI_GetWindowRect($hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
    EndFunc    ; -> _WinAPI_GetWindowWidth

    Func _WinAPI_InProcess($hwnd, ByRef $hlastwnd)
        If $hwnd = $hlastwnd Then Return True
        For $ii = $__g_ainprocess_winapi[0x0][0x0] To 0x1 Step + -1
            If $hwnd = $__g_ainprocess_winapi[$ii][0x0] Then
                If $__g_ainprocess_winapi[$ii][0x1] Then
                    $hlastwnd = $hwnd
                    Return True
                Else
                    Return False
                EndIf
            EndIf
        Next
        Local $ipid
        _WinAPI_GetWindowThreadProcessId($hwnd, $ipid)
        Local $icount = $__g_ainprocess_winapi[0x0][0x0] + 0x1
        If $icount >= 0x40 Then $icount = 0x1
        $__g_ainprocess_winapi[0x0][0x0] = $icount
        $__g_ainprocess_winapi[$icount][0x0] = $hwnd
        $__g_ainprocess_winapi[$icount][0x1] = ($ipid = @AutoItPID)
        Return $__g_ainprocess_winapi[$icount][0x1]
    EndFunc    ; -> _WinAPI_InProcess

    Func _WinAPI_InvalidateRect($hwnd, $trect = 0x0, $berase = True)
        If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hwnd, "struct*", $trect, "bool", $berase)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_InvalidateRect

    Func _WinAPI_IsClassName($hwnd, $sclassname)
        Local $sseparator = Opt("GUIDataSeparatorChar")
        Local $aclassname = StringSplit($sclassname, $sseparator)
        If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
        Local $sclasscheck = _WinAPI_GetClassName($hwnd)
        For $x = 0x1 To UBound($aclassname) + -1
            If StringUpper(StringMid($sclasscheck, 0x1, StringLen($aclassname[$x]))) = StringUpper($aclassname[$x]) Then Return True
        Next
        Return False
    EndFunc    ; -> _WinAPI_IsClassName

    Func _WinAPI_IsWindow($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsWindow

    Func _WinAPI_IsWindowVisible($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsWindowVisible

    Func _WinAPI_MoveWindow($hwnd, $ix, $iy, $iwidth, $iheight, $brepaint = True)
        Local $acall = DllCall("user32.dll", "bool", "MoveWindow", "hwnd", $hwnd, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "bool", $brepaint)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MoveWindow

    Func _WinAPI_SetFocus($hwnd)
        Local $acall = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetFocus

    Func _WinAPI_SetFont($hwnd, $hfont, $bredraw = True)
        _SendMessage($hwnd, $__WINAPICONSTANT_WM_SETFONT, $hfont, $bredraw, 0x0, "hwnd")
    EndFunc    ; -> _WinAPI_SetFont

    Func _WinAPI_SetParent($hwndchild, $hwndparent)
        Local $acall = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hwndchild, "hwnd", $hwndparent)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetParent

    Func _WinAPI_SetWindowPos($hwnd, $hafter, $ix, $iy, $icx, $icy, $IFLAGS)
        Local $acall = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hwnd, "hwnd", $hafter, "int", $ix, "int", $iy, "int", $icx, "int", $icy, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWindowPos

    Func _WinAPI_SetWindowText($hwnd, $stext)
        Local $acall = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hwnd, "wstr", $stext)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWindowText

    Func _WinAPI_ShowWindow($hwnd, $icmdshow = 0x5)
        Local $acall = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hwnd, "int", $icmdshow)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShowWindow

    Func _WinAPI_UpdateWindow($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UpdateWindow

#EndRegion Public Functions
#Region Internal Functions
    Func __WinAPI_EnumWindowsAdd($hwnd, $sclass = '')
        If $sclass = '' Then $sclass = _WinAPI_GetClassName($hwnd)
        $__g_awinlist_winapi[0x0][0x0]+= 0x1
        Local $icount = $__g_awinlist_winapi[0x0][0x0]
        If $icount >= $__g_awinlist_winapi[0x0][0x1] Then
            ReDim $__g_awinlist_winapi[$icount + 0x40][0x2]
            $__g_awinlist_winapi[0x0][0x1]+= 0x40
        EndIf
        $__g_awinlist_winapi[$icount][0x0] = $hwnd
        $__g_awinlist_winapi[$icount][0x1] = $sclass
    EndFunc    ; -> __WinAPI_EnumWindowsAdd

    Func __WinAPI_EnumWindowsChild($hwnd, $BVISIBLE = True)
        $hwnd = _WinAPI_GetWindow($hwnd, $GW_CHILD)
        While $hwnd <> 0x0
            If (Not $BVISIBLE) Or _WinAPI_IsWindowVisible($hwnd) Then
                __WinAPI_EnumWindowsAdd($hwnd)
                __WinAPI_EnumWindowsChild($hwnd, $BVISIBLE)
            EndIf
            $hwnd = _WinAPI_GetWindow($hwnd, $GW_HWNDNEXT)
        WEnd
    EndFunc    ; -> __WinAPI_EnumWindowsChild

    Func __WinAPI_EnumWindowsInit()
        ReDim $__g_awinlist_winapi[0x40][0x2]
        $__g_awinlist_winapi[0x0][0x0] = 0x0
        $__g_awinlist_winapi[0x0][0x1] = 0x40
    EndFunc    ; -> __WinAPI_EnumWindowsInit

#EndRegion Internal Functions
#Region Global Variables and Constants
    Global Const $FLASHW_CAPTION = 0x1
    Global Const $FLASHW_TRAY = 0x2
    Global Const $FLASHW_TIMER = 0x4
    Global Const $FLASHW_TIMERNOFG = 0xc
    Global Const $TAGUPDATELAYEREDWINDOWINFO = "dword Size;hwnd hDstDC;long DstX;long DstY;long cX;long cY;hwnd hSrcDC;long SrcX;long SrcY;dword crKey;byte BlendOp;byte BlendFlags;byte Alpha;byte AlphaFormat;" & _
        "dword Flags;long DirtyLeft;long DirtyTop;long DirtyRight;long DirtyBottom"
    Global Const $TAGWINDOWINFO = "dword Size;struct;long rWindow[4];endstruct;struct;long rClient[4];endstruct;dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBord" & _
        "ers;word atomWindowType;word CreatorVersion"
    Global Const $TAGWNDCLASS = "uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName"
    Global Const $TAGWNDCLASSEX = "uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
Global Const $TAGFLASHWINFO = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
#Region Public Functions
    Func _WinAPI_AdjustWindowRectEx(ByRef $trect, $istyle, $iexstyle = 0x0, $bmenu = False)
        Local $acall = DllCall("user32.dll", "bool", "AdjustWindowRectEx", "struct*", $trect, "dword", $istyle, "bool", $bmenu, "dword", $iexstyle)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AdjustWindowRectEx

    Func _WinAPI_AnimateWindow($hwnd, $IFLAGS, $iduration = 0x3e8)
        Local $acall = DllCall("user32.dll", "bool", "AnimateWindow", "hwnd", $hwnd, "dword", $iduration, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AnimateWindow

    Func _WinAPI_BeginDeferWindowPos($iamount = 0x1)
        Local $acall = DllCall("user32.dll", "handle", "BeginDeferWindowPos", "int", $iamount)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BeginDeferWindowPos

    Func _WinAPI_BringWindowToTop($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "BringWindowToTop", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BringWindowToTop

    Func _WinAPI_BroadcastSystemMessage($imsg, $wparam = 0x0, $lparam = 0x0, $IFLAGS = 0x0, $irecipients = 0x0)
        Local $acall = DllCall("user32.dll", "long", "BroadcastSystemMessageW", "dword", $IFLAGS, "dword*", $irecipients, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
        If @error Or ($acall[0x0] = + -1) Then Return SetError(@error, @extended, + -1)
        Return SetExtended($acall[0x2], $acall[0x0])
    EndFunc    ; -> _WinAPI_BroadcastSystemMessage

    Func _WinAPI_CallWindowProc($pprevwndfunc, $hwnd, $imsg, $wparam, $lparam)
        Local $acall = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $pprevwndfunc, "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CallWindowProc

    Func _WinAPI_CallWindowProcW($pprevwndproc, $hwnd, $imsg, $wparam, $lparam)
        Local $acall = DllCall("user32.dll", "lresult", "CallWindowProcW", "ptr", $pprevwndproc, "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CallWindowProcW

    Func _WinAPI_CascadeWindows($awnds, $trect = 0x0, $hparent = 0x0, $IFLAGS = 0x0, $istart = 0x0, $IEND = + -1)
        If __CheckErrorArrayBounds($awnds, $istart, $IEND) Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $icount = $IEND - $istart + 0x1
        Local $twnds = DllStructCreate("hwnd[" & $icount & "]")
        $icount = 0x1
        For $i = $istart To $IEND
            DllStructSetData($twnds, 0x1, $awnds[$i], $icount)
            $icount += 0x1
        Next
        Local $acall = DllCall("user32.dll", "word", "CascadeWindows", "hwnd", $hparent, "uint", $IFLAGS, "struct*", $trect, "uint", $icount + -1, "struct*", $twnds)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CascadeWindows

    Func _WinAPI_ChangeWindowMessageFilterEx($hwnd, $imsg, $iaction)
        Local $tcfs, $acall
        If $hwnd And (_WinAPI_GetVersion() > 6) Then
            Local Const $TAGCHANGEFILTERSTRUCT = "dword cbSize; dword ExtStatus"
            $tcfs = DllStructCreate($TAGCHANGEFILTERSTRUCT)
            DllStructSetData($tcfs, 0x1, DllStructGetSize($tcfs))
            $acall = DllCall("user32.dll", "bool", "ChangeWindowMessageFilterEx", "hwnd", $hwnd, "uint", $imsg, "dword", $iaction, "struct*", $tcfs)
        Else
            $tcfs = 0x0
            $acall = DllCall("user32.dll", "bool", "ChangeWindowMessageFilter", "uint", $imsg, "dword", $iaction)
        EndIf
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return SetExtended(DllStructGetData($tcfs, 0x2), 0x1)
    EndFunc    ; -> _WinAPI_ChangeWindowMessageFilterEx

    Func _WinAPI_ChildWindowFromPointEx($hwnd, $tpoint, $IFLAGS = 0x0)
        Local $acall = DllCall("user32.dll", "hwnd", "ChildWindowFromPointEx", "hwnd", $hwnd, "struct", $tpoint, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ChildWindowFromPointEx

    Func _WinAPI_CloseWindow($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "CloseWindow", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CloseWindow

    Func _WinAPI_DeferWindowPos($hinfo, $hwnd, $hafter, $ix, $iy, $iwidth, $iheight, $IFLAGS)
        Local $acall = DllCall("user32.dll", "handle", "DeferWindowPos", "handle", $hinfo, "hwnd", $hwnd, "hwnd", $hafter, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DeferWindowPos

    Func _WinAPI_DefWindowProc($hwnd, $imsg, $wparam, $lparam)
        Local $acall = DllCall("user32.dll", "lresult", "DefWindowProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DefWindowProc

    Func _WinAPI_DefWindowProcW($hwnd, $imsg, $wparam, $lparam)
        Local $acall = DllCall("user32.dll", "lresult", "DefWindowProcW", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DefWindowProcW

    Func _WinAPI_DeregisterShellHookWindow($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "DeregisterShellHookWindow", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DeregisterShellHookWindow

    Func _WinAPI_DragAcceptFiles($hwnd, $baccept = True)
        DllCall("shell32.dll", "none", "DragAcceptFiles", "hwnd", $hwnd, "bool", $baccept)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DragAcceptFiles

    Func _WinAPI_DragFinish($hdrop)
        DllCall("shell32.dll", "none", "DragFinish", "handle", $hdrop)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DragFinish

    Func _WinAPI_DragQueryFileEx($hdrop, $IFLAG = 0x0)
        Local $acall = DllCall("shell32.dll", "uint", "DragQueryFileW", "handle", $hdrop, "uint", + -1, "ptr", 0x0, "uint", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If Not $acall[0x0] Then Return SetError(0xa, 0x0, 0x0)
        Local $icount = $acall[0x0], $ivalidrow = 0x0
        Local $aret[$icount + 0x1]
        For $i = 0x0 To $icount + -1
            $acall = DllCall("shell32.dll", "uint", "DragQueryFileW", "handle", $hdrop, "uint", $i, "wstr", '', "uint", 0x1000)
            If Not $acall[0x0] Then Return SetError(0xb, 0x0, 0x0)
            If $IFLAG Then
                Local $bdir = _WinAPI_PathIsDirectory($acall[0x3])
                If (($IFLAG = 0x1) And $bdir) Or (($IFLAG = 0x2) And Not $bdir) Then
                    ContinueLoop
                EndIf
            EndIf
            $ivalidrow += 0x1
            $aret[$ivalidrow] = $acall[0x3]
            $aret[0x0]+= 0x1
        Next
        If Not $aret[0x0] Then Return SetError(0xc, 0x0, 0x0)
        __Inc($aret, + -1)
        Return $aret
    EndFunc    ; -> _WinAPI_DragQueryFileEx

    Func _WinAPI_DragQueryPoint($hdrop)
        Local $tpoint = DllStructCreate($TAGPOINT)
        Local $acall = DllCall("shell32.dll", "bool", "DragQueryPoint", "handle", $hdrop, "struct*", $tpoint)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tpoint
    EndFunc    ; -> _WinAPI_DragQueryPoint

    Func _WinAPI_EndDeferWindowPos($hinfo)
        Local $acall = DllCall("user32.dll", "bool", "EndDeferWindowPos", "handle", $hinfo)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_EndDeferWindowPos

    Func _WinAPI_EnumChildWindows($hwnd, $BVISIBLE = True)
        If Not _WinAPI_GetWindow($hwnd, 0x5) Then Return SetError(0x2, 0x0, 0x0)
        Local $henumproc = DllCallbackRegister("__EnumWindowsProc", "bool", "hwnd;lparam")
        Dim $__g_venum[0x65][0x2] = [[0x0]]
        DllCall("user32.dll", "bool", "EnumChildWindows", "hwnd", $hwnd, "ptr", DllCallbackGetPtr($henumproc), "lparam", $BVISIBLE)
        If @error Or Not $__g_venum[0x0][0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumChildWindows

    Func _WinAPI_FindWindow($sclassname, $swindowname)
        Local $acall = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sclassname, "wstr", $swindowname)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindWindow

    Func _WinAPI_FlashWindow($hwnd, $binvert = True)
        Local $acall = DllCall("user32.dll", "bool", "FlashWindow", "hwnd", $hwnd, "bool", $binvert)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FlashWindow

    Func _WinAPI_FlashWindowEx($hwnd, $IFLAGS = 0x3, $icount = 0x3, $itimeout = 0x0)
        Local $tflash = DllStructCreate($TAGFLASHWINFO)
        Local $iflash = DllStructGetSize($tflash)
        Local $imode = 0x0
        If BitAND($IFLAGS, 0x1) <> 0x0 Then $imode = BitOR($imode, $FLASHW_CAPTION)
        If BitAND($IFLAGS, 0x2) <> 0x0 Then $imode = BitOR($imode, $FLASHW_TRAY)
        If BitAND($IFLAGS, 0x4) <> 0x0 Then $imode = BitOR($imode, $FLASHW_TIMER)
        If BitAND($IFLAGS, 0x8) <> 0x0 Then $imode = BitOR($imode, $FLASHW_TIMERNOFG)
        DllStructSetData($tflash, "Size", $iflash)
        DllStructSetData($tflash, "hWnd", $hwnd)
        DllStructSetData($tflash, "Flags", $imode)
        DllStructSetData($tflash, "Count", $icount)
        DllStructSetData($tflash, "Timeout", $itimeout)
        Local $acall = DllCall("user32.dll", "bool", "FlashWindowEx", "struct*", $tflash)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FlashWindowEx

    Func _WinAPI_GetAncestor($hwnd, $IFLAGS = 0x1)
        Local $acall = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hwnd, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetAncestor

    Func _WinAPI_GetClassInfoEx($sclass, $hinstance = 0x0)
        Local $stypeofclass = "wstr"
        If Not IsString($sclass) Then $stypeofclass = "ptr"
        Local $twndclassex = DllStructCreate($TAGWNDCLASSEX)
        Local $acall = DllCall("user32.dll", "bool", "GetClassInfoExW", "handle", $hinstance, $stypeofclass, $sclass, "struct*", $twndclassex)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $twndclassex
    EndFunc    ; -> _WinAPI_GetClassInfoEx

    Func _WinAPI_GetClassLongEx($hwnd, $iindex)
        Local $acall
        If @AutoItX64 Then
            $acall = DllCall("user32.dll", "ulong_ptr", "GetClassLongPtrW", "hwnd", $hwnd, "int", $iindex)
        Else
            $acall = DllCall("user32.dll", "dword", "GetClassLongW", "hwnd", $hwnd, "int", $iindex)
        EndIf
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetClassLongEx

    Func _WinAPI_GetClientHeight($hwnd)
        Local $trect = _WinAPI_GetClientRect($hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top")
    EndFunc    ; -> _WinAPI_GetClientHeight

    Func _WinAPI_GetClientWidth($hwnd)
        Local $trect = _WinAPI_GetClientRect($hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
    EndFunc    ; -> _WinAPI_GetClientWidth

    Func _WinAPI_GetDlgItem($hwnd, $iitemid)
        Local $acall = DllCall("user32.dll", "hwnd", "GetDlgItem", "hwnd", $hwnd, "int", $iitemid)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetDlgItem

    Func _WinAPI_GetForegroundWindow()
        Local $acall = DllCall("user32.dll", "hwnd", "GetForegroundWindow")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetForegroundWindow

    Func _WinAPI_GetGUIThreadInfo($ithreadid)
        Local Const $TAGGUITHREADINFO = "dword Size;dword Flags;hwnd hWndActive;hwnd hWndFocus;hwnd hWndCapture;hwnd hWndMenuOwner;hwnd hWndMoveSize;hwnd hWndCaret;struct rcCaret;long left;long top;lon" & _
            "g right;long bottom;endstruct"
        Local $tgti = DllStructCreate($TAGGUITHREADINFO)
        DllStructSetData($tgti, 0x1, DllStructGetSize($tgti))
        Local $acall = DllCall("user32.dll", "bool", "GetGUIThreadInfo", "dword", $ithreadid, "struct*", $tgti)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0xb]
        For $i = 0x0 To 0xa
            $aret[$i] = DllStructGetData($tgti, $i + 0x2)
        Next
        For $i = 0x9 To 0xa
            $aret[$i]-= $aret[$i + -2]
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetGUIThreadInfo

    Func _WinAPI_GetLastActivePopup($hwnd)
        Local $acall = DllCall("user32.dll", "hwnd", "GetLastActivePopup", "hwnd", $hwnd)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        If $acall[0x0] = $hwnd Then Return SetError(0x1, 0x0, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetLastActivePopup

    Func _WinAPI_GetLayeredWindowAttributes($hwnd, ByRef $itranscolor, ByRef $itransgui, $bcolorref = False)
        $itranscolor = + -1
        $itransgui = + -1
        Local $acall = DllCall("user32.dll", "bool", "GetLayeredWindowAttributes", "hwnd", $hwnd, "INT*", $itranscolor, "byte*", $itransgui, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        If Not $bcolorref Then
            $acall[0x2] = Int(BinaryMid($acall[0x2], 0x3, 0x1) & BinaryMid($acall[0x2], 0x2, 0x1) & BinaryMid($acall[0x2], 0x1, 0x1))
        EndIf
        $itranscolor = $acall[0x2]
        $itransgui = $acall[0x3]
        Return $acall[0x4]
    EndFunc    ; -> _WinAPI_GetLayeredWindowAttributes

    Func _WinAPI_GetMessageExtraInfo()
        Local $acall = DllCall("user32.dll", "lparam", "GetMessageExtraInfo")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetMessageExtraInfo

    Func _WinAPI_GetShellWindow()
        Local $acall = DllCall("user32.dll", "hwnd", "GetShellWindow")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetShellWindow

    Func _WinAPI_GetTopWindow($hwnd)
        Local $acall = DllCall("user32.dll", "hwnd", "GetTopWindow", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetTopWindow

    Func _WinAPI_GetWindowDisplayAffinity($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "GetWindowDisplayAffinity", "hwnd", $hwnd, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetWindowDisplayAffinity

    Func _WinAPI_GetWindowInfo($hwnd)
        Local $twindowinfo = DllStructCreate($TAGWINDOWINFO)
        DllStructSetData($twindowinfo, "Size", DllStructGetSize($twindowinfo))
        Local $acall = DllCall("user32.dll", "bool", "GetWindowInfo", "hwnd", $hwnd, "struct*", $twindowinfo)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $twindowinfo
    EndFunc    ; -> _WinAPI_GetWindowInfo

    Func _WinAPI_GetWindowPlacement($hwnd)
        Local $twindowplacement = DllStructCreate($TAGWINDOWPLACEMENT)
        DllStructSetData($twindowplacement, "length", DllStructGetSize($twindowplacement))
        Local $acall = DllCall("user32.dll", "bool", "GetWindowPlacement", "hwnd", $hwnd, "struct*", $twindowplacement)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $twindowplacement
    EndFunc    ; -> _WinAPI_GetWindowPlacement

    Func _WinAPI_IsChild($hwnd, $hwndparent)
        Local $acall = DllCall("user32.dll", "bool", "IsChild", "hwnd", $hwndparent, "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsChild

    Func _WinAPI_IsHungAppWindow($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "IsHungAppWindow", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsHungAppWindow

    Func _WinAPI_IsIconic($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "IsIconic", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsIconic

    Func _WinAPI_IsWindowUnicode($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "IsWindowUnicode", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsWindowUnicode

    Func _WinAPI_IsZoomed($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "IsZoomed", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsZoomed

    Func _WinAPI_KillTimer($hwnd, $itimerid)
        Local $acall = DllCall("user32.dll", "bool", "KillTimer", "hwnd", $hwnd, "uint_ptr", $itimerid)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_KillTimer

    Func _WinAPI_OpenIcon($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "OpenIcon", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OpenIcon

    Func _WinAPI_PostMessage($hwnd, $imsg, $wparam, $lparam)
        Local $acall = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PostMessage

    Func _WinAPI_RegisterClass($twndclass)
        Local $acall = DllCall("user32.dll", "word", "RegisterClassW", "struct*", $twndclass)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RegisterClass

    Func _WinAPI_RegisterClassEx($twndclassex)
        Local $acall = DllCall("user32.dll", "word", "RegisterClassExW", "struct*", $twndclassex)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RegisterClassEx

    Func _WinAPI_RegisterShellHookWindow($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "RegisterShellHookWindow", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RegisterShellHookWindow

    Func _WinAPI_RegisterWindowMessage($smessage)
        Local $acall = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $smessage)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RegisterWindowMessage

    Func _WinAPI_SendMessageTimeout($hwnd, $imsg, $wparam = 0x0, $lparam = 0x0, $itimeout = 0x3e8, $IFLAGS = 0x0)
        Local $acall = DllCall("user32.dll", "lresult", "SendMessageTimeoutW", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam, "uint", $IFLAGS, "uint", $itimeout, "dword_ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, + -1)
        If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), + -1)
        Return $acall[0x7]
    EndFunc    ; -> _WinAPI_SendMessageTimeout

    Func _WinAPI_SetClassLongEx($hwnd, $iindex, $inewlong)
        Local $acall
        If @AutoItX64 Then
            $acall = DllCall("user32.dll", "ulong_ptr", "SetClassLongPtrW", "hwnd", $hwnd, "int", $iindex, "long_ptr", $inewlong)
        Else
            $acall = DllCall("user32.dll", "dword", "SetClassLongW", "hwnd", $hwnd, "int", $iindex, "long", $inewlong)
        EndIf
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetClassLongEx

    Func _WinAPI_SetForegroundWindow($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "SetForegroundWindow", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetForegroundWindow

    Func _WinAPI_SetLayeredWindowAttributes($hwnd, $itranscolor, $itransgui = 0xff, $IFLAGS = 0x3, $bcolorref = False)
        If $IFLAGS = Default Or $IFLAGS = '' Or $IFLAGS < 0x0 Then $IFLAGS = 0x3
        If Not $bcolorref Then
            $itranscolor = Int(BinaryMid($itranscolor, 0x3, 0x1) & BinaryMid($itranscolor, 0x2, 0x1) & BinaryMid($itranscolor, 0x1, 0x1))
        EndIf
        Local $acall = DllCall("user32.dll", "bool", "SetLayeredWindowAttributes", "hwnd", $hwnd, "INT", $itranscolor, "byte", $itransgui, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetLayeredWindowAttributes

    Func _WinAPI_SetMessageExtraInfo($lparam)
        Local $acall = DllCall("user32.dll", "lparam", "SetMessageExtraInfo", "lparam", $lparam)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetMessageExtraInfo

    Func _WinAPI_SetSysColors($velements, $vcolors)
        Local $bisearray = IsArray($velements), $biscarray = IsArray($vcolors)
        Local $ielementnum
        If Not $biscarray And Not $bisearray Then
            $ielementnum = 0x1
        ElseIf $biscarray Or $bisearray Then
            If Not $biscarray Or Not $bisearray Then Return SetError(+ -1, + -1, False)
            If UBound($velements) <> UBound($vcolors) Then Return SetError(+ -1, + -1, False)
            $ielementnum = UBound($velements)
        EndIf
        Local $telements = DllStructCreate("int Element[" & $ielementnum & "]")
        Local $tcolors = DllStructCreate("INT NewColor[" & $ielementnum & "]")
        If Not $bisearray Then
            DllStructSetData($telements, "Element", $velements, 0x1)
        Else
            For $x = 0x0 To $ielementnum + -1
                DllStructSetData($telements, "Element", $velements[$x], $x + 0x1)
            Next
        EndIf
        If Not $biscarray Then
            DllStructSetData($tcolors, "NewColor", $vcolors, 0x1)
        Else
            For $x = 0x0 To $ielementnum + -1
                DllStructSetData($tcolors, "NewColor", $vcolors[$x], $x + 0x1)
            Next
        EndIf
        Local $acall = DllCall("user32.dll", "bool", "SetSysColors", "int", $ielementnum, "struct*", $telements, "struct*", $tcolors)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetSysColors

    Func _WinAPI_SetTimer($hwnd, $itimerid, $ielapse, $ptimerfunc)
        Local $acall = DllCall("user32.dll", "uint_ptr", "SetTimer", "hwnd", $hwnd, "uint_ptr", $itimerid, "uint", $ielapse, "ptr", $ptimerfunc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetTimer

    Func _WinAPI_SetWindowDisplayAffinity($hwnd, $iaffinity)
        Local $acall = DllCall("user32.dll", "bool", "SetWindowDisplayAffinity", "hwnd", $hwnd, "dword", $iaffinity)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWindowDisplayAffinity

    Func _WinAPI_SetWindowLong($hwnd, $iindex, $ivalue)
        _WinAPI_SetLastError(0x0)
        Local $sfuncname = "SetWindowLongW"
        If @AutoItX64 Then $sfuncname = "SetWindowLongPtrW"
        Local $acall = DllCall("user32.dll", "long_ptr", $sfuncname, "hwnd", $hwnd, "int", $iindex, "long_ptr", $ivalue)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWindowLong

    Func _WinAPI_SetWindowPlacement($hwnd, $twindowplacement)
        Local $acall = DllCall("user32.dll", "bool", "SetWindowPlacement", "hwnd", $hwnd, "struct*", $twindowplacement)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWindowPlacement

    Func _WinAPI_ShowOwnedPopups($hwnd, $bshow)
        Local $acall = DllCall("user32.dll", "bool", "ShowOwnedPopups", "hwnd", $hwnd, "bool", $bshow)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShowOwnedPopups

    Func _WinAPI_SwitchToThisWindow($hwnd, $balttab = False)
        DllCall("user32.dll", "none", "SwitchToThisWindow", "hwnd", $hwnd, "bool", $balttab)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_SwitchToThisWindow

    Func _WinAPI_TileWindows($awnds, $trect = 0x0, $hparent = 0x0, $IFLAGS = 0x0, $istart = 0x0, $IEND = + -1)
        If __CheckErrorArrayBounds($awnds, $istart, $IEND) Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $icount = $IEND - $istart + 0x1
        Local $twnds = DllStructCreate("hwnd[" & $icount & "]")
        $icount = 0x1
        For $i = $istart To $IEND
            DllStructSetData($twnds, 0x1, $awnds[$i], $icount)
            $icount += 0x1
        Next
        Local $acall = DllCall("user32.dll", "word", "TileWindows", "hwnd", $hparent, "uint", $IFLAGS, "struct*", $trect, "uint", $icount + -1, "struct*", $twnds)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_TileWindows

    Func _WinAPI_UnregisterClass($sclass, $hinstance = 0x0)
        Local $stypeofclass = "wstr"
        If Not IsString($sclass) Then $stypeofclass = "ptr"
        Local $acall = DllCall("user32.dll", "bool", "UnregisterClassW", $stypeofclass, $sclass, "handle", $hinstance)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UnregisterClass

    Func _WinAPI_UpdateLayeredWindow($hwnd, $hdestdc, $tptdest, $tsize, $hsrcdc, $tptsrce, $irgb, $tblend, $IFLAGS)
        Local $acall = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hwnd, "handle", $hdestdc, "struct*", $tptdest, "struct*", $tsize, "handle", $hsrcdc, "struct*", $tptsrce, "dword", $irgb, "struct*", $tblend, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UpdateLayeredWindow

    Func _WinAPI_UpdateLayeredWindowEx($hwnd, $ix, $iy, $hbitmap, $iopacity = 0xff, $bdelete = False)
        Local $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
        Local $hdc = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
        Local $hdestdc = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hbitmap)
        Local $hdestsv = $acall[0x0]
        Local $tpoint
        If ($ix = + -1) And ($iy = + -1) Then
            $tpoint = DllStructCreate("int;int")
        Else
            $tpoint = DllStructCreate("int;int;int;int")
            DllStructSetData($tpoint, 0x3, $ix)
            DllStructSetData($tpoint, 0x4, $iy)
        EndIf
        DllStructSetData($tpoint, 0x1, 0x0)
        DllStructSetData($tpoint, 0x2, 0x0)
        Local $tblendfunction = DllStructCreate($TAGBLENDFUNCTION)
        DllStructSetData($tblendfunction, 0x1, 0x0)
        DllStructSetData($tblendfunction, 0x2, 0x0)
        DllStructSetData($tblendfunction, 0x3, $iopacity)
        DllStructSetData($tblendfunction, 0x4, 0x1)
        Local Const $TAGBITMAP = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
        Local $tobj = DllStructCreate($TAGBITMAP)
        DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
        Local $tsize = DllStructCreate($TAGSIZE, DllStructGetPtr($tobj, "bmWidth"))
        $acall = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hwnd, "handle", $hdc, "ptr", DllStructGetPtr($tpoint, 0x3), "struct*", $tsize, "handle", $hdestdc, "struct*", $tpoint, "dword", 0x0, "struct*", $tblendfunction, "dword", 0x2)
        Local $ierror = @error
        DllCall("user32.dll", "bool", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
        DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hdestsv)
        DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdestdc)
        If $ierror Then Return SetError($ierror, 0x0, False)
        If $bdelete Then
            DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hbitmap)
        EndIf
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UpdateLayeredWindowEx

    Func _WinAPI_UpdateLayeredWindowIndirect($hwnd, $tulwinfo)
        Local $acall = DllCall("user32.dll", "bool", "UpdateLayeredWindowIndirect", "hwnd", $hwnd, "struct*", $tulwinfo)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UpdateLayeredWindowIndirect

    Func _WinAPI_WindowFromPoint(ByRef $tpoint)
        Local $acall = DllCall("user32.dll", "hwnd", "WindowFromPoint", "struct", $tpoint)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_WindowFromPoint

#EndRegion Public Functions
#Region Internal Functions
    Func __EnumDefaultProc($pdata, $lparam)
        #forceref $lParam
        Local $ilength = _WinAPI_StrLen($pdata)
        __Inc($__g_venum)
        If $ilength Then
            $__g_venum[$__g_venum[0x0]] = DllStructGetData(DllStructCreate("wchar[" & ($ilength + 0x1) & "]", $pdata), 0x1)
        Else
            $__g_venum[$__g_venum[0x0]] = ''
        EndIf
        Return 0x1
    EndFunc    ; -> __EnumDefaultProc

#EndRegion Internal Functions
#Region Global Variables and Constants
    Global Const $TAGOSVERSIONINFOEX = $TAGOSVERSIONINFO & ";ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved"
    Global Const $TAGRAWINPUTDEVICE = "struct;ushort UsagePage;ushort Usage;dword Flags;hwnd hTarget;endstruct"
    Global Const $TAGRAWINPUTHEADER = "struct;dword Type;dword Size;handle hDevice;wparam wParam;endstruct"
    Global Const $TAGRAWMOUSE = "ushort Flags;ushort Alignment;ushort ButtonFlags;ushort ButtonData;ulong RawButtons;long LastX;long LastY;ulong ExtraInformation;"
    Global Const $TAGRAWKEYBOARD = "ushort MakeCode;ushort Flags;ushort Reserved;ushort VKey;uint Message;ulong ExtraInformation;"
    Global Const $TAGRAWHID = "dword SizeHid;dword Count;"
    Global Const $TAGRAWINPUTMOUSE = $TAGRAWINPUTHEADER & ";" & $TAGRAWMOUSE
    Global Const $TAGRAWINPUTKEYBOARD = $TAGRAWINPUTHEADER & ";" & $TAGRAWKEYBOARD
    Global Const $TAGRAWINPUTHID = $TAGRAWINPUTHEADER & ";" & $TAGRAWHID
    Global Const $TAGRID_DEVICE_INFO_MOUSE = "struct;dword Id;dword NumberOfButtons;dword SampleRate;int HasHorizontalWheel;endstruc"
    Global Const $TAGRID_DEVICE_INFO_KEYBOARD = "struct;dword KbType;dword KbSubType;dword KeyboardMode;dword NumberOfFunctionKeys;dword NumberOfIndicators;dword NumberOfKeysTotal;endstruct"
    Global Const $TAGRID_DEVICE_INFO_HID = "struct;dword VendorId;dword ProductId;dword VersionNumber;ushort UsagePage;ushort Usage;endstruc"
    Global Const $TAGRID_INFO_MOUSE = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_MOUSE & ";dword Unused[2];"
    Global Const $TAGRID_INFO_KEYBOARD = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_KEYBOARD
    Global Const $TAGRID_INFO_HID = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_HID & ";dword Unused[2]"
    Global Const $TAGUSEROBJECTFLAGS = "int Inherit;int Reserved;dword Flags"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_ActivateKeyboardLayout($hlocale, $IFLAG = 0x0)
        Local $acall = DllCall("user32.dll", "handle", "ActivateKeyboardLayout", "handle", $hlocale, "uint", $IFLAG)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ActivateKeyboardLayout

    Func _WinAPI_AddClipboardFormatListener($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "AddClipboardFormatListener", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AddClipboardFormatListener

    Func _WinAPI_CallNextHookEx($hhook, $icode, $wparam, $lparam)
        Local $acall = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hhook, "int", $icode, "wparam", $wparam, "lparam", $lparam)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CallNextHookEx

    Func _WinAPI_CloseDesktop($hdesktop)
        Local $acall = DllCall("user32.dll", "bool", "CloseDesktop", "handle", $hdesktop)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CloseDesktop

    Func _WinAPI_CloseWindowStation($hstation)
        Local $acall = DllCall("user32.dll", "bool", "CloseWindowStation", "handle", $hstation)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CloseWindowStation

    Func _WinAPI_CompressBuffer($puncompressedbuffer, $iuncompressedsize, $pcompressedbuffer, $icompressedsize, $iformatandengine = 0x2)
        Local $acall, $pworkspace = 0x0, $ierror = 0x0
        Do
            $acall = DllCall("ntdll.dll", "uint", "RtlGetCompressionWorkSpaceSize", "ushort", $iformatandengine, "ulong*", 0x0, "ulong*", 0x0)
            If @error Or $acall[0x0] Then
                $ierror = @error + 0x14
                ExitLoop
            EndIf
            $pworkspace = __HeapAlloc($acall[0x2])
            If @error Then
                $ierror = @error + 0x64
                ExitLoop
            EndIf
            $acall = DllCall("ntdll.dll", "uint", "RtlCompressBuffer", "ushort", $iformatandengine, "struct*", $puncompressedbuffer, "ulong", $iuncompressedsize, "struct*", $pcompressedbuffer, "ulong", $icompressedsize, "ulong", 0x1000, "ulong*", 0x0, "ptr", $pworkspace)
            If @error Or $acall[0x0] Or Not $acall[0x7] Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
        Until 0x1
        __HeapFree($pworkspace)
        If $ierror Then
            If IsArray($acall) Then
                Return SetError(0xa, $acall[0x0], 0x0)
            Else
                Return SetError($ierror, 0x0, 0x0)
            EndIf
        EndIf
        Return $acall[0x7]
    EndFunc    ; -> _WinAPI_CompressBuffer

    Func _WinAPI_ComputeCrc32($pmemory, $ilength)
        If _WinAPI_IsBadReadPtr($pmemory, $ilength) Then Return SetError(0x1, @extended, 0x0)
        Local $acall = DllCall("ntdll.dll", "dword", "RtlComputeCrc32", "dword", 0x0, "struct*", $pmemory, "int", $ilength)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ComputeCrc32

    Func _WinAPI_CreateDesktop($sname, $iaccess = 0x2, $IFLAGS = 0x0, $iheap = 0x0, $tsecurity = 0x0)
        Local $acall
        If $iheap Then
            $acall = DllCall("user32.dll", "handle", "CreateDesktopExW", "wstr", $sname, "ptr", 0x0, "ptr", 0x0, "dword", $IFLAGS, "dword", $iaccess, "struct*", $tsecurity, "ulong", $iheap, "ptr", 0x0)
        Else
            $acall = DllCall("user32.dll", "handle", "CreateDesktopW", "wstr", $sname, "ptr", 0x0, "ptr", 0x0, "dword", $IFLAGS, "dword", $iaccess, "struct*", $tsecurity)
        EndIf
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateDesktop

    Func _WinAPI_CreateWindowStation($sname = '', $iaccess = 0x0, $IFLAGS = 0x0, $tsecurity = 0x0)
        Local $acall = DllCall("user32.dll", "handle", "CreateWindowStationW", "wstr", $sname, "dword", $IFLAGS, "dword", $iaccess, "struct*", $tsecurity)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateWindowStation

    Func _WinAPI_DecompressBuffer($puncompressedbuffer, $iuncompressedsize, $pcompressedbuffer, $icompressedsize, $iformat = 0x2)
        Local $acall = DllCall("ntdll.dll", "long", "RtlDecompressBuffer", "ushort", $iformat, "struct*", $puncompressedbuffer, "ulong", $iuncompressedsize, "struct*", $pcompressedbuffer, "ulong", $icompressedsize, "ulong*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x6]
    EndFunc    ; -> _WinAPI_DecompressBuffer

    Func _WinAPI_DefRawInputProc($parawinput, $iinput)
        Local $acall = DllCall("user32.dll", "lresult", "DefRawInputProc", "ptr", $parawinput, "int", $iinput, "uint", DllStructGetSize(DllStructCreate($TAGRAWINPUTHEADER)))
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DefRawInputProc

    Func _WinAPI_EnumDesktops($hstation)
        If StringCompare(_WinAPI_GetUserObjectInformation($hstation, 0x3), "WindowStation") Then Return SetError(0x1, 0x0, 0x0)
        Local $henumproc = DllCallbackRegister("__EnumDefaultProc", "bool", "ptr;lparam")
        Dim $__g_venum[0x65] = [0x0]
        Local $acall = DllCall("user32.dll", "bool", "EnumDesktopsW", "handle", $hstation, "ptr", DllCallbackGetPtr($henumproc), "lparam", 0x0)
        If @error Or Not $acall[0x0] Or Not $__g_venum[0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumDesktops

    Func _WinAPI_EnumDesktopWindows($hdesktop, $BVISIBLE = True)
        If StringCompare(_WinAPI_GetUserObjectInformation($hdesktop, 0x3), "Desktop") Then Return SetError(0x1, 0x0, 0x0)
        Local $henumproc = DllCallbackRegister("__EnumWindowsProc", "bool", "hwnd;lparam")
        Dim $__g_venum[0x65][0x2] = [[0x0]]
        Local $acall = DllCall("user32.dll", "bool", "EnumDesktopWindows", "handle", $hdesktop, "ptr", DllCallbackGetPtr($henumproc), "lparam", $BVISIBLE)
        If @error Or Not $acall[0x0] Or Not $__g_venum[0x0][0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumDesktopWindows

    Func _WinAPI_EnumPageFiles()
        Local $ainfo = _WinAPI_GetSystemInfo()
        Local $henumproc = DllCallbackRegister("__EnumPageFilesProc", "bool", "lparam;ptr;ptr")
        Dim $__g_venum[0x65][0x4] = [[0x0]]
        Local $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "EnumPageFilesW", "ptr", DllCallbackGetPtr($henumproc), "lparam", $ainfo[0x1])
        If @error Or Not $acall[0x0] Or Not $__g_venum[0x0][0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumPageFiles

    Func _WinAPI_EnumRawInputDevices()
        Local Const $TAGRAWINPUTDEVICELIST = "struct;handle hDevice;dword Type;endstruct"
        Local $tridl, $ilength = DllStructGetSize(DllStructCreate($TAGRAWINPUTDEVICELIST))
        Local $acall = DllCall("user32.dll", "uint", "GetRawInputDeviceList", "ptr", 0x0, "uint*", 0x0, "uint", $ilength)
        If @error Then Return SetError(@error + 0xa, @extended, 0x0)
        If ($acall[0x0] = -1) Or (Not $acall[0x2]) Then Return SetError(0xa, + -1, 0x0)
        Local $tdata = DllStructCreate("byte[" & ($acall[0x2] * $ilength) & "]")
        Local $pdata = DllStructGetPtr($tdata)
        If @error Then Return SetError(@error + 0x14, 0x0, 0x0)
        $acall = DllCall("user32.dll", "uint", "GetRawInputDeviceList", "ptr", $pdata, "uint*", $acall[0x2], "uint", $ilength)
        If ($acall[0x0] = -1) Or (Not $acall[0x0]) Then Return SetError(0x1, + -1, 0x0)
        Local $aret[$acall[0x2] + 0x1][0x2] = [[$acall[0x2]]]
        For $i = 0x1 To $acall[0x2]
            $tridl = DllStructCreate("ptr;dword", $pdata + $ilength * ($i + -1))
            For $j = 0x0 To 0x1
                $aret[$i][$j] = DllStructGetData($tridl, $j + 0x1)
            Next
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_EnumRawInputDevices

    Func _WinAPI_EnumWindowStations()
        Local $henumproc = DllCallbackRegister("__EnumDefaultProc", "bool", "ptr;lparam")
        Dim $__g_venum[0x65] = [0x0]
        Local $acall = DllCall("user32.dll", "bool", "EnumWindowStationsW", "ptr", DllCallbackGetPtr($henumproc), "lparam", 0x0)
        If @error Or Not $acall[0x0] Or Not $__g_venum[0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumWindowStations

    Func _WinAPI_ExpandEnvironmentStrings($sstring)
        Local $acall = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $sstring, "wstr", '', "dword", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_ExpandEnvironmentStrings

    Func _WinAPI_GetActiveWindow()
        Local $acall = DllCall("user32.dll", "hwnd", "GetActiveWindow")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetActiveWindow

    Func _WinAPI_GetAsyncKeyState($ikey)
        Local $acall = DllCall("user32.dll", "short", "GetAsyncKeyState", "int", $ikey)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetAsyncKeyState

    Func _WinAPI_GetClipboardSequenceNumber()
        Local $acall = DllCall("user32.dll", "dword", "GetClipboardSequenceNumber")
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetClipboardSequenceNumber

    Func _WinAPI_GetCurrentHwProfile()
        Local $taghw_profile_info = "dword DockInfo;wchar szHwProfileGuid[39];wchar szHwProfileName[80]"
        Local $thwpi = DllStructCreate($taghw_profile_info)
        Local $acall = DllCall("advapi32.dll", "bool", "GetCurrentHwProfileW", "struct*", $thwpi)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x3]
        For $i = 0x0 To 0x2
            $aret[$i] = DllStructGetData($thwpi, $i + 0x1)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetCurrentHwProfile

    Func _WinAPI_GetDefaultPrinter()
        Local $acall = DllCall("winspool.drv", "bool", "GetDefaultPrinterW", "wstr", '', "dword*", 0x800)
        If @error Then Return SetError(@error, @extended, '')
        If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_GetDefaultPrinter

    Func _WinAPI_GetDllDirectory()
        Local $acall = DllCall("kernel32.dll", "dword", "GetDllDirectoryW", "dword", 0x1000, "wstr", '')
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetDllDirectory

    Func _WinAPI_GetEffectiveClientRect($hwnd, $actrl, $istart = 0x0, $IEND = + -1)
        If Not IsArray($actrl) Then
            Local $ictrl = $actrl
            Dim $actrl[0x1] = [$ictrl]
            $istart = 0x0
            $IEND = 0x0
        EndIf
        If __CheckErrorArrayBounds($actrl, $istart, $IEND) Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $icount = $IEND - $istart + 0x1
        Local $tctrl = DllStructCreate("uint64[" & ($icount + 0x2) & "]")
        $icount = 0x2
        For $i = $istart To $IEND
            If IsHWnd($actrl[$i]) Then
                $actrl[$i] = _WinAPI_GetDlgCtrlID($actrl[$i])
            EndIf
            DllStructSetData($tctrl, 0x1, _WinAPI_MakeQWord(0x1, $actrl[$i]), $icount)
            $icount += 0x1
        Next
        Local $trect = DllStructCreate($TAGRECT)
        DllCall("comctl32.dll", "none", "GetEffectiveClientRect", "hwnd", $hwnd, "struct*", $trect, "struct*", $tctrl)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_GetEffectiveClientRect

    Func _WinAPI_GetHandleInformation($hobject)
        Local $acall = DllCall("kernel32.dll", "bool", "GetHandleInformation", "handle", $hobject, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetHandleInformation

    Func _WinAPI_GetIdleTime()
        Local $tlastinputinfo = DllStructCreate("uint;dword")
        DllStructSetData($tlastinputinfo, 0x1, DllStructGetSize($tlastinputinfo))
        Local $acall = DllCall("user32.dll", "bool", "GetLastInputInfo", "struct*", $tlastinputinfo)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return _WinAPI_GetTickCount() - DllStructGetData($tlastinputinfo, 0x2)
    EndFunc    ; -> _WinAPI_GetIdleTime

    Func _WinAPI_GetKeyboardLayout($hwnd)
        Local $acall = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        $acall = DllCall("user32.dll", "handle", "GetKeyboardLayout", "dword", $acall[0x0])
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetKeyboardLayout

    Func _WinAPI_GetKeyboardLayoutList()
        Local $acall = DllCall("user32.dll", "uint", "GetKeyboardLayoutList", "int", 0x0, "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $tdata = DllStructCreate("handle[" & $acall[0x0] & "]")
        $acall = DllCall("user32.dll", "uint", "GetKeyboardLayoutList", "int", $acall[0x0], "struct*", $tdata)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $alist[$acall[0x0] + 0x1] = [$acall[0x0]]
        For $i = 0x1 To $alist[0x0]
            $alist[$i] = DllStructGetData($tdata, 0x1, $i)
        Next
        Return $alist
    EndFunc    ; -> _WinAPI_GetKeyboardLayoutList

    Func _WinAPI_GetKeyboardState()
        Local $tdata = DllStructCreate("byte[256]")
        Local $acall = DllCall("user32.dll", "bool", "GetKeyboardState", "struct*", $tdata)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tdata
    EndFunc    ; -> _WinAPI_GetKeyboardState

    Func _WinAPI_GetKeyboardType($itype)
        Local $acall = DllCall("user32.dll", "int", "GetKeyboardType", "int", $itype)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetKeyboardType

    Func _WinAPI_GetKeyNameText($lparam)
        Local $acall = DllCall("user32.dll", "int", "GetKeyNameTextW", "long", $lparam, "wstr", '', "int", 0x80)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetKeyNameText

    Func _WinAPI_GetKeyState($vkey)
        Local $acall = DllCall("user32.dll", "short", "GetKeyState", "int", $vkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetKeyState

    Func _WinAPI_GetModuleHandleEx($smodule, $IFLAGS = 0x0)
        If StringStripWS($smodule, $STR_STRIPLEADING + $STR_STRIPTRAILING) = '' Then $smodule = Null
        Local $acall = DllCall("kernel32.dll", "bool", "GetModuleHandleExW", "dword", $IFLAGS, "wstr", $smodule, "ptr*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_GetModuleHandleEx

    Func _WinAPI_GetMUILanguage()
        Local $acall = DllCall("comctl32.dll", "word", "GetMUILanguage")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetMUILanguage

    Func _WinAPI_GetPerformanceInfo()
        Local $tpi = DllStructCreate("dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword")
        Local $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "GetPerformanceInfo", "struct*", $tpi, "dword", DllStructGetSize($tpi))
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0xd]
        For $i = 0x0 To 0xc
            $aret[$i] = DllStructGetData($tpi, $i + 0x2)
        Next
        For $i = 0x0 To 0x8
            $aret[$i]*= $aret[0x9]
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetPerformanceInfo

    Func _WinAPI_GetProcAddress($hmodule, $vname)
        Local $stype = "str"
        If IsNumber($vname) Then $stype = "word"
        Local $acall = DllCall("kernel32.dll", "ptr", "GetProcAddress", "handle", $hmodule, $stype, $vname)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetProcAddress

    Func _WinAPI_GetPhysicallyInstalledSystemMemory()
        Local $acall = DllCall("kernel32.dll", "bool", "GetPhysicallyInstalledSystemMemory", "uint64*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_GetPhysicallyInstalledSystemMemory

    Func _WinAPI_GetProcessShutdownParameters()
        Local $acall = DllCall("kernel32.dll", "bool", "GetProcessShutdownParameters", "dword*", 0x0, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return SetExtended(Number(Not $acall[0x2]), $acall[0x1])
    EndFunc    ; -> _WinAPI_GetProcessShutdownParameters

    Func _WinAPI_GetProcessWindowStation()
        Local $acall = DllCall("user32.dll", "handle", "GetProcessWindowStation")
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetProcessWindowStation

    Func _WinAPI_GetPwrCapabilities()
        If Not __dll("powrprof.dll") Then Return SetError(0x67, 0x0, 0x0)
        Local $tspc = DllStructCreate("byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]")
        Local $acall = DllCall("powrprof.dll", "boolean", "GetPwrCapabilities", "struct*", $tspc)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x19]
        For $i = 0x0 To 0x11
            $aret[$i] = DllStructGetData($tspc, 0x1, $i + 0x1)
        Next
        $aret[0x12] = DllStructGetData($tspc, 0x3)
        For $i = 0x13 To 0x14
            $aret[$i] = DllStructGetData($tspc, 0x5, $i + -18)
        Next
        For $i = 0x15 To 0x18
            $aret[$i] = DllStructGetData($tspc, 0x7, $i + -20)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetPwrCapabilities

    Func _WinAPI_GetRawInputBuffer($pbuffer, $ilength)
        Local $acall = DllCall("user32.dll", "uint", "GetRawInputBuffer", "struct*", $pbuffer, "uint*", $ilength, "uint", DllStructGetSize(DllStructCreate($TAGRAWINPUTHEADER)))
        If @error Then Return SetError(@error, @extended, 0x0)
        If ($acall[0x0] = -1) Or (Not $acall[0x1]) Then Return SetError(0xa, + -1, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetRawInputBuffer

    Func _WinAPI_GetRawInputBufferLength()
        Local $acall = DllCall("user32.dll", "uint", "GetRawInputBuffer", "ptr", 0x0, "uint*", 0x0, "uint", DllStructGetSize(DllStructCreate($TAGRAWINPUTHEADER)))
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = -1 Then Return SetError(0xa, + -1, 0x0)
        Return $acall[0x2] * 0x8
    EndFunc    ; -> _WinAPI_GetRawInputBufferLength

    Func _WinAPI_GetRawInputData($hrawinput, $pbuffer, $ilength, $IFLAG)
        Local $acall = DllCall("user32.dll", "uint", "GetRawInputData", "handle", $hrawinput, "uint", $IFLAG, "struct*", $pbuffer, "uint*", $ilength, "uint", DllStructGetSize(DllStructCreate($TAGRAWINPUTHEADER)))
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = -1 Then Return SetError(0xa, + -1, 0x0)
        Return ($acall[0x3] ? $acall[0x0] : $acall[0x4])
    EndFunc    ; -> _WinAPI_GetRawInputData

    Func _WinAPI_GetRawInputDeviceInfo($hdevice, $pbuffer, $ilength, $IFLAG)
        Local $acall = DllCall("user32.dll", "uint", "GetRawInputDeviceInfoW", "handle", $hdevice, "uint", $IFLAG, "struct*", $pbuffer, "uint*", $ilength)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = -1 Then Return SetError(0xa, + -1, 0x0)
        Return ($acall[0x3] ? $acall[0x0] : $acall[0x4])
    EndFunc    ; -> _WinAPI_GetRawInputDeviceInfo

    Func _WinAPI_GetRegisteredRawInputDevices($pbuffer, $ilength)
        Local $ilengthraw = DllStructGetSize(DllStructCreate($TAGRAWINPUTDEVICE))
        Local $acall = DllCall("user32.dll", "uint", "GetRegisteredRawInputDevices", "struct*", $pbuffer, "uint*", Floor($ilength / $ilengthraw), "uint", $ilengthraw)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = -1 Then
            Local $ilasterror = _WinAPI_GetLastError()
            If $ilasterror = 0x7a Then Return SetExtended($ilasterror, $acall[0x2] * $ilengthraw)
            Return SetError(0xa, $ilasterror, 0x0)
        EndIf
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetRegisteredRawInputDevices

    Func _WinAPI_GetStartupInfo()
        Local $tsi = DllStructCreate($TAGSTARTUPINFO)
        DllCall("kernel32.dll", "none", "GetStartupInfoW", "struct*", $tsi)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $tsi
    EndFunc    ; -> _WinAPI_GetStartupInfo

    Func _WinAPI_GetSystemDEPPolicy()
        Local $acall = DllCall("kernel32.dll", "uint", "GetSystemDEPPolicy")
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetSystemDEPPolicy

    Func _WinAPI_GetSystemInfo()
        Local $sproc
        If _WinAPI_IsWow64Process() Then
            $sproc = "GetNativeSystemInfo"
        Else
            $sproc = "GetSystemInfo"
        EndIf
        Local Const $TAGSYSTEMINFO = "struct;word ProcessorArchitecture;word Reserved; endstruct;dword PageSize;" & "ptr MinimumApplicationAddress;ptr MaximumApplicationAddress;dword_ptr ActiveProcessorMask;dword NumberOfProcessors;" & "dword ProcessorType;dword AllocationGranularity;word ProcessorLevel;word ProcessorRevision"
        Local $tsysteminfo = DllStructCreate($TAGSYSTEMINFO)
        DllCall("kernel32.dll", "none", $sproc, "struct*", $tsysteminfo)
        If @error Then Return SetError(@error, @extended, 0x0)
        Local $aret[0xa]
        $aret[0x0] = DllStructGetData($tsysteminfo, 0x1)
        For $i = 0x1 To 0x9
            $aret[$i] = DllStructGetData($tsysteminfo, $i + 0x2)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetSystemInfo

    Func _WinAPI_GetSystemPowerStatus()
        Local $tagsystem_power_status = "byte ACLineStatus;byte BatteryFlag;byte BatteryLifePercent;byte Reserved1;" & "int BatteryLifeTime;int BatteryFullLifeTime"
        Local $tsystem_power_status = DllStructCreate($tagsystem_power_status)
        Local $acall = DllCall("kernel32.dll", "bool", "GetSystemPowerStatus", "struct*", $tsystem_power_status)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x5]
        $aret[0x0] = DllStructGetData($tsystem_power_status, 0x1)
        $aret[0x1] = DllStructGetData($tsystem_power_status, 0x2)
        $aret[0x2] = DllStructGetData($tsystem_power_status, 0x3)
        $aret[0x3] = DllStructGetData($tsystem_power_status, 0x5)
        $aret[0x4] = DllStructGetData($tsystem_power_status, 0x6)
        Return $aret
    EndFunc    ; -> _WinAPI_GetSystemPowerStatus

    Func _WinAPI_GetSystemTimes()
        Local $acall = DllCall("kernel32.dll", "bool", "GetSystemTimes", "uint64*", 0x0, "uint64*", 0x0, "uint64*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x3]
        For $i = 0x0 To 0x2
            $aret[$i] = $acall[$i + 0x1]
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetSystemTimes

    Func _WinAPI_GetSystemWow64Directory()
        Local $acall = DllCall("kernel32.dll", "uint", "GetSystemWow64DirectoryW", "wstr", '', "uint", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, _WinAPI_GetLastError(), '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_GetSystemWow64Directory

    Func _WinAPI_GetTickCount()
        Local $acall = DllCall("kernel32.dll", "dword", "GetTickCount")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetTickCount

    Func _WinAPI_GetTickCount64()
        Local $acall = DllCall("kernel32.dll", "uint64", "GetTickCount64")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetTickCount64

    Func _WinAPI_GetUserObjectInformation($hobject, $iindex)
        Local $acall = DllCall("user32.dll", "bool", "GetUserObjectInformationW", "handle", $hobject, "int", $iindex, "ptr", 0x0, "dword", 0x0, "dword*", 0x0)
        If @error Or Not $acall[0x5] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $tdata
        Switch $iindex
        Case 0x1
            $tdata = DllStructCreate($TAGUSEROBJECTFLAGS)
        Case 0x5, 0x6
            $tdata = DllStructCreate("uint")
        Case 0x2, 0x3
            $tdata = DllStructCreate("wchar[" & $acall[0x5] & "]")
        Case 0x4
            $tdata = DllStructCreate("byte[" & $acall[0x5] & "]")
        Case Else
            Return SetError(0x14, 0x0, 0x0)
        EndSwitch
        $acall = DllCall("user32.dll", "bool", "GetUserObjectInformationW", "handle", $hobject, "int", $iindex, "struct*", $tdata, "dword", DllStructGetSize($tdata), "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x1e, @extended, 0x0)
        Switch $iindex
        Case 0x1, 0x4
            Return $tdata
        Case Else
            Return DllStructGetData($tdata, 0x1)
        EndSwitch
    EndFunc    ; -> _WinAPI_GetUserObjectInformation

    Func _WinAPI_GetVersionEx()
        Local $tosversioninfoex = DllStructCreate($TAGOSVERSIONINFOEX)
        DllStructSetData($tosversioninfoex, "OSVersionInfoSize", DllStructGetSize($tosversioninfoex))
        Local $acall = DllCall("kernel32.dll", "bool", "GetVersionExW", "struct*", $tosversioninfoex)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tosversioninfoex
    EndFunc    ; -> _WinAPI_GetVersionEx

    Func _WinAPI_GetWorkArea()
        Local $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("user32.dll", "int", "SystemParametersInfo", "uint", 0x30, "uint", 0x0, "struct*", $trect, "uint", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_GetWorkArea

    Func _WinAPI_InitMUILanguage($ilanguage)
        DllCall("comctl32.dll", "none", "InitMUILanguage", "word", $ilanguage)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_InitMUILanguage

    Func _WinAPI_IsLoadKBLayout($ilanguage)
        Local $alayout = _WinAPI_GetKeyboardLayoutList()
        If @error Then Return SetError(@error, @extended, False)
        For $i = 0x1 To $alayout[0x0]
            If $alayout[$i] = $ilanguage Then Return True
        Next
        Return False
    EndFunc    ; -> _WinAPI_IsLoadKBLayout

    Func _WinAPI_IsProcessorFeaturePresent($ifeature)
        Local $acall = DllCall("kernel32.dll", "bool", "IsProcessorFeaturePresent", "dword", $ifeature)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsProcessorFeaturePresent

    Func _WinAPI_IsWindowEnabled($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "IsWindowEnabled", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsWindowEnabled

    Func _WinAPI_Keybd_Event($vkey, $IFLAGS, $iscancode = 0x0, $iextrainfo = 0x0)
        DllCall("user32.dll", "none", "keybd_event", "byte", $vkey, "byte", $iscancode, "dword", $IFLAGS, "ulong_ptr", $iextrainfo)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_Keybd_Event

    Func _WinAPI_LoadKeyboardLayout($ilanguage, $IFLAG = 0x0)
        Local $acall = DllCall("user32.dll", "handle", "LoadKeyboardLayoutW", "wstr", Hex($ilanguage, 0x8), "uint", $IFLAG)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LoadKeyboardLayout

    Func _WinAPI_LockWorkStation()
        Local $acall = DllCall("user32.dll", "bool", "LockWorkStation")
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LockWorkStation

    Func _WinAPI_MapVirtualKey($icode, $itype, $hlocale = 0x0)
        Local $acall = DllCall("user32.dll", "INT", "MapVirtualKeyExW", "uint", $icode, "uint", $itype, "uint_ptr", $hlocale)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MapVirtualKey

    Func _WinAPI_Mouse_Event($IFLAGS, $ix = 0x0, $iy = 0x0, $idata = 0x0, $iextrainfo = 0x0)
        DllCall("user32.dll", "none", "mouse_event", "dword", $IFLAGS, "dword", $ix, "dword", $iy, "dword", $idata, "ulong_ptr", $iextrainfo)
        If @error Then Return SetError(@error, @extended)
    EndFunc    ; -> _WinAPI_Mouse_Event

    Func _WinAPI_OpenDesktop($sname, $iaccess = 0x0, $IFLAGS = 0x0, $binherit = False)
        Local $acall = DllCall("user32.dll", "handle", "OpenDesktopW", "wstr", $sname, "dword", $IFLAGS, "bool", $binherit, "dword", $iaccess)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OpenDesktop

    Func _WinAPI_OpenInputDesktop($iaccess = 0x0, $IFLAGS = 0x0, $binherit = False)
        Local $acall = DllCall("user32.dll", "handle", "OpenInputDesktop", "dword", $IFLAGS, "bool", $binherit, "dword", $iaccess)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OpenInputDesktop

    Func _WinAPI_OpenWindowStation($sname, $iaccess = 0x0, $binherit = False)
        Local $acall = DllCall("user32.dll", "handle", "OpenWindowStationW", "wstr", $sname, "bool", $binherit, "dword", $iaccess)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OpenWindowStation

    Func _WinAPI_QueryPerformanceCounter()
        Local $acall = DllCall("kernel32.dll", "bool", "QueryPerformanceCounter", "int64*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_QueryPerformanceCounter

    Func _WinAPI_QueryPerformanceFrequency()
        Local $acall = DllCall("kernel32.dll", "bool", "QueryPerformanceFrequency", "int64*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_QueryPerformanceFrequency

    Func _WinAPI_RegisterHotKey($hwnd, $iid, $imodifiers, $vkey)
        Local $acall = DllCall("user32.dll", "bool", "RegisterHotKey", "hwnd", $hwnd, "int", $iid, "uint", $imodifiers, "uint", $vkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RegisterHotKey

    Func _WinAPI_RegisterPowerSettingNotification($hwnd, $sguid)
        Local $tguid = DllStructCreate($TAGGUID)
        Local $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
        If @error Or $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        $acall = DllCall("user32.dll", "handle", "RegisterPowerSettingNotification", "handle", $hwnd, "struct*", $tguid, "dword", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RegisterPowerSettingNotification

    Func _WinAPI_RegisterRawInputDevices($padevice, $icount = 0x1)
        Local $acall = DllCall("user32.dll", "bool", "RegisterRawInputDevices", "struct*", $padevice, "uint", $icount, "uint", DllStructGetSize(DllStructCreate($TAGRAWINPUTDEVICE)))
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RegisterRawInputDevices

    Func _WinAPI_ReleaseCapture()
        Local $acall = DllCall("user32.dll", "bool", "ReleaseCapture")
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ReleaseCapture

    Func _WinAPI_RemoveClipboardFormatListener($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "RemoveClipboardFormatListener", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RemoveClipboardFormatListener

    Func _WinAPI_SetActiveWindow($hwnd)
        Local $acall = DllCall("user32.dll", "int", "SetActiveWindow", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetActiveWindow

    Func _WinAPI_SetCapture($hwnd)
        Local $acall = DllCall("user32.dll", "hwnd", "SetCapture", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetCapture

    Func _WinAPI_SetDefaultPrinter($sprinter)
        Local $acall = DllCall("winspool.drv", "bool", "SetDefaultPrinterW", "wstr", $sprinter)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetDefaultPrinter

    Func _WinAPI_SetDllDirectory($sdirpath = Default)
        If $sdirpath = Default Then $sdirpath = Null
        Local $acall = DllCall("kernel32.dll", "bool", "SetDllDirectoryW", "wstr", $sdirpath)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetDllDirectory

    Func _WinAPI_SetKeyboardLayout($hwnd, $ilanguage, $IFLAGS = 0x0)
        If Not _WinAPI_IsWindow($hwnd) Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $hlocale = 0x0
        If $ilanguage Then
            $hlocale = _WinAPI_LoadKeyboardLayout($ilanguage)
            If Not $hlocale Then Return SetError(0xa, 0x0, 0x0)
        EndIf
        Local Const $WM_INPUTLANGCHANGEREQUEST = 0x50
        DllCall("user32.dll", "none", "SendMessage", "hwnd", $hwnd, "uint", $WM_INPUTLANGCHANGEREQUEST, "uint", $IFLAGS, "uint_ptr", $hlocale)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_SetKeyboardLayout

    Func _WinAPI_SetKeyboardState(ByRef $tstate)
        Local $acall = DllCall("user32.dll", "int", "SetKeyboardState", "struct*", $tstate)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetKeyboardState

    Func _WinAPI_SetProcessShutdownParameters($ilevel, $bdialog = False)
        Local $acall = DllCall("kernel32.dll", "bool", "SetProcessShutdownParameters", "dword", $ilevel, "dword", Not $bdialog)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetProcessShutdownParameters

    Func _WinAPI_SetProcessWindowStation($hstation)
        Local $acall = DllCall("user32.dll", "bool", "SetProcessWindowStation", "handle", $hstation)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetProcessWindowStation

    Func _WinAPI_SetUserObjectInformation($hobject, $iindex, ByRef $tdata)
        If $iindex <> 0x1 Then Return SetError(0xa, 0x0, False)
        Local $acall = DllCall("user32.dll", "bool", "SetUserObjectInformationW", "handle", $hobject, "int", 0x1, "struct*", $tdata, "dword", DllStructGetSize($tdata))
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetUserObjectInformation

    Func _WinAPI_SetWindowsHookEx($ihook, $pproc, $hdll, $ithreadid = 0x0)
        Local $acall = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $ihook, "ptr", $pproc, "handle", $hdll, "dword", $ithreadid)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWindowsHookEx

    Func _WinAPI_SetWinEventHook($ieventmin, $ieventmax, $peventproc, $ipid = 0x0, $ithreadid = 0x0, $IFLAGS = 0x0)
        Local $acall = DllCall("user32.dll", "handle", "SetWinEventHook", "uint", $ieventmin, "uint", $ieventmax, "ptr", 0x0, "ptr", $peventproc, "dword", $ipid, "dword", $ithreadid, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWinEventHook

    Func _WinAPI_ShutdownBlockReasonCreate($hwnd, $stext)
        Local $acall = DllCall("user32.dll", "bool", "ShutdownBlockReasonCreate", "hwnd", $hwnd, "wstr", $stext)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShutdownBlockReasonCreate

    Func _WinAPI_ShutdownBlockReasonDestroy($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "ShutdownBlockReasonDestroy", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShutdownBlockReasonDestroy

    Func _WinAPI_ShutdownBlockReasonQuery($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "ShutdownBlockReasonQuery", "hwnd", $hwnd, "wstr", '', "dword*", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_ShutdownBlockReasonQuery

    Func _WinAPI_SwitchDesktop($hdesktop)
        Local $acall = DllCall("user32.dll", "bool", "SwitchDesktop", "handle", $hdesktop)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SwitchDesktop

    Func _WinAPI_SystemParametersInfo($iaction, $iparam = 0x0, $vparam = 0x0, $iwinini = 0x0)
        Local $acall = DllCall("user32.dll", "bool", "SystemParametersInfoW", "uint", $iaction, "uint", $iparam, "struct*", $vparam, "uint", $iwinini)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SystemParametersInfo

    Func _WinAPI_TrackMouseEvent($hwnd, $IFLAGS, $itime = + -1)
        Local $ttme = DllStructCreate("dword;dword;hwnd;dword")
        DllStructSetData($ttme, 0x1, DllStructGetSize($ttme))
        DllStructSetData($ttme, 0x2, $IFLAGS)
        DllStructSetData($ttme, 0x3, $hwnd)
        DllStructSetData($ttme, 0x4, $itime)
        Local $acall = DllCall("user32.dll", "bool", "TrackMouseEvent", "struct*", $ttme)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_TrackMouseEvent

    Func _WinAPI_UnhookWindowsHookEx($hhook)
        Local $acall = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hhook)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UnhookWindowsHookEx

    Func _WinAPI_UnhookWinEvent($heventhook)
        Local $acall = DllCall("user32.dll", "bool", "UnhookWinEvent", "handle", $heventhook)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UnhookWinEvent

    Func _WinAPI_UnloadKeyboardLayout($hlocale)
        Local $acall = DllCall("user32.dll", "bool", "UnloadKeyboardLayout", "handle", $hlocale)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UnloadKeyboardLayout

    Func _WinAPI_UnregisterHotKey($hwnd, $iid)
        Local $acall = DllCall("user32.dll", "bool", "UnregisterHotKey", "hwnd", $hwnd, "int", $iid)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UnregisterHotKey

    Func _WinAPI_UnregisterPowerSettingNotification($hnotify)
        Local $acall = DllCall("user32.dll", "bool", "UnregisterPowerSettingNotification", "handle", $hnotify)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UnregisterPowerSettingNotification

    Func __EnumPageFilesProc($isize, $PINFO, $PFILE)
        Local $tepfi = DllStructCreate("dword;dword;ulong_ptr;ulong_ptr;ulong_ptr", $PINFO)
        __Inc($__g_venum)
        $__g_venum[$__g_venum[0x0][0x0]][0x0] = DllStructGetData(DllStructCreate("wchar[" & (_WinAPI_StrLen($PFILE) + 0x1) & "]", $PFILE), 0x1)
        For $i = 0x1 To 0x3
            $__g_venum[$__g_venum[0x0][0x0]][$i] = DllStructGetData($tepfi, $i + 0x2) * $isize
        Next
        Return 0x1
    EndFunc    ; -> __EnumPageFilesProc

#EndRegion Public Functions
Global $__g_ssourcename_event
Global Const $EVENTLOG_SUCCESS = 0x0
Global Const $EVENTLOG_ERROR_TYPE = 0x1
Global Const $EVENTLOG_WARNING_TYPE = 0x2
Global Const $EVENTLOG_INFORMATION_TYPE = 0x4
Global Const $EVENTLOG_AUDIT_SUCCESS = 0x8
Global Const $EVENTLOG_AUDIT_FAILURE = 0x10
Global Const $EVENTLOG_SEQUENTIAL_READ = 0x1
Global Const $EVENTLOG_SEEK_READ = 0x2
Global Const $EVENTLOG_FORWARDS_READ = 0x4
Global Const $EVENTLOG_BACKWARDS_READ = 0x8
Func _EventLog__Backup($heventlog, $sfilename)
    Local $acall = DllCall("advapi32.dll", "bool", "BackupEventLogW", "handle", $heventlog, "wstr", $sfilename)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _EventLog__Backup

Func _EventLog__Clear($heventlog, $sfilename)
    Local $btemp = False
    If StringLen($sfilename) = 0x0 Then
        $sfilename = @TempDir & "\\_EventLog_tempbackup.bak"
        $btemp = True
    EndIf
    Local $acall = DllCall("advapi32.dll", "bool", "ClearEventLogW", "handle", $heventlog, "wstr", $sfilename)
    If @error Then Return SetError(@error, @extended, False)
    If $btemp Then FileDelete($sfilename)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _EventLog__Clear

Func _EventLog__Close($heventlog)
    Local $acall = DllCall("advapi32.dll", "bool", "CloseEventLog", "handle", $heventlog)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _EventLog__Close

Func _EventLog__Count($heventlog)
    Local $acall = DllCall("advapi32.dll", "bool", "GetNumberOfEventLogRecords", "handle", $heventlog, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] = 0x0 Then Return + -1
    Return $acall[0x2]
EndFunc    ; -> _EventLog__Count

Func __EventLog_DecodeCategory($teventlog)
    Return DllStructGetData($teventlog, "EventCategory")
EndFunc    ; -> __EventLog_DecodeCategory

Func __EventLog_DecodeComputer($teventlog)
    Local $peventlog = DllStructGetPtr($teventlog)
    Local $ilength = DllStructGetData($teventlog, "UserSidOffset") + -1
    Local $ioffset = DllStructGetSize($teventlog)
    $ioffset += 0x2 * (StringLen(__EventLog_DecodeSource($teventlog)) + 0x1)
    $ilength -= $ioffset
    Local $tbuffer = DllStructCreate("wchar Text[" & $ilength & "]", $peventlog + $ioffset)
    Return DllStructGetData($tbuffer, "Text")
EndFunc    ; -> __EventLog_DecodeComputer

Func __EventLog_DecodeData($teventlog)
    Local $peventlog = DllStructGetPtr($teventlog)
    Local $ioffset = DllStructGetData($teventlog, "DataOffset")
    Local $ilength = DllStructGetData($teventlog, "DataLength")
    Local $tbuffer = DllStructCreate("byte[" & $ilength & "]", $peventlog + $ioffset)
    Local $ADATA[$ilength + 0x1]
    $ADATA[0x0] = $ilength
    For $ii = 0x1 To $ilength
        $ADATA[$ii] = DllStructGetData($tbuffer, 0x1, $ii)
    Next
    Return $ADATA
EndFunc    ; -> __EventLog_DecodeData

Func __EventLog_DecodeDate($ieventtime)
    Local $tint64 = DllStructCreate("int64")
    Local $pint64 = DllStructGetPtr($tint64)
    Local $tfiletime = DllStructCreate($TAGFILETIME, $pint64)
    DllStructSetData($tint64, 0x1, ($ieventtime * 0x989680) + 0x19db1ded53e8000)
    Local $tlocaltime = _Date_Time_FileTimeToLocalFileTime($tfiletime)
    Local $tsysttime = _Date_Time_FileTimeToSystemTime($tlocaltime)
    Local $imonth = DllStructGetData($tsysttime, "Month")
    Local $iday = DllStructGetData($tsysttime, "Day")
    Local $iyear = DllStructGetData($tsysttime, "Year")
    Return StringFormat("%02d/%02d/%04d", $imonth, $iday, $iyear)
EndFunc    ; -> __EventLog_DecodeDate

Func __EventLog_DecodeDesc($teventlog)
    Local $astrings = __EventLog_DecodeStrings($teventlog)
    Local $ssource = __EventLog_DecodeSource($teventlog)
    Local $ieventid = DllStructGetData($teventlog, "EventID")
    Local $skey = "HKLM\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\" & $__g_ssourcename_event & "\\" & $ssource
    Local $amsgdll = StringSplit(_WinAPI_ExpandEnvironmentStrings(RegRead($skey, "EventMessageFile")), ";")
    Local $IFLAGS = BitOR($FORMAT_MESSAGE_FROM_HMODULE, $FORMAT_MESSAGE_IGNORE_INSERTS)
    Local $sdesc = ''
    Local $tbuffer = 0x0
    For $ii = 0x1 To $amsgdll[0x0]
        Local $hdll = _WinAPI_LoadLibraryEx($amsgdll[$ii], $LOAD_LIBRARY_AS_DATAFILE)
        If $hdll = 0x0 Then ContinueLoop
        $tbuffer = DllStructCreate("wchar Text[4096]")
        _WinAPI_FormatMessage($IFLAGS, $hdll, $ieventid, 0x0, $tbuffer, 0x1000, 0x0)
        _WinAPI_FreeLibrary($hdll)
        $sdesc &= DllStructGetData($tbuffer, "Text")
    Next
    $skey = "HKLM\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\" & $__g_ssourcename_event & "\\" & $__g_ssourcename_event
    $amsgdll = StringSplit(_WinAPI_ExpandEnvironmentStrings(RegRead($skey, "ParameterMessageFile")), ";")
    For $ii = 0x1 To $amsgdll[0x0]
        $hdll = _WinAPI_LoadLibraryEx($amsgdll[$ii], $LOAD_LIBRARY_AS_DATAFILE)
        If $hdll <> 0x0 Then
            For $ij = 0x1 To $astrings[0x0]
                $tbuffer = DllStructCreate("wchar Text[4096]")
                If StringLeft($astrings[$ij], 0x2) == "%%" Then
                    _WinAPI_FormatMessage($IFLAGS, $hdll, Int(StringTrimLeft($astrings[$ij], 0x2)), 0x0, $tbuffer, 0x1000, 0x0)
                    If Not @error Then
                        $astrings[$ij] = DllStructGetData($tbuffer, "Text")
                    EndIf
                EndIf
            Next
            _WinAPI_FreeLibrary($hdll)
        EndIf
    Next
    If $sdesc = '' Then
        For $ii = 0x1 To $astrings[0x0]
            $sdesc &= $astrings[$ii]
        Next
    Else
        For $ii = $astrings[0x0] To 0x1 Step + -1
            $sdesc = StringReplace($sdesc, "%" & $ii, $astrings[$ii])
        Next
    EndIf
    Return StringStripWS($sdesc, $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndFunc    ; -> __EventLog_DecodeDesc

Func __EventLog_DecodeEventID($teventlog)
    Return BitAND(DllStructGetData($teventlog, "EventID"), 0x7fff)
EndFunc    ; -> __EventLog_DecodeEventID

Func __EventLog_DecodeSource($teventlog)
    Local $peventlog = DllStructGetPtr($teventlog)
    Local $ilength = DllStructGetData($teventlog, "UserSidOffset") + -1
    Local $ioffset = DllStructGetSize($teventlog)
    $ilength -= $ioffset
    Local $tbuffer = DllStructCreate("wchar Text[" & $ilength & "]", $peventlog + $ioffset)
    Return DllStructGetData($tbuffer, "Text")
EndFunc    ; -> __EventLog_DecodeSource

Func __EventLog_DecodeStrings($teventlog)
    Local $peventlog = DllStructGetPtr($teventlog)
    Local $inumstrs = DllStructGetData($teventlog, "NumStrings")
    Local $ioffset = DllStructGetData($teventlog, "StringOffset")
    Local $idataoffset = DllStructGetData($teventlog, "DataOffset")
    Local $tbuffer = DllStructCreate("wchar Text[" & $idataoffset - $ioffset & "]", $peventlog + $ioffset)
    Local $astrings[$inumstrs + 0x1]
    $astrings[0x0] = $inumstrs
    For $ii = 0x1 To $inumstrs
        $astrings[$ii] = DllStructGetData($tbuffer, "Text")
        $ioffset += 0x2 * (StringLen($astrings[$ii]) + 0x1)
        $tbuffer = DllStructCreate("wchar Text[" & $idataoffset - $ioffset & "]", $peventlog + $ioffset)
    Next
    Return $astrings
EndFunc    ; -> __EventLog_DecodeStrings

Func __EventLog_DecodeTime($ieventtime)
    Local $tint64 = DllStructCreate("int64")
    Local $pint64 = DllStructGetPtr($tint64)
    Local $tfiletime = DllStructCreate($TAGFILETIME, $pint64)
    DllStructSetData($tint64, 0x1, ($ieventtime * 0x989680) + 0x19db1ded53e8000)
    Local $tlocaltime = _Date_Time_FileTimeToLocalFileTime($tfiletime)
    Local $tsysttime = _Date_Time_FileTimeToSystemTime($tlocaltime)
    Local $ihours = DllStructGetData($tsysttime, "Hour")
    Local $iminutes = DllStructGetData($tsysttime, "Minute")
    Local $iseconds = DllStructGetData($tsysttime, "Second")
    Local $sampm = "AM"
    If $ihours < 0xc Then
        If $ihours = 0x0 Then
            $ihours = 0xc
        EndIf
    Else
        $sampm = "PM"
        If $ihours > 0xc Then
            $ihours -= 0xc
        EndIf
    EndIf
    Return StringFormat("%02d:%02d:%02d %s", $ihours, $iminutes, $iseconds, $sampm)
EndFunc    ; -> __EventLog_DecodeTime

Func __EventLog_DecodeTypeStr($ieventtype)
    Select
    Case $ieventtype = $EVENTLOG_SUCCESS
        Return "Success"
    Case $ieventtype = $EVENTLOG_ERROR_TYPE
        Return "Error"
    Case $ieventtype = $EVENTLOG_WARNING_TYPE
        Return "Warning"
    Case $ieventtype = $EVENTLOG_INFORMATION_TYPE
        Return "Information"
    Case $ieventtype = $EVENTLOG_AUDIT_SUCCESS
        Return "Success audit"
    Case $ieventtype = $EVENTLOG_AUDIT_FAILURE
        Return "Failure audit"
    Case Else
        Return $ieventtype
    EndSelect
EndFunc    ; -> __EventLog_DecodeTypeStr

Func __EventLog_DecodeUserName($teventlog)
    Local $peventlog = DllStructGetPtr($teventlog)
    If DllStructGetData($teventlog, "UserSidLength") = 0x0 Then Return ''
    Local $pacctsid = $peventlog + DllStructGetData($teventlog, "UserSidOffset")
    Local $aacctinfo = _Security__LookupAccountSid($pacctsid)
    If UBound($aacctinfo) >= 0x2 Then Return (Not StringLen($aacctinfo[0x1]) ? ''  : $aacctinfo[0x1] & "\\") & $aacctinfo[0x0]
    Return ''
EndFunc    ; -> __EventLog_DecodeUserName

Func _EventLog__DeregisterSource($heventlog)
    Local $acall = DllCall("advapi32.dll", "bool", "DeregisterEventSource", "handle", $heventlog)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _EventLog__DeregisterSource

Func _EventLog__Full($heventlog)
    Local $acall = DllCall("advapi32.dll", "bool", "GetEventLogInformation", "handle", $heventlog, "dword", 0x0, "dword*", 0x0, "dword", 0x4, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x3] <> 0x0
EndFunc    ; -> _EventLog__Full

Func _EventLog__Notify($heventlog, $hevent)
    Local $acall = DllCall("advapi32.dll", "bool", "NotifyChangeEventLog", "handle", $heventlog, "handle", $hevent)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _EventLog__Notify

Func _EventLog__Oldest($heventlog)
    Local $acall = DllCall("advapi32.dll", "bool", "GetOldestEventLogRecord", "handle", $heventlog, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x2]
EndFunc    ; -> _EventLog__Oldest

Func _EventLog__Open($sservername, $ssourcename)
    $__g_ssourcename_event = $ssourcename
    Local $acall = DllCall("advapi32.dll", "handle", "OpenEventLogW", "wstr", $sservername, "wstr", $ssourcename)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _EventLog__Open

Func _EventLog__OpenBackup($sservername, $sfilename)
    Local $acall = DllCall("advapi32.dll", "handle", "OpenBackupEventLogW", "wstr", $sservername, "wstr", $sfilename)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _EventLog__OpenBackup

Func _EventLog__Read($heventlog, $bread = True, $bforward = True, $ioffset = 0x0)
    Local $ireadflags, $aevent[0xf]
    $aevent[0x0] = False
    If $bread Then
        $ireadflags = $EVENTLOG_SEQUENTIAL_READ
    Else
        $ireadflags = $EVENTLOG_SEEK_READ
    EndIf
    If $bforward Then
        $ireadflags = BitOR($ireadflags, $EVENTLOG_FORWARDS_READ)
    Else
        $ireadflags = BitOR($ireadflags, $EVENTLOG_BACKWARDS_READ)
    EndIf
    Local $tbuffer = DllStructCreate("wchar[1]")
    Local $acall = DllCall("advapi32.dll", "bool", "ReadEventLogW", "handle", $heventlog, "dword", $ireadflags, "dword", $ioffset, "struct*", $tbuffer, "dword", 0x0, "dword*", 0x0, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, $aevent)
    Local $ibytesmin = $acall[0x7]
    $tbuffer = DllStructCreate("wchar[" & $ibytesmin + 0x1 & "]")
    $acall = DllCall("advapi32.dll", "bool", "ReadEventLogW", "handle", $heventlog, "dword", $ireadflags, "dword", $ioffset, "struct*", $tbuffer, "dword", $ibytesmin, "dword*", 0x0, "dword*", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, $aevent)
    Local $teventlog = DllStructCreate($TAGEVENTLOGRECORD, DllStructGetPtr($tbuffer))
    $aevent[0x0] = True
    $aevent[0x1] = DllStructGetData($teventlog, "RecordNumber")
    $aevent[0x2] = __EventLog_DecodeDate(DllStructGetData($teventlog, "TimeGenerated"))
    $aevent[0x3] = __EventLog_DecodeTime(DllStructGetData($teventlog, "TimeGenerated"))
    $aevent[0x4] = __EventLog_DecodeDate(DllStructGetData($teventlog, "TimeWritten"))
    $aevent[0x5] = __EventLog_DecodeTime(DllStructGetData($teventlog, "TimeWritten"))
    $aevent[0x6] = __EventLog_DecodeEventID($teventlog)
    $aevent[0x7] = DllStructGetData($teventlog, "EventType")
    $aevent[0x8] = __EventLog_DecodeTypeStr(DllStructGetData($teventlog, "EventType"))
    $aevent[0x9] = __EventLog_DecodeCategory($teventlog)
    $aevent[0xa] = __EventLog_DecodeSource($teventlog)
    $aevent[0xb] = __EventLog_DecodeComputer($teventlog)
    $aevent[0xc] = __EventLog_DecodeUserName($teventlog)
    $aevent[0xd] = __EventLog_DecodeDesc($teventlog)
    $aevent[0xe] = __EventLog_DecodeData($teventlog)
    Return $aevent
EndFunc    ; -> _EventLog__Read

Func _EventLog__RegisterSource($sservername, $ssourcename)
    $__g_ssourcename_event = $ssourcename
    Local $acall = DllCall("advapi32.dll", "handle", "RegisterEventSourceW", "wstr", $sservername, "wstr", $ssourcename)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _EventLog__RegisterSource

Func _EventLog__Report($heventlog, $itype, $icategory, $ieventid, $susername, $sdesc, $ADATA)
    Local $tsid = 0x0
    If $susername <> '' Then
        $tsid = _Security__GetAccountSid($susername)
    EndIf
    Local $idata = $ADATA[0x0]
    Local $tdata = DllStructCreate("byte[" & $idata & "]")
    Local $idesc = StringLen($sdesc) + 0x1
    Local $tdesc = DllStructCreate("wchar[" & $idesc & "]")
    Local $tptr = DllStructCreate("ptr")
    DllStructSetData($tptr, 0x1, DllStructGetPtr($tdesc))
    DllStructSetData($tdesc, 0x1, $sdesc)
    For $ii = 0x1 To $idata
        DllStructSetData($tdata, 0x1, $ADATA[$ii], $ii)
    Next
    Local $acall = DllCall("advapi32.dll", "bool", "ReportEventW", "handle", $heventlog, "word", $itype, "word", $icategory, "dword", $ieventid, "struct*", $tsid, "word", 0x1, "dword", $idata, "struct*", $tptr, "struct*", $tdata)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _EventLog__Report

Global Const $XLAND = 0x1
Global Const $XLBOTTOM10ITEMS = 0x4
Global Const $XLBOTTOM10PERCENT = 0x6
Global Const $XLFILTERCELLCOLOR = 0x8
Global Const $XLFILTERDYNAMIC = 0xb
Global Const $XLFILTERFONTCOLOR = 0x9
Global Const $XLFILTERICON = 0xa
Global Const $XLFILTERVALUES = 0x7
Global Const $XLOR = 0x2
Global Const $XLTOP10ITEMS = 0x3
Global Const $XLTOP10PERCENT = 0x5
Global Const $XLBOTTOM = + -4107
Global Const $XLCENTER = + -4108
Global Const $XLLEFT = + -4131
Global Const $XLRIGHT = + -4152
Global Const $XLTOP = + -4160
Global Const $XLCALCULATIONAUTOMATIC = + -4105
Global Const $XLCALCULATIONMANUAL = + -4135
Global Const $XLCALCULATIONSEMIAUTOMATIC = 0x2
Global Const $XLCELLTYPEALLFORMATCONDITIONS = + -4172
Global Const $XLCELLTYPEALLVALIDATION = + -4174
Global Const $XLCELLTYPEBLANKS = 0x4
Global Const $XLCELLTYPECOMMENTS = + -4144
Global Const $XLCELLTYPECONSTANTS = 0x2
Global Const $XLCELLTYPEFORMULAS = + -4123
Global Const $XLCELLTYPELASTCELL = 0xb
Global Const $XLCELLTYPESAMEFORMATCONDITIONS = + -4173
Global Const $XLCELLTYPESAMEVALIDATION = + -4175
Global Const $XLCELLTYPEVISIBLE = 0xc
Global Const $XLDMYFORMAT = 0x4
Global Const $XLDYMFORMAT = 0x7
Global Const $XLEMDFORMAT = 0xa
Global Const $XLGENERALFORMAT = 0x1
Global Const $XLMDYFORMAT = 0x3
Global Const $XLMYDFORMAT = 0x6
Global Const $XLSKIPCOLUMN = 0x9
Global Const $XLTEXTFORMAT = 0x2
Global Const $XLYDMFORMAT = 0x8
Global Const $XLYMDFORMAT = 0x5
Global Const $XLSHIFTTOLEFT = + -4159
Global Const $XLSHIFTUP = + -4162
Global Const $XLVALIDALERTINFORMATION = 0x3
Global Const $XLVALIDALERTSTOP = 0x1
Global Const $XLVALIDALERTWARNING = 0x2
Global Const $XLVALIDATECUSTOM = 0x7
Global Const $XLVALIDATEDATE = 0x4
Global Const $XLVALIDATEDECIMAL = 0x2
Global Const $XLVALIDATEINPUTONLY = 0x0
Global Const $XLVALIDATELIST = 0x3
Global Const $XLVALIDATETEXTLENGTH = 0x6
Global Const $XLVALIDATETIME = 0x5
Global Const $XLVALIDATEWHOLENUMBER = 0x1
Global Const $XLFILTERABOVEAVERAGE = 0x21
Global Const $XLFILTERALLDATESINPERIODAPRIL = 0x18
Global Const $XLFILTERALLDATESINPERIODAUGUST = 0x1c
Global Const $XLFILTERALLDATESINPERIODDECEMBER = 0x20
Global Const $XLFILTERALLDATESINPERIODFEBRURAY = 0x16
Global Const $XLFILTERALLDATESINPERIODJANUARY = 0x15
Global Const $XLFILTERALLDATESINPERIODJULY = 0x1b
Global Const $XLFILTERALLDATESINPERIODJUNE = 0x1a
Global Const $XLFILTERALLDATESINPERIODMARCH = 0x17
Global Const $XLFILTERALLDATESINPERIODMAY = 0x19
Global Const $XLFILTERALLDATESINPERIODNOVEMBER = 0x1f
Global Const $XLFILTERALLDATESINPERIODOCTOBER = 0x1e
Global Const $XLFILTERALLDATESINPERIODQUARTER1 = 0x11
Global Const $XLFILTERALLDATESINPERIODQUARTER2 = 0x12
Global Const $XLFILTERALLDATESINPERIODQUARTER3 = 0x13
Global Const $XLFILTERALLDATESINPERIODQUARTER4 = 0x14
Global Const $XLFILTERALLDATESINPERIODSEPTEMBER = 0x1d
Global Const $XLFILTERBELOWAVERAGE = 0x22
Global Const $XLFILTERLASTMONTH = 0x8
Global Const $XLFILTERLASTQUARTER = 0xb
Global Const $XLFILTERLASTWEEK = 0x5
Global Const $XLFILTERLASTYEAR = 0xe
Global Const $XLFILTERNEXTMONTH = 0x9
Global Const $XLFILTERNEXTQUARTER = 0xc
Global Const $XLFILTERNEXTWEEK = 0x6
Global Const $XLFILTERNEXTYEAR = 0xf
Global Const $XLFILTERTHISMONTH = 0x7
Global Const $XLFILTERTHISQUARTER = 0xa
Global Const $XLFILTERTHISWEEK = 0x4
Global Const $XLFILTERTHISYEAR = 0xd
Global Const $XLFILTERTODAY = 0x1
Global Const $XLFILTERTOMORROW = 0x3
Global Const $XLFILTERYEARTODATE = 0x10
Global Const $XLFILTERYESTERDAY = 0x2
Global Const $XLADDIN = 0x12
Global Const $XLADDIN8 = 0x12
Global Const $XLCSV = 0x6
Global Const $XLCSVMAC = 0x16
Global Const $XLCSVMSDOS = 0x18
Global Const $XLCSVUTF8 = 0x3e
Global Const $XLCSVWINDOWS = 0x17
Global Const $XLCURRENTPLATFORMTEXT = + -4158
Global Const $XLDBF2 = 0x7
Global Const $XLDBF3 = 0x8
Global Const $XLDBF4 = 0xb
Global Const $XLDIF = 0x9
Global Const $XLEXCEL12 = 0x32
Global Const $XLEXCEL2 = 0x10
Global Const $XLEXCEL2FAREAST = 0x1b
Global Const $XLEXCEL3 = 0x1d
Global Const $XLEXCEL4 = 0x21
Global Const $XLEXCEL4WORKBOOK = 0x23
Global Const $XLEXCEL5 = 0x27
Global Const $XLEXCEL7 = 0x27
Global Const $XLEXCEL8 = 0x38
Global Const $XLEXCEL9795 = 0x2b
Global Const $XLHTML = 0x2c
Global Const $XLINTLADDIN = 0x1a
Global Const $XLINTLMACRO = 0x19
Global Const $XLOPENDOCUMENTSPREADSHEET = 0x3c
Global Const $XLOPENXMLADDIN = 0x37
Global Const $XLOPENXMLSTRICTWORKBOOK = 0x3d
Global Const $XLOPENXMLTEMPLATE = 0x36
Global Const $XLOPENXMLTEMPLATEMACROENABLED = 0x35
Global Const $XLOPENXMLWORKBOOK = 0x33
Global Const $XLOPENXMLWORKBOOKMACROENABLED = 0x34
Global Const $XLSYLK = 0x2
Global Const $XLTEMPLATE = 0x11
Global Const $XLTEMPLATE8 = 0x11
Global Const $XLTEXTMAC = 0x13
Global Const $XLTEXTMSDOS = 0x15
Global Const $XLTEXTPRINTER = 0x24
Global Const $XLTEXTWINDOWS = 0x14
Global Const $XLUNICODETEXT = 0x2a
Global Const $XLWEBARCHIVE = 0x2d
Global Const $XLWJ2WD1 = 0xe
Global Const $XLWJ3 = 0x28
Global Const $XLWJ3FJ3 = 0x29
Global Const $XLWK1 = 0x5
Global Const $XLWK1ALL = 0x1f
Global Const $XLWK1FMT = 0x1e
Global Const $XLWK3 = 0xf
Global Const $XLWK3FM3 = 0x20
Global Const $XLWK4 = 0x26
Global Const $XLWKS = 0x4
Global Const $XLWORKBOOKDEFAULT = 0x33
Global Const $XLWORKBOOKNORMAL = + -4143
Global Const $XLWORKS2FAREAST = 0x1c
Global Const $XLWQ1 = 0x22
Global Const $XLXMLSPREADSHEET = 0x2e
Global Const $XLCOMMENTS = + -4144
Global Const $XLCOMMENTSTHREADED = + -4184
Global Const $XLFORMULAS = + -4123
Global Const $XLVALUES = + -4163
Global Const $XLQUALITYMINIMUM = 0x1
Global Const $XLQUALITYSTANDARD = 0x0
Global Const $XLTYPEPDF = 0x0
Global Const $XLTYPEXPS = 0x1
Global Const $XLBETWEEN = 0x1
Global Const $XLEQUAL = 0x3
Global Const $XLGREATER = 0x5
Global Const $XLGREATEREQUAL = 0x7
Global Const $XLLESS = 0x6
Global Const $XLLESSEQUAL = 0x8
Global Const $XLNOTBETWEEN = 0x2
Global Const $XLNOTEQUAL = 0x4
Global Const $XLFORMATFROMLEFTORABOVE = 0x0
Global Const $XLFORMATFROMRIGHTORBELOW = 0x1
Global Const $XLSHIFTDOWN = + -4121
Global Const $XLSHIFTTORIGHT = + -4161
Global Const $XLPART = 0x2
Global Const $XLWHOLE = 0x1
Global Const $XLPASTESPECIALOPERATIONADD = 0x2
Global Const $XLPASTESPECIALOPERATIONDIVIDE = 0x5
Global Const $XLPASTESPECIALOPERATIONMULTIPLY = 0x4
Global Const $XLPASTESPECIALOPERATIONNONE = + -4142
Global Const $XLPASTESPECIALOPERATIONSUBTRACT = 0x3
Global Const $XLPASTEALL = + -4104
Global Const $XLPASTEALLEXCEPTBORDERS = 0x7
Global Const $XLPASTEALLMERGINGCONDITIONALFORMATS = 0xe
Global Const $XLPASTEALLUSINGSOURCETHEME = 0xd
Global Const $XLPASTECOLUMNWIDTHS = 0x8
Global Const $XLPASTECOMMENTS = + -4144
Global Const $XLPASTEFORMATS = + -4122
Global Const $XLPASTEFORMULAS = + -4123
Global Const $XLPASTEFORMULASANDNUMBERFORMATS = 0xb
Global Const $XLPASTEVALIDATION = 0x6
Global Const $XLPASTEVALUES = + -4163
Global Const $XLPASTEVALUESANDNUMBERFORMATS = 0xc
Global Const $XLMACINTOSH = 0x1
Global Const $XLMSDOS = 0x3
Global Const $XLWINDOWS = 0x2
Global Const $XLA1 = 0x1
Global Const $XLR1C1 = + -4150
Global Const $XLABSOLUTE = 0x1
Global Const $XLABSROWRELCOLUMN = 0x2
Global Const $XLRELATIVE = 0x4
Global Const $XLRELROWABSCOLUMN = 0x3
Global Const $XLSHEETHIDDEN = 0x0
Global Const $XLSHEETVERYHIDDEN = 0x2
Global Const $XLSHEETVISIBLE = + -1
Global Const $XLSORTNORMAL = 0x0
Global Const $XLSORTTEXTASNUMBERS = 0x1
Global Const $XLSORTONCELLCOLOR = 0x1
Global Const $XLSORTONFONTCOLOR = 0x2
Global Const $XLSORTONICON = 0x3
Global Const $XLSORTONVALUES = 0x0
Global Const $XLASCENDING = 0x1
Global Const $XLDESCENDING = 0x2
Global Const $XLMANUAL = + -4135
Global Const $XLSORTCOLUMNS = 0x1
Global Const $XLSORTROWS = 0x2
Global Const $XLDELIMITED = 0x1
Global Const $XLFIXEDWIDTH = 0x2
Global Const $XLTEXTQUALIFIERDOUBLEQUOTE = 0x1
Global Const $XLTEXTQUALIFIERNONE = + -4142
Global Const $XLTEXTQUALIFIERSINGLEQUOTE = 0x2
Global Const $XLGUESS = 0x0
Global Const $XLNO = 0x2
Global Const $XLYES = 0x1
Func _Excel_Open($BVISIBLE = Default, $bdisplayalerts = Default, $bscreenupdating = Default, $binteractive = Default, $bforcenew = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    Local $oexcel, $bapplcloseonquit = False
    If $BVISIBLE = Default Then $BVISIBLE = True
    If $bdisplayalerts = Default Then $bdisplayalerts = False
    If $bscreenupdating = Default Then $bscreenupdating = True
    If $binteractive = Default Then $binteractive = True
    If $bforcenew = Default Then $bforcenew = False
    If Not $bforcenew Then $oexcel = ObjGet('', "Excel.Application")
    If $bforcenew Or @error Then
        $oexcel = ObjCreate("Excel.Application")
        If @error Or Not IsObj($oexcel) Then Return SetError(0x1, @error, 0x0)
        $bapplcloseonquit = True
    EndIf
    __Excel_CloseOnQuit($oexcel, $bapplcloseonquit)
    $oexcel.Visible = $BVISIBLE
    $oexcel.DisplayAlerts = $bdisplayalerts
    $oexcel.ScreenUpdating = $bscreenupdating
    $oexcel.Interactive = $binteractive
    Return SetError(0x0, $bapplcloseonquit, $oexcel)
EndFunc    ; -> _Excel_Open

Func _Excel_Close(ByRef $oexcel, $bsavechanges = Default, $bforceclose = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If $bsavechanges = Default Then $bsavechanges = True
    If $bforceclose = Default Then $bforceclose = False
    If Not IsObj($oexcel) Or ObjName($oexcel, 0x1) <> "_Application" Then Return SetError(0x1, 0x0, 0x0)
    If $bsavechanges Then
        For $oworkbook In $oexcel.Workbooks
            If Not $oworkbook.Saved Then
                $oworkbook.Save()
                If @error Then Return SetError(0x3, @error, 0x0)
            EndIf
        Next
    EndIf
    If __Excel_CloseOnQuit($oexcel) Or $bforceclose Then
        $oexcel.Quit()
        If @error Then Return SetError(0x2, @error, 0x0)
        __Excel_CloseOnQuit($oexcel, False)
        $oexcel = 0x0
    EndIf
    Return 0x1
EndFunc    ; -> _Excel_Close

Func _Excel_BookAttach($sstring, $smode = Default, $oinstance = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    Local $oworkbook, $icount = 0x0, $sclsid_workbook = "{00020819-0000-0000-C000-000000000046}"
    If $smode = Default Then $smode = "FilePath"
    While True
        $oworkbook = ObjGet('', $sclsid_workbook, $icount + 0x1)
        If @error Then Return SetError(0x1, @error, 0x0)
        $icount += 0x1
        If $oinstance <> Default And $oinstance <> $oworkbook.Parent Then ContinueLoop
        Switch $smode
        Case "filename"
            If $oworkbook.Name = $sstring Then Return $oworkbook
        Case "filepath"
            If $oworkbook.FullName = $sstring Then Return $oworkbook
        Case "title"
            If $oworkbook.Application.Caption = $sstring Then Return $oworkbook
        Case Else
            Return SetError(0x2, 0x0, 0x0)
        EndSwitch
    WEnd
EndFunc    ; -> _Excel_BookAttach

Func _Excel_BookClose(ByRef $oworkbook, $bsave = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If $bsave = Default Then $bsave = True
    If $bsave And Not $oworkbook.Saved Then
        $oworkbook.Save()
        If @error Then Return SetError(0x2, @error, 0x0)
    EndIf
    $oworkbook.Close()
    If @error Then Return SetError(0x3, @error, 0x0)
    $oworkbook = 0x0
    Return 0x1
EndFunc    ; -> _Excel_BookClose

Func _Excel_BookList($oexcel = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    Local $abooks[0x1][0x3], $iindex = 0x0
    If IsObj($oexcel) Then
        If ObjName($oexcel, 0x1) <> "_Application" Then Return SetError(0x1, 0x0, 0x0)
        Local $itemp = $oexcel.Workbooks.Count
        ReDim $abooks[$itemp][0x3]
        For $iindex = 0x0 To $itemp + -1
            $abooks[$iindex][0x0] = $oexcel.Workbooks($iindex + 0x1)
            $abooks[$iindex][0x1] = $oexcel.Workbooks($iindex + 0x1).Name
            $abooks[$iindex][0x2] = $oexcel.Workbooks($iindex + 0x1).Path
        Next
    Else
        If $oexcel <> Default Then Return SetError(0x1, 0x0, 0x0)
        Local $oworkbook, $sclsid_workbook = "{00020819-0000-0000-C000-000000000046}"
        While True
            $oworkbook = ObjGet('', $sclsid_workbook, $iindex + 0x1)
            If @error Then ExitLoop
            ReDim $abooks[$iindex + 0x1][0x3]
            $abooks[$iindex][0x0] = $oworkbook
            $abooks[$iindex][0x1] = $oworkbook.Name
            $abooks[$iindex][0x2] = $oworkbook.Path
            $iindex += 0x1
        WEnd
    EndIf
    Return $abooks
EndFunc    ; -> _Excel_BookList

Func _Excel_BookNew($oexcel, $isheets = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oexcel) Or ObjName($oexcel, 0x1) <> "_Application" Then Return SetError(0x1, 0x0, 0x0)
    With $oexcel
        If $isheets <> Default Then
            If $isheets < 0x1 Or $isheets > 0xff Then Return SetError(0x4, 0x0, 0x0)
            Local $isheetsbackup = .SheetsInNewWorkbook
            .SheetsInNewWorkbook = $isheets
            If @error Then Return SetError(0x2, @error, 0x0)
        EndIf
        Local $oworkbook = .Workbooks.Add()
        If @error Then
            Local $ierror = @error
            If $isheets <> Default Then.SheetsInNewWorkbook = $isheetsbackup
            Return SetError(0x3, $ierror, 0x0)
        EndIf
        If $isheets <> Default Then.SheetsInNewWorkbook = $isheetsbackup
    EndWith
    Return $oworkbook
EndFunc    ; -> _Excel_BookNew

Func _Excel_BookOpen($oexcel, $sfilepath, $breadonly = Default, $BVISIBLE = Default, $spassword = Default, $swritepassword = Default, $bupdatelinks = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oexcel) Or ObjName($oexcel, 0x1) <> "_Application" Then Return SetError(0x1, @error, 0x0)
    If StringLeft($sfilepath, 0x4) <> "HTTP" And Not FileExists($sfilepath) Then Return SetError(0x2, 0x0, 0x0)
    If $breadonly = Default Then $breadonly = False
    If $BVISIBLE = Default Then $BVISIBLE = True
    Local $oworkbook = $oexcel.Workbooks.Open($sfilepath, $bupdatelinks, $breadonly, Default, $spassword, $swritepassword)
    If @error Then Return SetError(0x3, @error, 0x0)
    If Not IsObj($oworkbook) Then Return SetError(0x4, @error, 0x0)
    Local $owindow = $oexcel.Windows($oworkbook.Name)
    If IsObj($owindow) Then $owindow.Visible = $BVISIBLE
    If $breadonly = False And $oworkbook.Readonly = True Then Return SetError(0x0, 0x1, $oworkbook)
    Return $oworkbook
EndFunc    ; -> _Excel_BookOpen

Func _Excel_BookOpenText($oexcel, $sfilepath, $istartrow = Default, $idatatype = Default, $stextqualifier = Default, $bconsecutivedelimiter = Default, $SDELIMITER = Default, $afieldinfo = Default, $sdecimalseparator = Default, $sthousandsseparator = Default, $btrailingminusnumbers = Default, $iorigin = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    Local $btab = False, $bsemicolon = False, $bcomma = False, $bspace = False, $adelimiter[0x1], $bother = False, $sotherchar
    If Not IsObj($oexcel) Or ObjName($oexcel, 0x1) <> "_Application" Then Return SetError(0x1, @error, 0x0)
    If StringLeft($sfilepath, 0x4) <> "HTTP" And Not FileExists($sfilepath) Then Return SetError(0x2, 0x0, 0x0)
    If $istartrow = Default Then $istartrow = 0x1
    If $stextqualifier = Default Then $stextqualifier = $XLTEXTQUALIFIERDOUBLEQUOTE
    If $bconsecutivedelimiter = Default Then $bconsecutivedelimiter = False
    If $SDELIMITER = Default Then $SDELIMITER = ","
    If $btrailingminusnumbers = Default Then $btrailingminusnumbers = True
    If StringInStr($SDELIMITER, @TAB) > 0x0 Then $btab = True
    If StringInStr($SDELIMITER, ";") > 0x0 Then $bsemicolon = True
    If StringInStr($SDELIMITER, ",") > 0x0 Then $bcomma = True
    If StringInStr($SDELIMITER, " ") > 0x0 Then $bspace = True
    $adelimiter = StringRegExp($SDELIMITER, "[^;, " & @TAB & "]", $STR_REGEXPARRAYMATCH)
    If Not @error Then
        $sotherchar = $adelimiter[0x0]
        $bother = True
    EndIf
    $oexcel.Workbooks.OpenText($sfilepath, $iorigin, $istartrow, $idatatype, $stextqualifier, $bconsecutivedelimiter, $btab, $bsemicolon, $bcomma, $bspace, $bother, $sotherchar, $afieldinfo, Default, $sdecimalseparator, $sthousandsseparator, $btrailingminusnumbers, False)
    If @error Then Return SetError(0x3, @error, 0x0)
    Return $oexcel.ActiveWorkbook
EndFunc    ; -> _Excel_BookOpenText

Func _Excel_BookSave($oworkbook)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If Not $oworkbook.Saved Then
        $oworkbook.Save()
        If @error Then Return SetError(0x2, @error, 0x0)
        Return SetError(0x0, 0x1, 0x1)
    EndIf
    Return 0x1
EndFunc    ; -> _Excel_BookSave

Func _Excel_BookSaveAs($oworkbook, $sfilepath, $iformat = Default, $boverwrite = Default, $spassword = Default, $swritepassword = Default, $breadonlyrecommended = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If $iformat = Default Then
        $iformat = $XLWORKBOOKDEFAULT
    Else
        If Not IsNumber($iformat) Then Return SetError(0x2, 0x0, 0x0)
    EndIf
    If $boverwrite = Default Then $boverwrite = False
    If $breadonlyrecommended = Default Then $breadonlyrecommended = False
    If FileExists($sfilepath) Then
        If Not $boverwrite Then Return SetError(0x3, 0x0, 0x0)
        Local $iresult = FileDelete($sfilepath)
        If $iresult = 0x0 Then Return SetError(0x4, 0x0, 0x0)
    EndIf
    $oworkbook.SaveAs($sfilepath, $iformat, $spassword, $swritepassword, $breadonlyrecommended)
    If @error Then Return SetError(0x5, @error, 0x0)
    Return 0x1
EndFunc    ; -> _Excel_BookSaveAs

Func _Excel_ColumnToLetter($icolumn)
    If Not StringRegExp($icolumn, "^[0-9]+$") Then Return SetError(0x1, 0x0, '')
    Local $sletters, $itemp
    While $icolumn
        $itemp = Mod($icolumn, 0x1a)
        If $itemp = 0x0 Then $itemp = 0x1a
        $sletters = Chr($itemp + 0x40) & $sletters
        $icolumn = ($icolumn - $itemp) / 0x1a
    WEnd
    Return $sletters
EndFunc    ; -> _Excel_ColumnToLetter

Func _Excel_ColumnToNumber($scolumn)
    $scolumn = StringUpper($scolumn)
    If Not StringRegExp($scolumn, "^[A-Z]+$") Then Return SetError(0x1, 0x0, 0x0)
    Local $sletters = StringSplit($scolumn, '')
    Local $inumber = 0x0
    Local $ilen = StringLen($scolumn)
    For $i = 0x1 To $sletters[0x0]
        $inumber += 0x1a ^ ($ilen - $i) * (Asc($sletters[$i]) + -64)
    Next
    Return $inumber
EndFunc    ; -> _Excel_ColumnToNumber

Func _Excel_ConvertFormula($oexcel, $sformula, $ifromstyle, $itostyle = Default, $itoabsolute = Default, $vrelativeto = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oexcel) Or ObjName($oexcel, 0x1) <> "_Application" Then Return SetError(0x1, 0x0, '')
    If $vrelativeto <> Default Then
        If Not IsObj($vrelativeto) Then $vrelativeto = $oexcel.Range($vrelativeto)
        If @error Or Not IsObj($vrelativeto) Then Return SetError(0x2, 0x0, '')
    EndIf
    Local $sconverted = $oexcel.ConvertFormula($sformula, $ifromstyle, $itostyle, $itoabsolute, $vrelativeto)
    Return $sconverted
EndFunc    ; -> _Excel_ConvertFormula

Func _Excel_Export($oexcel, $vobject, $sfilename, $itype = Default, $iquality = Default, $bincludeproperties = Default, $ifrom = Default, $ito = Default, $bopenafterpublish = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oexcel) Or ObjName($oexcel, 0x1) <> "_Application" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vobject) Then $vobject = $oexcel.Range($vobject)
    If @error Or Not IsObj($vobject) Then Return SetError(0x2, @error, 0x0)
    If $sfilename = '' Then Return SetError(0x3, 0x0, 0x0)
    If $itype = Default Then $itype = $XLTYPEPDF
    If $iquality = Default Then $iquality = $XLQUALITYSTANDARD
    If $bincludeproperties = Default Then $bincludeproperties = True
    If $bopenafterpublish = Default Then $bopenafterpublish = False
    $vobject.ExportAsFixedFormat($itype, $sfilename, $iquality, $bincludeproperties, Default, $ifrom, $ito, $bopenafterpublish)
    If @error Then Return SetError(0x4, @error, 0x0)
    Return $vobject
EndFunc    ; -> _Excel_Export

Func _Excel_FilterGet($oworkbook, $vworksheet = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vworksheet) Then
        If $vworksheet = Default Then
            $vworksheet = $oworkbook.ActiveSheet
        Else
            $vworksheet = $oworkbook.WorkSheets.Item($vworksheet)
        EndIf
        If @error Or Not IsObj($vworksheet) Then Return SetError(0x2, @error, 0x0)
    ElseIf ObjName($vworksheet, 0x1) <> "_Worksheet" Then
        Return SetError(0x2, @error, 0x0)
    EndIf
    Local $iindex = 0x0, $irecords, $iitems = $vworksheet.AutoFilter.Filters.Count
    If $iitems > 0x0 Then
        Local $afilters[$iitems][0x7]
        For $ofilter In $vworksheet.AutoFilter.Filters
            $afilters[$iindex][0x0] = $ofilter.On
            $afilters[$iindex][0x1] = $ofilter.Count
            $afilters[$iindex][0x2] = $ofilter.Criteria1
            If IsArray($ofilter.Criteria1) Then $afilters[$iindex][0x2] = _ArrayToString($afilters[$iindex][0x2])
            $afilters[$iindex][0x3] = $ofilter.Criteria2
            If IsArray($ofilter.Criteria2) Then $afilters[$iindex][0x3] = _ArrayToString($afilters[$iindex][0x3])
            $afilters[$iindex][0x4] = $ofilter.Operator
            $afilters[$iindex][0x5] = $ofilter.Parent.Range
            $irecords = 0x0
            For $oarea In $ofilter.Parent.Range.SpecialCells($XLCELLTYPEVISIBLE).Areas
                $irecords = $irecords + $oarea.Rows.Count
            Next
            $afilters[$iindex][0x6] = $irecords
            $iindex = $iindex + 0x1
        Next
        Return $afilters
    Else
        Return SetError(0x3, 0x0, '')
    EndIf
EndFunc    ; -> _Excel_FilterGet

Func _Excel_FilterSet($oworkbook, $vworksheet, $vrange, $ifield, $scriteria1 = Default, $ioperator = Default, $scriteria2 = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vworksheet) Then
        If $vworksheet = Default Then
            $vworksheet = $oworkbook.ActiveSheet
        Else
            $vworksheet = $oworkbook.WorkSheets.Item($vworksheet)
        EndIf
        If @error Or Not IsObj($vworksheet) Then Return SetError(0x2, @error, 0x0)
    ElseIf ObjName($vworksheet, 0x1) <> "_Worksheet" Then
        Return SetError(0x2, @error, 0x0)
    EndIf
    If $vrange = Default Then
        $vrange = $vworksheet.Usedrange
    ElseIf Not IsObj($vrange) Then
        $vrange = $vworksheet.Range($vrange)
        If @error Or Not IsObj($vrange) Then Return SetError(0x3, @error, 0x0)
    EndIf
    If $ifield <> 0x0 Then
        $vrange.AutoFilter($ifield, $scriteria1, $ioperator, $scriteria2)
        If @error Then Return SetError(0x4, @error, 0x0)
        If $vworksheet.Filtermode = False Then $vworksheet.AutoFilterMode = False
    Else
        $vworksheet.AutoFilterMode = False
    EndIf
    Return 0x1
EndFunc    ; -> _Excel_FilterSet

Func _Excel_PictureAdd($oworkbook, $vworksheet, $sfile, $vrangeorleft, $itop = Default, $iwidth = Default, $iheight = Default, $bkeepratio = True)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    Local $oreturn, $iposleft, $ipostop
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If Not FileExists($sfile) Then Return SetError(0x5, 0x0, 0x0)
    If Not IsObj($vworksheet) Then
        If $vworksheet = Default Then
            $vworksheet = $oworkbook.ActiveSheet
        Else
            $vworksheet = $oworkbook.WorkSheets.Item($vworksheet)
        EndIf
        If @error Or Not IsObj($vworksheet) Then Return SetError(0x2, @error, 0x0)
    ElseIf ObjName($vworksheet, 0x1) <> "_Worksheet" Then
        Return SetError(0x2, @error, 0x0)
    EndIf
    If IsNumber($vrangeorleft) Then
        $iposleft = $vrangeorleft
        $ipostop = $itop
    Else
        If Not IsObj($vrangeorleft) Then
            $vrangeorleft = $vworksheet.Range($vrangeorleft)
            If @error Or Not IsObj($vrangeorleft) Then Return SetError(0x3, @error, 0x0)
        EndIf
        $iposleft = $vrangeorleft.Left
        $ipostop = $vrangeorleft.Top
    EndIf
    If IsNumber($vrangeorleft) Or ($vrangeorleft.Columns.Count = 0x1 And $vrangeorleft.Rows.Count = 0x1) Then
        If $iwidth = Default And $iheight = Default Then
            $oreturn = $vworksheet.Shapes.AddPicture($sfile, + -1, + -1, $iposleft, $ipostop, 0x0, 0x0)
            If @error Then Return SetError(0x4, @error, 0x0)
            $oreturn.Scalewidth(0x1, + -1, 0x0)
            $oreturn.Scaleheight(0x1, + -1, 0x0)
        ElseIf $iwidth = Default Then
            $oreturn = $vworksheet.Shapes.AddPicture($sfile, + -1, + -1, $iposleft, $ipostop, 0x0, 0x0)
            If @error Then Return SetError(0x4, @error, 0x0)
            $oreturn.Visible = 0x0
            $oreturn.Scalewidth(0x1, + -1, 0x0)
            $oreturn.Scaleheight(0x1, + -1, 0x0)
            $oreturn.Scalewidth($iheight / $oreturn.Height, + -1, 0x0)
            $oreturn.Scaleheight($iheight / $oreturn.Height, + -1, 0x0)
            $oreturn.Visible = 0x1
        ElseIf $iheight = Default Then
            $oreturn = $vworksheet.Shapes.AddPicture($sfile, + -1, + -1, $iposleft, $ipostop, 0x0, 0x0)
            If @error Then Return SetError(0x4, @error, 0x0)
            $oreturn.Visible = 0x0
            $oreturn.Scalewidth(0x1, + -1, 0x0)
            $oreturn.Scaleheight(0x1, + -1, 0x0)
            $oreturn.Scaleheight($iwidth / $oreturn.Width, + -1, 0x0)
            $oreturn.Scalewidth($iwidth / $oreturn.Width, + -1, 0x0)
            $oreturn.Visible = 0x1
        Else
            $oreturn = $vworksheet.Shapes.AddPicture($sfile, + -1, + -1, $iposleft, $ipostop, $iwidth, $iheight)
            If @error Then Return SetError(0x4, @error, 0x0)
        EndIf
    Else
        If $bkeepratio = True Then
            $oreturn = $vworksheet.Shapes.AddPicture($sfile, + -1, + -1, $iposleft, $ipostop, 0x0, 0x0)
            If @error Then Return SetError(0x4, @error, 0x0)
            $oreturn.Visible = 0x0
            $oreturn.Scalewidth(0x1, + -1, 0x0)
            $oreturn.Scaleheight(0x1, + -1, 0x0)
            Local $irw = $vrangeorleft.Width / $oreturn.Width
            Local $irh = $vrangeorleft.Height / $oreturn.Height
            If $irw < $irh Then
                $oreturn.Scaleheight($irw, + -1, 0x0)
                $oreturn.Scalewidth($irw, + -1, 0x0)
            Else
                $oreturn.Scaleheight($irh, + -1, 0x0)
                $oreturn.Scalewidth($irh, + -1, 0x0)
            EndIf
            $oreturn.Visible = 0x1
        Else
            $oreturn = $vworksheet.Shapes.AddPicture($sfile, + -1, + -1, $iposleft, $ipostop, $vrangeorleft.Width, $vrangeorleft.Height)
            If @error Then Return SetError(0x4, @error, 0x0)
        EndIf
    EndIf
    Return $oreturn
EndFunc    ; -> _Excel_PictureAdd

Func _Excel_Print($oexcel, $vobject, $icopies = Default, $sprinter = Default, $bpreview = Default, $ifrom = Default, $ito = Default, $bprinttofile = Default, $bcollate = Default, $sprtofilename = '')
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oexcel) Or ObjName($oexcel, 0x1) <> "_Application" Then Return SetError(0x1, 0x0, 0x0)
    If IsString($vobject) Then $vobject = $oexcel.Range($vobject)
    If @error Or Not IsObj($vobject) Then Return SetError(0x2, @error, 0x0)
    $vobject.PrintOut($ifrom, $ito, $icopies, $bpreview, $sprinter, $bprinttofile, $bcollate, $sprtofilename)
    If @error Then Return SetError(0x3, @error, 0x0)
    Return $vobject
EndFunc    ; -> _Excel_Print

Func _Excel_RangeCopyPaste($oworksheet, $vsourcerange, $vtargetrange = Default, $bcut = Default, $ipaste = Default, $ioperation = Default, $bskipblanks = Default, $btranspose = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworksheet) Or ObjName($oworksheet, 0x1) <> "_Worksheet" Then Return SetError(0x1, 0x0, 0x0)
    If $bcut = Default Then $bcut = False
    If $vsourcerange = Default And $vtargetrange = Default Then Return SetError(0x7, 0x0, 0x0)
    If Not IsObj($vsourcerange) And $vsourcerange <> Default Then
        $vsourcerange = $oworksheet.Range($vsourcerange)
        If @error Then Return SetError(0x2, @error, 0x0)
    EndIf
    If Not IsObj($vtargetrange) And $vtargetrange <> Default Then
        $vtargetrange = $oworksheet.Range($vtargetrange)
        If @error Then Return SetError(0x3, @error, 0x0)
    EndIf
    If $vsourcerange = Default Then
        If $bskipblanks = Default Then $bskipblanks = False
        If $btranspose = Default Then $btranspose = False
        $vtargetrange.PasteSpecial($ipaste, $ioperation, $bskipblanks, $btranspose)
        If @error Then Return SetError(0x4, @error, 0x0)
    Else
        If $bcut Then
            $vsourcerange.Cut($vtargetrange)
            If @error Then Return SetError(0x5, @error, 0x0)
        Else
            $vsourcerange.Copy($vtargetrange)
            If @error Then Return SetError(0x6, @error, 0x0)
        EndIf
    EndIf
    If $vtargetrange <> Default Then
        Return $vtargetrange
    Else
        Return 0x1
    EndIf
EndFunc    ; -> _Excel_RangeCopyPaste

Func _Excel_RangeDelete($oworksheet, $vrange, $ishift = Default, $ientirerowcol = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworksheet) Or ObjName($oworksheet, 0x1) <> "_Worksheet" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vrange) Then
        $vrange = $oworksheet.Range($vrange)
        If @error Then Return SetError(0x2, @error, 0x0)
    EndIf
    If $ientirerowcol = 0x1 Then
        $vrange.EntireRow.Delete($ishift)
    ElseIf $ientirerowcol = 0x2 Then
        $vrange.EntireColumn.Delete($ishift)
    Else
        $vrange.Delete($ishift)
    EndIf
    If @error Then Return SetError(0x3, @error, 0x0)
    Return 0x1
EndFunc    ; -> _Excel_RangeDelete

Func _Excel_RangeFind($oworkbook, $ssearch, $vrange = Default, $ilookin = Default, $ilookat = Default, $bmatchcase = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If StringStripWS($ssearch, BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) = '' Then Return SetError(0x2, 0x0, 0x0)
    If $ilookin = Default Then $ilookin = $XLVALUES
    If $ilookat = Default Then $ilookat = $XLPART
    If $bmatchcase = Default Then $bmatchcase = False
    Local $omatch, $sfirst = '', $bsearchworkbook = False, $osheet
    If $vrange = Default Then
        $bsearchworkbook = True
        $osheet = $oworkbook.Sheets(0x1)
        $vrange = $osheet.UsedRange
    ElseIf IsString($vrange) Then
        $vrange = $oworkbook.Activesheet.Range($vrange)
        If @error Then Return SetError(0x3, @error, 0x0)
    EndIf
    Local $aret[0x64][0x6], $iindex = 0x0, $iindexsheets = 0x1, $otemp
    While 0x1
        $omatch = $vrange.Find($ssearch, Default, $ilookin, $ilookat, Default, Default, $bmatchcase)
        If @error Then Return SetError(0x4, @error, 0x0)
        If IsObj($omatch) Then
            $sfirst = $omatch.Address
            While 0x1
                $aret[$iindex][0x0] = $omatch.Worksheet.Name
                $otemp = $omatch.Name
                If Not @error Then $aret[$iindex][0x1] = $otemp.Name
                $aret[$iindex][0x2] = $omatch.Address
                $aret[$iindex][0x3] = $omatch.Value
                $aret[$iindex][0x4] = $omatch.Formula
                $otemp = $omatch.Comment
                If IsObj($otemp) Then $aret[$iindex][0x5] = $otemp.Text
                $iindex = $iindex + 0x1
                If Mod($iindex, 0x64) = 0x0 Then ReDim $aret[UBound($aret, 0x1) + 0x64][0x6]
                $omatch = $vrange.Findnext($omatch)
                If Not IsObj($omatch) Or $sfirst = $omatch.Address Then ExitLoop
            WEnd
        EndIf
        If Not $bsearchworkbook Then ExitLoop
        $iindexsheets = $iindexsheets + 0x1
        $sfirst = ''
        $osheet = $oworkbook.Sheets($iindexsheets)
        If @error Then ExitLoop
        $vrange = $osheet.UsedRange
    WEnd
    ReDim $aret[$iindex][0x6]
    Return $aret
EndFunc    ; -> _Excel_RangeFind

Func _Excel_RangeInsert($oworksheet, $vrange, $ishift = Default, $icopyorigin = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworksheet) Or ObjName($oworksheet, 0x1) <> "_Worksheet" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vrange) Then
        $vrange = $oworksheet.Range($vrange)
        If @error Then Return SetError(0x2, @error, 0x0)
    EndIf
    $vrange.Insert($ishift, $icopyorigin)
    If @error Then Return SetError(0x3, @error, 0x0)
    Return $vrange
EndFunc    ; -> _Excel_RangeInsert

Func _Excel_RangeLinkAddRemove($oworkbook, $vworksheet, $vrange, $saddress, $ssubaddress = Default, $sscreentip = Default, $stexttodisplay = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    Local $olink
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vworksheet) Then
        If $vworksheet = Default Then
            $vworksheet = $oworkbook.ActiveSheet
        Else
            $vworksheet = $oworkbook.WorkSheets.Item($vworksheet)
        EndIf
        If @error Or Not IsObj($vworksheet) Then Return SetError(0x2, @error, 0x0)
    ElseIf ObjName($vworksheet, 0x1) <> "_Worksheet" Then
        Return SetError(0x2, @error, 0x0)
    EndIf
    If Not IsObj($vrange) Then
        $vrange = $vworksheet.Range($vrange)
        If @error Or Not IsObj($vrange) Then Return SetError(0x3, @error, 0x0)
    EndIf
    If $saddress = '' Then
        $vrange.Hyperlinks.Delete()
        If @error Then Return SetError(0x4, @error, 0x0)
        Return 0x1
    Else
        $olink = $vworksheet.Hyperlinks.Add($vrange, $saddress, $ssubaddress, $sscreentip, $stexttodisplay)
        If @error Then Return SetError(0x4, @error, 0x0)
        Return $olink
    EndIf
EndFunc    ; -> _Excel_RangeLinkAddRemove

Func _Excel_RangeRead($oworkbook, $vworksheet = Default, $vrange = Default, $ireturn = Default, $bforcefunc = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vworksheet) Then
        If $vworksheet = Default Then
            $vworksheet = $oworkbook.ActiveSheet
        Else
            $vworksheet = $oworkbook.WorkSheets.Item($vworksheet)
        EndIf
        If @error Or Not IsObj($vworksheet) Then Return SetError(0x2, @error, 0x0)
    ElseIf ObjName($vworksheet, 0x1) <> "_Worksheet" Then
        Return SetError(0x2, @error, 0x0)
    EndIf
    If $vrange = Default Then
        $vrange = $vworksheet.Usedrange
    ElseIf Not IsObj($vrange) Then
        $vrange = $vworksheet.Range($vrange)
        If @error Or Not IsObj($vrange) Then Return SetError(0x3, @error, 0x0)
    EndIf
    If $ireturn = Default Then
        $ireturn = 0x1
    ElseIf $ireturn < 0x1 Or $ireturn > 0x4 Then
        Return SetError(0x4, 0x0, 0x0)
    EndIf
    If $bforcefunc = Default Then $bforcefunc = False
    Local $vresult, $icellcount = $vrange.Columns.Count * $vrange.Rows.Count
    If $ireturn = 0x3 And $icellcount > 0x1 Then Return SetError(0x8, @error, 0x0)
    If $icellcount > 0x1000000 Then Return SetError(0x6, 0x0, 0x0)
    If $icellcount > 0xffff Then $bforcefunc = True
    If $bforcefunc Then
        Switch $ireturn
        Case 0x1
            $vresult = $vrange.Value
        Case 0x2
            $vresult = $vrange.Formula
        Case 0x3
            $vresult = $vrange.Text
        Case Else
            $vresult = $vrange.Value2
        EndSwitch
        If @error Then Return SetError(0x7, @error, 0x0)
        If $icellcount > 0x1 Then _ArrayTranspose($vresult)
    Else
        Local $oexcel = $oworkbook.Parent
        Switch $ireturn
        Case 0x1
            $vresult = $oexcel.Transpose($vrange.Value)
        Case 0x2
            $vresult = $oexcel.Transpose($vrange.Formula)
        Case 0x3
            $vresult = $oexcel.Transpose($vrange.Text)
        Case Else
            $vresult = $oexcel.Transpose($vrange.Value2)
        EndSwitch
        If @error Then Return SetError(0x5, @error, 0x0)
    EndIf
    Return $vresult
EndFunc    ; -> _Excel_RangeRead

Func _Excel_RangeReplace($oworkbook, $vworksheet, $vrange, $ssearch, $sreplace, $ilookat = Default, $bmatchcase = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vworksheet) Then
        If $vworksheet = Default Then
            $vworksheet = $oworkbook.ActiveSheet
        Else
            $vworksheet = $oworkbook.WorkSheets.Item($vworksheet)
        EndIf
        If @error Or Not IsObj($vworksheet) Then Return SetError(0x2, @error, 0x0)
    ElseIf ObjName($vworksheet, 0x1) <> "_Worksheet" Then
        Return SetError(0x2, @error, 0x0)
    EndIf
    If StringStripWS($ssearch, BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) = '' Then Return SetError(0x3, 0x0, 0x0)
    If $vrange = Default Then
        $vrange = $vworksheet.Usedrange
    ElseIf Not IsObj($vrange) Then
        $vrange = $vworksheet.Range($vrange)
        If @error Or Not IsObj($vrange) Then Return SetError(0x4, @error, 0x0)
    EndIf
    If $ilookat = Default Then $ilookat = $XLPART
    If $bmatchcase = Default Then $bmatchcase = False
    Local $breplace
    $breplace = $vrange.Replace($ssearch, $sreplace, $ilookat, Default, $bmatchcase)
    If @error Then Return SetError(0x5, @error, 0x0)
    Return SetError(0x0, $breplace, $vrange)
EndFunc    ; -> _Excel_RangeReplace

Func _Excel_RangeSort($oworkbook, $vworksheet, $vrange, $vkey1, $iorder1 = Default, $isorttext = Default, $iheader = Default, $bmatchcase = Default, $iorientation = Default, $vkey2 = Default, $iorder2 = Default, $vkey3 = Default, $iorder3 = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vworksheet) Then
        If $vworksheet = Default Then
            $vworksheet = $oworkbook.ActiveSheet
        Else
            $vworksheet = $oworkbook.WorkSheets.Item($vworksheet)
        EndIf
        If @error Or Not IsObj($vworksheet) Then Return SetError(0x2, @error, 0x0)
    ElseIf ObjName($vworksheet, 0x1) <> "_Worksheet" Then
        Return SetError(0x2, @error, 0x0)
    EndIf
    If $vrange = Default Then
        $vrange = $vworksheet.Usedrange
    ElseIf Not IsObj($vrange) Then
        $vrange = $vworksheet.Range($vrange)
        If @error Or Not IsObj($vrange) Then Return SetError(0x3, @error, 0x0)
    EndIf
    $vkey1 = $vworksheet.Range($vkey1)
    If @error Or Not IsObj($vkey1) Then Return SetError(0x4, @error, 0x0)
    If $vkey2 <> Default Then
        $vkey2 = $vworksheet.Range($vkey2)
        If @error Or Not IsObj($vkey2) Then Return SetError(0x5, @error, 0x0)
    EndIf
    If $vkey3 <> Default Then
        $vkey3 = $vworksheet.Range($vkey3)
        If @error Or Not IsObj($vkey3) Then Return SetError(0x6, @error, 0x0)
    EndIf
    If $iheader = Default Then $iheader = $XLNO
    If $bmatchcase = Default Then $bmatchcase = False
    If $iorientation = Default Then $iorientation = $XLSORTCOLUMNS
    If $iorder1 = Default Then $iorder1 = $XLASCENDING
    If $isorttext = Default Then $isorttext = $XLSORTNORMAL
    If $iorder2 = Default Then $iorder2 = $XLASCENDING
    If $iorder3 = Default Then $iorder3 = $XLASCENDING
    If Int($oworkbook.Parent.Version) < 0x70 Then
        $vrange.Sort($vkey1, $iorder1, $vkey2, Default, $iorder2, $vkey3, $iorder3, $iheader, Default, $bmatchcase, $iorientation, Default, $isorttext, $isorttext, $isorttext)
    Else
        $vworksheet.Sort.SortFields.Clear
        $vworksheet.Sort.SortFields.Add($vkey1, $XLSORTONVALUES, $iorder1)
        If $vkey2 <> Default Then $vworksheet.Sort.SortFields.Add($vkey2, $XLSORTONVALUES, $iorder2)
        If $vkey3 <> Default Then $vworksheet.Sort.SortFields.Add($vkey3, $XLSORTONVALUES, $iorder3)
        $vworksheet.Sort.SetRange($vrange)
        $vworksheet.Sort.Header = $iheader
        $vworksheet.Sort.MatchCase = $bmatchcase
        $vworksheet.Sort.Orientation = $iorientation
        $vworksheet.Sort.Apply
    EndIf
    If @error Then Return SetError(0x7, @error, 0x0)
    Return $vrange
EndFunc    ; -> _Excel_RangeSort

Func _Excel_RangeValidate($oworkbook, $vworksheet, $vrange, $itype, $sformula1, $ioperator = Default, $sformula2 = Default, $bignoreblank = Default, $ialertstyle = Default, $serrormessage = Default, $sinputmessage = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vworksheet) Then
        If $vworksheet = Default Then
            $vworksheet = $oworkbook.ActiveSheet
        Else
            $vworksheet = $oworkbook.WorkSheets.Item($vworksheet)
        EndIf
        If @error Or Not IsObj($vworksheet) Then Return SetError(0x2, @error, 0x0)
    ElseIf ObjName($vworksheet, 0x1) <> "_Worksheet" Then
        Return SetError(0x2, @error, 0x0)
    EndIf
    If $vrange = Default Then
        $vrange = $vworksheet.Usedrange
    ElseIf Not IsObj($vrange) Then
        $vrange = $vworksheet.Range($vrange)
        If @error Or Not IsObj($vrange) Then Return SetError(0x3, @error, 0x0)
    EndIf
    If $bignoreblank = Default Then $bignoreblank = True
    If $ialertstyle = Default Then $ialertstyle = $XLVALIDALERTSTOP
    $vrange.Validation.Delete()
    $vrange.Validation.Add($itype, $ialertstyle, $ioperator, $sformula1, $sformula2)
    If @error Then Return SetError(0x4, @error, 0x0)
    $vrange.Validation.IgnoreBlank = $bignoreblank
    If $sinputmessage <> Default Then
        $vrange.Validation.InputMessage = $sinputmessage
        $vrange.Validation.ShowInput = True
    EndIf
    If $serrormessage <> Default Then
        $vrange.Validation.ErrorMessage = $serrormessage
        $vrange.Validation.ShowError = True
    EndIf
    Return $vrange
EndFunc    ; -> _Excel_RangeValidate

Func _Excel_RangeWrite($oworkbook, $vworksheet, $vvalue, $vrange = Default, $bvalue = Default, $bforcefunc = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vworksheet) Then
        If $vworksheet = Default Then
            $vworksheet = $oworkbook.ActiveSheet
        Else
            $vworksheet = $oworkbook.WorkSheets.Item($vworksheet)
        EndIf
        If @error Or Not IsObj($vworksheet) Then Return SetError(0x2, @error, 0x0)
    ElseIf ObjName($vworksheet, 0x1) <> "_Worksheet" Then
        Return SetError(0x2, @error, 0x0)
    EndIf
    If $vrange = Default Then $vrange = "A1"
    If $bvalue = Default Then $bvalue = True
    If $bforcefunc = Default Then $bforcefunc = False
    If Not IsObj($vrange) Then
        $vrange = $vworksheet.Range($vrange)
        If @error Or Not IsObj($vrange) Then Return SetError(0x3, @error, 0x0)
    EndIf
    If Not IsArray($vvalue) Then
        If $bvalue Then
            $vrange.Value = $vvalue
        Else
            $vrange.Formula = $vvalue
        EndIf
        If @error Then Return SetError(0x4, @error, 0x0)
    Else
        If $vrange.Columns.Count = 0x1 And $vrange.Rows.Count = 0x1 Then
            If UBound($vvalue, 0x0) = 0x1 Then
                $vrange = $vrange.Resize(UBound($vvalue, 0x1), 0x1)
            Else
                $vrange = $vrange.Resize(UBound($vvalue, 0x1), UBound($vvalue, 0x2))
            EndIf
        EndIf
        If $bforcefunc Then
            _ArrayTranspose($vvalue)
            If $bvalue Then
                $vrange.Value = $vvalue
            Else
                $vrange.Formula = $vvalue
            EndIf
            If @error Then Return SetError(0x5, @error, 0x0)
        Else
            Local $oexcel = $oworkbook.Parent
            If $bvalue Then
                $vrange.Value = $oexcel.Transpose($vvalue)
            Else
                $vrange.Formula = $oexcel.Transpose($vvalue)
            EndIf
            If @error Then Return SetError(0x6, @error, 0x0)
        EndIf
    EndIf
    Return $vrange
EndFunc    ; -> _Excel_RangeWrite

Func _Excel_SheetAdd($oworkbook, $vsheet = Default, $bbefore = Default, $icount = Default, $sname = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    Local $binsertatend = False, $istartsheet, $obefore = Default, $oafter = Default
    If $icount = Default Then $icount = 0x1
    If $icount > 0xff Then Return SetError(0x6, 0x0, 0x0)
    If $bbefore = Default Then $bbefore = True
    If $vsheet = Default Then
        $vsheet = $oworkbook.ActiveSheet
    ElseIf Not IsObj($vsheet) Then
        If $vsheet = + -1 Then
            $vsheet = $oworkbook.WorkSheets.Item($oworkbook.WorkSheets.Count)
        Else
            $vsheet = $oworkbook.WorkSheets.Item($vsheet)
        EndIf
        If @error Then Return SetError(0x2, @error, 0x0)
        If $vsheet.Index = $oworkbook.WorkSheets.Count And $bbefore = False Then $binsertatend = True
    EndIf
    If $sname <> Default Then
        Local $aname = StringSplit($sname, "|")
        SetError(0x0)
        If $aname[0x1] <> '' Then
            For $iindex1 = 0x1 To $aname[0x0]
                For $iindex2 = 0x1 To $oworkbook.WorkSheets.Count
                    If $oworkbook.WorkSheets($iindex2).Name = $aname[$iindex1] Then Return SetError(0x3, $iindex1, 0x0)
                Next
            Next
        Else
            $sname = Default
        EndIf
    EndIf
    If $bbefore Then
        $obefore = $vsheet
    Else
        $oafter = $vsheet
    EndIf
    Local $osheet = $oworkbook.WorkSheets.Add($obefore, $oafter, $icount)
    If @error Then Return SetError(0x4, @error, 0x0)
    If $sname <> Default Then
        If $binsertatend = True Then
            $istartsheet = $osheet.Index - $icount + 0x1
        Else
            $istartsheet = $osheet.Index
        EndIf
        $iindex2 = 0x1
        For $isheet = $istartsheet To $istartsheet + $icount + -1
            If $aname[$iindex2] <> '' Then $oworkbook.WorkSheets($isheet).Name = $aname[$iindex2]
            If @error Then Return SetError(0x5, @error, 0x0)
            $iindex2 += 0x1
            If $iindex2 > $aname[0x0] Then ExitLoop
        Next
    EndIf
    Return $osheet
EndFunc    ; -> _Excel_SheetAdd

Func _Excel_SheetCopyMove($osourcebook, $vsourcesheet = Default, $otargetbook = Default, $vtargetsheet = Default, $bbefore = Default, $bcopy = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    Local $vbefore = Default, $vafter = Default
    If Not IsObj($osourcebook) Or ObjName($osourcebook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    If $vsourcesheet = Default Then $vsourcesheet = $osourcebook.ActiveSheet
    If $otargetbook = Default Then $otargetbook = $osourcebook
    If Not IsObj($otargetbook) Or ObjName($otargetbook, 0x1) <> "_Workbook" Then Return SetError(0x2, 0x0, 0x0)
    If $vtargetsheet = Default Then $vtargetsheet = 0x1
    If $bbefore = Default Then $bbefore = True
    If $bcopy = Default Then $bcopy = True
    If Not IsObj($vsourcesheet) Then
        $vsourcesheet = $osourcebook.Sheets($vsourcesheet)
        If @error Or Not IsObj($vsourcesheet) Then SetError(0x3, @error, 0x0)
    EndIf
    If Not IsObj($vtargetsheet) Then
        $vtargetsheet = $otargetbook.Sheets($vtargetsheet)
        If @error Or Not IsObj($vtargetsheet) Then SetError(0x4, @error, 0x0)
    EndIf
    If $bbefore Then
        $vbefore = $vtargetsheet
    Else
        $vafter = $vtargetsheet
    EndIf
    If $bcopy Then
        $vsourcesheet.Copy($vbefore, $vafter)
    Else
        $vsourcesheet.Move($vbefore, $vafter)
    EndIf
    If @error Then Return SetError(0x5, @error, 0x0)
    If $bbefore Then
        Return $otargetbook.Sheets($vtargetsheet.Index + -1)
    Else
        Return $otargetbook.Sheets($vtargetsheet.Index + 0x1)
    EndIf
EndFunc    ; -> _Excel_SheetCopyMove

Func _Excel_SheetDelete($oworkbook, $vsheet = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    Local $osheet
    If $vsheet = Default Then
        $osheet = $oworkbook.ActiveSheet
    ElseIf Not IsObj($vsheet) Then
        $osheet = $oworkbook.WorkSheets.Item($vsheet)
    Else
        $osheet = $vsheet
    EndIf
    If @error Then Return SetError(0x2, @error, 0x0)
    $osheet.Delete()
    If @error Then Return SetError(0x3, @error, 0x0)
    Return 0x1
EndFunc    ; -> _Excel_SheetDelete

Func _Excel_SheetList($oworkbook)
    Local $oerror = ObjEvent("AutoIt.Error", "__Excel_COMErrFunc")
    #forceref $oError
    If Not IsObj($oworkbook) Or ObjName($oworkbook, 0x1) <> "_Workbook" Then Return SetError(0x1, 0x0, 0x0)
    Local $isheetcount = $oworkbook.Sheets.Count
    Local $asheets[$isheetcount][0x2]
    For $iindex = 0x0 To $isheetcount + -1
        $asheets[$iindex][0x0] = $oworkbook.Sheets($iindex + 0x1).Name
        $asheets[$iindex][0x1] = $oworkbook.Sheets($iindex + 0x1)
    Next
    Return $asheets
EndFunc    ; -> _Excel_SheetList

Func __Excel_CloseOnQuit($oexcel, $bnewstate = Default)
    Static $bstate[0x65] = [0x0]
    If $bnewstate = True Then
        For $i = 0x1 To $bstate[0x0]
            If Not IsObj($bstate[$i]) Or $bstate[$i] = $oexcel Then
                $bstate[$i] = $oexcel
                Return True
            EndIf
        Next
        $bstate[0x0] = $bstate[0x0] + 0x1
        $bstate[$bstate[0x0]] = $oexcel
        Return True
    Else
        For $i = 0x1 To $bstate[0x0]
            If $bstate[$i] = $oexcel Then
                If $bnewstate = False Then
                    $bstate[$i] = 0x0
                    Return False
                Else
                    Return True
                EndIf
            EndIf
        Next
    EndIf
    Return False
EndFunc    ; -> __Excel_CloseOnQuit

Func __Excel_COMErrFunc()
EndFunc    ; -> __Excel_COMErrFunc

Func _FileCountLines($sfilepath)
    FileReadToArray($sfilepath)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return @extended
EndFunc    ; -> _FileCountLines

Func _FileCreate($sfilepath)
    Local $hfileopen = FileOpen($sfilepath, BitOR($FO_OVERWRITE, $FO_CREATEPATH))
    If $hfileopen = + -1 Then Return SetError(0x1, 0x0, 0x0)
    Local $ifilewrite = FileWrite($hfileopen, '')
    FileClose($hfileopen)
    If Not $ifilewrite Then Return SetError(0x2, 0x0, 0x0)
    Return 0x1
EndFunc    ; -> _FileCreate

Func _FileListToArray($sfilepath, $sfilter = "*", $IFLAG = $FLTA_FILESFOLDERS, $breturnpath = False)
    Local $SDELIMITER = "|", $sfilelist = '', $sfilename = '', $sfullpath = ''
    $sfilepath = StringRegExpReplace($sfilepath, "[\\\\/]+$", '') & "\\"
    If $IFLAG = Default Then $IFLAG = $FLTA_FILESFOLDERS
    If $breturnpath Then $sfullpath = $sfilepath
    If $sfilter = Default Then $sfilter = "*"
    If Not FileExists($sfilepath) Then Return SetError(0x1, 0x0, 0x0)
    If StringRegExp($sfilter, "[\\\\/:><\\|]|(?s)^\\s*$") Then Return SetError(0x2, 0x0, 0x0)
    If Not ($IFLAG = 0x0 Or $IFLAG = 0x1 Or $IFLAG = 0x2) Then Return SetError(0x3, 0x0, 0x0)
    Local $hsearch = FileFindFirstFile($sfilepath & $sfilter)
    If @error Then Return SetError(0x4, 0x0, 0x0)
    While 0x1
        $sfilename = FileFindNextFile($hsearch)
        If @error Then ExitLoop
        If ($IFLAG + @extended = 0x2) Then ContinueLoop
        $sfilelist &= $SDELIMITER & $sfullpath & $sfilename
    WEnd
    FileClose($hsearch)
    If $sfilelist = '' Then Return SetError(0x4, 0x0, 0x0)
    Return StringSplit(StringTrimLeft($sfilelist, 0x1), $SDELIMITER)
EndFunc    ; -> _FileListToArray

Func _FileListToArrayRec($sfilepath, $smask = "*", $ireturn = $FLTAR_FILESFOLDERS, $irecur = $FLTAR_NORECUR, $isort = $FLTAR_NOSORT, $ireturnpath = $FLTAR_RELPATH)
    If Not FileExists($sfilepath) Then Return SetError(0x1, 0x1, '')
    If $smask = Default Then $smask = "*"
    If $ireturn = Default Then $ireturn = $FLTAR_FILESFOLDERS
    If $irecur = Default Then $irecur = $FLTAR_NORECUR
    If $isort = Default Then $isort = $FLTAR_NOSORT
    If $ireturnpath = Default Then $ireturnpath = $FLTAR_RELPATH
    If $irecur > 0x1 Or Not IsInt($irecur) Then Return SetError(0x1, 0x6, '')
    Local $blongpath = False
    If StringLeft($sfilepath, 0x4) == "\\\\?\\" Then
        $blongpath = True
    EndIf
    Local $sfolderslash = ''
    If StringRight($sfilepath, 0x1) = "\\" Then
        $sfolderslash = "\\"
    Else
        $sfilepath = $sfilepath & "\\"
    EndIf
    Local $asfoldersearchlist[0x64] = [0x1]
    $asfoldersearchlist[0x1] = $sfilepath
    Local $ihide_hs = 0x0, $shide_hs = ''
    If BitAND($ireturn, $FLTAR_NOHIDDEN) Then
        $ihide_hs += 0x2
        $shide_hs &= "H"
        $ireturn -= $FLTAR_NOHIDDEN
    EndIf
    If BitAND($ireturn, $FLTAR_NOSYSTEM) Then
        $ihide_hs += 0x4
        $shide_hs &= "S"
        $ireturn -= $FLTAR_NOSYSTEM
    EndIf
    Local $ihide_link = 0x0
    If BitAND($ireturn, $FLTAR_NOLINK) Then
        $ihide_link = 0x400
        $ireturn -= $FLTAR_NOLINK
    EndIf
    Local $imaxlevel = 0x0
    If $irecur < 0x0 Then
        StringReplace($sfilepath, "\\", '', 0x0, $STR_NOCASESENSEBASIC)
        $imaxlevel = @extended - $irecur
    EndIf
    Local $sexclude_list = '', $sexclude_list_folder = '', $sinclude_list = "*"
    Local $amasksplit = StringSplit($smask, "|")
    Switch $amasksplit[0x0]
    Case 0x3
        $sexclude_list_folder = $amasksplit[0x3]
        ContinueCase
    Case 0x2
        $sexclude_list = $amasksplit[0x2]
        ContinueCase
    Case 0x1
        $sinclude_list = $amasksplit[0x1]
    EndSwitch
    Local $sinclude_file_mask = ".+"
    If $sinclude_list <> "*" Then
        If Not __FLTAR_ListToMask($sinclude_file_mask, $sinclude_list) Then Return SetError(0x1, 0x2, '')
    EndIf
    Local $sinclude_folder_mask = ".+"
    Switch $ireturn
    Case 0x0
        Switch $irecur
        Case 0x0
            $sinclude_folder_mask = $sinclude_file_mask
        EndSwitch
    Case 0x2
        $sinclude_folder_mask = $sinclude_file_mask
    EndSwitch
    Local $sexclude_file_mask = ":"
    If $sexclude_list <> '' Then
        If Not __FLTAR_ListToMask($sexclude_file_mask, $sexclude_list) Then Return SetError(0x1, 0x3, '')
    EndIf
    Local $sexclude_folder_mask = ":"
    If $irecur Then
        If $sexclude_list_folder Then
            If Not __FLTAR_ListToMask($sexclude_folder_mask, $sexclude_list_folder) Then Return SetError(0x1, 0x4, '')
        EndIf
        If $ireturn = 0x2 Then
            $sexclude_folder_mask = $sexclude_file_mask
        EndIf
    Else
        $sexclude_folder_mask = $sexclude_file_mask
    EndIf
    If Not ($ireturn = 0x0 Or $ireturn = 0x1 Or $ireturn = 0x2) Then Return SetError(0x1, 0x5, '')
    If Not ($isort = 0x0 Or $isort = 0x1 Or $isort = 0x2) Then Return SetError(0x1, 0x7, '')
    If Not ($ireturnpath = 0x0 Or $ireturnpath = 0x1 Or $ireturnpath = 0x2) Then Return SetError(0x1, 0x8, '')
    If $ihide_link Then
        Local $tfile_data = DllStructCreate("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" & "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
        Local $hdll = DllOpen("kernel32.dll"), $adll_ret
    EndIf
    Local $asreturnlist[0x64] = [0x0]
    Local $asfilematchlist = $asreturnlist, $asrootfilematchlist = $asreturnlist, $asfoldermatchlist = $asreturnlist
    Local $bfolder = False, $hsearch = 0x0, $scurrentpath = '', $sname = '', $sretpath = ''
    Local $iattribs = 0x0, $sattribs = ''
    Local $asfolderfilesectionlist[0x64][0x2] = [[0x0, 0x0]]
    While $asfoldersearchlist[0x0] > 0x0
        $scurrentpath = $asfoldersearchlist[$asfoldersearchlist[0x0]]
        $asfoldersearchlist[0x0]-= 0x1
        Switch $ireturnpath
        Case 0x1
            $sretpath = StringReplace($scurrentpath, $sfilepath, '')
        Case 0x2
            If $blongpath Then
                $sretpath = StringTrimLeft($scurrentpath, 0x4)
            Else
                $sretpath = $scurrentpath
            EndIf
        EndSwitch
        If $ihide_link Then
            $adll_ret = DllCall($hdll, "handle", "FindFirstFileW", "wstr", $scurrentpath & "*", "struct*", $tfile_data)
            If @error Or Not $adll_ret[0x0] Then
                ContinueLoop
            EndIf
            $hsearch = $adll_ret[0x0]
        Else
            $hsearch = FileFindFirstFile($scurrentpath & "*")
            If $hsearch = + -1 Then
                ContinueLoop
            EndIf
        EndIf
        If $ireturn = 0x0 And $isort And $ireturnpath Then
            __FLTAR_AddToList($asfolderfilesectionlist, $sretpath, $asfilematchlist[0x0] + 0x1)
        EndIf
        $sattribs = ''
        While 0x1
            If $ihide_link Then
                $adll_ret = DllCall($hdll, "int", "FindNextFileW", "handle", $hsearch, "struct*", $tfile_data)
                If @error Or Not $adll_ret[0x0] Then
                    ExitLoop
                EndIf
                $sname = DllStructGetData($tfile_data, "FileName")
                If $sname = ".." Or $sname = "." Then
                    ContinueLoop
                EndIf
                $iattribs = DllStructGetData($tfile_data, "FileAttributes")
                If $ihide_hs And BitAND($iattribs, $ihide_hs) Then
                    ContinueLoop
                EndIf
                If BitAND($iattribs, $ihide_link) Then
                    ContinueLoop
                EndIf
                $bfolder = False
                If BitAND($iattribs, 0x10) Then
                    $bfolder = True
                EndIf
            Else
                $bfolder = False
                $sname = FileFindNextFile($hsearch, 0x1)
                If @error Then
                    ExitLoop
                EndIf
                If $sname = ".." Or $sname = "." Then
                    ContinueLoop
                EndIf
                $sattribs = @extended
                If StringInStr($sattribs, "D") Then
                    $bfolder = True
                EndIf
                If StringRegExp($sattribs, "[" & $shide_hs & "]") Then
                    ContinueLoop
                EndIf
            EndIf
            If $bfolder Then
                Select
                Case $irecur < 0x0
                    StringReplace($scurrentpath, "\\", '', 0x0, $STR_NOCASESENSEBASIC)
                    If @extended < $imaxlevel Then
                        ContinueCase
                    EndIf
                Case $irecur = 0x1
                    If Not StringRegExp($sname, $sexclude_folder_mask) Then
                        __FLTAR_AddToList($asfoldersearchlist, $scurrentpath & $sname & "\\")
                    EndIf
                EndSelect
            EndIf
            If $isort Then
                If $bfolder Then
                    If StringRegExp($sname, $sinclude_folder_mask) And Not StringRegExp($sname, $sexclude_folder_mask) Then
                        __FLTAR_AddToList($asfoldermatchlist, $sretpath & $sname & $sfolderslash)
                    EndIf
                Else
                    If StringRegExp($sname, $sinclude_file_mask) And Not StringRegExp($sname, $sexclude_file_mask) Then
                        If $scurrentpath = $sfilepath Then
                            __FLTAR_AddToList($asrootfilematchlist, $sretpath & $sname)
                        Else
                            __FLTAR_AddToList($asfilematchlist, $sretpath & $sname)
                        EndIf
                    EndIf
                EndIf
            Else
                If $bfolder Then
                    If $ireturn <> 0x1 And StringRegExp($sname, $sinclude_folder_mask) And Not StringRegExp($sname, $sexclude_folder_mask) Then
                        __FLTAR_AddToList($asreturnlist, $sretpath & $sname & $sfolderslash)
                    EndIf
                Else
                    If $ireturn <> 0x2 And StringRegExp($sname, $sinclude_file_mask) And Not StringRegExp($sname, $sexclude_file_mask) Then
                        __FLTAR_AddToList($asreturnlist, $sretpath & $sname)
                    EndIf
                EndIf
            EndIf
        WEnd
        If $ihide_link Then
            DllCall($hdll, "int", "FindClose", "ptr", $hsearch)
        Else
            FileClose($hsearch)
        EndIf
    WEnd
    If $ihide_link Then
        DllClose($hdll)
    EndIf
    If $isort Then
        Switch $ireturn
        Case 0x2
            If $asfoldermatchlist[0x0] = 0x0 Then Return SetError(0x1, 0x9, '')
            ReDim $asfoldermatchlist[$asfoldermatchlist[0x0] + 0x1]
            $asreturnlist = $asfoldermatchlist
            __ArrayDualPivotSort($asreturnlist, 0x1, $asreturnlist[0x0])
        Case 0x1
            If $asrootfilematchlist[0x0] = 0x0 And $asfilematchlist[0x0] = 0x0 Then Return SetError(0x1, 0x9, '')
            If $ireturnpath = 0x0 Then
                __FLTAR_AddFileLists($asreturnlist, $asrootfilematchlist, $asfilematchlist)
                __ArrayDualPivotSort($asreturnlist, 0x1, $asreturnlist[0x0])
            Else
                __FLTAR_AddFileLists($asreturnlist, $asrootfilematchlist, $asfilematchlist, 0x1)
            EndIf
        Case 0x0
            If $asrootfilematchlist[0x0] = 0x0 And $asfoldermatchlist[0x0] = 0x0 Then Return SetError(0x1, 0x9, '')
            If $ireturnpath = 0x0 Then
                __FLTAR_AddFileLists($asreturnlist, $asrootfilematchlist, $asfilematchlist)
                $asreturnlist[0x0]+= $asfoldermatchlist[0x0]
                ReDim $asfoldermatchlist[$asfoldermatchlist[0x0] + 0x1]
                _ArrayConcatenate($asreturnlist, $asfoldermatchlist, 0x1)
                __ArrayDualPivotSort($asreturnlist, 0x1, $asreturnlist[0x0])
            Else
                Local $asreturnlist[$asfilematchlist[0x0] + $asrootfilematchlist[0x0] + $asfoldermatchlist[0x0] + 0x1]
                $asreturnlist[0x0] = $asfilematchlist[0x0] + $asrootfilematchlist[0x0] + $asfoldermatchlist[0x0]
                __ArrayDualPivotSort($asrootfilematchlist, 0x1, $asrootfilematchlist[0x0])
                For $i = 0x1 To $asrootfilematchlist[0x0]
                    $asreturnlist[$i] = $asrootfilematchlist[$i]
                Next
                Local $inextinsertionindex = $asrootfilematchlist[0x0] + 0x1
                __ArrayDualPivotSort($asfoldermatchlist, 0x1, $asfoldermatchlist[0x0])
                Local $sfoldertofind = ''
                For $i = 0x1 To $asfoldermatchlist[0x0]
                    $asreturnlist[$inextinsertionindex] = $asfoldermatchlist[$i]
                    $inextinsertionindex += 0x1
                    If $sfolderslash Then
                        $sfoldertofind = $asfoldermatchlist[$i]
                    Else
                        $sfoldertofind = $asfoldermatchlist[$i] & "\\"
                    EndIf
                    Local $ifilesectionendindex = 0x0, $ifilesectionstartindex = 0x0
                    For $j = 0x1 To $asfolderfilesectionlist[0x0][0x0]
                        If $sfoldertofind = $asfolderfilesectionlist[$j][0x0] Then
                            $ifilesectionstartindex = $asfolderfilesectionlist[$j][0x1]
                            If $j = $asfolderfilesectionlist[0x0][0x0] Then
                                $ifilesectionendindex = $asfilematchlist[0x0]
                            Else
                                $ifilesectionendindex = $asfolderfilesectionlist[$j + 0x1][0x1] + -1
                            EndIf
                            If $isort = 0x1 Then
                                __ArrayDualPivotSort($asfilematchlist, $ifilesectionstartindex, $ifilesectionendindex)
                            EndIf
                            For $k = $ifilesectionstartindex To $ifilesectionendindex
                                $asreturnlist[$inextinsertionindex] = $asfilematchlist[$k]
                                $inextinsertionindex += 0x1
                            Next
                            ExitLoop
                        EndIf
                    Next
                Next
            EndIf
        EndSwitch
    Else
        If $asreturnlist[0x0] = 0x0 Then Return SetError(0x1, 0x9, '')
        ReDim $asreturnlist[$asreturnlist[0x0] + 0x1]
    EndIf
    Return $asreturnlist
EndFunc    ; -> _FileListToArrayRec

Func __FLTAR_AddFileLists(ByRef $astarget, $assource_1, $assource_2, $isort = 0x0)
    ReDim $assource_1[$assource_1[0x0] + 0x1]
    If $isort = 0x1 Then __ArrayDualPivotSort($assource_1, 0x1, $assource_1[0x0])
    $astarget = $assource_1
    $astarget[0x0]+= $assource_2[0x0]
    ReDim $assource_2[$assource_2[0x0] + 0x1]
    If $isort = 0x1 Then __ArrayDualPivotSort($assource_2, 0x1, $assource_2[0x0])
    _ArrayConcatenate($astarget, $assource_2, 0x1)
EndFunc    ; -> __FLTAR_AddFileLists

Func __FLTAR_AddToList(ByRef $alist, $vvalue_0, $vvalue_1 = + -1)
    If $vvalue_1 = + -1 Then
        $alist[0x0]+= 0x1
        If UBound($alist) <= $alist[0x0] Then ReDim $alist[UBound($alist) * 0x2]
        $alist[$alist[0x0]] = $vvalue_0
    Else
        $alist[0x0][0x0]+= 0x1
        If UBound($alist) <= $alist[0x0][0x0] Then ReDim $alist[UBound($alist) * 0x2][0x2]
        $alist[$alist[0x0][0x0]][0x0] = $vvalue_0
        $alist[$alist[0x0][0x0]][0x1] = $vvalue_1
    EndIf
EndFunc    ; -> __FLTAR_AddToList

Func __FLTAR_ListToMask(ByRef $smask, $slist)
    If StringRegExp($slist, "\\\\|/|:|\\<|\\>|\\|") Then Return 0x0
    $slist = StringReplace(StringStripWS(StringRegExpReplace($slist, "\\s*;\\s*", ";"), BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)), ";", "|")
    $slist = StringReplace(StringReplace(StringRegExpReplace($slist, "[][$^.{}()+\\-]", "\\\\$0"), "?", "."), "*", ".*?")
    $smask = "(?i)^(" & $slist & ")\\z"
    Return 0x1
EndFunc    ; -> __FLTAR_ListToMask

Func _FilePrint($sfilepath, $ishow = @SW_HIDE)
    Return ShellExecute($sfilepath, '', @WorkingDir, "print", $ishow = Default  ? @SW_HIDE  : $ishow)
EndFunc    ; -> _FilePrint

Func _FileReadToArray($sfilepath, ByRef $vreturn, $IFLAGS = $FRTA_COUNT, $SDELIMITER = '')
    $vreturn = 0x0
    If $IFLAGS = Default Then $IFLAGS = $FRTA_COUNT
    If $SDELIMITER = Default Then $SDELIMITER = ''
    Local $bexpand = True
    If BitAND($IFLAGS, $FRTA_INTARRAYS) Then
        $bexpand = False
        $IFLAGS -= $FRTA_INTARRAYS
    EndIf
    Local $ientire = $STR_CHRSPLIT
    If BitAND($IFLAGS, $FRTA_ENTIRESPLIT) Then
        $ientire = $STR_ENTIRESPLIT
        $IFLAGS -= $FRTA_ENTIRESPLIT
    EndIf
    Local $inocount = 0x0
    If $IFLAGS <> $FRTA_COUNT Then
        $IFLAGS = $FRTA_NOCOUNT
        $inocount = $STR_NOCOUNT
    EndIf
    If $SDELIMITER Then
        Local $alines = FileReadToArray($sfilepath)
        If @error Then Return SetError(@error, 0x0, 0x0)
        Local $idim_1 = UBound($alines) + $IFLAGS
        If $bexpand Then
            Local $idim_2 = UBound(StringSplit($alines[0x0], $SDELIMITER, $ientire + $STR_NOCOUNT))
            Local $atemp_array[$idim_1][$idim_2]
            Local $ifields, $asplit
            For $i = 0x0 To $idim_1 - $IFLAGS + -1
                $asplit = StringSplit($alines[$i], $SDELIMITER, $ientire + $STR_NOCOUNT)
                $ifields = UBound($asplit)
                If $ifields <> $idim_2 Then
                    Return SetError(0x3, 0x0, 0x0)
                EndIf
                For $j = 0x0 To $ifields + -1
                    $atemp_array[$i + $IFLAGS][$j] = $asplit[$j]
                Next
            Next
            If $idim_2 < 0x2 Then Return SetError(0x4, 0x0, 0x0)
            If $IFLAGS Then
                $atemp_array[0x0][0x0] = $idim_1 - $IFLAGS
                $atemp_array[0x0][0x1] = $idim_2
            EndIf
        Else
            Local $atemp_array[$idim_1]
            For $i = 0x0 To $idim_1 - $IFLAGS + -1
                $atemp_array[$i + $IFLAGS] = StringSplit($alines[$i], $SDELIMITER, $ientire + $inocount)
            Next
            If $IFLAGS Then
                $atemp_array[0x0] = $idim_1 - $IFLAGS
            EndIf
        EndIf
        $vreturn = $atemp_array
    Else
        If $IFLAGS Then
            Local $hfileopen = FileOpen($sfilepath, $FO_READ)
            If $hfileopen = + -1 Then Return SetError(0x1, 0x0, 0x0)
            Local $sfileread = FileRead($hfileopen)
            FileClose($hfileopen)
            If StringLen($sfileread) Then
                $vreturn = StringRegExp(@LF & $sfileread, "(?|(\\N+)\\z|(\\N*)(?:\\R))", $STR_REGEXPARRAYGLOBALMATCH)
                $vreturn[0x0] = UBound($vreturn) + -1
            Else
                Return SetError(0x2, 0x0, 0x0)
            EndIf
        Else
            $vreturn = FileReadToArray($sfilepath)
            If @error Then
                $vreturn = 0x0
                Return SetError(@error, 0x0, 0x0)
            EndIf
        EndIf
    EndIf
    Return 0x1
EndFunc    ; -> _FileReadToArray

Func _FileWriteFromArray($sfilepath, Const ByRef $AARRAY, $IBASE = Default, $iubound = Default, $SDELIMITER = "|")
    Local $ireturn = 0x0
    If Not IsArray($AARRAY) Then Return SetError(0x2, 0x0, $ireturn)
    Local $idims = UBound($AARRAY, $UBOUND_DIMENSIONS)
    If $idims > 0x2 Then Return SetError(0x4, 0x0, 0x0)
    Local $ilast = UBound($AARRAY) + -1
    If $iubound = Default Or $iubound > $ilast Then $iubound = $ilast
    If $IBASE < 0x0 Or $IBASE = Default Then $IBASE = 0x0
    If $IBASE > $iubound Then Return SetError(0x5, 0x0, $ireturn)
    If $SDELIMITER = Default Then $SDELIMITER = "|"
    Local $hfileopen = $sfilepath
    If IsString($sfilepath) Then
        $hfileopen = FileOpen($sfilepath, $FO_OVERWRITE)
        If $hfileopen = + -1 Then Return SetError(0x1, 0x0, $ireturn)
    EndIf
    Local $ierror = 0x0
    $ireturn = 0x1
    Switch $idims
    Case 0x1
        For $i = $IBASE To $iubound
            If Not FileWrite($hfileopen, $AARRAY[$i] & @CRLF) Then
                $ierror = 0x3
                $ireturn = 0x0
                ExitLoop
            EndIf
        Next
    Case 0x2
        Local $stemp = ''
        For $i = $IBASE To $iubound
            $stemp = $AARRAY[$i][0x0]
            For $j = 0x1 To UBound($AARRAY, $UBOUND_COLUMNS) + -1
                $stemp &= $SDELIMITER & $AARRAY[$i][$j]
            Next
            If Not FileWrite($hfileopen, $stemp & @CRLF) Then
                $ierror = 0x3
                $ireturn = 0x0
                ExitLoop
            EndIf
        Next
    EndSwitch
    If IsString($sfilepath) Then FileClose($hfileopen)
    Return SetError($ierror, 0x0, $ireturn)
EndFunc    ; -> _FileWriteFromArray

Func _FileWriteLog($slogpath, $slogmsg, $IFLAG = + -1)
    Local $iopenmode = $FO_APPEND
    Local $smsg = @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " : " & $slogmsg
    If $IFLAG = Default Then $IFLAG = + -1
    If $IFLAG <> + -1 Then
        $iopenmode = $FO_OVERWRITE
        $smsg &= @CRLF & FileRead($slogpath)
    EndIf
    Local $hfileopen = $slogpath
    If IsString($slogpath) Then $hfileopen = FileOpen($slogpath, $iopenmode)
    If $hfileopen = + -1 Then Return SetError(0x1, 0x0, 0x0)
    Local $ireturn = FileWriteLine($hfileopen, $smsg)
    If IsString($slogpath) Then $ireturn = FileClose($hfileopen)
    If $IFLAG <> + -1 And Not IsString($slogpath) Then SetExtended(0x1)
    If $ireturn = 0x0 Then Return SetError(0x2, 0x0, 0x0)
    Return $ireturn
EndFunc    ; -> _FileWriteLog

Func _FileWriteToLine($sfilepath, $iline, $stext, $boverwrite = False, $bfill = False)
    If $boverwrite = Default Then $boverwrite = False
    If $bfill = Default Then $bfill = False
    If Not FileExists($sfilepath) Then Return SetError(0x2, 0x0, 0x0)
    If $iline <= 0x0 Then Return SetError(0x4, 0x0, 0x0)
    If Not (IsBool($boverwrite) Or $boverwrite = 0x0 Or $boverwrite = 0x1) Then Return SetError(0x5, 0x0, 0x0)
    If Not IsString($stext) Then
        $stext = String($stext)
        If $stext = '' Then Return SetError(0x6, 0x0, 0x0)
    EndIf
    If Not IsBool($bfill) Then Return SetError(0x7, 0x0, 0x0)
    Local $AARRAY = FileReadToArray($sfilepath)
    If @error Then Local $AARRAY[0x0]
    Local $iubound = UBound($AARRAY) + -1
    If $bfill Then
        If $iubound < $iline Then
            ReDim $AARRAY[$iline]
            $iubound = $iline + -1
        EndIf
    Else
        If ($iubound + 0x1) < $iline Then Return SetError(0x1, 0x0, 0x0)
    EndIf
    $AARRAY[$iline + -1] = ($boverwrite  ? $stext  : $stext & @CRLF & $AARRAY[$iline + -1])
    Local $sdata = ''
    For $i = 0x0 To $iubound
        $sdata &= $AARRAY[$i] & @CRLF
    Next
    $sdata = StringTrimRight($sdata, StringLen(@CRLF))
    Local $hfileopen = FileOpen($sfilepath, FileGetEncoding($sfilepath) + $FO_OVERWRITE)
    If $hfileopen = + -1 Then Return SetError(0x3, 0x0, 0x0)
    FileWrite($hfileopen, $sdata)
    FileClose($hfileopen)
    Return 0x1
EndFunc    ; -> _FileWriteToLine

Func _PathFull($srelativepath, $sbasepath = @WorkingDir)
    If Not $srelativepath Or $srelativepath = "." Then Return $sbasepath
    Local $sfullpath = StringReplace($srelativepath, "/", "\\")
    Local Const $SFULLPATHCONST = $sfullpath
    Local $spath
    Local $brootonly = StringLeft($sfullpath, 0x1) = "\\" And StringMid($sfullpath, 0x2, 0x1) <> "\\"
    If $sbasepath = Default Then $sbasepath = @WorkingDir
    For $i = 0x1 To 0x2
        $spath = StringLeft($sfullpath, 0x2)
        If $spath = "\\\\" Then
            $sfullpath = StringTrimLeft($sfullpath, 0x2)
            Local $nserverlen = StringInStr($sfullpath, "\\") + -1
            $spath = "\\\\" & StringLeft($sfullpath, $nserverlen)
            $sfullpath = StringTrimLeft($sfullpath, $nserverlen)
            ExitLoop
        ElseIf StringRight($spath, 0x1) = ":" Then
            $sfullpath = StringTrimLeft($sfullpath, 0x2)
            ExitLoop
        Else
            $sfullpath = $sbasepath & "\\" & $sfullpath
        EndIf
    Next
    If StringLeft($sfullpath, 0x1) <> "\\" Then
        If StringLeft($SFULLPATHCONST, 0x2) = StringLeft($sbasepath, 0x2) Then
            $sfullpath = $sbasepath & "\\" & $sfullpath
        Else
            $sfullpath = "\\" & $sfullpath
        EndIf
    EndIf
    Local $atemp = StringSplit($sfullpath, "\\")
    Local $apathparts[$atemp[0x0]], $j = 0x0
    For $i = 0x2 To $atemp[0x0]
        If $atemp[$i] = ".." Then
            If $j Then $j -= 0x1
        ElseIf Not ($atemp[$i] = '' And $i <> $atemp[0x0]) And $atemp[$i] <> "." Then
            $apathparts[$j] = $atemp[$i]
            $j += 0x1
        EndIf
    Next
    $sfullpath = $spath
    If Not $brootonly Then
        For $i = 0x0 To $j + -1
            $sfullpath &= "\\" & $apathparts[$i]
        Next
    Else
        $sfullpath &= $SFULLPATHCONST
        If StringInStr($sfullpath, "..") Then $sfullpath = _PathFull($sfullpath)
    EndIf
    Do
        $sfullpath = StringReplace($sfullpath, ".\\", "\\")
    Until @extended = 0x0
    Return $sfullpath
EndFunc    ; -> _PathFull

Func _PathGetRelative($sfrom, $sto)
    If StringRight($sfrom, 0x1) <> "\\" Then $sfrom &= "\\"
    If StringRight($sto, 0x1) <> "\\" Then $sto &= "\\"
    If $sfrom = $sto Then Return SetError(0x1, 0x0, StringTrimRight($sto, 0x1))
    Local $asfrom = StringSplit($sfrom, "\\")
    Local $asto = StringSplit($sto, "\\")
    If $asfrom[0x1] <> $asto[0x1] Then Return SetError(0x2, 0x0, StringTrimRight($sto, 0x1))
    Local $i = 0x2
    Local $idiff = 0x1
    While 0x1
        If $asfrom[$i] <> $asto[$i] Then
            $idiff = $i
            ExitLoop
        EndIf
        $i += 0x1
    WEnd
    $i = 0x1
    Local $srelpath = ''
    For $j = 0x1 To $asto[0x0]
        If $i >= $idiff Then
            $srelpath &= "\\" & $asto[$i]
        EndIf
        $i += 0x1
    Next
    $srelpath = StringTrimLeft($srelpath, 0x1)
    $i = 0x1
    For $j = 0x1 To $asfrom[0x0]
        If $i > $idiff Then
            $srelpath = "..\\" & $srelpath
        EndIf
        $i += 0x1
    Next
    If StringRight($srelpath, 0x1) == "\\" Then $srelpath = StringTrimRight($srelpath, 0x1)
    Return $srelpath
EndFunc    ; -> _PathGetRelative

Func _PathMake($sdrive, $sdir, $sfilename, $sextension)
    If StringLen($sdrive) Then
        If Not (StringLeft($sdrive, 0x2) = "\\\\") Then $sdrive = StringLeft($sdrive, 0x1) & ":"
    EndIf
    If StringLen($sdir) Then
        If Not (StringRight($sdir, 0x1) = "\\") And Not (StringRight($sdir, 0x1) = "/") Then $sdir = $sdir & "\\"
    Else
        $sdir = "\\"
    EndIf
    If StringLen($sdir) Then
        If Not (StringLeft($sdir, 0x1) = "\\") And Not (StringLeft($sdir, 0x1) = "/") Then $sdir = "\\" & $sdir
    EndIf
    If StringLen($sextension) Then
        If Not (StringLeft($sextension, 0x1) = ".") Then $sextension = "." & $sextension
    EndIf
    Return $sdrive & $sdir & $sfilename & $sextension
EndFunc    ; -> _PathMake

Func _PathSplit($sfilepath, ByRef $sdrive, ByRef $sdir, ByRef $sfilename, ByRef $sextension)
    Local $AARRAY = StringRegExp($sfilepath, "^\\h*((?:\\\\\\\\\\?\\\\)*(\\\\\\\\[^\\?\\/\\\\]+|[A-Za-z]:)?(.*[\\/\\\\]\\h*)?((?:[^\\.\\/\\\\]|(?(?=\\.[^\\/\\\\]*\\.)\\.))*)?([^\\/\\\\]*))$", $STR_REGEXPARRAYMATCH)
    If @error Then
        ReDim $AARRAY[0x5]
        $AARRAY[$PATH_ORIGINAL] = $sfilepath
    EndIf
    $sdrive = $AARRAY[$PATH_DRIVE]
    If StringLeft($AARRAY[$PATH_DIRECTORY], 0x1) == "/" Then
        $sdir = StringRegExpReplace($AARRAY[$PATH_DIRECTORY], "\\h*[\\/\\\\]+\\h*", "\\/")
    Else
        $sdir = StringRegExpReplace($AARRAY[$PATH_DIRECTORY], "\\h*[\\/\\\\]+\\h*", "\\\\")
    EndIf
    $AARRAY[$PATH_DIRECTORY] = $sdir
    $sfilename = $AARRAY[$PATH_FILENAME]
    $sextension = $AARRAY[$PATH_EXTENSION]
    Return $AARRAY
EndFunc    ; -> _PathSplit

Func _ReplaceStringInFile($sfilepath, $ssearchstring, $sreplacestring, $icasesensitive = 0x0, $ioccurance = 0x1)
    If StringInStr(FileGetAttrib($sfilepath), "R") Then Return SetError(0x1, 0x0, + -1)
    Local $hfileopen = FileOpen($sfilepath, $FO_READ)
    If $hfileopen = + -1 Then Return SetError(0x2, 0x0, + -1)
    Local $sfileread = FileRead($hfileopen)
    FileClose($hfileopen)
    If $icasesensitive = Default Then $icasesensitive = 0x0
    If $ioccurance = Default Then $ioccurance = 0x1
    $sfileread = StringReplace($sfileread, $ssearchstring, $sreplacestring, 0x1 - $ioccurance, $icasesensitive)
    Local $ireturn = @extended
    If $ireturn Then
        Local $ifileencoding = FileGetEncoding($sfilepath)
        $hfileopen = FileOpen($sfilepath, $ifileencoding + $FO_OVERWRITE)
        If $hfileopen = + -1 Then Return SetError(0x3, 0x0, + -1)
        FileWrite($hfileopen, $sfileread)
        FileClose($hfileopen)
    EndIf
    Return $ireturn
EndFunc    ; -> _ReplaceStringInFile

Func _TempFile($sdirectoryname = @TempDir, $sfileprefix = "~", $sfileextension = ".tmp", $irandomlength = 0x7)
    If $irandomlength = Default Or $irandomlength <= 0x0 Then $irandomlength = 0x7
    If $sdirectoryname = Default Or (Not FileExists($sdirectoryname)) Then $sdirectoryname = @TempDir
    If $sfileextension = Default Then $sfileextension = ".tmp"
    If $sfileprefix = Default Then $sfileprefix = "~"
    If Not FileExists($sdirectoryname) Then $sdirectoryname = @ScriptDir
    $sdirectoryname = StringRegExpReplace($sdirectoryname, "[\\\\/]+$", '')
    $sfileextension = StringRegExpReplace($sfileextension, "^\\.+", '')
    $sfileprefix = StringRegExpReplace($sfileprefix, "[\\\\/:*?""<>|]", '')
    Local $stempname = ''
    Do
        $stempname = ''
        While StringLen($stempname) < $irandomlength
            $stempname &= Chr(Random(0x61, 0x7a, 0x1))
        WEnd
        $stempname = $sdirectoryname & "\\" & $sfileprefix & $stempname & "." & $sfileextension
    Until Not FileExists($stempname)
    Return $stempname
EndFunc    ; -> _TempFile

Global $__g_hwininet_ftp = + -1
Global $__g_hcallback_ftp, $__g_bcallback_ftp = False
Global Const $INTERNET_OPEN_TYPE_DIRECT = 0x1
Global Const $INTERNET_OPEN_TYPE_PRECONFIG = 0x0
Global Const $INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY = 0x4
Global Const $INTERNET_OPEN_TYPE_PROXY = 0x3
Global Const $FTP_TRANSFER_TYPE_UNKNOWN = 0x0
Global Const $FTP_TRANSFER_TYPE_ASCII = 0x1
Global Const $FTP_TRANSFER_TYPE_BINARY = 0x2
Global Const $INTERNET_FLAG_DEFAULT = 0x0
Global Const $INTERNET_FLAG_PASSIVE = 0x8000000
Global Const $INTERNET_FLAG_TRANSFER_ASCII = $FTP_TRANSFER_TYPE_ASCII
Global Const $INTERNET_FLAG_TRANSFER_BINARY = $FTP_TRANSFER_TYPE_BINARY
Global Const $INTERNET_DEFAULT_FTP_PORT = 0x15
Global Const $INTERNET_SERVICE_FTP = 0x1
Global Const $INTERNET_SERVICE_GOPHER = 0x2
Global Const $INTERNET_SERVICE_HTTP = 0x3
Global Const $INTERNET_FLAG_HYPERLINK = 0x400
Global Const $INTERNET_FLAG_NEED_FILE = 0x10
Global Const $INTERNET_FLAG_NO_CACHE_WRITE = 0x4000000
Global Const $INTERNET_FLAG_RELOAD = -2147483648
Global Const $INTERNET_FLAG_RESYNCHRONIZE = 0x800
Global Const $INTERNET_FLAG_ASYNC = 0x10000000
Global Const $INTERNET_FLAG_FROM_CACHE = 0x1000000
Global Const $INTERNET_FLAG_OFFLINE = $INTERNET_FLAG_FROM_CACHE
Global Const $INTERNET_STATUS_CLOSING_CONNECTION = 0x32
Global Const $INTERNET_STATUS_CONNECTION_CLOSED = 0x33
Global Const $INTERNET_STATUS_CONNECTING_TO_SERVER = 0x14
Global Const $INTERNET_STATUS_CONNECTED_TO_SERVER = 0x15
Global Const $INTERNET_STATUS_CTL_RESPONSE_RECEIVED = 0x2a
Global Const $INTERNET_STATUS_INTERMEDIATE_RESPONSE = 0x78
Global Const $INTERNET_STATUS_PREFETCH = 0x2b
Global Const $INTERNET_STATUS_REDIRECT = 0x6e
Global Const $INTERNET_STATUS_REQUEST_COMPLETE = 0x64
Global Const $INTERNET_STATUS_HANDLE_CREATED = 0x3c
Global Const $INTERNET_STATUS_HANDLE_CLOSING = 0x46
Global Const $INTERNET_STATUS_SENDING_REQUEST = 0x1e
Global Const $INTERNET_STATUS_REQUEST_SENT = 0x1f
Global Const $INTERNET_STATUS_RECEIVING_RESPONSE = 0x28
Global Const $INTERNET_STATUS_RESPONSE_RECEIVED = 0x29
Global Const $INTERNET_STATUS_STATE_CHANGE = 0xc8
Global Const $INTERNET_STATUS_RESOLVING_NAME = 0xa
Global Const $INTERNET_STATUS_NAME_RESOLVED = 0xb
Func _FTP_Close($hsession)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $acall = DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $hsession)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, _WinAPI_GetLastError(), 0x0)
    If $__g_bcallback_ftp = True Then DllCallbackFree($__g_hcallback_ftp)
    Return $acall[0x0]
EndFunc    ; -> _FTP_Close

Func _FTP_Command($hftpsession, $sftpcommand, $IFLAGS = $FTP_TRANSFER_TYPE_ASCII, $iexpectresponse = 0x0, $icontext = 0x0)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpcommand = DllCall($__g_hwininet_ftp, "bool", "FtpCommandW", "handle", $hftpsession, "bool", $iexpectresponse, "dword", $IFLAGS, "wstr", $sftpcommand, "dword_ptr", $icontext, "ptr*", 0x0)
    If @error Or $ai_ftpcommand[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return SetError(0x0, $ai_ftpcommand[0x6], $ai_ftpcommand[0x0])
EndFunc    ; -> _FTP_Command

Func _FTP_Connect($hinternetsession, $sservername, $susername, $spassword, $ipassive = 0x0, $iserverport = 0x0, $iservice = $INTERNET_SERVICE_FTP, $IFLAGS = $INTERNET_FLAG_DEFAULT, $fucontext = 0x0)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    If $ipassive == 0x1 Then $IFLAGS = BitOR($IFLAGS, $INTERNET_FLAG_PASSIVE)
    Local $ai_internetconnect = DllCall($__g_hwininet_ftp, "hwnd", "InternetConnectW", "handle", $hinternetsession, "wstr", $sservername, "ushort", $iserverport, "wstr", $susername, "wstr", $spassword, "dword", $iservice, "dword", $IFLAGS, "dword_ptr", $fucontext)
    If @error Or $ai_internetconnect[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_internetconnect[0x0]
EndFunc    ; -> _FTP_Connect

Func _FTP_DecodeInternetStatus($iinternetstatus)
    Switch $iinternetstatus
    Case $INTERNET_STATUS_CLOSING_CONNECTION
        Return "Closing connection ..."
    Case $INTERNET_STATUS_CONNECTION_CLOSED
        Return "Connection closed"
    Case $INTERNET_STATUS_CONNECTING_TO_SERVER
        Return "Connecting to server ..."
    Case $INTERNET_STATUS_CONNECTED_TO_SERVER
        Return "Connected to server"
    Case $INTERNET_STATUS_CTL_RESPONSE_RECEIVED
        Return "CTL esponse received"
    Case $INTERNET_STATUS_INTERMEDIATE_RESPONSE
        Return "Intermediate response"
    Case $INTERNET_STATUS_PREFETCH
        Return "Prefetch"
    Case $INTERNET_STATUS_REDIRECT
        Return "Redirect"
    Case $INTERNET_STATUS_REQUEST_COMPLETE
        Return "Request complete"
    Case $INTERNET_STATUS_HANDLE_CREATED
        Return "Handle created"
    Case $INTERNET_STATUS_HANDLE_CLOSING
        Return "Handle closing ..."
    Case $INTERNET_STATUS_SENDING_REQUEST
        Return "Sending request ..."
    Case $INTERNET_STATUS_REQUEST_SENT
        Return "Request sent"
    Case $INTERNET_STATUS_RECEIVING_RESPONSE
        Return "Receiving response ..."
    Case $INTERNET_STATUS_RESPONSE_RECEIVED
        Return "Response received"
    Case $INTERNET_STATUS_STATE_CHANGE
        Return "State change"
    Case $INTERNET_STATUS_RESOLVING_NAME
        Return "Resolving name ..."
    Case $INTERNET_STATUS_NAME_RESOLVED
        Return "Name resolved"
    Case Else
        Return "UNKNOWN status = " & $iinternetstatus
    EndSwitch
EndFunc    ; -> _FTP_DecodeInternetStatus

Func _FTP_DirCreate($hftpsession, $sremote)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpmakedir = DllCall($__g_hwininet_ftp, "bool", "FtpCreateDirectoryW", "handle", $hftpsession, "wstr", $sremote)
    If @error Or $ai_ftpmakedir[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_ftpmakedir[0x0]
EndFunc    ; -> _FTP_DirCreate

Func _FTP_DirDelete($hftpsession, $sremote)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpdeldir = DllCall($__g_hwininet_ftp, "bool", "FtpRemoveDirectoryW", "handle", $hftpsession, "wstr", $sremote)
    If @error Or $ai_ftpdeldir[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_ftpdeldir[0x0]
EndFunc    ; -> _FTP_DirDelete

Func _FTP_DirGetCurrent($hftpsession)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpgetcurrentdir = DllCall($__g_hwininet_ftp, "bool", "FtpGetCurrentDirectoryW", "handle", $hftpsession, "wstr", '', "dword*", 0x104)
    If @error Or $ai_ftpgetcurrentdir[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_ftpgetcurrentdir[0x2]
EndFunc    ; -> _FTP_DirGetCurrent

Func _FTP_DirPutContents($hftpsession, $slocalfolder, $sremotefolder, $brecursiveput, $icontext = 0x0)
    If StringRight($slocalfolder, 0x1) == "\\" Then $slocalfolder = StringTrimRight($slocalfolder, 0x1)
    Local $hsearch = FileFindFirstFile($slocalfolder & "\\*.*")
    If $hsearch = + -1 Then Return SetError(0x1, 0x0, 0x0)
    Local $sfile
    While 0x1
        $sfile = FileFindNextFile($hsearch)
        If @error Then ExitLoop
        If StringInStr(FileGetAttrib($slocalfolder & "\\" & $sfile), "D") Then
            _FTP_DirCreate($hftpsession, $sremotefolder & "/" & $sfile)
            If $brecursiveput Then
                _FTP_DirPutContents($hftpsession, $slocalfolder & "\\" & $sfile, $sremotefolder & "/" & $sfile, $brecursiveput, $icontext)
            EndIf
        Else
            _FTP_FilePut($hftpsession, $slocalfolder & "\\" & $sfile, $sremotefolder & "/" & $sfile, 0x0, $icontext)
        EndIf
    WEnd
    FileClose($hsearch)
    Return 0x1
EndFunc    ; -> _FTP_DirPutContents

Func _FTP_DirSetCurrent($hftpsession, $sremote)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpsetcurrentdir = DllCall($__g_hwininet_ftp, "bool", "FtpSetCurrentDirectoryW", "handle", $hftpsession, "wstr", $sremote)
    If @error Or $ai_ftpsetcurrentdir[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_ftpsetcurrentdir[0x0]
EndFunc    ; -> _FTP_DirSetCurrent

Func _FTP_FileClose($hftpfile)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $acall = DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $hftpfile)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc    ; -> _FTP_FileClose

Func _FTP_FileDelete($hftpsession, $sremotefile)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpputfile = DllCall($__g_hwininet_ftp, "bool", "FtpDeleteFileW", "handle", $hftpsession, "wstr", $sremotefile)
    If @error Or $ai_ftpputfile[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_ftpputfile[0x0]
EndFunc    ; -> _FTP_FileDelete

Func _FTP_FileGet($hftpsession, $sremotefile, $slocalfile, $bfailifexists = False, $iflagsandattributes = 0x0, $IFLAGS = $FTP_TRANSFER_TYPE_UNKNOWN, $icontext = 0x0)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpgetfile = DllCall($__g_hwininet_ftp, "bool", "FtpGetFileW", "handle", $hftpsession, "wstr", $sremotefile, "wstr", $slocalfile, "bool", $bfailifexists, "dword", $iflagsandattributes, "dword", $IFLAGS, "dword_ptr", $icontext)
    If @error Or $ai_ftpgetfile[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_ftpgetfile[0x0]
EndFunc    ; -> _FTP_FileGet

Func _FTP_FileGetSize($hftpsession, $sfilename)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpgetsizehandle = DllCall($__g_hwininet_ftp, "handle", "FtpOpenFileW", "handle", $hftpsession, "wstr", $sfilename, "dword", $GENERIC_READ, "dword", $INTERNET_FLAG_NO_CACHE_WRITE + $INTERNET_FLAG_TRANSFER_BINARY, "dword_ptr", 0x0)
    If @error Or $ai_ftpgetsizehandle[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Local $ai_ftpgetfilesize = DllCall($__g_hwininet_ftp, "dword", "FtpGetFileSize", "handle", $ai_ftpgetsizehandle[0x0], "dword*", 0x0)
    If @error Or $ai_ftpgetfilesize[0x0] = 0x0 Then
        Local $ilasterror = _WinAPI_GetLastError()
        DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $ai_ftpgetsizehandle[0x0])
        Return SetError(+ -1, $ilasterror, 0x0)
    EndIf
    DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $ai_ftpgetsizehandle[0x0])
    Return _WinAPI_MakeQWord($ai_ftpgetfilesize[0x0], $ai_ftpgetfilesize[0x2])
EndFunc    ; -> _FTP_FileGetSize

Func _FTP_FileOpen($hconnect, $sfilename, $iaccess = $GENERIC_READ, $IFLAGS = $INTERNET_FLAG_TRANSFER_BINARY, $icontext = 0x0)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpopenfile = DllCall($__g_hwininet_ftp, "handle", "FtpOpenFileW", "handle", $hconnect, "wstr", $sfilename, "dword", $iaccess, "dword", $IFLAGS, "dword_ptr", $icontext)
    If @error Or $ai_ftpopenfile[0x0] == 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_ftpopenfile[0x0]
EndFunc    ; -> _FTP_FileOpen

Func _FTP_FilePut($hftpsession, $slocalfile, $sremotefile, $IFLAGS = 0x0, $icontext = 0x0)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpputfile = DllCall($__g_hwininet_ftp, "bool", "FtpPutFileW", "handle", $hftpsession, "wstr", $slocalfile, "wstr", $sremotefile, "dword", $IFLAGS, "dword_ptr", $icontext)
    If @error Or $ai_ftpputfile[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_ftpputfile[0x0]
EndFunc    ; -> _FTP_FilePut

Func _FTP_FileRead($hftpfile, $inumberofbytestoread)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $tbuffer = DllStructCreate("byte[" & $inumberofbytestoread & "]")
    Local $ai_ftpreadfile = DllCall($__g_hwininet_ftp, "bool", "InternetReadFile", "handle", $hftpfile, "struct*", $tbuffer, "dword", $inumberofbytestoread, "dword*", 0x0)
    If @error Then Return SetError(0x1, _WinAPI_GetLastError(), 0x0)
    Local $inumberofbytesread = $ai_ftpreadfile[0x4]
    If $inumberofbytesread == 0x0 And $ai_ftpreadfile[0x0] == 0x1 Then
        Return SetError(+ -1, 0x0, 0x0)
    ElseIf $ai_ftpreadfile[0x0] == 0x0 Then
        Return SetError(0x2, _WinAPI_GetLastError(), 0x0)
    EndIf
    Local $s_fileread
    If $inumberofbytestoread > $inumberofbytesread Then
        $s_fileread = BinaryMid(DllStructGetData($tbuffer, 0x1), 0x1, $inumberofbytesread)
    Else
        $s_fileread = DllStructGetData($tbuffer, 0x1)
    EndIf
    Return SetError(0x0, $inumberofbytesread, $s_fileread)
EndFunc    ; -> _FTP_FileRead

Func _FTP_FileRename($hftpsession, $sexisting, $snew)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftprenamefile = DllCall($__g_hwininet_ftp, "bool", "FtpRenameFileW", "handle", $hftpsession, "wstr", $sexisting, "wstr", $snew)
    If @error Or $ai_ftprenamefile[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_ftprenamefile[0x0]
EndFunc    ; -> _FTP_FileRename

Func _FTP_FileTimeLoHiToStr($ilodword, $ihidword, $ifmt = 0x0)
    Local $tfiletime = DllStructCreate($TAGFILETIME)
    If Not $ilodword And Not $ihidword Then Return SetError(0x1, 0x0, '')
    DllStructSetData($tfiletime, 0x1, $ilodword)
    DllStructSetData($tfiletime, 0x2, $ihidword)
    Local $sdate = _Date_Time_FileTimeToStr($tfiletime, $ifmt)
    Return SetError(@error, @extended, $sdate)
EndFunc    ; -> _FTP_FileTimeLoHiToStr

Func _FTP_FindFileClose($hftpfind)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $ai_ftpputfile = DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $hftpfind)
    If @error Or $ai_ftpputfile[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), '')
    Return $ai_ftpputfile[0x0]
EndFunc    ; -> _FTP_FindFileClose

Func _FTP_FindFileFirst($hftpsession, $sremotepath, ByRef $hftpfind, $IFLAGS = 0x0, $icontext = 0x0)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $t_dllstruct = DllStructCreate($TAGWIN32_FIND_DATA)
    If @error Then Return SetError(+ -3, 0x0, '')
    Local $a_ftpfilelist[0x1]
    $a_ftpfilelist[0x0] = 0x0
    Local $ai_ftpfirstfile = DllCall($__g_hwininet_ftp, "handle", "FtpFindFirstFileW", "handle", $hftpsession, "wstr", $sremotepath, "struct*", $t_dllstruct, "dword", $IFLAGS, "dword_ptr", $icontext)
    If @error Or $ai_ftpfirstfile[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), $ai_ftpfirstfile)
    $hftpfind = $ai_ftpfirstfile[0x0]
    Local $a_ftpfilelist[0xc]
    $a_ftpfilelist[0x0] = 0xb
    $a_ftpfilelist[0x1] = DllStructGetData($t_dllstruct, "dwFileAttributes")
    $a_ftpfilelist[0x2] = DllStructGetData($t_dllstruct, "ftCreationTime", 0x1)
    $a_ftpfilelist[0x3] = DllStructGetData($t_dllstruct, "ftCreationTime", 0x2)
    $a_ftpfilelist[0x4] = DllStructGetData($t_dllstruct, "ftLastAccessTime", 0x1)
    $a_ftpfilelist[0x5] = DllStructGetData($t_dllstruct, "ftLastAccessTime", 0x2)
    $a_ftpfilelist[0x6] = DllStructGetData($t_dllstruct, "ftLastWriteTime", 0x1)
    $a_ftpfilelist[0x7] = DllStructGetData($t_dllstruct, "ftLastWriteTime", 0x2)
    $a_ftpfilelist[0x8] = DllStructGetData($t_dllstruct, "nFileSizeHigh")
    $a_ftpfilelist[0x9] = DllStructGetData($t_dllstruct, "nFileSizeLow")
    $a_ftpfilelist[0xa] = DllStructGetData($t_dllstruct, "cFileName")
    $a_ftpfilelist[0xb] = DllStructGetData($t_dllstruct, "cAlternateFileName")
    Return $a_ftpfilelist
EndFunc    ; -> _FTP_FindFileFirst

Func _FTP_FindFileNext($hftpfind)
    Local $t_dllstruct = DllStructCreate($TAGWIN32_FIND_DATA)
    Local $a_ftpfilelist[0x1]
    $a_ftpfilelist[0x0] = 0x0
    Local $ai_ftpputfile = DllCall($__g_hwininet_ftp, "bool", "InternetFindNextFileW", "handle", $hftpfind, "struct*", $t_dllstruct)
    If @error Or $ai_ftpputfile[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), $a_ftpfilelist)
    Local $a_ftpfilelist[0xc]
    $a_ftpfilelist[0x0] = 0xb
    $a_ftpfilelist[0x1] = DllStructGetData($t_dllstruct, "dwFileAttributes")
    $a_ftpfilelist[0x2] = DllStructGetData($t_dllstruct, "ftCreationTime", 0x1)
    $a_ftpfilelist[0x3] = DllStructGetData($t_dllstruct, "ftCreationTime", 0x2)
    $a_ftpfilelist[0x4] = DllStructGetData($t_dllstruct, "ftLastAccessTime", 0x1)
    $a_ftpfilelist[0x5] = DllStructGetData($t_dllstruct, "ftLastAccessTime", 0x2)
    $a_ftpfilelist[0x6] = DllStructGetData($t_dllstruct, "ftLastWriteTime", 0x1)
    $a_ftpfilelist[0x7] = DllStructGetData($t_dllstruct, "ftLastWriteTime", 0x2)
    $a_ftpfilelist[0x8] = DllStructGetData($t_dllstruct, "nFileSizeHigh")
    $a_ftpfilelist[0x9] = DllStructGetData($t_dllstruct, "nFileSizeLow")
    $a_ftpfilelist[0xa] = DllStructGetData($t_dllstruct, "cFileName")
    $a_ftpfilelist[0xb] = DllStructGetData($t_dllstruct, "cAlternateFileName")
    Return $a_ftpfilelist
EndFunc    ; -> _FTP_FindFileNext

Func _FTP_GetLastResponseInfo(ByRef $ierror, ByRef $smessage)
    Local $ai_lastresponseinfo = DllCall($__g_hwininet_ftp, "bool", "InternetGetLastResponseInfoW", "dword*", 0x0, "wstr", '', "dword*", 0x1000)
    If @error Or $ai_lastresponseinfo[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    $ierror = $ai_lastresponseinfo[0x1]
    $smessage = $ai_lastresponseinfo[0x2]
    Return $ai_lastresponseinfo[0x0]
EndFunc    ; -> _FTP_GetLastResponseInfo

Func _FTP_ListToArray($hftpsession, $ireturntype = 0x0, $IFLAGS = $INTERNET_FLAG_NO_CACHE_WRITE, $icontext = 0x0)
    Local $AARRAY[0x1]
    $AARRAY[0x0] = 0x0
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, $AARRAY)
    $AARRAY = __FTP_ListToArray($hftpsession, $ireturntype, $IFLAGS, 0x0, 0x1, $icontext)
    Return SetError(@error, @extended, $AARRAY)
EndFunc    ; -> _FTP_ListToArray

Func _FTP_ListToArray2D($hftpsession, $ireturntype = 0x0, $IFLAGS = $INTERNET_FLAG_NO_CACHE_WRITE, $icontext = 0x0)
    Local $AARRAY[0x1][0x1]
    $AARRAY[0x0][0x0] = 0x0
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, $AARRAY)
    $AARRAY = __FTP_ListToArray($hftpsession, $ireturntype, $IFLAGS, 0x0, 0x2, $icontext)
    Return SetError(@error, @extended, $AARRAY)
EndFunc    ; -> _FTP_ListToArray2D

Func _FTP_ListToArrayEx($hftpsession, $ireturntype = 0x0, $IFLAGS = $INTERNET_FLAG_NO_CACHE_WRITE, $ifmt = 0x1, $icontext = 0x0)
    Local $AARRAY[0x1][0x1]
    $AARRAY[0x0][0x0] = 0x0
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, $AARRAY)
    $AARRAY = __FTP_ListToArray($hftpsession, $ireturntype, $IFLAGS, $ifmt, 0x6, $icontext)
    Return SetError(@error, @extended, $AARRAY)
EndFunc    ; -> _FTP_ListToArrayEx

Func _FTP_Open($sagent, $iaccesstype = $INTERNET_OPEN_TYPE_DIRECT, $sproxyname = '', $sproxybypass = '', $IFLAGS = 0x0)
    If $__g_hwininet_ftp = + -1 Then __FTP_Init()
    Local $ai_internetopen = DllCall($__g_hwininet_ftp, "handle", "InternetOpenW", "wstr", $sagent, "dword", $iaccesstype, "wstr", $sproxyname, "wstr", $sproxybypass, "dword", $IFLAGS)
    If @error Or $ai_internetopen[0x0] = 0x0 Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Return $ai_internetopen[0x0]
EndFunc    ; -> _FTP_Open

Func _FTP_ProgressDownload($hftpsession, $slocalfile, $sremotefile, $hfunctiontocall = 0x0)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $hfile = FileOpen($slocalfile, $FO_OVERWRITE + $FO_BINARY)
    If $hfile < 0x0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $ai_ftpopenfile = DllCall($__g_hwininet_ftp, "handle", "FtpOpenFileW", "handle", $hftpsession, "wstr", $sremotefile, "dword", $GENERIC_READ, "dword", $FTP_TRANSFER_TYPE_BINARY, "dword_ptr", 0x0)
    If @error Or $ai_ftpopenfile[0x0] = 0x0 Then Return SetError(+ -3, _WinAPI_GetLastError(), 0x0)
    Local $ai_ftpgetfilesize = DllCall($__g_hwininet_ftp, "dword", "FtpGetFileSize", "handle", $ai_ftpopenfile[0x0], "dword*", 0x0)
    If @error Then Return SetError(+ -2, _WinAPI_GetLastError(), 0x0)
    If Not IsFunc($hfunctiontocall) Then ProgressOn("FTP Download", "Downloading " & $slocalfile)
    Local $ilen = _WinAPI_MakeQWord($ai_ftpgetfilesize[0x0], $ai_ftpgetfilesize[0x2])
    Local Const $ICHUNKSIZE = 0x100 * 0x400
    Local $ilast = Mod($ilen, $ICHUNKSIZE)
    Local $iparts = Ceiling($ilen / $ICHUNKSIZE)
    Local $tbuffer = DllStructCreate("byte[" & $ICHUNKSIZE & "]")
    Local $acall, $ai_ftpread, $iout, $iret, $ilasterror
    Local $x = $ICHUNKSIZE
    Local $idone = 0x0
    For $i = 0x1 To $iparts
        If $i = $iparts And $ilast > 0x0 Then
            $x = $ilast
        EndIf
        $ai_ftpread = DllCall($__g_hwininet_ftp, "bool", "InternetReadFile", "handle", $ai_ftpopenfile[0x0], "struct*", $tbuffer, "dword", $x, "dword*", $iout)
        If @error Or $ai_ftpread[0x0] = 0x0 Then
            $ilasterror = _WinAPI_GetLastError()
            $acall = DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $ai_ftpopenfile[0x0])
            FileClose($hfile)
            If Not IsFunc($hfunctiontocall) Then ProgressOff()
            Return SetError(+ -4, $ilasterror, 0x0)
        EndIf
        $iret = FileWrite($hfile, BinaryMid(DllStructGetData($tbuffer, 0x1), 0x1, $ai_ftpread[0x4]))
        If Not $iret Then
            $ilasterror = _WinAPI_GetLastError()
            $acall = DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $ai_ftpopenfile[0x0])
            FileClose($hfile)
            FileDelete($slocalfile)
            If Not IsFunc($hfunctiontocall) Then ProgressOff()
            Return SetError(+ -7, $ilasterror, 0x0)
        EndIf
        $idone += $ai_ftpread[0x4]
        If Not IsFunc($hfunctiontocall) Then
            ProgressSet(($idone / $ilen) * 0x64)
        Else
            $iret = $hfunctiontocall(($idone / $ilen) * 0x64)
            If $iret <= 0x0 Then
                $ilasterror = @error
                $acall = DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $ai_ftpopenfile[0x0])
                FileClose($hfile)
                FileDelete($slocalfile)
                If Not IsFunc($hfunctiontocall) Then ProgressOff()
                Return SetError(+ -6, $ilasterror, $iret)
            EndIf
        EndIf
        Sleep(0xa)
    Next
    FileClose($hfile)
    If Not IsFunc($hfunctiontocall) Then ProgressOff()
    $acall = DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $ai_ftpopenfile[0x0])
    If @error Or Not $acall[0x0] Then
        Return SetError(+ -5, _WinAPI_GetLastError(), 0x0)
    EndIf
    Return 0x1
EndFunc    ; -> _FTP_ProgressDownload

Func _FTP_ProgressUpload($hftpsession, $slocalfile, $sremotefile, $hfunctiontocall = 0x0)
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $hfile = FileOpen($slocalfile, $FO_BINARY)
    If @error Then Return SetError(+ -1, _WinAPI_GetLastError(), 0x0)
    Local $ai_ftpopenfile = DllCall($__g_hwininet_ftp, "handle", "FtpOpenFileW", "handle", $hftpsession, "wstr", $sremotefile, "dword", $GENERIC_WRITE, "dword", $FTP_TRANSFER_TYPE_BINARY, "dword_ptr", 0x0)
    If @error Or $ai_ftpopenfile[0x0] = 0x0 Then Return SetError(+ -3, _WinAPI_GetLastError(), 0x0)
    If Not IsFunc($hfunctiontocall) Then ProgressOn("FTP Upload", "Uploading " & $slocalfile)
    Local $ilen = FileGetSize($slocalfile)
    Local Const $ICHUNKSIZE = 0x100 * 0x400
    Local $ilast = Mod($ilen, $ICHUNKSIZE)
    Local $iparts = Ceiling($ilen / $ICHUNKSIZE)
    Local $tbuffer = DllStructCreate("byte[" & $ICHUNKSIZE & "]")
    Local $acall, $ai_ftpwrite, $iout, $iret, $ilasterror
    Local $x = $ICHUNKSIZE
    Local $idone = 0x0
    For $i = 0x1 To $iparts
        If $i = $iparts And $ilast > 0x0 Then
            $x = $ilast
        EndIf
        DllStructSetData($tbuffer, 0x1, FileRead($hfile, $x))
        $ai_ftpwrite = DllCall($__g_hwininet_ftp, "bool", "InternetWriteFile", "handle", $ai_ftpopenfile[0x0], "struct*", $tbuffer, "dword", $x, "dword*", $iout)
        If @error Or $ai_ftpwrite[0x0] = 0x0 Then
            $ilasterror = _WinAPI_GetLastError()
            $acall = DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $ai_ftpopenfile[0x0])
            FileClose($hfile)
            If Not IsFunc($hfunctiontocall) Then ProgressOff()
            Return SetError(+ -4, $ilasterror, 0x0)
        EndIf
        $idone += $x
        If Not IsFunc($hfunctiontocall) Then
            ProgressSet(($idone / $ilen) * 0x64)
        Else
            $iret = $hfunctiontocall(($idone / $ilen) * 0x64)
            If $iret <= 0x0 Then
                $ilasterror = @error
                $acall = DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $ai_ftpopenfile[0x0])
                DllCall($__g_hwininet_ftp, "bool", "FtpDeleteFileW", "handle", $hftpsession, "wstr", $sremotefile)
                FileClose($hfile)
                If Not IsFunc($hfunctiontocall) Then ProgressOff()
                Return SetError(+ -6, $ilasterror, $iret)
            EndIf
        EndIf
        Sleep(0xa)
    Next
    FileClose($hfile)
    If Not IsFunc($hfunctiontocall) Then ProgressOff()
    $acall = DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $ai_ftpopenfile[0x0])
    If @error Or Not $acall[0x0] Then Return SetError(+ -5, _WinAPI_GetLastError(), 0x0)
    Return 0x1
EndFunc    ; -> _FTP_ProgressUpload

Func _FTP_SetStatusCallback($hinternetsession, $sfunctionname)
    #Au3Stripper_Ignore_Funcs=$sFunctionName
    If $__g_hwininet_ftp = + -1 Then Return SetError(+ -2, 0x0, 0x0)
    Local $hcallback_register = DllCallbackRegister($sfunctionname, "none", "ptr;ptr;dword;ptr;dword")
    If Not $hcallback_register Then Return SetError(+ -1, 0x0, 0x0)
    Local $ah_callbackfunction = DllCall("wininet.dll", "ptr", "InternetSetStatusCallback", "ptr", $hinternetsession, "ulong_ptr", DllCallbackGetPtr($hcallback_register))
    If @error Then Return SetError(+ -3, 0x0, 0x0)
    If $ah_callbackfunction[0x0] = Ptr(+ -1) Then Return SetError(+ -4, 0x0, 0x0)
    $__g_bcallback_ftp = True
    $__g_hcallback_ftp = $hcallback_register
    Return $ah_callbackfunction[0x1]
EndFunc    ; -> _FTP_SetStatusCallback

Func __FTP_ListToArray($hftpsession, $ireturntype, $IFLAGS, $ifmt, $iarraycount, $icontext)
    If $iarraycount = 0x1 Then
        Local $asfilearray[0x1], $adirectoryarray[0x1]
        $asfilearray[0x0] = 0x0
    Else
        Local $asfilearray[0x1][$iarraycount], $adirectoryarray[0x1][$iarraycount]
        $asfilearray[0x0][0x0] = 0x0
    EndIf
    If $ireturntype < 0x0 Or $ireturntype > 0x2 Then Return SetError(0x3, 0x0, $asfilearray)
    Local $twin32_find_data = DllStructCreate($TAGWIN32_FIND_DATA)
    Local $ilasterror
    Local $afindfirstcall = DllCall($__g_hwininet_ftp, "handle", "FtpFindFirstFileW", "handle", $hftpsession, "wstr", '', "struct*", $twin32_find_data, "dword", $IFLAGS, "dword_ptr", $icontext)
    If @error Or Not $afindfirstcall[0x0] Then
        $ilasterror = _WinAPI_GetLastError()
        If $ilasterror = 0x2ee3 Then
            Local $ierror, $smessage
            _FTP_GetLastResponseInfo($ierror, $smessage)
            $ilasterror = $ierror
        EndIf
        Return SetError(0x1, $ilasterror, $asfilearray)
    EndIf
    Local $idirectoryindex = 0x0, $sfileindex = 0x0
    Local $tfiletime, $bisdir, $afindnextcall
    Do
        $bisdir = BitAND(DllStructGetData($twin32_find_data, "dwFileAttributes"), $FILE_ATTRIBUTE_DIRECTORY) = $FILE_ATTRIBUTE_DIRECTORY
        If $bisdir And ($ireturntype <> 0x2) Then
            $idirectoryindex += 0x1
            If $iarraycount = 0x1 Then
                If UBound($adirectoryarray) < $idirectoryindex + 0x1 Then ReDim $adirectoryarray[$idirectoryindex * 0x2]
                $adirectoryarray[$idirectoryindex] = DllStructGetData($twin32_find_data, "cFileName")
            Else
                If UBound($adirectoryarray) < $idirectoryindex + 0x1 Then ReDim $adirectoryarray[$idirectoryindex * 0x2][$iarraycount]
                $adirectoryarray[$idirectoryindex][0x0] = DllStructGetData($twin32_find_data, "cFileName")
                $adirectoryarray[$idirectoryindex][0x1] = _WinAPI_MakeQWord(DllStructGetData($twin32_find_data, "nFileSizeLow"), DllStructGetData($twin32_find_data, "nFileSizeHigh"))
                If $iarraycount = 0x6 Then
                    $adirectoryarray[$idirectoryindex][0x2] = DllStructGetData($twin32_find_data, "dwFileAttributes")
                    $tfiletime = DllStructCreate($TAGFILETIME, DllStructGetPtr($twin32_find_data, "ftLastWriteTime"))
                    $adirectoryarray[$idirectoryindex][0x3] = _Date_Time_FileTimeToStr($tfiletime, $ifmt)
                    $tfiletime = DllStructCreate($TAGFILETIME, DllStructGetPtr($twin32_find_data, "ftCreationTime"))
                    $adirectoryarray[$idirectoryindex][0x4] = _Date_Time_FileTimeToStr($tfiletime, $ifmt)
                    $tfiletime = DllStructCreate($TAGFILETIME, DllStructGetPtr($twin32_find_data, "ftLastAccessTime"))
                    $adirectoryarray[$idirectoryindex][0x5] = _Date_Time_FileTimeToStr($tfiletime, $ifmt)
                EndIf
            EndIf
        ElseIf Not $bisdir And $ireturntype <> 0x1 Then
            $sfileindex += 0x1
            If $iarraycount = 0x1 Then
                If UBound($asfilearray) < $sfileindex + 0x1 Then ReDim $asfilearray[$sfileindex * 0x2]
                $asfilearray[$sfileindex] = DllStructGetData($twin32_find_data, "cFileName")
            Else
                If UBound($asfilearray) < $sfileindex + 0x1 Then ReDim $asfilearray[$sfileindex * 0x2][$iarraycount]
                $asfilearray[$sfileindex][0x0] = DllStructGetData($twin32_find_data, "cFileName")
                $asfilearray[$sfileindex][0x1] = _WinAPI_MakeQWord(DllStructGetData($twin32_find_data, "nFileSizeLow"), DllStructGetData($twin32_find_data, "nFileSizeHigh"))
                If $iarraycount = 0x6 Then
                    $asfilearray[$sfileindex][0x2] = DllStructGetData($twin32_find_data, "dwFileAttributes")
                    $tfiletime = DllStructCreate($TAGFILETIME, DllStructGetPtr($twin32_find_data, "ftLastWriteTime"))
                    $asfilearray[$sfileindex][0x3] = _Date_Time_FileTimeToStr($tfiletime, $ifmt)
                    $tfiletime = DllStructCreate($TAGFILETIME, DllStructGetPtr($twin32_find_data, "ftCreationTime"))
                    $asfilearray[$sfileindex][0x4] = _Date_Time_FileTimeToStr($tfiletime, $ifmt)
                    $tfiletime = DllStructCreate($TAGFILETIME, DllStructGetPtr($twin32_find_data, "ftLastAccessTime"))
                    $asfilearray[$sfileindex][0x5] = _Date_Time_FileTimeToStr($tfiletime, $ifmt)
                EndIf
            EndIf
        EndIf
        $afindnextcall = DllCall($__g_hwininet_ftp, "bool", "InternetFindNextFileW", "handle", $afindfirstcall[0x0], "struct*", $twin32_find_data)
        If @error Then
            $ilasterror = _WinAPI_GetLastError()
            DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $afindfirstcall[0x0])
            Return SetError(0x2, $ilasterror, $asfilearray)
        EndIf
    Until Not $afindnextcall[0x0]
    DllCall($__g_hwininet_ftp, "bool", "InternetCloseHandle", "handle", $afindfirstcall[0x0])
    If $iarraycount = 0x1 Then
        $adirectoryarray[0x0] = $idirectoryindex
        $asfilearray[0x0] = $sfileindex
    Else
        $adirectoryarray[0x0][0x0] = $idirectoryindex
        $asfilearray[0x0][0x0] = $sfileindex
    EndIf
    Switch $ireturntype
    Case 0x0
        If $iarraycount = 0x1 Then
            ReDim $adirectoryarray[$adirectoryarray[0x0] + $asfilearray[0x0] + 0x1]
            For $i = 0x1 To $sfileindex
                $adirectoryarray[$adirectoryarray[0x0] + $i] = $asfilearray[$i]
            Next
            $adirectoryarray[0x0]+= $asfilearray[0x0]
        Else
            ReDim $adirectoryarray[$adirectoryarray[0x0][0x0] + $asfilearray[0x0][0x0] + 0x1][$iarraycount]
            For $i = 0x1 To $sfileindex
                For $j = 0x0 To $iarraycount + -1
                    $adirectoryarray[$adirectoryarray[0x0][0x0] + $i][$j] = $asfilearray[$i][$j]
                Next
            Next
            $adirectoryarray[0x0][0x0]+= $asfilearray[0x0][0x0]
        EndIf
        Return $adirectoryarray
    Case 0x1
        If $iarraycount = 0x1 Then
            ReDim $adirectoryarray[$idirectoryindex + 0x1]
        Else
            ReDim $adirectoryarray[$idirectoryindex + 0x1][$iarraycount]
        EndIf
        Return $adirectoryarray
    Case 0x2
        If $iarraycount = 0x1 Then
            ReDim $asfilearray[$sfileindex + 0x1]
        Else
            ReDim $asfilearray[$sfileindex + 0x1][$iarraycount]
        EndIf
        Return $asfilearray
    EndSwitch
EndFunc    ; -> __FTP_ListToArray

Func __FTP_Init()
    $__g_hwininet_ftp = DllOpen("wininet.dll")
EndFunc    ; -> __FTP_Init

Global Const $GDIP_DASHCAPFLAT = 0x0
Global Const $GDIP_DASHCAPROUND = 0x2
Global Const $GDIP_DASHCAPTRIANGLE = 0x3
Global Const $GDIP_DASHSTYLESOLID = 0x0
Global Const $GDIP_DASHSTYLEDASH = 0x1
Global Const $GDIP_DASHSTYLEDOT = 0x2
Global Const $GDIP_DASHSTYLEDASHDOT = 0x3
Global Const $GDIP_DASHSTYLEDASHDOTDOT = 0x4
Global Const $GDIP_DASHSTYLECUSTOM = 0x5
Global Const $GDIP_EPGCHROMINANCETABLE = "{F2E455DC-09B3-4316-8260-676ADA32481C}"
Global Const $GDIP_EPGCOLORDEPTH = "{66087055-AD66-4C7C-9A18-38A2310B8337}"
Global Const $GDIP_EPGCOMPRESSION = "{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}"
Global Const $GDIP_EPGLUMINANCETABLE = "{EDB33BCE-0266-4A77-B904-27216099E717}"
Global Const $GDIP_EPGQUALITY = "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}"
Global Const $GDIP_EPGRENDERMETHOD = "{6D42C53A-229A-4825-8BB7-5C99E2B9A8B8}"
Global Const $GDIP_EPGSAVEFLAG = "{292266FC-AC40-47BF-8CFC-A85B89A655DE}"
Global Const $GDIP_EPGSCANMETHOD = "{3A4E2661-3109-4E56-8536-42C156E7DCFA}"
Global Const $GDIP_EPGTRANSFORMATION = "{8D0EB2D1-A58E-4EA8-AA14-108074B7B6F9}"
Global Const $GDIP_EPGVERSION = "{24D18C76-814A-41A4-BF53-1C219CCCF797}"
Global Const $GDIP_EPTBYTE = 0x1
Global Const $GDIP_EPTASCII = 0x2
Global Const $GDIP_EPTSHORT = 0x3
Global Const $GDIP_EPTLONG = 0x4
Global Const $GDIP_EPTRATIONAL = 0x5
Global Const $GDIP_EPTLONGRANGE = 0x6
Global Const $GDIP_EPTUNDEFINED = 0x7
Global Const $GDIP_EPTRATIONALRANGE = 0x8
Global Const $GDIP_ERROK = 0x0
Global Const $GDIP_ERRGENERICERROR = 0x1
Global Const $GDIP_ERRINVALIDPARAMETER = 0x2
Global Const $GDIP_ERROUTOFMEMORY = 0x3
Global Const $GDIP_ERROBJECTBUSY = 0x4
Global Const $GDIP_ERRINSUFFICIENTBUFFER = 0x5
Global Const $GDIP_ERRNOTIMPLEMENTED = 0x6
Global Const $GDIP_ERRWIN32ERROR = 0x7
Global Const $GDIP_ERRWRONGSTATE = 0x8
Global Const $GDIP_ERRABORTED = 0x9
Global Const $GDIP_ERRFILENOTFOUND = 0xa
Global Const $GDIP_ERRVALUEOVERFLOW = 0xb
Global Const $GDIP_ERRACCESSDENIED = 0xc
Global Const $GDIP_ERRUNKNOWNIMAGEFORMAT = 0xd
Global Const $GDIP_ERRFONTFAMILYNOTFOUND = 0xe
Global Const $GDIP_ERRFONTSTYLENOTFOUND = 0xf
Global Const $GDIP_ERRNOTTRUETYPEFONT = 0x10
Global Const $GDIP_ERRUNSUPPORTEDGDIVERSION = 0x11
Global Const $GDIP_ERRGDIPLUSNOTINITIALIZED = 0x12
Global Const $GDIP_ERRPROPERTYNOTFOUND = 0x13
Global Const $GDIP_ERRPROPERTYNOTSUPPORTED = 0x14
Global Const $GDIP_EVTCOMPRESSIONLZW = 0x2
Global Const $GDIP_EVTCOMPRESSIONCCITT3 = 0x3
Global Const $GDIP_EVTCOMPRESSIONCCITT4 = 0x4
Global Const $GDIP_EVTCOMPRESSIONRLE = 0x5
Global Const $GDIP_EVTCOMPRESSIONNONE = 0x6
Global Const $GDIP_EVTTRANSFORMROTATE90 = 0xd
Global Const $GDIP_EVTTRANSFORMROTATE180 = 0xe
Global Const $GDIP_EVTTRANSFORMROTATE270 = 0xf
Global Const $GDIP_EVTTRANSFORMFLIPHORIZONTAL = 0x10
Global Const $GDIP_EVTTRANSFORMFLIPVERTICAL = 0x11
Global Const $GDIP_EVTMULTIFRAME = 0x12
Global Const $GDIP_EVTLASTFRAME = 0x13
Global Const $GDIP_EVTFLUSH = 0x14
Global Const $GDIP_EVTFRAMEDIMENSIONPAGE = 0x17
Global Const $GDIP_ICFENCODER = 0x1
Global Const $GDIP_ICFDECODER = 0x2
Global Const $GDIP_ICFSUPPORTBITMAP = 0x4
Global Const $GDIP_ICFSUPPORTVECTOR = 0x8
Global Const $GDIP_ICFSEEKABLEENCODE = 0x10
Global Const $GDIP_ICFBLOCKINGDECODE = 0x20
Global Const $GDIP_ICFBUILTIN = 0x10000
Global Const $GDIP_ICFSYSTEM = 0x20000
Global Const $GDIP_ICFUSER = 0x40000
Global Const $GDIP_ILMREAD = 0x1
Global Const $GDIP_ILMWRITE = 0x2
Global Const $GDIP_ILMUSERINPUTBUF = 0x4
Global Const $GDIP_LINECAPFLAT = 0x0
Global Const $GDIP_LINECAPSQUARE = 0x1
Global Const $GDIP_LINECAPROUND = 0x2
Global Const $GDIP_LINECAPTRIANGLE = 0x3
Global Const $GDIP_LINECAPNOANCHOR = 0x10
Global Const $GDIP_LINECAPSQUAREANCHOR = 0x11
Global Const $GDIP_LINECAPROUNDANCHOR = 0x12
Global Const $GDIP_LINECAPDIAMONDANCHOR = 0x13
Global Const $GDIP_LINECAPARROWANCHOR = 0x14
Global Const $GDIP_LINECAPCUSTOM = 0xff
Global Const $GDIP_PXF01INDEXED = 0x30101
Global Const $GDIP_PXF04INDEXED = 0x30402
Global Const $GDIP_PXF08INDEXED = 0x30803
Global Const $GDIP_PXF16GRAYSCALE = 0x101004
Global Const $GDIP_PXF16RGB555 = 0x21005
Global Const $GDIP_PXF16RGB565 = 0x21006
Global Const $GDIP_PXF16ARGB1555 = 0x61007
Global Const $GDIP_PXF24RGB = 0x21808
Global Const $GDIP_PXF32RGB = 0x22009
Global Const $GDIP_PXF32ARGB = 0x26200a
Global Const $GDIP_PXF32PARGB = 0xe200b
Global Const $GDIP_PXF48RGB = 0x10300c
Global Const $GDIP_PXF64ARGB = 0x34400d
Global Const $GDIP_PXF64PARGB = 0x1a400e
Global Const $GDIP_IMAGEFORMAT_UNDEFINED = "{B96B3CA9-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_MEMORYBMP = "{B96B3CAA-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_BMP = "{B96B3CAB-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_EMF = "{B96B3CAC-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_WMF = "{B96B3CAD-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_JPEG = "{B96B3CAE-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_PNG = "{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_GIF = "{B96B3CB0-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_TIFF = "{B96B3CB1-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_EXIF = "{B96B3CB2-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_ICON = "{B96B3CB5-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGETYPE_UNKNOWN = 0x0
Global Const $GDIP_IMAGETYPE_BITMAP = 0x1
Global Const $GDIP_IMAGETYPE_METAFILE = 0x2
Global Const $GDIP_IMAGEFLAGS_NONE = 0x0
Global Const $GDIP_IMAGEFLAGS_SCALABLE = 0x1
Global Const $GDIP_IMAGEFLAGS_HASALPHA = 0x2
Global Const $GDIP_IMAGEFLAGS_HASTRANSLUCENT = 0x4
Global Const $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE = 0x8
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_RGB = 0x10
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_CMYK = 0x20
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_GRAY = 0x40
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR = 0x80
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_YCCK = 0x100
Global Const $GDIP_IMAGEFLAGS_HASREALDPI = 0x1000
Global Const $GDIP_IMAGEFLAGS_HASREALPIXELSIZE = 0x2000
Global Const $GDIP_IMAGEFLAGS_READONLY = 0x10000
Global Const $GDIP_IMAGEFLAGS_CACHING = 0x20000
Global Const $GDIP_SMOOTHINGMODE_INVALID = + -1
Global Const $GDIP_SMOOTHINGMODE_DEFAULT = 0x0
Global Const $GDIP_SMOOTHINGMODE_HIGHSPEED = 0x1
Global Const $GDIP_SMOOTHINGMODE_HIGHQUALITY = 0x2
Global Const $GDIP_SMOOTHINGMODE_NONE = 0x3
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X4 = 0x4
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS = $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 = 0x5
Global Const $GDIP_RLUM = 0.3086
Global Const $GDIP_GLUM = 0.6094
Global Const $GDIP_BLUM = 0.082
Global Const $GDIP_INTERPOLATIONMODE_INVALID = + -1
Global Const $GDIP_INTERPOLATIONMODE_DEFAULT = 0x0
Global Const $GDIP_INTERPOLATIONMODE_LOWQUALITY = 0x1
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITY = 0x2
Global Const $GDIP_INTERPOLATIONMODE_BILINEAR = 0x3
Global Const $GDIP_INTERPOLATIONMODE_BICUBIC = 0x4
Global Const $GDIP_INTERPOLATIONMODE_NEARESTNEIGHBOR = 0x5
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBILINEAR = 0x6
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC = 0x7
Global Const $GDIP_PIXELOFFSETMODE_INVALID = + -1
Global Const $GDIP_PIXELOFFSETMODE_DEFAULT = 0x0
Global Const $GDIP_PIXELOFFSETMODE_HIGHSPEED = 0x1
Global Const $GDIP_PIXELOFFSETMODE_HIGHQUALITY = 0x2
Global Const $GDIP_PIXELOFFSETMODE_NONE = 0x3
Global Const $GDIP_PIXELOFFSETMODE_HALF = 0x4
Global Const $GDIP_PENSETLINEJOIN_MITER = 0x0
Global Const $GDIP_PENSETLINEJOIN_BEVEL = 0x1
Global Const $GDIP_PENSETLINEJOIN_ROUND = 0x2
Global Const $GDIP_PENSETLINEJOIN_MITERCLIPPED = 0x3
Global Const $GDIP_FILLMODEALTERNATE = 0x0
Global Const $GDIP_FILLMODEWINDING = 0x1
Global Const $GDIP_QUALITYMODEINVALID = + -1
Global Const $GDIP_QUALITYMODEDEFAULT = 0x0
Global Const $GDIP_QUALITYMODELOW = 0x1
Global Const $GDIP_QUALITYMODEHIGH = 0x2
Global Const $GDIP_COMPOSITINGMODESOURCEOVER = 0x0
Global Const $GDIP_COMPOSITINGMODESOURCECOPY = 0x1
Global Const $GDIP_COMPOSITINGQUALITY_DEFAULT = 0x0
Global Const $GDIP_COMPOSITINGQUALITY_HIGHSPEED = 0x1
Global Const $GDIP_COMPOSITINGQUALITY_HIGHQUALITY = 0x2
Global Const $GDIP_COMPOSITINGQUALITY_GAMMACORRECTED = 0x3
Global Const $GDIP_COMPOSITINGQUALITY_ASSUMELINEAR = 0x4
Global Const $GDIP_HATCHSTYLE_HORIZONTAL = 0x0
Global Const $GDIP_HATCHSTYLE_VERTICAL = 0x1
Global Const $GDIP_HATCHSTYLE_FORWARDDIAGONAL = 0x2
Global Const $GDIP_HATCHSTYLE_BACKWARDDIAGONAL = 0x3
Global Const $GDIP_HATCHSTYLE_CROSS = 0x4
Global Const $GDIP_HATCHSTYLE_DIAGONALCROSS = 0x5
Global Const $GDIP_HATCHSTYLE_05PERCENT = 0x6
Global Const $GDIP_HATCHSTYLE_10PERCENT = 0x7
Global Const $GDIP_HATCHSTYLE_20PERCENT = 0x8
Global Const $GDIP_HATCHSTYLE_25PERCENT = 0x9
Global Const $GDIP_HATCHSTYLE_30PERCENT = 0xa
Global Const $GDIP_HATCHSTYLE_40PERCENT = 0xb
Global Const $GDIP_HATCHSTYLE_50PERCENT = 0xc
Global Const $GDIP_HATCHSTYLE_60PERCENT = 0xd
Global Const $GDIP_HATCHSTYLE_70PERCENT = 0xe
Global Const $GDIP_HATCHSTYLE_75PERCENT = 0xf
Global Const $GDIP_HATCHSTYLE_80PERCENT = 0x10
Global Const $GDIP_HATCHSTYLE_90PERCENT = 0x11
Global Const $GDIP_HATCHSTYLE_LIGHTDOWNWARDDIAGONAL = 0x12
Global Const $GDIP_HATCHSTYLE_LIGHTUPWARDDIAGONAL = 0x13
Global Const $GDIP_HATCHSTYLE_DARKDOWNWARDDIAGONAL = 0x14
Global Const $GDIP_HATCHSTYLE_DARKUPWARDDIAGONAL = 0x15
Global Const $GDIP_HATCHSTYLE_WIDEDOWNWARDDIAGONAL = 0x16
Global Const $GDIP_HATCHSTYLE_WIDEUPWARDDIAGONAL = 0x17
Global Const $GDIP_HATCHSTYLE_LIGHTVERTICAL = 0x18
Global Const $GDIP_HATCHSTYLE_LIGHTHORIZONTAL = 0x19
Global Const $GDIP_HATCHSTYLE_NARROWVERTICAL = 0x1a
Global Const $GDIP_HATCHSTYLE_NARROWHORIZONTAL = 0x1b
Global Const $GDIP_HATCHSTYLE_DARKVERTICAL = 0x1c
Global Const $GDIP_HATCHSTYLE_DARKHORIZONTAL = 0x1d
Global Const $GDIP_HATCHSTYLE_DASHEDDOWNWARDDIAGONAL = 0x1e
Global Const $GDIP_HATCHSTYLE_DASHEDUPWARDDIAGONAL = 0x1f
Global Const $GDIP_HATCHSTYLE_DASHEDHORIZONTAL = 0x20
Global Const $GDIP_HATCHSTYLE_DASHEDVERTICAL = 0x21
Global Const $GDIP_HATCHSTYLE_SMALLCONFETTI = 0x22
Global Const $GDIP_HATCHSTYLE_LARGECONFETTI = 0x23
Global Const $GDIP_HATCHSTYLE_ZIGZAG = 0x24
Global Const $GDIP_HATCHSTYLE_WAVE = 0x25
Global Const $GDIP_HATCHSTYLE_DIAGONALBRICK = 0x26
Global Const $GDIP_HATCHSTYLE_HORIZONTALBRICK = 0x27
Global Const $GDIP_HATCHSTYLE_WEAVE = 0x28
Global Const $GDIP_HATCHSTYLE_PLAID = 0x29
Global Const $GDIP_HATCHSTYLE_DIVOT = 0x2a
Global Const $GDIP_HATCHSTYLE_DOTTEDGRID = 0x2b
Global Const $GDIP_HATCHSTYLE_DOTTEDDIAMOND = 0x2c
Global Const $GDIP_HATCHSTYLE_SHINGLE = 0x2d
Global Const $GDIP_HATCHSTYLE_TRELLIS = 0x2e
Global Const $GDIP_HATCHSTYLE_SPHERE = 0x2f
Global Const $GDIP_HATCHSTYLE_SMALLGRID = 0x30
Global Const $GDIP_HATCHSTYLE_SMALLCHECKERBOARD = 0x31
Global Const $GDIP_HATCHSTYLE_LARGECHECKERBOARD = 0x32
Global Const $GDIP_HATCHSTYLE_OUTLINEDDIAMOND = 0x33
Global Const $GDIP_HATCHSTYLE_SOLIDDIAMOND = 0x34
Global Const $GDIP_HATCHSTYLE_TOTAL = 0x35
Global Const $GDIP_HATCHSTYLE_LARGEGRID = $GDIP_HATCHSTYLE_CROSS
Global Const $GDIP_HATCHSTYLE_MIN = $GDIP_HATCHSTYLE_HORIZONTAL
Global Const $GDIP_HATCHSTYLE_MAX = $GDIP_HATCHSTYLE_TOTAL + -1
Global Const $GDIP_BLUREFFECTGUID = "{633C80A4-1843-482b-9EF2-BE2834C5FDD4}"
Global Const $GDIP_SHARPENEFFECTGUID = "{63CBF3EE-C526-402c-8F71-62C540BF5142}"
Global Const $GDIP_COLORMATRIXEFFECTGUID = "{718F2615-7933-40e3-A511-5F68FE14DD74}"
Global Const $GDIP_COLORLUTEFFECTGUID = "{A7CE72A9-0F7F-40d7-B3CC-D0C02D5C3212}"
Global Const $GDIP_BRIGHTNESSCONTRASTEFFECTGUID = "{D3A1DBE1-8EC4-4c17-9F4C-EA97AD1C343D}"
Global Const $GDIP_HUESATURATIONLIGHTNESSEFFECTGUID = "{8B2DD6C3-EB07-4d87-A5F0-7108E26A9C5F}"
Global Const $GDIP_LEVELSEFFECTGUID = "{99C354EC-2A31-4f3a-8C34-17A803B33A25}"
Global Const $GDIP_TINTEFFECTGUID = "{1077AF00-2848-4441-9489-44AD4C2D7A2C}"
Global Const $GDIP_COLORBALANCEEFFECTGUID = "{537E597D-251E-48da-9664-29CA496B70F8}"
Global Const $GDIP_REDEYECORRECTIONEFFECTGUID = "{74D29D05-69A4-4266-9549-3CC52836B632}"
Global Const $GDIP_COLORCURVEEFFECTGUID = "{DD6A0022-58E4-4a67-9D9B-D48EB881A53D}"
Global Const $GDIP_ADJUSTEXPOSURE = 0x0
Global Const $GDIP_ADJUSTDENSITY = 0x1
Global Const $GDIP_ADJUSTCONTRAST = 0x2
Global Const $GDIP_ADJUSTHIGHLIGHT = 0x3
Global Const $GDIP_ADJUSTSHADOW = 0x4
Global Const $GDIP_ADJUSTMIDTONE = 0x5
Global Const $GDIP_ADJUSTWHITESATURATION = 0x6
Global Const $GDIP_ADJUSTBLACKSATURATION = 0x7
Global Const $GDIP_CURVECHANNELALL = 0x0
Global Const $GDIP_CURVECHANNELRED = 0x1
Global Const $GDIP_CURVECHANNELGREEN = 0x2
Global Const $GDIP_CURVECHANNELBLUE = 0x3
Global Const $GDIP_PALETTETYPECUSTOM = 0x0
Global Const $GDIP_PALETTETYPEOPTIMAL = 0x1
Global Const $GDIP_PALETTETYPEFIXEDBW = 0x2
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE8 = 0x3
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE27 = 0x4
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE64 = 0x5
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE125 = 0x6
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE216 = 0x7
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE252 = 0x8
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE256 = 0x9
Global Const $GDIP_PALETTEFLAGSHASALPHA = 0x1
Global Const $GDIP_PALETTEFLAGSGRAYSCALE = 0x2
Global Const $GDIP_PALETTEFLAGSHALFTONE = 0x4
Global Const $GDIP_DITHERTYPENONE = 0x0
Global Const $GDIP_DITHERTYPESOLID = 0x1
Global Const $GDIP_DITHERTYPEORDERED4X4 = 0x2
Global Const $GDIP_DITHERTYPEORDERED8X8 = 0x3
Global Const $GDIP_DITHERTYPEORDERED16X16 = 0x4
Global Const $GDIP_DITHERTYPEORDERED91X91 = 0x5
Global Const $GDIP_DITHERTYPESPIRAL4X4 = 0x6
Global Const $GDIP_DITHERTYPESPIRAL8X8 = 0x7
Global Const $GDIP_DITHERTYPEDUALSPIRAL4X4 = 0x8
Global Const $GDIP_DITHERTYPEDUALSPIRAL8X8 = 0x9
Global Const $GDIP_DITHERTYPEERRORDIFFUSION = 0xa
Global Const $GDIP_DITHERTYPEMAX = 0xa
Global Const $GDIP_HISTOGRAMFORMATARGB = 0x0
Global Const $GDIP_HISTOGRAMFORMATPARGB = 0x1
Global Const $GDIP_HISTOGRAMFORMATRGB = 0x2
Global Const $GDIP_HISTOGRAMFORMATGRAY = 0x3
Global Const $GDIP_HISTOGRAMFORMATB = 0x4
Global Const $GDIP_HISTOGRAMFORMATG = 0x5
Global Const $GDIP_HISTOGRAMFORMATR = 0x6
Global Const $GDIP_HISTOGRAMFORMATA = 0x7
Global Const $GDIP_TEXTRENDERINGHINTSYSTEMDEFAULT = 0x0
Global Const $GDIP_TEXTRENDERINGHINTSINGLEBITPERPIXELGRIDFIT = 0x1
Global Const $GDIP_TEXTRENDERINGHINTSINGLEBITPERPIXEL = 0x2
Global Const $GDIP_TEXTRENDERINGHINTANTIALIASGRIDFIT = 0x3
Global Const $GDIP_TEXTRENDERINGHINTANTIALIAS = 0x4
Global Const $GDIP_TEXTRENDERINGHINTCLEARTYPEGRIDFIT = 0x5
Global Const $GDIP_ROTATENONEFLIPNONE = 0x0
Global Const $GDIP_ROTATE90FLIPNONE = 0x1
Global Const $GDIP_ROTATE180FLIPNONE = 0x2
Global Const $GDIP_ROTATE270FLIPNONE = 0x3
Global Const $GDIP_ROTATENONEFLIPX = 0x4
Global Const $GDIP_ROTATE90FLIPX = 0x5
Global Const $GDIP_ROTATE180FLIPX = 0x6
Global Const $GDIP_ROTATE270FLIPX = 0x7
Global Const $GDIP_ROTATENONEFLIPY = $GDIP_ROTATE180FLIPX
Global Const $GDIP_ROTATE90FLIPY = $GDIP_ROTATE270FLIPX
Global Const $GDIP_ROTATE180FLIPY = $GDIP_ROTATENONEFLIPX
Global Const $GDIP_ROTATE270FLIPY = $GDIP_ROTATE90FLIPX
Global Const $GDIP_ROTATENONEFLIPXY = $GDIP_ROTATE180FLIPNONE
Global Const $GDIP_ROTATE90FLIPXY = $GDIP_ROTATE270FLIPNONE
Global Const $GDIP_ROTATE270FLIPXY = $GDIP_ROTATE90FLIPNONE
Global Const $GDIP_FRAMEDIMENSION_TIME = "{6AEDBD6D-3FB5-418A-83A6-7F45229DC872}"
Global Const $GDIP_FRAMEDIMENSION_RESOLUTION = "{84236F7B-3BD3-428F-8DAB-4EA1439CA315}"
Global Const $GDIP_FRAMEDIMENSION_PAGE = "{7462DC86-6180-4C7E-8E3F-EE7333A7A483}"
Global Const $GDIP_COLORADJUSTTYPE_DEFAULT = 0x0
Global Const $GDIP_COLORADJUSTTYPE_BITMAP = 0x1
Global Const $GDIP_COLORADJUSTTYPE_BRUSH = 0x2
Global Const $GDIP_COLORADJUSTTYPE_PEN = 0x3
Global Const $GDIP_COLORADJUSTTYPE_TEXT = 0x4
Global Const $GDIP_COLORADJUSTTYPE_COUNT = 0x5
Global Const $GDIP_COLORADJUSTTYPE_ANY = 0x6
Global Enum $GDIP_WRAPMODETILE, $GDIP_WRAPMODETILEFLIPX, $GDIP_WRAPMODETILEFLIPY, $GDIP_WRAPMODETILEFLIPXY, $GDIP_WRAPMODECLAMP
#Region Global Variables and Constants
    Global Const $__TAGWINAPICOM_GUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_CLSIDFromProgID($sprogid)
        Local $tguid = DllStructCreate($__TAGWINAPICOM_GUID)
        Local $acall = DllCall("ole32.dll", "long", "CLSIDFromProgID", "wstr", $sprogid, "struct*", $tguid)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        $acall = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", '', "int", 0x27)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_CLSIDFromProgID

    Func _WinAPI_CoInitialize($IFLAGS = 0x0)
        Local $acall = DllCall("ole32.dll", "long", "CoInitializeEx", "ptr", 0x0, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_CoInitialize

    Func _WinAPI_CoTaskMemAlloc($isize)
        Local $acall = DllCall("ole32.dll", "ptr", "CoTaskMemAlloc", "uint_ptr", $isize)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CoTaskMemAlloc

    Func _WinAPI_CoTaskMemFree($pmemory)
        DllCall("ole32.dll", "none", "CoTaskMemFree", "ptr", $pmemory)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_CoTaskMemFree

    Func _WinAPI_CoTaskMemRealloc($pmemory, $isize)
        Local $acall = DllCall("ole32.dll", "ptr", "CoTaskMemRealloc", "ptr", $pmemory, "ulong_ptr", $isize)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CoTaskMemRealloc

    Func _WinAPI_CoUninitialize()
        DllCall("ole32.dll", "none", "CoUninitialize")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_CoUninitialize

    Func _WinAPI_CreateGUID()
        Local $tguid = DllStructCreate($__TAGWINAPICOM_GUID)
        Local $acall = DllCall("ole32.dll", "long", "CoCreateGuid", "struct*", $tguid)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        $acall = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", '', "int", 0x10000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_CreateGUID

    Func _WinAPI_CreateStreamOnHGlobal($hglobal = 0x0, $bdeleteonrelease = True)
        Local $acall = DllCall("ole32.dll", "long", "CreateStreamOnHGlobal", "handle", $hglobal, "bool", $bdeleteonrelease, "ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_CreateStreamOnHGlobal

    Func _WinAPI_GetHGlobalFromStream($pstream)
        Local $acall = DllCall("ole32.dll", "uint", "GetHGlobalFromStream", "ptr", $pstream, "ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetHGlobalFromStream

    Func _WinAPI_ProgIDFromCLSID($sclsid)
        Local $tguid = DllStructCreate($__TAGWINAPICOM_GUID)
        Local $acall = DllCall("ole32.dll", "uint", "CLSIDFromString", "wstr", $sclsid, "struct*", $tguid)
        If @error Or $acall[0x0] Then Return SetError(@error + 0x14, @extended, '')
        $acall = DllCall("ole32.dll", "uint", "ProgIDFromCLSID", "struct*", $tguid, "ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Local $sid = _WinAPI_GetString($acall[0x2])
        _WinAPI_CoTaskMemFree($acall[0x2])
        Return $sid
    EndFunc    ; -> _WinAPI_ProgIDFromCLSID

    Func _WinAPI_ReleaseStream($pstream)
        Local $acall = DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $pstream, "ulong_ptr", 0x8 * (0x1 + @AutoItX64), "uint", 0x4, "ushort", 0x17, "uint", 0x0, "ptr", 0x0, "ptr", 0x0, "str", '')
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ReleaseStream

#EndRegion Public Functions
#Region Global Variables and Constants
    Global Const $TAGBITMAPV4HEADER = "struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPel" & _
        "sPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dw" & _
        "ord bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct"
    Global Const $TAGCOLORADJUSTMENT = "ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;sh" & _
        "ort Brightness;short Colorfulness;short RedGreenTint"
    Global Const $TAGDEVMODE = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;sho" & _
        "rt PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar Form" & _
        "Name[32];ushort Unused1;dword Unused2[3];dword Nup;dword Unused3;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved" & _
        "2;dword PanningWidth;dword PanningHeight"
    Global Const $TAGDEVMODE_DISPLAY = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;" & $TAGPOINT & ";dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword D" & _
        "isplayFlags;dword DisplayFrequency"
    Global Const $TAGDWM_COLORIZATION_PARAMETERS = "dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend"
    Global Const $TAGENHMETAHEADER = "struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Descr" & _
        "iption;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruc" & _
        "t"
    Global Const $TAGEXTLOGPEN = "dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries"
    Global Const $TAGFONTSIGNATURE = "dword fsUsb[4];dword fsCsb[2]"
    Global Const $TAGGLYPHMETRICS = "uint BlackBoxX;uint BlackBoxY;" & $TAGPOINT & ";short CellIncX;short CellIncY"
    Global Const $TAGLOGBRUSH = "uint Style;dword Color;ulong_ptr Hatch"
    Global Const $TAGLOGPEN = "uint Style;dword Width;dword Color"
    Global Const $TAGMAT2 = "short eM11[2];short eM12[2];short eM21[2];short eM22[2]"
    Global Const $TAGNEWTEXTMETRIC = $TAGTEXTMETRIC & ";dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth"
    Global Const $TAGNEWTEXTMETRICEX = $TAGNEWTEXTMETRIC & ";" & $TAGFONTSIGNATURE
    Global Const $TAGPANOSE = "struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte b" & _
        "XHeight;endstruct"
    Global Const $TAGOUTLINETEXTMETRIC = "struct;uint otmSize;" & $TAGTEXTMETRIC & ";byte otmFiller;" & $TAGPANOSE & ";byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint" & _
        " otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSi" & _
        "ze[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int" & _
        " otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct"
    Global Const $TAGPAINTSTRUCT = "hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]"
    Global Const $TAGRGNDATAHEADER = "struct;dword Size;dword Type;dword Count;dword RgnSize;" & $TAGRECT & ";endstruct"
    Global Const $TAGXFORM = "float eM11;float eM12;float eM21;float eM22;float eDx;float eDy"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_AbortPath($hdc)
        Local $acall = DllCall("gdi32.dll", "bool", "AbortPath", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AbortPath

    Func _WinAPI_AddFontMemResourceEx($pdata, $isize)
        Local $acall = DllCall("gdi32.dll", "handle", "AddFontMemResourceEx", "ptr", $pdata, "dword", $isize, "ptr", 0x0, "dword*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return SetExtended($acall[0x4], $acall[0x0])
    EndFunc    ; -> _WinAPI_AddFontMemResourceEx

    Func _WinAPI_AddFontResourceEx($sfont, $IFLAG = 0x0, $bnotify = False)
        Local $acall = DllCall("gdi32.dll", "int", "AddFontResourceExW", "wstr", $sfont, "dword", $IFLAG, "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        If $bnotify Then
            Local Const $WM_FONTCHANGE = 0x1d
            Local Const $HWND_BROADCAST = 0xffff
            DllCall("user32.dll", "lresult", "SendMessage", "hwnd", $HWND_BROADCAST, "uint", $WM_FONTCHANGE, "wparam", 0x0, "lparam", 0x0)
        EndIf
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AddFontResourceEx

    Func _WinAPI_AddIconOverlay($hicon, $hoverlay)
        Local $acall, $hresult = 0x0, $ierror = 0x0
        Local $ahdev[0x2] = [0x0, 0x0]
        Local $tsize = _WinAPI_GetIconDimension($hicon)
        Local $hil = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", DllStructGetData($tsize, 0x1), "int", DllStructGetData($tsize, 0x2), "uint", 0x21, "int", 0x2, "int", 0x2)
        If @error Or Not $hil[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Do
            $ahdev[0x0] = _WinAPI_Create32BitHICON($hicon)
            If @error Then
                $ierror = @error + 0x64
                ExitLoop
            EndIf
            $acall = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hil[0x0], "int", + -1, "handle", $ahdev[0x0])
            If @error Or ($acall[0x0] = + -1) Then
                $ierror = @error + 0xc8
                ExitLoop
            EndIf
            $ahdev[0x1] = _WinAPI_Create32BitHICON($hoverlay)
            If @error Then
                $ierror = @error + 0x12c
                ExitLoop
            EndIf
            $acall = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hil[0x0], "int", + -1, "handle", $ahdev[0x1])
            If @error Or ($acall[0x0] = + -1) Then
                $ierror = @error + 0x190
                ExitLoop
            EndIf
            $acall = DllCall("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $hil[0x0], "int", 0x1, "int", 0x1)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x1f4
                ExitLoop
            EndIf
            $acall = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $hil[0x0], "int", 0x0, "uint", 0x100)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x258
                ExitLoop
            EndIf
            $hresult = $acall[0x0]
        Until 0x1
        DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hil[0x0])
        For $i = 0x0 To 0x1
            If $ahdev[$i] Then
                _WinAPI_DestroyIcon($ahdev[$i])
            EndIf
        Next
        If Not $hresult Then Return SetError($ierror, 0x0, 0x0)
        Return $hresult
    EndFunc    ; -> _WinAPI_AddIconOverlay

    Func _WinAPI_AdjustBitmap($hbitmap, $iwidth, $iheight, $imode = 0x3, $tadjustment = 0x0)
        Local $tobj = DllStructCreate($TAGBITMAP)
        Local $acall = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        If $iwidth = + -1 Then
            $iwidth = DllStructGetData($tobj, "bmWidth")
        EndIf
        If $iheight = + -1 Then
            $iheight = DllStructGetData($tobj, "bmHeight")
        EndIf
        $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", 0x0)
        Local $hdc = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
        Local $hdestdc = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
        Local $hbmp = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hbmp)
        Local $hdestsv = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
        Local $hsrcdc = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hbitmap)
        Local $hsrcsv = $acall[0x0]
        If _WinAPI_SetStretchBltMode($hdestdc, $imode) Then
            Switch $imode
            Case 0x4
                If IsDllStruct($tadjustment) Then
                    If Not _WinAPI_SetColorAdjustment($hdestdc, $tadjustment) Then
                    EndIf
                EndIf
            Case Else
            EndSwitch
        EndIf
        $acall = _WinAPI_StretchBlt($hdestdc, 0x0, 0x0, $iwidth, $iheight, $hsrcdc, 0x0, 0x0, DllStructGetData($tobj, "bmWidth"), DllStructGetData($tobj, "bmHeight"), 0xcc0020)
        DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0x0, "handle", $hdc)
        DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hdestsv)
        DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hsrcsv)
        DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdestdc)
        DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hsrcdc)
        If Not $acall Then Return SetError(0xa, 0x0, 0x0)
        Return $hbmp
    EndFunc    ; -> _WinAPI_AdjustBitmap

    Func _WinAPI_AlphaBlend($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $ialpha, $balpha = False)
        Local $iblend = BitOR(BitShift(Not ($balpha = False), + -24), BitShift(BitAND($ialpha, 0xff), + -16))
        Local $acall = DllCall("gdi32.dll", "bool", "GdiAlphaBlend", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", $iblend)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AlphaBlend

    Func _WinAPI_AngleArc($hdc, $ix, $iy, $iradius, $nstartangle, $nsweepangle)
        Local $acall = DllCall("gdi32.dll", "bool", "AngleArc", "handle", $hdc, "int", $ix, "int", $iy, "dword", $iradius, "float", $nstartangle, "float", $nsweepangle)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AngleArc

    Func _WinAPI_Arc($hdc, $trect, $ixstartarc, $iystartarc, $ixendarc, $iyendarc)
        Local $acall = DllCall("gdi32.dll", "bool", "Arc", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4), "int", $ixstartarc, "int", $iystartarc, "int", $ixendarc, "int", $iyendarc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_Arc

    Func _WinAPI_ArcTo($hdc, $trect, $ixradial1, $iyradial1, $ixradial2, $iyradial2)
        Local $acall = DllCall("gdi32.dll", "bool", "ArcTo", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4), "int", $ixradial1, "int", $iyradial1, "int", $ixradial2, "int", $iyradial2)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ArcTo

    Func _WinAPI_BeginPaint($hwnd, ByRef $tpaintstruct)
        $tpaintstruct = DllStructCreate($TAGPAINTSTRUCT)
        Local $acall = DllCall("user32.dll", "handle", "BeginPaint", "hwnd", $hwnd, "struct*", $tpaintstruct)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BeginPaint

    Func _WinAPI_BeginPath($hdc)
        Local $acall = DllCall("gdi32.dll", "bool", "BeginPath", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BeginPath

    Func _WinAPI_CloseEnhMetaFile($hdc)
        Local $acall = DllCall("gdi32.dll", "handle", "CloseEnhMetaFile", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CloseEnhMetaFile

    Func _WinAPI_CloseFigure($hdc)
        Local $acall = DllCall("gdi32.dll", "bool", "CloseFigure", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CloseFigure

    Func _WinAPI_ColorAdjustLuma($irgb, $ipercent, $bscale = True)
        If $irgb = + -1 Then Return SetError(0xa, 0x0, + -1)
        If $bscale Then
            $ipercent = Floor($ipercent * 0xa)
        EndIf
        Local $acall = DllCall("shlwapi.dll", "dword", "ColorAdjustLuma", "dword", __rgb($irgb), "int", $ipercent, "bool", $bscale)
        If @error Then Return SetError(@error, @extended, + -1)
        Return __rgb($acall[0x0])
    EndFunc    ; -> _WinAPI_ColorAdjustLuma

    Func _WinAPI_ColorHLSToRGB($ihue, $iluminance, $isaturation)
        If Not $isaturation Then $ihue = 0xa0
        Local $acall = DllCall("shlwapi.dll", "dword", "ColorHLSToRGB", "word", $ihue, "word", $iluminance, "word", $isaturation)
        If @error Then Return SetError(@error, @extended, + -1)
        Return __rgb($acall[0x0])
    EndFunc    ; -> _WinAPI_ColorHLSToRGB

    Func _WinAPI_ColorRGBToHLS($irgb, ByRef $ihue, ByRef $iluminance, ByRef $isaturation)
        Local $acall = DllCall("shlwapi.dll", "none", "ColorRGBToHLS", "dword", __rgb($irgb), "word*", 0x0, "word*", 0x0, "word*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        $ihue = $acall[0x2]
        $iluminance = $acall[0x3]
        $isaturation = $acall[0x4]
        Return 0x1
    EndFunc    ; -> _WinAPI_ColorRGBToHLS

    Func _WinAPI_CombineTransform($txform1, $txform2)
        Local $txform = DllStructCreate($TAGXFORM)
        Local $acall = DllCall("gdi32.dll", "bool", "CombineTransform", "struct*", $txform, "struct*", $txform1, "struct*", $txform2)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $txform
    EndFunc    ; -> _WinAPI_CombineTransform

    Func _WinAPI_CompressBitmapBits($hbitmap, ByRef $pbuffer, $icompression = 0x0, $iquality = 0x64)
        If Not __dll("gdiplus.dll") Then Return SetError(0x67, 0x0, 0x0)
        Local $asize[0x2], $icount, $iformat, $ilength, $smime, $acall, $hdc, $hsv, $hmem, $tbits, $tdata, $pdata, $ierror = 0x1
        Local $hsource = 0x0, $himage = 0x0, $htoken = 0x0, $pstream = 0x0, $tparam = 0x0
        Local $tdib = DllStructCreate($TAGDIBSECTION)
        Do
            Switch $icompression
            Case 0x0
                $smime = "image/png"
            Case 0x1
                $smime = "image/jpeg"
            Case Else
                $ierror = 0xa
                ExitLoop
            EndSwitch
            While $hbitmap
                If Not _WinAPI_GetObject($hbitmap, DllStructGetSize($tdib), $tdib) Then
                    $ierror = 0xb
                    ExitLoop 0x2
                EndIf
                If (DllStructGetData($tdib, "bmBitsPixel") = 0x20) And (Not DllStructGetData($tdib, "biCompression")) Then
                    $ierror = 0xc
                    ExitLoop
                EndIf
                If $hsource Then
                    $ierror = 0xd
                    ExitLoop 0x2
                EndIf
                $hsource = _WinAPI_CreateDIB(DllStructGetData($tdib, "bmWidth"), DllStructGetData($tdib, "bmHeight"))
                If Not $hsource Then
                    $ierror = @error + 0x64
                    ExitLoop 0x2
                EndIf
                $hdc = _WinAPI_CreateCompatibleDC(0x0)
                $hsv = _WinAPI_SelectObject($hdc, $hsource)
                If _WinAPI_DrawBitmap($hdc, 0x0, 0x0, $hbitmap) Then
                    $hbitmap = $hsource
                Else
                    $ierror = @error + 0xc8
                    $hbitmap = 0x0
                EndIf
                _WinAPI_SelectObject($hdc, $hsv)
                _WinAPI_DeleteDC($hdc)
            WEnd
            If Not $hbitmap Then
                ExitLoop
            EndIf
            For $i = 0x0 To 0x1
                $asize[$i] = DllStructGetData($tdib, $i + 0x2)
            Next
            $tbits = DllStructCreate("byte[" & ($asize[0x0] * $asize[0x1] * 0x4) & "]")
            If Not _WinAPI_GetBitmapBits($hbitmap, DllStructGetSize($tbits), $tbits) Then
                $ierror = @error + 0x12c
                ExitLoop
            EndIf
            $tdata = DllStructCreate($TAGGDIPSTARTUPINPUT)
            DllStructSetData($tdata, "Version", 0x1)
            $acall = DllCall("gdiplus.dll", "int", "GdiplusStartup", "ulong_ptr*", 0x0, "struct*", $tdata, "ptr", 0x0)
            If @error Or $acall[0x0] Then
                $ierror = @error + 0x190
                ExitLoop
            EndIf
            If _WinAPI_IsAlphaBitmap($hbitmap) Then
                $iformat = 0x26200a
            Else
                $iformat = 0x22009
            EndIf
            $htoken = $acall[0x1]
            $acall = DllCall("gdiplus.dll", "int", "GdipCreateBitmapFromScan0", "int", $asize[0x0], "int", $asize[0x1], "uint", $asize[0x0] * 0x4, "int", $iformat, "struct*", $tbits, "ptr*", 0x0)
            If @error Or $acall[0x0] Then
                $ierror = @error + 0x1f4
                ExitLoop
            EndIf
            $himage = $acall[0x6]
            $acall = DllCall("gdiplus.dll", "int", "GdipGetImageEncodersSize", "uint*", 0x0, "uint*", 0x0)
            If @error Or $acall[0x0] Then
                $ierror = @error + 0x258
                ExitLoop
            EndIf
            $icount = $acall[0x1]
            $tdata = DllStructCreate("byte[" & $acall[0x2] & "]")
            If @error Then
                $ierror = @error + 0x2bc
                ExitLoop
            EndIf
            $pdata = DllStructGetPtr($tdata)
            $acall = DllCall("gdiplus.dll", "int", "GdipGetImageEncoders", "uint", $icount, "uint", $acall[0x2], "struct*", $tdata)
            If @error Or $acall[0x0] Then
                $ierror = @error + 0x320
                ExitLoop
            EndIf
            Local $tcodec, $pencoder = 0x0
            For $i = 0x1 To $icount
                $tcodec = DllStructCreate($TAGGDIPIMAGECODECINFO, $pdata)
                If Not StringInStr(_WinAPI_GetString(DllStructGetData($tcodec, "MimeType")), $smime) Then
                    $pdata += DllStructGetSize($TAGGDIPIMAGECODECINFO)
                Else
                    $pencoder = $pdata
                    $ierror = 0x0
                    ExitLoop
                EndIf
            Next
            If Not $pencoder Then
                $ierror = 0xf
                ExitLoop
            EndIf
            Switch $icompression
            Case 0x0
            Case 0x1
                Local Const $TAGENCODERPARAMETER = "byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue"
                $tparam = DllStructCreate("dword Count;" & $TAGENCODERPARAMETER & ";ulong Quality")
                DllStructSetData($tparam, "Count", 0x1)
                DllStructSetData($tparam, "NumberOfValues", 0x1)
                DllStructSetData($tparam, "Type", 0x4)
                DllStructSetData($tparam, "pValue", DllStructGetPtr($tparam, "Quality"))
                DllStructSetData($tparam, "Quality", $iquality)
                $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}", "ptr", DllStructGetPtr($tparam, 0x2))
                If @error Or $acall[0x0] Then
                    $tparam = 0x0
                EndIf
            EndSwitch
            $pstream = _WinAPI_CreateStreamOnHGlobal()
            $acall = DllCall("gdiplus.dll", "int", "GdipSaveImageToStream", "handle", $himage, "ptr", $pstream, "ptr", $pencoder, "struct*", $tparam)
            If @error Or $acall[0x0] Then
                $ierror = @error + 0x384
                ExitLoop
            EndIf
            $hmem = _WinAPI_GetHGlobalFromStream($pstream)
            $acall = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hmem)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x3e8
                ExitLoop
            EndIf
            $ilength = $acall[0x0]
            $acall = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hmem)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x44c
                ExitLoop
            EndIf
            $pbuffer = __HeapReAlloc($pbuffer, $ilength, 0x1)
            If Not @error Then
                _WinAPI_MoveMemory($pbuffer, $acall[0x0], $ilength)
            Else
                $ierror = @error + 0x514
            EndIf
        Until 0x1
        If $pstream Then
            _WinAPI_ReleaseStream($pstream)
        EndIf
        If $himage Then
            DllCall("gdiplus.dll", "int", "GdipDisposeImage", "handle", $himage)
        EndIf
        If $htoken Then
            DllCall("gdiplus.dll", "none", "GdiplusShutdown", "ulong_ptr", $htoken)
        EndIf
        If $hsource Then
            _WinAPI_DeleteObject($hsource)
        EndIf
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $ilength
    EndFunc    ; -> _WinAPI_CompressBitmapBits

    Func _WinAPI_CopyEnhMetaFile($hemf, $sfilepath = '')
        If Not StringStripWS($sfilepath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sfilepath = Null
        Local $acall = DllCall("gdi32.dll", "handle", "CopyEnhMetaFileW", "handle", $hemf, "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CopyEnhMetaFile

    Func _WinAPI_CopyRect($trect)
        Local $tdata = DllStructCreate($TAGRECT)
        Local $acall = DllCall("user32.dll", "bool", "CopyRect", "struct*", $tdata, "struct*", $trect)
        If @error Or Not $acall[0x0] Then SetError(@error + 0xa, @extended, 0x0)
        Return $tdata
    EndFunc    ; -> _WinAPI_CopyRect

    Func _WinAPI_Create32BitHBITMAP($hicon, $bdib = False, $bdelete = False)
        Local $hbitmap = 0x0
        Local $adib[0x2] = [0x0, 0x0]
        Local $htemp = _WinAPI_Create32BitHICON($hicon)
        If @error Then Return SetError(@error, @extended, 0x0)
        Local $ierror = 0x0
        Do
            Local $ticoninfo = DllStructCreate($TAGICONINFO)
            Local $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $htemp, "struct*", $ticoninfo)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
            For $i = 0x0 To 0x1
                $adib[$i] = DllStructGetData($ticoninfo, $i + 0x4)
            Next
            Local $tbitmap = DllStructCreate($TAGBITMAP)
            If Not _WinAPI_GetObject($adib[0x0], DllStructGetSize($tbitmap), $tbitmap) Then
                $ierror = @error + 0x14
                ExitLoop
            EndIf
            If $bdib Then
                $hbitmap = _WinAPI_CreateDIB(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"))
                Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
                Local $hsv = _WinAPI_SelectObject($hdc, $hbitmap)
                _WinAPI_DrawIconEx($hdc, 0x0, 0x0, $htemp)
                _WinAPI_SelectObject($hdc, $hsv)
                _WinAPI_DeleteDC($hdc)
            Else
                $hbitmap = $adib[0x1]
                $adib[0x1] = 0x0
            EndIf
        Until 0x1
        For $i = 0x0 To 0x1
            If $adib[$i] Then
                _WinAPI_DeleteObject($adib[$i])
            EndIf
        Next
        _WinAPI_DestroyIcon($htemp)
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        If Not $hbitmap Then Return SetError(0xc, 0x0, 0x0)
        If $bdelete Then
            _WinAPI_DestroyIcon($hicon)
        EndIf
        Return $hbitmap
    EndFunc    ; -> _WinAPI_Create32BitHBITMAP

    Func _WinAPI_CreateBitmapIndirect(ByRef $tbitmap)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateBitmapIndirect", "struct*", $tbitmap)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateBitmapIndirect

    Func _WinAPI_CreateBrushIndirect($istyle, $irgb, $ihatch = 0x0)
        Local $tlogbrush = DllStructCreate($TAGLOGBRUSH)
        DllStructSetData($tlogbrush, 0x1, $istyle)
        DllStructSetData($tlogbrush, 0x2, __rgb($irgb))
        DllStructSetData($tlogbrush, 0x3, $ihatch)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateBrushIndirect", "struct*", $tlogbrush)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateBrushIndirect

    Func _WinAPI_CreateColorAdjustment($IFLAGS = 0x0, $iilluminant = 0x0, $igammar = 0x2710, $igammag = 0x2710, $igammab = 0x2710, $iblack = 0x0, $iwhite = 0x2710, $icontrast = 0x0, $ibrightness = 0x0, $icolorfulness = 0x0, $itint = 0x0)
        Local $tca = DllStructCreate($TAGCOLORADJUSTMENT)
        DllStructSetData($tca, 0x1, DllStructGetSize($tca))
        DllStructSetData($tca, 0x2, $IFLAGS)
        DllStructSetData($tca, 0x3, $iilluminant)
        DllStructSetData($tca, 0x4, $igammar)
        DllStructSetData($tca, 0x5, $igammag)
        DllStructSetData($tca, 0x6, $igammab)
        DllStructSetData($tca, 0x7, $iblack)
        DllStructSetData($tca, 0x8, $iwhite)
        DllStructSetData($tca, 0x9, $icontrast)
        DllStructSetData($tca, 0xa, $ibrightness)
        DllStructSetData($tca, 0xb, $icolorfulness)
        DllStructSetData($tca, 0xc, $itint)
        Return $tca
    EndFunc    ; -> _WinAPI_CreateColorAdjustment

    Func _WinAPI_CreateCompatibleBitmapEx($hdc, $iwidth, $iheight, $irgb)
        Local $hbrush = _WinAPI_CreateBrushIndirect(0x0, $irgb)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
        Local $hdestdc = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
        Local $hbmp = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hbmp)
        Local $hdestsv = $acall[0x0]
        Local $trect = _WinAPI_CreateRectEx(0x0, 0x0, $iwidth, $iheight)
        Local $ierror = 0x0
        $acall = DllCall("user32.dll", "int", "FillRect", "handle", $hdestdc, "struct*", $trect, "handle", $hbrush)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0xa
            _WinAPI_DeleteObject($hbmp)
        EndIf
        _WinAPI_DeleteObject($hbrush)
        DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hdestsv)
        DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdestdc)
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $hbmp
    EndFunc    ; -> _WinAPI_CreateCompatibleBitmapEx

    Func _WinAPI_CreateDIBitmap($hdc, ByRef $tbitmapinfo, $iusage, $pbits = 0x0)
        Local $iinit = 0x0
        If $pbits Then
            $iinit = 0x4
        EndIf
        Local $acall = DllCall("gdi32.dll", "handle", "CreateDIBitmap", "handle", $hdc, "struct*", $tbitmapinfo, "dword", $iinit, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateDIBitmap

    Func _WinAPI_CreateEllipticRgn($trect)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateEllipticRgnIndirect", "struct*", $trect)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateEllipticRgn

    Func _WinAPI_CreateEnhMetaFile($hdc = 0x0, $trect = 0x0, $bpixels = False, $sfilepath = '', $sdescription = '')
        If Not StringStripWS($sfilepath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sfilepath = Null
        Local $tdata = 0x0, $ADATA = StringSplit($sdescription, "|", $STR_NOCOUNT)
        If UBound($ADATA) < 0x2 Then
            ReDim $ADATA[0x2]
            $ADATA[0x1] = ''
        EndIf
        For $i = 0x0 To 0x1
            $ADATA[$i] = StringStripWS($ADATA[$i], $STR_STRIPLEADING + $STR_STRIPTRAILING)
        Next
        If ($ADATA[0x0]) Or ($ADATA[0x1]) Then
            $tdata = _WinAPI_ArrayToStruct($ADATA)
        EndIf
        Local $ixp, $iyp, $ixm, $iym, $href = 0x0
        If $bpixels And (IsDllStruct($trect)) Then
            If Not $hdc Then
                $href = _WinAPI_GetDC(0x0)
            EndIf
            $ixp = _WinAPI_GetDeviceCaps($href, 0x8)
            $iyp = _WinAPI_GetDeviceCaps($href, 0xa)
            $ixm = _WinAPI_GetDeviceCaps($href, 0x4)
            $iym = _WinAPI_GetDeviceCaps($href, 0x6)
            If $href Then
                _WinAPI_ReleaseDC(0x0, $href)
            EndIf
            For $i = 0x1 To 0x3 Step 0x2
                DllStructSetData($trect, $i, Round(DllStructGetData($trect, $i) * $ixm / $ixp * 0x64))
            Next
            For $i = 0x2 To 0x4 Step 0x2
                DllStructSetData($trect, $i, Round(DllStructGetData($trect, $i) * $iym / $iyp * 0x64))
            Next
        EndIf
        Local $acall = DllCall("gdi32.dll", "handle", "CreateEnhMetaFileW", "handle", $hdc, "wstr", $sfilepath, "struct*", $trect, "struct*", $tdata)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateEnhMetaFile

    Func _WinAPI_CreateFontEx($iheight, $iwidth = 0x0, $iescapement = 0x0, $iorientation = 0x0, $iweight = 0x190, $bitalic = False, $bunderline = False, $bstrikeout = False, $icharset = 0x1, $ioutprecision = 0x0, $iclipprecision = 0x0, $iquality = 0x0, $ipitchandfamily = 0x0, $sfacename = '', $istyle = 0x0)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iheight, "int", $iwidth, "int", $iescapement, "int", $iorientation, "int", $iweight, "dword", $bitalic, "dword", $bunderline, "dword", $bstrikeout, "dword", $icharset, "dword", $ioutprecision, "dword", $iclipprecision, "dword", $iquality, "dword", $ipitchandfamily, "wstr", _WinAPI_GetFontName($sfacename, $istyle, $icharset))
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateFontEx

    Func _WinAPI_CreateNullRgn()
        Local $acall = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", 0x0, "int", 0x0, "int", 0x0, "int", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateNullRgn

    Func _WinAPI_CreatePen($ipenstyle, $iwidth, $icolor)
        Local $acall = DllCall("gdi32.dll", "handle", "CreatePen", "int", $ipenstyle, "int", $iwidth, "INT", $icolor)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreatePen

    Func _WinAPI_CreatePolygonRgn(Const ByRef $APOINT, $istart = 0x0, $IEND = + -1, $imode = 0x1)
        If __CheckErrorArrayBounds($APOINT, $istart, $IEND, 0x2, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $tagstruct = ''
        For $i = $istart To $IEND
            $tagstruct &= "int[2];"
        Next
        Local $tdata = DllStructCreate($tagstruct)
        Local $icount = 0x1
        For $i = $istart To $IEND
            For $j = 0x0 To 0x1
                DllStructSetData($tdata, $icount, $APOINT[$i][$j], $j + 0x1)
            Next
            $icount += 0x1
        Next
        Local $acall = DllCall("gdi32.dll", "handle", "CreatePolygonRgn", "struct*", $tdata, "int", $icount + -1, "int", $imode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreatePolygonRgn

    Func _WinAPI_CreateRectRgnIndirect($trect)
        Local $acall = DllCall("gdi32.dll", "handle", "CreateRectRgnIndirect", "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateRectRgnIndirect

    Func _WinAPI_CreateSolidBitmap($hwnd, $icolor, $iwidth, $iheight, $brgb = 0x1)
        Local $hdc = _WinAPI_GetDC($hwnd)
        Local $hdestdc = _WinAPI_CreateCompatibleDC($hdc)
        Local $hbitmap = _WinAPI_CreateCompatibleBitmap($hdc, $iwidth, $iheight)
        Local $hold = _WinAPI_SelectObject($hdestdc, $hbitmap)
        Local $trect = DllStructCreate($TAGRECT)
        DllStructSetData($trect, 0x1, 0x0)
        DllStructSetData($trect, 0x2, 0x0)
        DllStructSetData($trect, 0x3, $iwidth)
        DllStructSetData($trect, 0x4, $iheight)
        If $brgb Then
            $icolor = BitOR(BitAND($icolor, 0xff00), BitShift(BitAND($icolor, 0xff), + -16), BitShift(BitAND($icolor, 0xff0000), 0x10))
        EndIf
        Local $hbrush = _WinAPI_CreateSolidBrush($icolor)
        If Not _WinAPI_FillRect($hdestdc, $trect, $hbrush) Then
            _WinAPI_DeleteObject($hbitmap)
            $hbitmap = 0x0
        EndIf
        _WinAPI_DeleteObject($hbrush)
        _WinAPI_ReleaseDC($hwnd, $hdc)
        _WinAPI_SelectObject($hdestdc, $hold)
        _WinAPI_DeleteDC($hdestdc)
        If Not $hbitmap Then Return SetError(0x1, 0x0, 0x0)
        Return $hbitmap
    EndFunc    ; -> _WinAPI_CreateSolidBitmap

    Func _WinAPI_CreateTransform($nm11 = 0x1, $nm12 = 0x0, $nm21 = 0x0, $nm22 = 0x1, $ndx = 0x0, $ndy = 0x0)
        Local $txform = DllStructCreate($TAGXFORM)
        DllStructSetData($txform, 0x1, $nm11)
        DllStructSetData($txform, 0x2, $nm12)
        DllStructSetData($txform, 0x3, $nm21)
        DllStructSetData($txform, 0x4, $nm22)
        DllStructSetData($txform, 0x5, $ndx)
        DllStructSetData($txform, 0x6, $ndy)
        Return $txform
    EndFunc    ; -> _WinAPI_CreateTransform

    Func _WinAPI_DeleteEnhMetaFile($hemf)
        Local $acall = DllCall("gdi32.dll", "bool", "DeleteEnhMetaFile", "handle", $hemf)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DeleteEnhMetaFile

    Func _WinAPI_DPtoLP($hdc, ByRef $tpoint, $icount = 0x1)
        Local $acall = DllCall("gdi32.dll", "bool", "DPtoLP", "handle", $hdc, "struct*", $tpoint, "int", $icount)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DPtoLP

    Func _WinAPI_DrawAnimatedRects($hwnd, $trectfrom, $trectto)
        Local $acall = DllCall("user32.dll", "bool", "DrawAnimatedRects", "hwnd", $hwnd, "int", 0x3, "struct*", $trectfrom, "struct*", $trectto)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DrawAnimatedRects

    Func _WinAPI_DrawBitmap($hdc, $ix, $iy, $hbitmap, $irop = 0xcc0020)
        Local $tobj = DllStructCreate($TAGBITMAP)
        Local $acall = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", 0x0)
        Local $_hdc = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $_hdc)
        Local $hsrcdc = $acall[0x0]
        $acall = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hbitmap)
        Local $hsrcsv = $acall[0x0]
        Local $ierror = 0x0
        $acall = DllCall("gdi32.dll", "int", "BitBlt", "hwnd", $hdc, "int", $ix, "int", $iy, "int", DllStructGetData($tobj, "bmWidth"), "int", DllStructGetData($tobj, "bmHeight"), "hwnd", $hsrcdc, "int", 0x0, "int", 0x0, "int", $irop)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x1
        EndIf
        DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0x0, "handle", $_hdc)
        DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hsrcsv)
        DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hsrcdc)
        If $ierror Then Return SetError(0xa, 0x0, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DrawBitmap

    Func _WinAPI_DrawFocusRect($hdc, $trect)
        Local $acall = DllCall("user32.dll", "bool", "DrawFocusRect", "handle", $hdc, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DrawFocusRect

    Func _WinAPI_DrawLine($hdc, $ix1, $iy1, $ix2, $iy2)
        _WinAPI_MoveTo($hdc, $ix1, $iy1)
        If @error Then Return SetError(@error, @extended, False)
        _WinAPI_LineTo($hdc, $ix2, $iy2)
        If @error Then Return SetError(@error + 0xa, @extended, False)
        Return True
    EndFunc    ; -> _WinAPI_DrawLine

    Func _WinAPI_DrawShadowText($hdc, $stext, $irgbtext, $irgbshadow, $ixoffset = 0x0, $iyoffset = 0x0, $trect = 0x0, $IFLAGS = 0x0)
        Local $acall
        If Not IsDllStruct($trect) Then
            $trect = DllStructCreate($TAGRECT)
            $acall = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", _WinAPI_WindowFromDC($hdc), "struct*", $trect)
            If @error Then Return SetError(@error + 0xa, @extended, 0x0)
            If Not $acall[0x0] Then Return SetError(0xa, 0x0, 0x0)
        EndIf
        $acall = DllCall("comctl32.dll", "int", "DrawShadowText", "handle", $hdc, "wstr", $stext, "uint", + -1, "struct*", $trect, "dword", $IFLAGS, "int", __rgb($irgbtext), "int", __rgb($irgbshadow), "int", $ixoffset, "int", $iyoffset)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DrawShadowText

    Func _WinAPI_DwmDefWindowProc($hwnd, $imsg, $wparam, $lparam)
        Local $acall = DllCall("dwmapi.dll", "bool", "DwmDefWindowProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam, "lresult*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_DwmDefWindowProc

    Func _WinAPI_DwmEnableBlurBehindWindow($hwnd, $benable = True, $btransition = False, $hrgn = 0x0)
        Local $tblurbehind = DllStructCreate("dword;bool;handle;bool")
        Local $IFLAGS = 0x0
        If $hrgn Then
            $IFLAGS += 0x2
            DllStructSetData($tblurbehind, 0x3, $hrgn)
        EndIf
        DllStructSetData($tblurbehind, 0x1, BitOR($IFLAGS, 0x5))
        DllStructSetData($tblurbehind, 0x2, $benable)
        DllStructSetData($tblurbehind, 0x4, $btransition)
        Local $acall = DllCall("dwmapi.dll", "long", "DwmEnableBlurBehindWindow", "hwnd", $hwnd, "struct*", $tblurbehind)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DwmEnableBlurBehindWindow

    Func _WinAPI_DwmEnableComposition($benable)
        If $benable Then $benable = 0x1
        Local $acall = DllCall("dwmapi.dll", "long", "DwmEnableComposition", "uint", $benable)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DwmEnableComposition

    Func _WinAPI_DwmExtendFrameIntoClientArea($hwnd, $tmargins = 0x0)
        If Not IsDllStruct($tmargins) Then
            $tmargins = _WinAPI_CreateMargins(+ -1, + -1, + -1, + -1)
        EndIf
        Local $acall = DllCall("dwmapi.dll", "long", "DwmExtendFrameIntoClientArea", "hwnd", $hwnd, "struct*", $tmargins)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DwmExtendFrameIntoClientArea

    Func _WinAPI_DwmGetColorizationColor()
        Local $acall = DllCall("dwmapi.dll", "long", "DwmGetColorizationColor", "dword*", 0x0, "bool*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return SetExtended($acall[0x2], $acall[0x1])
    EndFunc    ; -> _WinAPI_DwmGetColorizationColor

    Func _WinAPI_DwmGetColorizationParameters()
        Local $tdwmcp = DllStructCreate($TAGDWM_COLORIZATION_PARAMETERS)
        Local $acall = DllCall("dwmapi.dll", "uint", 0x7f, "struct*", $tdwmcp)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $tdwmcp
    EndFunc    ; -> _WinAPI_DwmGetColorizationParameters

    Func _WinAPI_DwmGetWindowAttribute($hwnd, $iattribute)
        Local $tagstruct
        Switch $iattribute
        Case 0x5, 0x9
            $tagstruct = $TAGRECT
        Case 0x1
            $tagstruct = "uint"
        Case Else
            Return SetError(0xb, 0x0, 0x0)
        EndSwitch
        Local $tdata = DllStructCreate($tagstruct)
        Local $acall = DllCall("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $hwnd, "dword", $iattribute, "struct*", $tdata, "dword", DllStructGetSize($tdata))
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Switch $iattribute
        Case 0x1
            Return DllStructGetData($tdata, 0x1)
        Case Else
            Return $tdata
        EndSwitch
    EndFunc    ; -> _WinAPI_DwmGetWindowAttribute

    Func _WinAPI_DwmInvalidateIconicBitmaps($hwnd)
        Local $acall = DllCall("dwmapi.dll", "long", "DwmInvalidateIconicBitmaps", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DwmInvalidateIconicBitmaps

    Func _WinAPI_DwmIsCompositionEnabled()
        Local $acall = DllCall("dwmapi.dll", "long", "DwmIsCompositionEnabled", "bool*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_DwmIsCompositionEnabled

    Func _WinAPI_DwmQueryThumbnailSourceSize($hthumbnail)
        Local $tsize = DllStructCreate($TAGSIZE)
        Local $acall = DllCall("dwmapi.dll", "long", "DwmQueryThumbnailSourceSize", "handle", $hthumbnail, "struct*", $tsize)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $tsize
    EndFunc    ; -> _WinAPI_DwmQueryThumbnailSourceSize

    Func _WinAPI_DwmRegisterThumbnail($hdestination, $hsource)
        Local $acall = DllCall("dwmapi.dll", "long", "DwmRegisterThumbnail", "hwnd", $hdestination, "hwnd", $hsource, "handle*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_DwmRegisterThumbnail

    Func _WinAPI_DwmSetColorizationParameters($tdwmcp)
        Local $acall = DllCall("dwmapi.dll", "uint", 0x83, "struct*", $tdwmcp, "uint", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DwmSetColorizationParameters

    Func _WinAPI_DwmSetIconicLivePreviewBitmap($hwnd, $hbitmap, $bframe = False, $tclient = 0x0)
        Local $IFLAGS
        If $bframe Then
            $IFLAGS = 0x1
        Else
            $IFLAGS = 0x0
        EndIf
        Local $acall = DllCall("dwmapi.dll", "uint", "DwmSetIconicLivePreviewBitmap", "hwnd", $hwnd, "handle", $hbitmap, "struct*", $tclient, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DwmSetIconicLivePreviewBitmap

    Func _WinAPI_DwmSetIconicThumbnail($hwnd, $hbitmap, $bframe = False)
        Local $IFLAGS
        If $bframe Then
            $IFLAGS = 0x1
        Else
            $IFLAGS = 0x0
        EndIf
        Local $acall = DllCall("dwmapi.dll", "long", "DwmSetIconicThumbnail", "hwnd", $hwnd, "handle", $hbitmap, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DwmSetIconicThumbnail

    Func _WinAPI_DwmSetWindowAttribute($hwnd, $iattribute, $idata)
        Switch $iattribute
        Case 0x2, 0x3, 0x4, 0x6, 0x7, 0x8, 0xa, 0xb, 0xc
        Case Else
            Return SetError(0x1, 0x0, 0x0)
        EndSwitch
        Local $acall = DllCall("dwmapi.dll", "long", "DwmSetWindowAttribute", "hwnd", $hwnd, "dword", $iattribute, "dword*", $idata, "dword", 0x4)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DwmSetWindowAttribute

    Func _WinAPI_DwmUnregisterThumbnail($hthumbnail)
        Local $acall = DllCall("dwmapi.dll", "long", "DwmUnregisterThumbnail", "handle", $hthumbnail)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DwmUnregisterThumbnail

    Func _WinAPI_DwmUpdateThumbnailProperties($hthumbnail, $BVISIBLE = True, $bclientareaonly = False, $iopacity = 0xff, $trectdest = 0x0, $trectsrc = 0x0)
        Local Const $TAGDWM_THUMBNAIL_PROPERTIES = "struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct"
        Local $tthumbnailproperties = DllStructCreate($TAGDWM_THUMBNAIL_PROPERTIES)
        Local $tsize, $IFLAGS = 0x0
        If Not IsDllStruct($trectdest) Then
            $tsize = _WinAPI_DwmQueryThumbnailSourceSize($hthumbnail)
            If @error Then
                Return SetError(@error + 0xa, @extended, 0x0)
            EndIf
            $trectdest = _WinAPI_CreateRectEx(0x0, 0x0, DllStructGetData($tsize, 0x1), DllStructGetData($tsize, 0x2))
        EndIf
        For $i = 0x1 To 0x4
            DllStructSetData($tthumbnailproperties, 0x2, DllStructGetData($trectdest, $i), $i)
        Next
        If IsDllStruct($trectsrc) Then
            $IFLAGS += 0x2
            For $i = 0x1 To 0x4
                DllStructSetData($tthumbnailproperties, 0x3, DllStructGetData($trectsrc, $i), $i)
            Next
        EndIf
        DllStructSetData($tthumbnailproperties, 0x1, BitOR($IFLAGS, 0x1d))
        DllStructSetData($tthumbnailproperties, 0x4, $iopacity)
        DllStructSetData($tthumbnailproperties, 0x5, $BVISIBLE)
        DllStructSetData($tthumbnailproperties, 0x6, $bclientareaonly)
        Local $acall = DllCall("dwmapi.dll", "long", "DwmUpdateThumbnailProperties", "handle", $hthumbnail, "struct*", $tthumbnailproperties)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DwmUpdateThumbnailProperties

    Func _WinAPI_Ellipse($hdc, $trect)
        Local $acall = DllCall("gdi32.dll", "bool", "Ellipse", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4))
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_Ellipse

    Func _WinAPI_EndPaint($hwnd, ByRef $tpaintstruct)
        Local $acall = DllCall("user32.dll", "bool", "EndPaint", "hwnd", $hwnd, "struct*", $tpaintstruct)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_EndPaint

    Func _WinAPI_EndPath($hdc)
        Local $acall = DllCall("gdi32.dll", "bool", "EndPath", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_EndPath

    Func _WinAPI_EnumDisplayMonitors($hdc = 0x0, $trect = 0x0)
        Local $henumproc = DllCallbackRegister("__EnumDisplayMonitorsProc", "bool", "handle;handle;ptr;lparam")
        Dim $__g_venum[0x65][0x2] = [[0x0]]
        Local $acall = DllCall("user32.dll", "bool", "EnumDisplayMonitors", "handle", $hdc, "struct*", $trect, "ptr", DllCallbackGetPtr($henumproc), "lparam", 0x0)
        If @error Or Not $acall[0x0] Or Not $__g_venum[0x0][0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        DllCallbackFree($henumproc)
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumDisplayMonitors

    Func _WinAPI_EnumDisplaySettings($SDEVICE, $imode)
        If Not StringStripWS($SDEVICE, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $SDEVICE = Null
        Local $tdevmode = DllStructCreate($TAGDEVMODE_DISPLAY)
        DllStructSetData($tdevmode, "Size", DllStructGetSize($tdevmode))
        DllStructSetData($tdevmode, "DriverExtra", 0x0)
        Local $acall = DllCall("user32.dll", "bool", "EnumDisplaySettingsW", "wstr", $SDEVICE, "dword", $imode, "struct*", $tdevmode)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x5]
        $aret[0x0] = DllStructGetData($tdevmode, "PelsWidth")
        $aret[0x1] = DllStructGetData($tdevmode, "PelsHeight")
        $aret[0x2] = DllStructGetData($tdevmode, "BitsPerPel")
        $aret[0x3] = DllStructGetData($tdevmode, "DisplayFrequency")
        $aret[0x4] = DllStructGetData($tdevmode, "DisplayFlags")
        Return $aret
    EndFunc    ; -> _WinAPI_EnumDisplaySettings

    Func _WinAPI_EnumFontFamilies($hdc = 0x0, $sfacename = '', $icharset = 0x1, $IFONTTYPE = 0x7, $SPATTERN = '', $BEXCLUDE = False)
        Local $tlogfont = DllStructCreate($TAGLOGFONT)
        Local $tpattern = DllStructCreate("uint;uint;ptr;wchar[" & (StringLen($SPATTERN) + 0x1) & "]")
        DllStructSetData($tpattern, 0x1, $IFONTTYPE)
        If Not $SPATTERN Then
            DllStructSetData($tpattern, 0x2, 0x0)
            DllStructSetData($tpattern, 0x3, 0x0)
        Else
            DllStructSetData($tpattern, 0x2, $BEXCLUDE)
            DllStructSetData($tpattern, 0x3, DllStructGetPtr($tpattern, 0x4))
            DllStructSetData($tpattern, 0x4, $SPATTERN)
        EndIf
        DllStructSetData($tlogfont, 0x9, $icharset)
        DllStructSetData($tlogfont, 0xd, 0x0)
        DllStructSetData($tlogfont, 0xe, StringLeft($sfacename, 0x1f))
        Local $hcdc
        If Not $hdc Then
            $hcdc = _WinAPI_CreateCompatibleDC(0x0)
        Else
            $hcdc = $hdc
        EndIf
        Dim $__g_venum[0x65][0x8] = [[0x0]]
        Local $henumproc = DllCallbackRegister("__EnumFontFamiliesProc", "int", "ptr;ptr;dword;PTR")
        Local $acall = DllCall("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $hcdc, "struct*", $tlogfont, "ptr", DllCallbackGetPtr($henumproc), "struct*", $tpattern, "dword", 0x0)
        If @error Or Not $acall[0x0] Or Not $__g_venum[0x0][0x0] Then
            $__g_venum = @error + 0xa
        EndIf
        DllCallbackFree($henumproc)
        If Not $hdc Then
            _WinAPI_DeleteDC($hcdc)
        EndIf
        If $__g_venum Then Return SetError($__g_venum, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumFontFamilies

    Func _WinAPI_EqualRect($trect1, $trect2)
        Local $acall = DllCall("user32.dll", "bool", "EqualRect", "struct*", $trect1, "struct*", $trect2)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_EqualRect

    Func _WinAPI_EqualRgn($hrgn1, $hrgn2)
        Local $acall = DllCall("gdi32.dll", "bool", "EqualRgn", "handle", $hrgn1, "handle", $hrgn2)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_EqualRgn

    Func _WinAPI_ExcludeClipRect($hdc, $trect)
        Local $acall = DllCall("gdi32.dll", "int", "ExcludeClipRect", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4))
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ExcludeClipRect

    Func _WinAPI_ExtCreatePen($ipenstyle, $iwidth, $ibrushstyle, $irgb, $ihatch = 0x0, $auserstyle = 0x0, $istart = 0x0, $IEND = + -1)
        Local $icount = 0x0, $tstyle = 0x0
        If BitAND($ipenstyle, 0xff) = 0x7 Then
            If __CheckErrorArrayBounds($auserstyle, $istart, $IEND) Then Return SetError(@error + 0xa, @extended, 0x0)
            $tstyle = DllStructCreate("dword[" & ($IEND - $istart + 0x1) & "]")
            For $i = $istart To $IEND
                DllStructSetData($tstyle, 0x1, $auserstyle[$i], $icount + 0x1)
                $icount += 0x1
            Next
        EndIf
        Local $tlogbrush = DllStructCreate($TAGLOGBRUSH)
        DllStructSetData($tlogbrush, 0x1, $ibrushstyle)
        DllStructSetData($tlogbrush, 0x2, __rgb($irgb))
        DllStructSetData($tlogbrush, 0x3, $ihatch)
        Local $acall = DllCall("gdi32.dll", "handle", "ExtCreatePen", "dword", $ipenstyle, "dword", $iwidth, "struct*", $tlogbrush, "dword", $icount, "struct*", $tstyle)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ExtCreatePen

    Func _WinAPI_ExtCreateRegion($trgndata, $txform = 0x0)
        Local $acall = DllCall("gdi32.dll", "handle", "ExtCreateRegion", "struct*", $txform, "dword", DllStructGetSize($trgndata), "struct*", $trgndata)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ExtCreateRegion

    Func _WinAPI_ExtFloodFill($hdc, $ix, $iy, $irgb, $itype = 0x0)
        Local $acall = DllCall("gdi32.dll", "bool", "ExtFloodFill", "handle", $hdc, "int", $ix, "int", $iy, "dword", __rgb($irgb), "uint", $itype)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ExtFloodFill

    Func _WinAPI_ExtSelectClipRgn($hdc, $hrgn, $imode = 0x5)
        Local $acall = DllCall("gdi32.dll", "int", "ExtSelectClipRgn", "handle", $hdc, "handle", $hrgn, "int", $imode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ExtSelectClipRgn

    Func _WinAPI_FillPath($hdc)
        Local $acall = DllCall("gdi32.dll", "bool", "FillPath", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FillPath

    Func _WinAPI_FillRgn($hdc, $hrgn, $hbrush)
        Local $acall = DllCall("gdi32.dll", "bool", "FillRgn", "handle", $hdc, "handle", $hrgn, "handle", $hbrush)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FillRgn

    Func _WinAPI_FlattenPath($hdc)
        Local $acall = DllCall("gdi32.dll", "bool", "FlattenPath", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FlattenPath

    Func _WinAPI_FrameRgn($hdc, $hrgn, $hbrush, $iwidth, $iheight)
        Local $acall = DllCall("gdi32.dll", "bool", "FrameRgn", "handle", $hdc, "handle", $hrgn, "handle", $hbrush, "int", $iwidth, "int", $iheight)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FrameRgn

    Func _WinAPI_GdiComment($hdc, $pbuffer, $isize)
        Local $acall = DllCall("gdi32.dll", "bool", "GdiComment", "handle", $hdc, "uint", $isize, "struct*", $pbuffer)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GdiComment

    Func _WinAPI_GetArcDirection($hdc)
        Local $acall = DllCall("gdi32.dll", "int", "GetArcDirection", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        If ($acall[0x0] < 0x1) Or ($acall[0x0] > 0x2) Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetArcDirection

    Func _WinAPI_GetBitmapBits($hbitmap, $isize, $pbits)
        Local $acall = DllCall("gdi32.dll", "long", "GetBitmapBits", "handle", $hbitmap, "long", $isize, "struct*", $pbits)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetBitmapBits

    Func _WinAPI_GetBitmapDimensionEx($hbitmap)
        Local $tsize = DllStructCreate($TAGSIZE)
        Local $acall = DllCall("gdi32.dll", "bool", "GetBitmapDimensionEx", "handle", $hbitmap, "struct*", $tsize)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tsize
    EndFunc    ; -> _WinAPI_GetBitmapDimensionEx

    Func _WinAPI_GetBkColor($hdc)
        Local $acall = DllCall("gdi32.dll", "dword", "GetBkColor", "handle", $hdc)
        If @error Or ($acall[0x0] = + -1) Then Return SetError(@error, @extended, + -1)
        Return __rgb($acall[0x0])
    EndFunc    ; -> _WinAPI_GetBkColor

    Func _WinAPI_GetBoundsRect($hdc, $IFLAGS = 0x0)
        Local $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("gdi32.dll", "uint", "GetBoundsRect", "handle", $hdc, "struct*", $trect, "uint", $IFLAGS)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return SetExtended($acall[0x0], $trect)
    EndFunc    ; -> _WinAPI_GetBoundsRect

    Func _WinAPI_GetBrushOrg($hdc)
        Local $tpoint = DllStructCreate($TAGPOINT)
        Local $acall = DllCall("gdi32.dll", "bool", "GetBrushOrgEx", "handle", $hdc, "struct*", $tpoint)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tpoint
    EndFunc    ; -> _WinAPI_GetBrushOrg

    Func _WinAPI_GetBValue($irgb)
        Return BitShift(BitAND(__rgb($irgb), 0xff0000), 0x10)
    EndFunc    ; -> _WinAPI_GetBValue

    Func _WinAPI_GetClipBox($hdc, ByRef $trect)
        $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("gdi32.dll", "int", "GetClipBox", "handle", $hdc, "struct*", $trect)
        If @error Or Not $acall[0x0] Then
            $trect = 0x0
            Return SetError(@error, @extended, 0x0)
        EndIf
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetClipBox

    Func _WinAPI_GetClipRgn($hdc)
        Local $hrgn = _WinAPI_CreateRectRgn(0x0, 0x0, 0x0, 0x0)
        Local $ierror = 0x0
        Local $acall = DllCall("gdi32.dll", "int", "GetClipRgn", "handle", $hdc, "handle", $hrgn)
        If @error Or ($acall[0x0] = + -1) Then $ierror = @error + 0xa
        If $ierror Or Not $acall[0x0] Then
            _WinAPI_DeleteObject($hrgn)
            $hrgn = 0x0
        EndIf
        Return SetError($ierror, 0x0, $hrgn)
    EndFunc    ; -> _WinAPI_GetClipRgn

    Func _WinAPI_GetColorAdjustment($hdc)
        Local $tadjustment = DllStructCreate($TAGCOLORADJUSTMENT)
        Local $acall = DllCall("gdi32.dll", "bool", "GetColorAdjustment", "handle", $hdc, "struct*", $tadjustment)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tadjustment
    EndFunc    ; -> _WinAPI_GetColorAdjustment

    Func _WinAPI_GetCurrentPosition($hdc)
        Local $tpoint = DllStructCreate($TAGPOINT)
        Local $acall = DllCall("gdi32.dll", "int", "GetCurrentPositionEx", "handle", $hdc, "struct*", $tpoint)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tpoint
    EndFunc    ; -> _WinAPI_GetCurrentPosition

    Func _WinAPI_GetDeviceGammaRamp($hdc, ByRef $aramp)
        $aramp = 0x0
        Local $tdata = DllStructCreate("word[256];word[256];word[256]")
        Local $acall = DllCall("gdi32.dll", "bool", "GetDeviceGammaRamp", "handle", $hdc, "struct*", $tdata)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Dim $aramp[0x100][0x3]
        For $i = 0x0 To 0x2
            For $j = 0x0 To 0xff
                $aramp[$j][$i] = DllStructGetData($tdata, $i + 0x1, $j + 0x1)
            Next
        Next
        Return 0x1
    EndFunc    ; -> _WinAPI_GetDeviceGammaRamp

    Func _WinAPI_GetDIBColorTable($hbitmap)
        Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
        Local $hsv = _WinAPI_SelectObject($hdc, $hbitmap)
        Local $tpeak = DllStructCreate("dword[256]")
        Local $ierror = 0x0
        Local $acall = DllCall("gdi32.dll", "uint", "GetDIBColorTable", "handle", $hdc, "uint", 0x0, "uint", 0x100, "struct*", $tpeak)
        If @error Or Not $acall[0x0] Then $ierror = @error + 0xa
        _WinAPI_SelectObject($hdc, $hsv)
        _WinAPI_DeleteDC($hdc)
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Local $tdata = DllStructCreate("dword[" & $acall[0x0] & "]")
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        _WinAPI_MoveMemory($tdata, $acall[0x4], 0x4 * $acall[0x0])
        Return SetExtended($acall[0x0], $tdata)
    EndFunc    ; -> _WinAPI_GetDIBColorTable

    Func _WinAPI_GetDIBits($hdc, $hbitmap, $istartscan, $iscanlines, $pbits, $tbi, $iusage)
        Local $acall = DllCall("gdi32.dll", "int", "GetDIBits", "handle", $hdc, "handle", $hbitmap, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbi, "uint", $iusage)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetDIBits

    Func _WinAPI_GetEnhMetaFile($sfilepath)
        Local $acall = DllCall("gdi32.dll", "handle", "GetEnhMetaFileW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetEnhMetaFile

    Func _WinAPI_GetEnhMetaFileBits($hemf, ByRef $pbuffer)
        Local $acall = DllCall("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $hemf, "uint", 0x0, "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x32, @extended, 0x0)
        $pbuffer = __HeapReAlloc($pbuffer, $acall[0x0], 0x1)
        If @error Then Return SetError(@error, @extended, 0x0)
        $acall = DllCall("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $hemf, "uint", $acall[0x0], "ptr", $pbuffer)
        If Not $acall[0x0] Then Return SetError(0x3c, 0x0, 0x0)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetEnhMetaFileBits

    Func _WinAPI_GetEnhMetaFileDescription($hemf)
        Local $tdata = DllStructCreate("wchar[4096]")
        Local $acall = DllCall("gdi32.dll", "uint", "GetEnhMetaFileDescriptionW", "handle", $hemf, "uint", 0x1000, "struct*", $tdata)
        If @error Or ($acall[0x0] = -1) Then Return SetError(@error + 0x14, $acall[0x0], 0x0)
        If Not $acall[0x0] Then Return 0x0
        Local $ADATA = _WinAPI_StructToArray($tdata)
        If @error Then Return SetError(@error, @extended, 0x0)
        Local $aret[0x2]
        For $i = 0x0 To 0x1
            If $ADATA[0x0] > $i Then
                $aret[$i] = $ADATA[$i + 0x1]
            Else
                $aret[$i] = ''
            EndIf
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetEnhMetaFileDescription

    Func _WinAPI_GetEnhMetaFileDimension($hemf)
        Local $tenhmetaheader = _WinAPI_GetEnhMetaFileHeader($hemf)
        If @error Then Return SetError(@error, @extended, 0x0)
        Local $tsize = DllStructCreate($TAGSIZE)
        DllStructSetData($tsize, 0x1, Round((DllStructGetData($tenhmetaheader, "rcFrame", 0x3) - DllStructGetData($tenhmetaheader, "rcFrame", 0x1)) * DllStructGetData($tenhmetaheader, "Device", 0x1) / DllStructGetData($tenhmetaheader, "Millimeters", 0x1) / 0x64))
        DllStructSetData($tsize, 0x2, Round((DllStructGetData($tenhmetaheader, "rcFrame", 0x4) - DllStructGetData($tenhmetaheader, "rcFrame", 0x2)) * DllStructGetData($tenhmetaheader, "Device", 0x2) / DllStructGetData($tenhmetaheader, "Millimeters", 0x2) / 0x64))
        Return $tsize
    EndFunc    ; -> _WinAPI_GetEnhMetaFileDimension

    Func _WinAPI_GetEnhMetaFileHeader($hemf)
        Local $tenhmetaheader = DllStructCreate($TAGENHMETAHEADER)
        Local $acall = DllCall("gdi32.dll", "uint", "GetEnhMetaFileHeader", "handle", $hemf, "uint", DllStructGetSize($tenhmetaheader), "struct*", $tenhmetaheader)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return SetExtended($acall[0x0], $tenhmetaheader)
    EndFunc    ; -> _WinAPI_GetEnhMetaFileHeader

    Func _WinAPI_GetFontName($sfacename, $istyle = 0x0, $icharset = 0x1)
        If Not $sfacename Then Return SetError(0x1, 0x0, '')
        Local $IFLAGS = 0x0
        If BitAND($istyle, 0x1) Then
            $IFLAGS += 0x20
        EndIf
        If BitAND($istyle, 0x2) Then
            $IFLAGS += 0x1
        EndIf
        If Not $IFLAGS Then
            $IFLAGS = 0x40
        EndIf
        Local $tlogfont = DllStructCreate($TAGLOGFONT)
        DllStructSetData($tlogfont, 0x9, $icharset)
        DllStructSetData($tlogfont, 0xd, 0x0)
        DllStructSetData($tlogfont, 0xe, StringLeft($sfacename, 0x1f))
        Local $tfn = DllStructCreate("dword;wchar[64]")
        DllStructSetData($tfn, 0x1, $IFLAGS)
        DllStructSetData($tfn, 0x2, '')
        Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
        Local $henumproc = DllCallbackRegister("__EnumFontStylesProc", "int", "ptr;ptr;dword;lparam")
        Local $sret = ''
        Local $acall = DllCall("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $hdc, "struct*", $tlogfont, "ptr", DllCallbackGetPtr($henumproc), "struct*", $tfn, "dword", 0x0)
        If Not @error And Not $acall[0x0] Then $sret = DllStructGetData($tfn, 0x2)
        DllCallbackFree($henumproc)
        _WinAPI_DeleteDC($hdc)
        If Not $sret Then Return SetError(0x2, 0x0, '')
        Return $sret
    EndFunc    ; -> _WinAPI_GetFontName

    Func _WinAPI_GetFontResourceInfo($sfont, $bforce = False, $IFLAG = Default)
        If $IFLAG = Default Then
            If $bforce Then
                If Not _WinAPI_AddFontResourceEx($sfont, $FR_NOT_ENUM) Then Return SetError(@error + 0x14, @extended, '')
            EndIf
            Local $ierror = 0x0
            Local $aret = DllCall("gdi32.dll", "bool", "GetFontResourceInfoW", "wstr", $sfont, "dword*", 0x1000, "wstr", '', "dword", 0x1)
            If @error Or Not $aret[0x0] Then $ierror = @error + 0xa
            If $bforce Then
                _WinAPI_RemoveFontResourceEx($sfont, $FR_NOT_ENUM)
            EndIf
            If $ierror Then Return SetError($ierror, 0x0, '')
            Return $aret[0x3]
        Else
            If Not FileExists($sfont) Then
                $sfont = RegRead("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", "Fonts") & "\\" & $sfont
                If Not FileExists($sfont) Then Return SetError(0x1f, 0x0, '')
            EndIf
            Local Const $hfile = _WinAPI_CreateFile($sfont, 0x2, 0x2, 0x2)
            If Not $hfile Then Return SetError(0x20, _WinAPI_GetLastError(), '')
            Local Const $IFILE = FileGetSize($sfont)
            Local Const $tbuffer = DllStructCreate("byte[" & $IFILE + 0x1 & "]")
            Local Const $PFILE = DllStructGetPtr($tbuffer)
            Local $iread
            _WinAPI_ReadFile($hfile, $PFILE, $IFILE, $iread)
            _WinAPI_CloseHandle($hfile)
            Local $sttfname = _WinAPI_GetFontMemoryResourceInfo($PFILE, $IFLAG)
            If @error Then
                If @error = 0x1 Then
                    $sttfname = _WinAPI_GetFontResourceInfo($sfont, True)
                    Return SetError(@error, @extended, $sttfname)
                EndIf
                Return SetError(0x21, @error, '')
            EndIf
            Return $sttfname
        EndIf
    EndFunc    ; -> _WinAPI_GetFontResourceInfo

    Func _WinAPI_GetFontMemoryResourceInfo($pmemory, $IFLAG = 0x1)
        Local Const $TAGTT_OFFSET_TABLE = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
        Local Const $TAGTT_TABLE_DIRECTORY = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
        Local Const $TAGTT_NAME_TABLE_HEADER = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
        Local Const $TAGTT_NAME_RECORD = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
        Local $tttoffsettable = DllStructCreate($TAGTT_OFFSET_TABLE, $pmemory)
        Local $inumoftables = _WinAPI_SwapWord(DllStructGetData($tttoffsettable, "uNumOfTables"))
        If Not (_WinAPI_SwapWord(DllStructGetData($tttoffsettable, "uMajorVersion")) = 0x1 And _WinAPI_SwapWord(DllStructGetData($tttoffsettable, "uMinorVersion")) = 0x0) Then Return SetError(0x1, 0x0, '')
        Local $itbldirsize = DllStructGetSize(DllStructCreate($TAGTT_TABLE_DIRECTORY))
        Local $bfound = False, $ioffset, $ttbldir
        For $i = 0x0 To $inumoftables + -1
            $ttbldir = DllStructCreate($TAGTT_TABLE_DIRECTORY, $pmemory + DllStructGetSize($tttoffsettable) + $i * $itbldirsize)
            If StringLeft(DllStructGetData($ttbldir, "szTag"), 0x4) = "name" Then
                $bfound = True
                $ioffset = _WinAPI_SwapDWord(DllStructGetData($ttbldir, "uOffset"))
                ExitLoop
            EndIf
        Next
        If Not $bfound Then Return SetError(0x2, 0x0, '')
        Local $tntheader = DllStructCreate($TAGTT_NAME_TABLE_HEADER, $pmemory + $ioffset)
        Local $intheadersize = DllStructGetSize($tntheader)
        Local $inrcount = _WinAPI_SwapWord(DllStructGetData($tntheader, "uNRCount"))
        Local $istorageoffset = _WinAPI_SwapWord(DllStructGetData($tntheader, "uStorageOffset"))
        Local $ittrecordsize = DllStructGetSize(DllStructCreate($TAGTT_NAME_RECORD))
        Local $tresult, $sresult, $istringlength = 0x0, $istringoffset, $iencodingid, $tttrecord
        For $i = 0x0 To $inrcount + -1
            $tttrecord = DllStructCreate($TAGTT_NAME_RECORD, $pmemory + $ioffset + $intheadersize + $i * $ittrecordsize)
            If @error Then ContinueLoop
            If _WinAPI_SwapWord($tttrecord.uNameID) = $IFLAG Then
                $istringlength = _WinAPI_SwapWord(DllStructGetData($tttrecord, "uStringLength"))
                $istringoffset = _WinAPI_SwapWord(DllStructGetData($tttrecord, "uStringOffset"))
                $iencodingid = _WinAPI_SwapWord(DllStructGetData($tttrecord, "uEncodingID"))
                Local $swchar = "char"
                If $iencodingid = 0x1 Then
                    $swchar = "word"
                    $istringlength /= 0x2
                EndIf
                If Not $istringlength Then
                    $sresult = ''
                    ContinueLoop
                EndIf
                $tresult = DllStructCreate($swchar & " szTTFName[" & $istringlength & "]", $pmemory + $ioffset + $istringoffset + $istorageoffset)
                If $iencodingid = 0x1 Then
                    $sresult = ''
                    For $j = 0x1 To $istringlength
                        $sresult &= ChrW(_WinAPI_SwapWord(DllStructGetData($tresult, 0x1, $j)))
                    Next
                Else
                    $sresult = $tresult.szTTFName
                EndIf
                If StringLen($sresult) > 0x0 Then ExitLoop
            EndIf
        Next
        Return $sresult
    EndFunc    ; -> _WinAPI_GetFontMemoryResourceInfo

    Func _WinAPI_GetGlyphOutline($hdc, $schar, $iformat, ByRef $pbuffer, $tmat2 = 0x0)
        Local $tgm = DllStructCreate($TAGGLYPHMETRICS)
        Local $acall, $ilength = 0x0
        If Not IsDllStruct($tmat2) Then
            $tmat2 = DllStructCreate("short[8]")
            DllStructSetData($tmat2, 0x1, 0x1, 0x2)
            DllStructSetData($tmat2, 0x1, 0x1, 0x8)
        EndIf
        If $iformat Then
            $acall = DllCall("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $hdc, "uint", AscW($schar), "uint", $iformat, "struct*", $tgm, "dword", 0x0, "ptr", 0x0, "struct*", $tmat2)
            If @error Or ($acall[0x0] = -1) Then Return SetError(@error + 0xa, @extended, 0x0)
            $ilength = $acall[0x0]
            $pbuffer = __HeapReAlloc($pbuffer, $ilength, 0x1)
            If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        EndIf
        $acall = DllCall("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $hdc, "uint", AscW($schar), "uint", $iformat, "struct*", $tgm, "dword", $ilength, "ptr", $pbuffer, "struct*", $tmat2)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = -1 Then Return SetError(0xa, + -1, 0x0)
        Return SetExtended($ilength, $tgm)
    EndFunc    ; -> _WinAPI_GetGlyphOutline

    Func _WinAPI_GetGraphicsMode($hdc)
        Local $acall = DllCall("gdi32.dll", "int", "GetGraphicsMode", "handle", $hdc)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetGraphicsMode

    Func _WinAPI_GetGValue($irgb)
        Return BitShift(BitAND(__rgb($irgb), 0xff00), 0x8)
    EndFunc    ; -> _WinAPI_GetGValue

    Func _WinAPI_GetMapMode($hdc)
        Local $acall = DllCall("gdi32.dll", "int", "GetMapMode", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetMapMode

    Func _WinAPI_GetMonitorInfo($hmonitor)
        Local $tmiex = DllStructCreate("dword;long[4];long[4];dword;wchar[32]")
        DllStructSetData($tmiex, 0x1, DllStructGetSize($tmiex))
        Local $acall = DllCall("user32.dll", "bool", "GetMonitorInfoW", "handle", $hmonitor, "struct*", $tmiex)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x4]
        For $i = 0x0 To 0x1
            $aret[$i] = DllStructCreate($TAGRECT)
            _WinAPI_MoveMemory($aret[$i], DllStructGetPtr($tmiex, $i + 0x2), 0x10)
        Next
        $aret[0x3] = DllStructGetData($tmiex, 0x5)
        Switch DllStructGetData($tmiex, 0x4)
        Case 0x1
            $aret[0x2] = 0x1
        Case Else
            $aret[0x2] = 0x0
        EndSwitch
        Return $aret
    EndFunc    ; -> _WinAPI_GetMonitorInfo

    Func _WinAPI_GetOutlineTextMetrics($hdc)
        Local $acall = DllCall("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $hdc, "uint", 0x0, "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $tdata = DllStructCreate("byte[" & $acall[0x0] & "]")
        Local $toltm = DllStructCreate($TAGOUTLINETEXTMETRIC, DllStructGetPtr($tdata))
        $acall = DllCall("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $hdc, "uint", $acall[0x0], "struct*", $tdata)
        If Not $acall[0x0] Then Return SetError(0x14, 0x0, 0x0)
        Return $toltm
    EndFunc    ; -> _WinAPI_GetOutlineTextMetrics

    Func _WinAPI_GetPixel($hdc, $ix, $iy)
        Local $acall = DllCall("gdi32.dll", "dword", "GetPixel", "handle", $hdc, "int", $ix, "int", $iy)
        If @error Or ($acall[0x0] = -1) Then Return SetError(@error, @extended, + -1)
        Return __rgb($acall[0x0])
    EndFunc    ; -> _WinAPI_GetPixel

    Func _WinAPI_GetPolyFillMode($hdc)
        Local $acall = DllCall("gdi32.dll", "int", "GetPolyFillMode", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetPolyFillMode

    Func _WinAPI_GetPosFromRect($trect)
        Local $aret[0x4]
        For $i = 0x0 To 0x3
            $aret[$i] = DllStructGetData($trect, $i + 0x1)
            If @error Then Return SetError(@error, @extended, 0x0)
        Next
        For $i = 0x2 To 0x3
            $aret[$i]-= $aret[$i + -2]
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetPosFromRect

    Func _WinAPI_GetRegionData($hrgn, ByRef $trgndata)
        Local $acall = DllCall("gdi32.dll", "dword", "GetRegionData", "handle", $hrgn, "dword", 0x0, "ptr", 0x0)
        If @error Or Not $acall[0x0] Then
            $trgndata = 0x0
            Return SetError(@error, @extended, False)
        EndIf
        $trgndata = DllStructCreate($TAGRGNDATAHEADER)
        Local $irectsize = $acall[0x0] - DllStructGetSize($trgndata)
        If $irectsize > 0x0 Then $trgndata = DllStructCreate($TAGRGNDATAHEADER & ";byte[" & $irectsize & "]")
        $acall = DllCall("gdi32.dll", "dword", "GetRegionData", "handle", $hrgn, "dword", $acall[0x0], "struct*", $trgndata)
        If Not $acall[0x0] Then $trgndata = 0x0
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetRegionData

    Func _WinAPI_GetRgnBox($hrgn, ByRef $trect)
        $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("gdi32.dll", "int", "GetRgnBox", "handle", $hrgn, "struct*", $trect)
        If @error Or Not $acall[0x0] Then
            $trect = 0x0
            Return SetError(@error, @extended, 0x0)
        EndIf
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetRgnBox

    Func _WinAPI_GetROP2($hdc)
        Local $acall = DllCall("gdi32.dll", "int", "GetROP2", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetROP2

    Func _WinAPI_GetRValue($irgb)
        Return BitAND(__rgb($irgb), 0xff)
    EndFunc    ; -> _WinAPI_GetRValue

    Func _WinAPI_GetStretchBltMode($hdc)
        Local $acall = DllCall("gdi32.dll", "int", "GetStretchBltMode", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetStretchBltMode

    Func _WinAPI_GetTabbedTextExtent($hdc, $stext, $atab = 0x0, $istart = 0x0, $IEND = + -1)
        Local $itab, $icount
        If Not IsArray($atab) Then
            If $atab Then
                $itab = $atab
                Dim $atab[0x1] = [$itab]
                $istart = 0x0
                $IEND = 0x0
                $icount = 0x1
            Else
                $icount = 0x0
            EndIf
        Else
            $icount = 0x1
        EndIf
        Local $ttab = 0x0
        If $icount Then
            If __CheckErrorArrayBounds($atab, $istart, $IEND) Then Return SetError(@error + 0xa, @extended, 0x0)
            $icount = $IEND - $istart + 0x1
            $ttab = DllStructCreate("uint[" & $icount & "]")
            $itab = 0x1
            For $i = $istart To $IEND
                DllStructSetData($ttab, 0x1, $atab[$i], $itab)
                $itab += 0x1
            Next
        EndIf
        Local $acall = DllCall("user32.dll", "dword", "GetTabbedTextExtentW", "handle", $hdc, "wstr", $stext, "int", StringLen($stext), "int", $icount, "struct*", $ttab)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Return _WinAPI_CreateSize(_WinAPI_LoWord($acall[0x0]), _WinAPI_HiWord($acall[0x0]))
    EndFunc    ; -> _WinAPI_GetTabbedTextExtent

    Func _WinAPI_GetTextAlign($hdc)
        Local $acall = DllCall("gdi32.dll", "uint", "GetTextAlign", "handle", $hdc)
        If @error Or ($acall[0x0] = -1) Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetTextAlign

    Func _WinAPI_GetTextCharacterExtra($hdc)
        Local $acall = DllCall("gdi32.dll", "int", "GetTextCharacterExtra", "handle", $hdc)
        If @error Or ($acall[0x0] = 0x8000000) Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetTextCharacterExtra

    Func _WinAPI_GetTextFace($hdc)
        Local $acall = DllCall("gdi32.dll", "int", "GetTextFaceW", "handle", $hdc, "int", 0x800, "wstr", '')
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_GetTextFace

    Func _WinAPI_GetUDFColorMode()
        Return Number($__g_irgbmode)
    EndFunc    ; -> _WinAPI_GetUDFColorMode

    Func _WinAPI_GetUpdateRect($hwnd, $berase = True)
        Local $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("user32.dll", "bool", "GetUpdateRect", "hwnd", $hwnd, "struct*", $trect, "bool", $berase)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_GetUpdateRect

    Func _WinAPI_GetUpdateRgn($hwnd, $hrgn, $berase = True)
        Local $acall = DllCall("user32.dll", "int", "GetUpdateRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $berase)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetUpdateRgn

    Func _WinAPI_GetWindowExt($hdc)
        Local $tsize = DllStructCreate($TAGSIZE)
        Local $acall = DllCall("gdi32.dll", "bool", "GetWindowExtEx", "handle", $hdc, "struct*", $tsize)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tsize
    EndFunc    ; -> _WinAPI_GetWindowExt

    Func _WinAPI_GetWindowOrg($hdc)
        Local $tpoint = DllStructCreate($TAGPOINT)
        Local $acall = DllCall("gdi32.dll", "bool", "GetWindowOrgEx", "handle", $hdc, "struct*", $tpoint)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tpoint
    EndFunc    ; -> _WinAPI_GetWindowOrg

    Func _WinAPI_GetWindowRgnBox($hwnd, ByRef $trect)
        $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("gdi32.dll", "int", "GetWindowRgnBox", "hwnd", $hwnd, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetWindowRgnBox

    Func _WinAPI_GetWorldTransform($hdc)
        Local $txform = DllStructCreate($TAGXFORM)
        Local $acall = DllCall("gdi32.dll", "bool", "GetWorldTransform", "handle", $hdc, "struct*", $txform)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $txform
    EndFunc    ; -> _WinAPI_GetWorldTransform

    Func _WinAPI_GradientFill($hdc, Const ByRef $AVERTEX, $istart = 0x0, $IEND = + -1, $BROTATE = False)
        If __CheckErrorArrayBounds($AVERTEX, $istart, $IEND, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
        If UBound($AVERTEX, $UBOUND_COLUMNS) < 0x3 Then Return SetError(0xd, 0x0, 0x0)
        Local $ipoint = $IEND - $istart + 0x1
        If $ipoint > 0x3 Then
            $IEND = $istart + 0x2
            $ipoint = 0x3
        EndIf
        Local $imode
        Switch $ipoint
        Case 0x2
            $imode = Number(Not $BROTATE)
        Case 0x3
            $imode = 0x2
        Case Else
            Return SetError(0xf, 0x0, 0x0)
        EndSwitch
        Local $tagstruct = ''
        For $i = $istart To $IEND
            $tagstruct &= "ushort[8];"
        Next
        Local $tvertex = DllStructCreate($tagstruct)
        Local $icount = 0x1
        Local $tgradient = DllStructCreate("ulong[" & $ipoint & "]")
        For $i = $istart To $IEND
            DllStructSetData($tgradient, 0x1, $icount + -1, $icount)
            DllStructSetData($tvertex, $icount, _WinAPI_LoWord($AVERTEX[$i][0x0]), 0x1)
            DllStructSetData($tvertex, $icount, _WinAPI_HiWord($AVERTEX[$i][0x0]), 0x2)
            DllStructSetData($tvertex, $icount, _WinAPI_LoWord($AVERTEX[$i][0x1]), 0x3)
            DllStructSetData($tvertex, $icount, _WinAPI_HiWord($AVERTEX[$i][0x1]), 0x4)
            DllStructSetData($tvertex, $icount, BitShift(_WinAPI_GetRValue($AVERTEX[$i][0x2]), + -8), 0x5)
            DllStructSetData($tvertex, $icount, BitShift(_WinAPI_GetGValue($AVERTEX[$i][0x2]), + -8), 0x6)
            DllStructSetData($tvertex, $icount, BitShift(_WinAPI_GetBValue($AVERTEX[$i][0x2]), + -8), 0x7)
            DllStructSetData($tvertex, $icount, 0x0, 0x8)
            $icount += 0x1
        Next
        Local $acall = DllCall("gdi32.dll", "bool", "GdiGradientFill", "handle", $hdc, "struct*", $tvertex, "ulong", $ipoint, "struct*", $tgradient, "ulong", 0x1, "ulong", $imode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GradientFill

    Func _WinAPI_InflateRect(ByRef $trect, $idx, $idy)
        Local $acall = DllCall("user32.dll", "bool", "InflateRect", "struct*", $trect, "int", $idx, "int", $idy)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_InflateRect

    Func _WinAPI_IntersectClipRect($hdc, $trect)
        Local $acall = DllCall("gdi32.dll", "int", "IntersectClipRect", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4))
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IntersectClipRect

    Func _WinAPI_IntersectRect($trect1, $trect2)
        Local $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("user32.dll", "bool", "IntersectRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_IntersectRect

    Func _WinAPI_InvalidateRgn($hwnd, $hrgn = 0x0, $berase = True)
        Local $acall = DllCall("user32.dll", "bool", "InvalidateRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $berase)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_InvalidateRgn

    Func _WinAPI_InvertANDBitmap($hbitmap, $bdelete = False)
        Local $tbitmap = DllStructCreate($TAGBITMAP)
        If Not _WinAPI_GetObject($hbitmap, DllStructGetSize($tbitmap), $tbitmap) Or (DllStructGetData($tbitmap, "bmBitsPixel") <> 0x1) Then
            Return SetError(@error + 0xa, @extended, 0x0)
        EndIf
        Local $hresult = _WinAPI_CreateDIB(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"), 0x1)
        If Not $hresult Then Return SetError(@error, @extended, 0x0)
        Local $hsrcdc = _WinAPI_CreateCompatibleDC(0x0)
        Local $hsrcsv = _WinAPI_SelectObject($hsrcdc, $hbitmap)
        Local $hdstdc = _WinAPI_CreateCompatibleDC(0x0)
        Local $hdstsv = _WinAPI_SelectObject($hdstdc, $hresult)
        _WinAPI_BitBlt($hdstdc, 0x0, 0x0, DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"), $hsrcdc, 0x0, 0x0, 0x330008)
        _WinAPI_SelectObject($hsrcdc, $hsrcsv)
        _WinAPI_DeleteDC($hsrcdc)
        _WinAPI_SelectObject($hdstdc, $hdstsv)
        _WinAPI_DeleteDC($hdstdc)
        If $bdelete Then
            _WinAPI_DeleteObject($hbitmap)
        EndIf
        Return $hresult
    EndFunc    ; -> _WinAPI_InvertANDBitmap

    Func _WinAPI_InvertColor($icolor)
        If $icolor = + -1 Then Return 0x0
        Return 0xffffff - BitAND($icolor, 0xffffff)
    EndFunc    ; -> _WinAPI_InvertColor

    Func _WinAPI_InvertRect($hdc, ByRef $trect)
        Local $acall = DllCall("user32.dll", "bool", "InvertRect", "handle", $hdc, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_InvertRect

    Func _WinAPI_InvertRgn($hdc, $hrgn)
        Local $acall = DllCall("gdi32.dll", "bool", "InvertRgn", "handle", $hdc, "handle", $hrgn)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_InvertRgn

    Func _WinAPI_IsRectEmpty(ByRef $trect)
        Local $acall = DllCall("user32.dll", "bool", "IsRectEmpty", "struct*", $trect)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsRectEmpty

    Func _WinAPI_LineDDA($ix1, $iy1, $ix2, $iy2, $plineproc, $pdata = 0x0)
        Local $acall = DllCall("gdi32.dll", "bool", "LineDDA", "int", $ix1, "int", $iy1, "int", $ix2, "int", $iy2, "ptr", $plineproc, "lparam", $pdata)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LineDDA

    Func _WinAPI_LineTo($hdc, $ix, $iy)
        Local $acall = DllCall("gdi32.dll", "bool", "LineTo", "handle", $hdc, "int", $ix, "int", $iy)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LineTo

    Func _WinAPI_LockWindowUpdate($hwnd)
        Local $acall = DllCall("user32.dll", "bool", "LockWindowUpdate", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LockWindowUpdate

    Func _WinAPI_LPtoDP($hdc, ByRef $tpoint, $icount = 0x1)
        Local $acall = DllCall("gdi32.dll", "bool", "LPtoDP", "handle", $hdc, "struct*", $tpoint, "int", $icount)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LPtoDP

    Func _WinAPI_MaskBlt($hdestdc, $ixdest, $iydest, $iwidth, $iheight, $hsrcdc, $ixsrc, $iysrc, $hmask, $ixmask, $iymask, $irop)
        Local $acall = DllCall("gdi32.dll", "bool", "MaskBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidth, "int", $iheight, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "handle", $hmask, "int", $ixmask, "int", $iymask, "dword", $irop)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MaskBlt

    Func _WinAPI_ModifyWorldTransform($hdc, ByRef $txform, $imode)
        Local $acall = DllCall("gdi32.dll", "bool", "ModifyWorldTransform", "handle", $hdc, "struct*", $txform, "dword", $imode)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ModifyWorldTransform

    Func _WinAPI_MonitorFromPoint(ByRef $tpoint, $IFLAG = 0x1)
        If DllStructGetSize($tpoint) <> 0x8 Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $acall = DllCall("user32.dll", "handle", "MonitorFromPoint", "struct", $tpoint, "dword", $IFLAG)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MonitorFromPoint

    Func _WinAPI_MonitorFromRect(ByRef $trect, $IFLAG = 0x1)
        Local $acall = DllCall("user32.dll", "ptr", "MonitorFromRect", "struct*", $trect, "dword", $IFLAG)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MonitorFromRect

    Func _WinAPI_MonitorFromWindow($hwnd, $IFLAG = 0x1)
        Local $acall = DllCall("user32.dll", "handle", "MonitorFromWindow", "hwnd", $hwnd, "dword", $IFLAG)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MonitorFromWindow

    Func _WinAPI_MoveTo($hdc, $ix, $iy)
        Local $acall = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hdc, "int", $ix, "int", $iy, "ptr", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MoveTo

    Func _WinAPI_MoveToEx($hdc, $ix, $iy)
        Local $tpoint = DllStructCreate($TAGPOINT)
        Local $acall = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $tpoint)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tpoint
    EndFunc    ; -> _WinAPI_MoveToEx

    Func _WinAPI_OffsetClipRgn($hdc, $ixoffset, $iyoffset)
        Local $acall = DllCall("gdi32.dll", "int", "OffsetClipRgn", "handle", $hdc, "int", $ixoffset, "int", $iyoffset)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OffsetClipRgn

    Func _WinAPI_OffsetPoints(ByRef $APOINT, $ixoffset, $iyoffset, $istart = 0x0, $IEND = + -1)
        If __CheckErrorArrayBounds($APOINT, $istart, $IEND, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
        If UBound($APOINT, $UBOUND_COLUMNS) < 0x2 Then Return SetError(0xd, 0x0, 0x0)
        For $i = $istart To $IEND
            $APOINT[$i][0x0]+= $ixoffset
            $APOINT[$i][0x1]+= $iyoffset
        Next
        Return 0x1
    EndFunc    ; -> _WinAPI_OffsetPoints

    Func _WinAPI_OffsetRect(ByRef $trect, $idx, $idy)
        Local $acall = DllCall("user32.dll", "bool", "OffsetRect", "struct*", $trect, "int", $idx, "int", $idy)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OffsetRect

    Func _WinAPI_OffsetRgn($hrgn, $ixoffset, $iyoffset)
        Local $acall = DllCall("gdi32.dll", "int", "OffsetRgn", "handle", $hrgn, "int", $ixoffset, "int", $iyoffset)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OffsetRgn

    Func _WinAPI_OffsetWindowOrg($hdc, $ixoffset, $iyoffset)
        $__g_vext = DllStructCreate($TAGPOINT)
        Local $acall = DllCall("gdi32.dll", "bool", "OffsetWindowOrgEx", "handle", $hdc, "int", $ixoffset, "int", $iyoffset, "struct*", $__g_vext)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OffsetWindowOrg

    Func _WinAPI_PaintDesktop($hdc)
        Local $acall = DllCall("user32.dll", "bool", "PaintDesktop", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PaintDesktop

    Func _WinAPI_PaintRgn($hdc, $hrgn)
        Local $acall = DllCall("gdi32.dll", "bool", "PaintRgn", "handle", $hdc, "handle", $hrgn)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PaintRgn

    Func _WinAPI_PatBlt($hdc, $ix, $iy, $iwidth, $iheight, $irop)
        Local $acall = DllCall("gdi32.dll", "bool", "PatBlt", "handle", $hdc, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "dword", $irop)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PatBlt

    Func _WinAPI_PathToRegion($hdc)
        Local $acall = DllCall("gdi32.dll", "handle", "PathToRegion", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathToRegion

    Func _WinAPI_PlayEnhMetaFile($hdc, $hemf, ByRef $trect)
        Local $acall = DllCall("gdi32.dll", "bool", "PlayEnhMetaFile", "handle", $hdc, "handle", $hemf, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PlayEnhMetaFile

    Func _WinAPI_PlgBlt($hdestdc, Const ByRef $APOINT, $hsrcdc, $ixsrc, $iysrc, $iwidth, $iheight, $hmask = 0x0, $ixmask = 0x0, $iymask = 0x0)
        If (UBound($APOINT) < 0x3) Or (UBound($APOINT, $UBOUND_COLUMNS) < 0x2) Then Return SetError(0xc, 0x0, False)
        Local $tpoints = DllStructCreate("long[2];long[2];long[2]")
        For $i = 0x0 To 0x2
            For $j = 0x0 To 0x1
                DllStructSetData($tpoints, $i + 0x1, $APOINT[$i][$j], $j + 0x1)
            Next
        Next
        Local $acall = DllCall("gdi32.dll", "bool", "PlgBlt", "handle", $hdestdc, "struct*", $tpoints, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidth, "int", $iheight, "handle", $hmask, "int", $ixmask, "int", $iymask)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PlgBlt

    Func _WinAPI_PolyBezier($hdc, Const ByRef $APOINT, $istart = 0x0, $IEND = + -1)
        If __CheckErrorArrayBounds($APOINT, $istart, $IEND, 0x2, 0x2) Then Return SetError(@error + 0xa, @extended, False)
        Local $ipoint = 0x1 + 0x3 * Floor(($IEND - $istart) / 0x3)
        If $ipoint < 0x1 Then Return SetError(0xf, 0x0, False)
        $IEND = $istart + $ipoint + -1
        Local $tagstruct = ''
        For $i = $istart To $IEND
            $tagstruct &= "long[2];"
        Next
        Local $tpoint = DllStructCreate($tagstruct)
        Local $icount = 0x0
        For $i = $istart To $IEND
            $icount += 0x1
            For $j = 0x0 To 0x1
                DllStructSetData($tpoint, $icount, $APOINT[$i][$j], $j + 0x1)
            Next
        Next
        Local $acall = DllCall("gdi32.dll", "bool", "PolyBezier", "handle", $hdc, "struct*", $tpoint, "dword", $ipoint)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PolyBezier

    Func _WinAPI_PolyBezierTo($hdc, Const ByRef $APOINT, $istart = 0x0, $IEND = + -1)
        If __CheckErrorArrayBounds($APOINT, $istart, $IEND, 0x2, 0x2) Then Return SetError(@error + 0xa, @extended, False)
        Local $ipoint = 0x3 * Floor(($IEND - $istart + 0x1) / 0x3)
        If $ipoint < 0x3 Then Return SetError(0xf, 0x0, False)
        $IEND = $istart + $ipoint + -1
        Local $tagstruct = ''
        For $i = $istart To $IEND
            $tagstruct &= "long[2];"
        Next
        Local $tpoint = DllStructCreate($tagstruct)
        Local $icount = 0x0
        For $i = $istart To $IEND
            $icount += 0x1
            For $j = 0x0 To 0x1
                DllStructSetData($tpoint, $icount, $APOINT[$i][$j], $j + 0x1)
            Next
        Next
        Local $acall = DllCall("gdi32.dll", "bool", "PolyBezierTo", "handle", $hdc, "struct*", $tpoint, "dword", $ipoint)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PolyBezierTo

    Func _WinAPI_PolyDraw($hdc, Const ByRef $APOINT, $istart = 0x0, $IEND = + -1)
        If __CheckErrorArrayBounds($APOINT, $istart, $IEND, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
        If UBound($APOINT, $UBOUND_COLUMNS) < 0x3 Then Return SetError(0xd, 0x0, False)
        Local $ipoint = $IEND - $istart + 0x1
        Local $tagstruct = ''
        For $i = $istart To $IEND
            $tagstruct &= "long[2];"
        Next
        Local $tpoint = DllStructCreate($tagstruct)
        Local $ttypes = DllStructCreate("byte[" & $ipoint & "]")
        Local $icount = 0x0
        For $i = $istart To $IEND
            $icount += 0x1
            For $j = 0x0 To 0x1
                DllStructSetData($tpoint, $icount, $APOINT[$i][$j], $j + 0x1)
            Next
            DllStructSetData($ttypes, 0x1, $APOINT[$i][0x2], $icount)
        Next
        Local $acall = DllCall("gdi32.dll", "bool", "PolyDraw", "handle", $hdc, "struct*", $tpoint, "struct*", $ttypes, "dword", $ipoint)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PolyDraw

    Func _WinAPI_Polygon($hdc, Const ByRef $APOINT, $istart = 0x0, $IEND = + -1)
        If __CheckErrorArrayBounds($APOINT, $istart, $IEND, 0x2, 0x2) Then Return SetError(@error + 0xa, @extended, False)
        Local $tagstruct = ''
        For $i = $istart To $IEND
            $tagstruct &= "int[2];"
        Next
        Local $tdata = DllStructCreate($tagstruct)
        Local $icount = 0x1
        For $i = $istart To $IEND
            For $j = 0x0 To 0x1
                DllStructSetData($tdata, $icount, $APOINT[$i][$j], $j + 0x1)
            Next
            $icount += 0x1
        Next
        Local $acall = DllCall("gdi32.dll", "bool", "Polygon", "handle", $hdc, "struct*", $tdata, "int", $icount + -1)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_Polygon

    Func _WinAPI_PtInRectEx($ix, $iy, $ileft, $itop, $iright, $ibottom)
        Local $trect = _WinAPI_CreateRect($ileft, $itop, $iright, $ibottom)
        Local $tpoint = _WinAPI_CreatePoint($ix, $iy)
        Local $acall = DllCall("user32.dll", "bool", "PtInRect", "struct*", $trect, "struct", $tpoint)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PtInRectEx

    Func _WinAPI_PtInRegion($hrgn, $ix, $iy)
        Local $acall = DllCall("gdi32.dll", "bool", "PtInRegion", "handle", $hrgn, "int", $ix, "int", $iy)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PtInRegion

    Func _WinAPI_PtVisible($hdc, $ix, $iy)
        Local $acall = DllCall("gdi32.dll", "bool", "PtVisible", "handle", $hdc, "int", $ix, "int", $iy)
        If @error Then Return SetError(@error + 0xa, @extended, 0x0)
        If $acall[0x0] = + -1 Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PtVisible

    Func _WinAPI_RadialGradientFill($hdc, $ix, $iy, $iradius, $irgb1, $irgb2, $fanglestart = 0x0, $fangleend = 0x168, $fstep = 0x5)
        If Abs($fanglestart) > 0x168 Then
            $fanglestart = Mod($fanglestart, 0x168)
        EndIf
        If Abs($fangleend) > 0x168 Then
            $fangleend = Mod($fangleend, 0x168)
        EndIf
        If ($fanglestart < 0x0) Or ($fangleend < 0x0) Then
            $fanglestart += 0x168
            $fangleend += 0x168
        EndIf
        If $fanglestart > $fangleend Then
            Local $fval = $fanglestart
            $fanglestart = $fangleend
            $fangleend = $fval
        EndIf
        If $fstep < 0x1 Then
            $fstep = 0x1
        EndIf
        Local $fki = ATan(0x1) / 0x2d
        Local $ixp = Round($ix + $iradius * Cos($fki * $fanglestart))
        Local $iyp = Round($iy + $iradius * Sin($fki * $fanglestart))
        Local $ixn, $iyn, $fan = $fanglestart
        Local $AVERTEX[0x3][0x3]
        While $fan < $fangleend
            $fan += $fstep
            If $fan > $fangleend Then
                $fan = $fangleend
            EndIf
            $ixn = Round($ix + $iradius * Cos($fki * $fan))
            $iyn = Round($iy + $iradius * Sin($fki * $fan))
            $AVERTEX[0x0][0x0] = $ix
            $AVERTEX[0x0][0x1] = $iy
            $AVERTEX[0x0][0x2] = $irgb1
            $AVERTEX[0x1][0x0] = $ixp
            $AVERTEX[0x1][0x1] = $iyp
            $AVERTEX[0x1][0x2] = $irgb2
            $AVERTEX[0x2][0x0] = $ixn
            $AVERTEX[0x2][0x1] = $iyn
            $AVERTEX[0x2][0x2] = $irgb2
            If Not _WinAPI_GradientFill($hdc, $AVERTEX, 0x0, 0x2) Then
                Return SetError(@error, @extended, 0x0)
            EndIf
            $ixp = $ixn
            $iyp = $iyn
        WEnd
        Return 0x1
    EndFunc    ; -> _WinAPI_RadialGradientFill

    Func _WinAPI_Rectangle($hdc, $trect)
        Local $acall = DllCall("gdi32.dll", "bool", "Rectangle", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4))
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_Rectangle

    Func _WinAPI_RectInRegion($hrgn, $trect)
        Local $acall = DllCall("gdi32.dll", "bool", "RectInRegion", "handle", $hrgn, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RectInRegion

    Func _WinAPI_RectIsEmpty(ByRef $trect)
        Return (DllStructGetData($trect, "Left") = 0x0) And (DllStructGetData($trect, "Top") = 0x0) And (DllStructGetData($trect, "Right") = 0x0) And (DllStructGetData($trect, "Bottom") = 0x0)
    EndFunc    ; -> _WinAPI_RectIsEmpty

    Func _WinAPI_RectVisible($hdc, $trect)
        Local $acall = DllCall("gdi32.dll", "bool", "RectVisible", "handle", $hdc, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        Switch $acall[0x0]
        Case 0x0, 0x1, 0x2
        Case Else
            Return SetError(0xa, $acall[0x0], 0x0)
        EndSwitch
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RectVisible

    Func _WinAPI_RemoveFontMemResourceEx($hfont)
        Local $acall = DllCall("gdi32.dll", "bool", "RemoveFontMemResourceEx", "handle", $hfont)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RemoveFontMemResourceEx

    Func _WinAPI_RemoveFontResourceEx($sfont, $IFLAG = 0x0, $bnotify = False)
        Local $acall = DllCall("gdi32.dll", "bool", "RemoveFontResourceExW", "wstr", $sfont, "dword", $IFLAG, "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
        If $bnotify Then
            Local Const $WM_FONTCHANGE = 0x1d
            Local Const $HWND_BROADCAST = 0xffff
            DllCall("user32.dll", "none", "SendMessage", "hwnd", $HWND_BROADCAST, "uint", $WM_FONTCHANGE, "wparam", 0x0, "lparam", 0x0)
        EndIf
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RemoveFontResourceEx

    Func _WinAPI_RGB($ired, $igreen, $iblue)
        Return __rgb(BitOR(BitShift($iblue, + -16), BitShift($igreen, + -8), $ired))
    EndFunc    ; -> _WinAPI_RGB

    Func _WinAPI_RotatePoints(ByRef $APOINT, $ixc, $iyc, $fangle, $istart = 0x0, $IEND = + -1)
        If __CheckErrorArrayBounds($APOINT, $istart, $IEND, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
        If UBound($APOINT, $UBOUND_COLUMNS) < 0x2 Then Return SetError(0xd, 0x0, 0x0)
        Local $fcos = Cos(ATan(0x1) / 0x2d * $fangle)
        Local $fsin = Sin(ATan(0x1) / 0x2d * $fangle)
        Local $ixn, $iyn
        For $i = $istart To $IEND
            $ixn = $APOINT[$i][0x0] - $ixc
            $iyn = $APOINT[$i][0x1] - $iyc
            $APOINT[$i][0x0] = $ixc + Round($ixn * $fcos - $iyn * $fsin)
            $APOINT[$i][0x1] = $iyc + Round($ixn * $fsin + $iyn * $fcos)
        Next
        Return 0x1
    EndFunc    ; -> _WinAPI_RotatePoints

    Func _WinAPI_RoundRect($hdc, $trect, $iwidth, $iheight)
        Local $acall = DllCall("gdi32.dll", "bool", "RoundRect", "handle", $hdc, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4), "int", $iwidth, "int", $iheight)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RoundRect

    Func _WinAPI_SaveHBITMAPToFile($sfilepath, $hbitmap, $ixpelspermeter = Default, $iypelspermeter = Default)
        Local $tbmp = DllStructCreate("align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset")
        Local $tdib = DllStructCreate($TAGDIBSECTION)
        Local $hdc, $hsv, $hsource = 0x0
        While $hbitmap
            If (Not _WinAPI_GetObject($hbitmap, DllStructGetSize($tdib), $tdib)) Or (DllStructGetData($tdib, "biCompression")) Then
                $hbitmap = 0x0
            Else
                Switch DllStructGetData($tdib, "bmBitsPixel")
                Case 0x20
                    If Not _WinAPI_IsAlphaBitmap($hbitmap) Then
                        If Not $hsource Then
                            $hsource = _WinAPI_CreateDIB(DllStructGetData($tdib, "bmWidth"), DllStructGetData($tdib, "bmHeight"), 0x18)
                            If Not $hsource Then
                                $hbitmap = 0x0
                            EndIf
                            $hdc = _WinAPI_CreateCompatibleDC(0x0)
                            $hsv = _WinAPI_SelectObject($hdc, $hsource)
                            If _WinAPI_DrawBitmap($hdc, 0x0, 0x0, $hbitmap) Then
                                $hbitmap = $hsource
                            Else
                                $hbitmap = 0x0
                            EndIf
                            _WinAPI_SelectObject($hdc, $hsv)
                            _WinAPI_DeleteDC($hdc)
                        Else
                            $hbitmap = 0x0
                        EndIf
                        ContinueLoop
                    EndIf
                Case Else
                EndSwitch
                If (Not DllStructGetData($tdib, "bmBits")) Or (Not DllStructGetData($tdib, "biSizeImage")) Then
                    If Not $hsource Then
                        $hbitmap = _WinAPI_CopyBitmap($hbitmap)
                        $hsource = $hbitmap
                    Else
                        $hbitmap = 0x0
                    EndIf
                Else
                    ExitLoop
                EndIf
            EndIf
        WEnd
        Local $hfile = 0x0, $ierror = 0x0, $iresult = 0x0
        Do
            If Not $hbitmap Then
                $ierror = 0x1
                ExitLoop
            EndIf
            Local $ADATA[0x4][0x2]
            $ADATA[0x0][0x0] = DllStructGetPtr($tbmp)
            $ADATA[0x0][0x1] = DllStructGetSize($tbmp)
            $ADATA[0x1][0x0] = DllStructGetPtr($tdib, "biSize")
            $ADATA[0x1][0x1] = 0x28
            $ADATA[0x2][0x1] = DllStructGetData($tdib, "biClrUsed") * 0x4
            Local $ttable = 0x0
            If $ADATA[0x2][0x1] Then
                $ttable = _WinAPI_GetDIBColorTable($hbitmap)
                If @error Or (@extended <> $ADATA[0x2][0x1] / 0x4) Then
                    $ierror = @error + 0xa
                    ExitLoop
                EndIf
            EndIf
            $ADATA[0x2][0x0] = DllStructGetPtr($ttable)
            $ADATA[0x3][0x0] = DllStructGetData($tdib, "bmBits")
            $ADATA[0x3][0x1] = DllStructGetData($tdib, "biSizeImage")
            DllStructSetData($tbmp, "bfType", 0x4d42)
            DllStructSetData($tbmp, "bfSize", $ADATA[0x0][0x1] + $ADATA[0x1][0x1] + $ADATA[0x2][0x1] + $ADATA[0x3][0x1])
            DllStructSetData($tbmp, "bfReserved1", 0x0)
            DllStructSetData($tbmp, "bfReserved2", 0x0)
            DllStructSetData($tbmp, "bfOffset", $ADATA[0x0][0x1] + $ADATA[0x1][0x1] + $ADATA[0x2][0x1])
            $hdc = _WinAPI_GetDC(0x0)
            If $ixpelspermeter = Default Then
                If Not DllStructGetData($tdib, "biXPelsPerMeter") Then
                    DllStructSetData($tdib, "biXPelsPerMeter", _WinAPI_GetDeviceCaps($hdc, 0x8) / _WinAPI_GetDeviceCaps($hdc, 0x4) * 0x3e8)
                EndIf
            Else
                DllStructSetData($tdib, "biXPelsPerMeter", $ixpelspermeter)
            EndIf
            If $iypelspermeter = Default Then
                If Not DllStructGetData($tdib, "biYPelsPerMeter") Then
                    DllStructSetData($tdib, "biYPelsPerMeter", _WinAPI_GetDeviceCaps($hdc, 0xa) / _WinAPI_GetDeviceCaps($hdc, 0x6) * 0x3e8)
                EndIf
            Else
                DllStructSetData($tdib, "biYPelsPerMeter", $iypelspermeter)
            EndIf
            _WinAPI_ReleaseDC(0x0, $hdc)
            $hfile = _WinAPI_CreateFile($sfilepath, 0x1, 0x4)
            If @error Then
                $ierror = @error + 0x14
                ExitLoop
            EndIf
            Local $ibytes
            For $i = 0x0 To 0x3
                If $ADATA[$i][0x1] Then
                    If Not _WinAPI_WriteFile($hfile, $ADATA[$i][0x0], $ADATA[$i][0x1], $ibytes) Then
                        $ierror = @error + 0x1e
                        ExitLoop 0x2
                    EndIf
                EndIf
            Next
            $iresult = 0x1
        Until 0x1
        If $hsource Then
            _WinAPI_DeleteObject($hsource)
        EndIf
        _WinAPI_CloseHandle($hfile)
        If Not $iresult Then
            FileDelete($sfilepath)
        EndIf
        Return SetError($ierror, 0x0, $iresult)
    EndFunc    ; -> _WinAPI_SaveHBITMAPToFile

    Func _WinAPI_SaveHICONToFile($sfilepath, Const ByRef $VICON, $BCOMPRESS = 0x0, $istart = 0x0, $IEND = + -1)
        Local $aicon, $atemp, $icount = 0x1
        If Not IsArray($VICON) Then
            Dim $aicon[0x1] = [$VICON]
            Dim $atemp[0x1] = [0x0]
        Else
            If __CheckErrorArrayBounds($VICON, $istart, $IEND) Then Return SetError(@error + 0xa, @extended, 0x0)
            $icount = $IEND - $istart + 0x1
            If $icount Then
                Dim $aicon[$icount]
                Dim $atemp[$icount]
                For $i = 0x0 To $icount + -1
                    $aicon[$i] = $VICON[$istart + $i]
                    $atemp[$i] = 0x0
                Next
            EndIf
        EndIf
        Local $hfile = _WinAPI_CreateFile($sfilepath, 0x1, 0x4)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $tico = DllStructCreate("align 1;ushort Reserved;ushort Type;ushort Count;byte Data[" & (0x10 * $icount) & "]")
        Local $ilength = DllStructGetSize($tico)
        Local $tbi = DllStructCreate($TAGBITMAPINFOHEADER)
        Local $tii = DllStructCreate($TAGICONINFO)
        Local $tdib = DllStructCreate($TAGDIBSECTION)
        Local $idib = DllStructGetSize($tdib)
        Local $pdib = DllStructGetPtr($tdib)
        Local $ioffset = $ilength
        DllStructSetData($tbi, "biSize", 0x28)
        DllStructSetData($tbi, "biPlanes", 0x1)
        DllStructSetData($tbi, "biXPelsPerMeter", 0x0)
        DllStructSetData($tbi, "biYPelsPerMeter", 0x0)
        DllStructSetData($tbi, "biClrUsed", 0x0)
        DllStructSetData($tbi, "biClrImportant", 0x0)
        DllStructSetData($tico, "Reserved", 0x0)
        DllStructSetData($tico, "Type", 0x1)
        DllStructSetData($tico, "Count", $icount)
        Local $iresult = 0x0, $ierror = 0x0, $ibytes
        Local $ainfo[0x8], $acall, $pdata = 0x0, $iindex = 0x0
        Local $asize[0x2], $tdata = 0x0
        Do
            If Not _WinAPI_WriteFile($hfile, $tico, $ilength, $ibytes) Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            While $icount > $iindex
                $acall = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $aicon[$iindex], "struct*", $tii)
                If @error Or Not $acall[0x0] Then
                    $ierror = @error + 0x28
                    ExitLoop 0x2
                EndIf
                For $i = 0x4 To 0x5
                    $ainfo[$i] = _WinAPI_CopyImage(DllStructGetData($tii, $i), 0x0, 0x0, 0x0, 0x2008)
                    If _WinAPI_GetObject($ainfo[$i], $idib, $pdib) Then
                        $ainfo[$i + -4] = DllStructGetData($tdib, "biSizeImage")
                        $ainfo[$i + -2] = DllStructGetData($tdib, "bmBits")
                    Else
                        $ierror = @error + 0x32
                    EndIf
                Next
                $ainfo[0x6] = 0x28
                $ainfo[0x7] = DllStructGetData($tdib, "bmBitsPixel")
                Switch $ainfo[0x7]
                Case 0x10, 0x18
                Case 0x20
                    If Not _WinAPI_IsAlphaBitmap($ainfo[0x5]) Then
                        If Not $atemp[$iindex] Then
                            $aicon[$iindex] = _WinAPI_Create32BitHICON($aicon[$iindex])
                            $atemp[$iindex] = $aicon[$iindex]
                            If Not @error Then
                                ContinueLoop
                            Else
                                ContinueCase
                            EndIf
                        EndIf
                    Else
                        If ($ainfo[0x1] >= 0x100 * 0x100 * 0x4) And ($BCOMPRESS) Then
                            $ibytes = _WinAPI_CompressBitmapBits($ainfo[0x5], $pdata)
                            If Not @error Then
                                $ainfo[0x0] = 0x0
                                $ainfo[0x1] = $ibytes
                                $ainfo[0x2] = 0x0
                                $ainfo[0x3] = $pdata
                                $ainfo[0x6] = 0x0
                            EndIf
                        EndIf
                    EndIf
                Case Else
                    $ierror = 0x3c
                EndSwitch
                If Not $ierror Then
                    $tdata = DllStructCreate("byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset", DllStructGetPtr($tico) + 0x6 + 0x10 * $iindex)
                    DllStructSetData($tdata, "ColorCount", 0x0)
                    DllStructSetData($tdata, "Reserved", 0x0)
                    DllStructSetData($tdata, "Planes", 0x1)
                    DllStructSetData($tdata, "BitCount", $ainfo[0x7])
                    DllStructSetData($tdata, "Size", $ainfo[0x0] + $ainfo[0x1] + $ainfo[0x6])
                    DllStructSetData($tdata, "Offset", $ioffset)
                    For $i = 0x0 To 0x1
                        $asize[$i] = DllStructGetData($tdib, $i + 0x2)
                        If $asize[$i] < 0x100 Then
                            DllStructSetData($tdata, $i + 0x1, $asize[$i])
                        Else
                            DllStructSetData($tdata, $i + 0x1, 0x0)
                        EndIf
                    Next
                    DllStructSetData($tbi, "biWidth", $asize[0x0])
                    DllStructSetData($tbi, "biHeight", 0x2 * $asize[0x1])
                    DllStructSetData($tbi, "biBitCount", $ainfo[0x7])
                    DllStructSetData($tbi, "biCompression", 0x0)
                    DllStructSetData($tbi, "biSizeImage", $ainfo[0x0] + $ainfo[0x1])
                    $ioffset += $ainfo[0x0] + $ainfo[0x1] + $ainfo[0x6]
                    Do
                        If $ainfo[0x6] Then
                            If Not _WinAPI_WriteFile($hfile, $tbi, $ainfo[0x6], $ibytes) Then
                                $ierror = @error + 0x46
                                ExitLoop
                            EndIf
                            For $i = 0x1 To 0x0 Step + -1
                                If Not _WinAPI_WriteFile($hfile, $ainfo[$i + 0x2], $ainfo[$i], $ibytes) Then
                                    $ierror = @error + 0x50
                                    ExitLoop 0x2
                                EndIf
                            Next
                        Else
                            If Not _WinAPI_WriteFile($hfile, $ainfo[0x3], $ainfo[0x1], $ibytes) Then
                                $ierror = @error + 0x5a
                                ExitLoop
                            EndIf
                        EndIf
                    Until 0x1
                EndIf
                For $i = 0x4 To 0x5
                    _WinAPI_DeleteObject($ainfo[$i])
                Next
                If $ierror Then
                    ExitLoop 0x2
                EndIf
                $iindex += 0x1
            WEnd
            $acall = DllCall("kernel32.dll", "bool", "SetFilePointerEx", "handle", $hfile, "int64", 0x0, "int64*", 0x0, "dword", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x64
                ExitLoop
            EndIf
            If Not _WinAPI_WriteFile($hfile, $tico, $ilength, $ibytes) Then
                $ierror = @error + 0x6e
                ExitLoop
            EndIf
            $iresult = 0x1
        Until 0x1
        For $i = 0x0 To $icount + -1
            If $atemp[$i] Then
                _WinAPI_DestroyIcon($atemp[$i])
            EndIf
        Next
        If $pdata Then
            __HeapFree($pdata)
        EndIf
        _WinAPI_CloseHandle($hfile)
        If Not $iresult Then
            FileDelete($sfilepath)
        EndIf
        Return SetError($ierror, 0x0, $iresult)
    EndFunc    ; -> _WinAPI_SaveHICONToFile

    Func _WinAPI_ScaleWindowExt($hdc, $ixnum, $ixdenom, $iynum, $iydenom)
        $__g_vext = DllStructCreate($TAGSIZE)
        Local $acall = DllCall("gdi32.dll", "bool", "ScaleWindowExtEx", "handle", $hdc, "int", $ixnum, "int", $ixdenom, "int", $iynum, "int", $iydenom, "struct*", $__g_vext)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ScaleWindowExt

    Func _WinAPI_SelectClipPath($hdc, $imode = 0x5)
        Local $acall = DllCall("gdi32.dll", "bool", "SelectClipPath", "handle", $hdc, "int", $imode)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SelectClipPath

    Func _WinAPI_SelectClipRgn($hdc, $hrgn)
        Local $acall = DllCall("gdi32.dll", "int", "SelectClipRgn", "handle", $hdc, "handle", $hrgn)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SelectClipRgn

    Func _WinAPI_SetArcDirection($hdc, $idirection)
        Local $acall = DllCall("gdi32.dll", "int", "SetArcDirection", "handle", $hdc, "int", $idirection)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetArcDirection

    Func _WinAPI_SetBitmapBits($hbitmap, $isize, $pbits)
        Local $acall = DllCall("gdi32.dll", "long", "SetBitmapBits", "handle", $hbitmap, "dword", $isize, "struct*", $pbits)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetBitmapBits

    Func _WinAPI_SetBitmapDimensionEx($hbitmap, $iwidth, $iheight)
        $__g_vext = DllStructCreate($TAGSIZE)
        Local $acall = DllCall("gdi32.dll", "bool", "SetBitmapDimensionEx", "handle", $hbitmap, "int", $iwidth, "int", $iheight, "struct*", $__g_vext)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetBitmapDimensionEx

    Func _WinAPI_SetBoundsRect($hdc, $IFLAGS, $trect = 0x0)
        Local $acall = DllCall("gdi32.dll", "uint", "SetBoundsRect", "handle", $hdc, "struct*", $trect, "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetBoundsRect

    Func _WinAPI_SetBrushOrg($hdc, $ix, $iy)
        $__g_vext = DllStructCreate($TAGPOINT)
        Local $acall = DllCall("gdi32.dll", "bool", "SetBrushOrgEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $__g_vext)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetBrushOrg

    Func _WinAPI_SetColorAdjustment($hdc, $tadjustment)
        Local $acall = DllCall("gdi32.dll", "bool", "SetColorAdjustment", "handle", $hdc, "struct*", $tadjustment)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetColorAdjustment

    Func _WinAPI_SetDCBrushColor($hdc, $irgb)
        Local $acall = DllCall("gdi32.dll", "dword", "SetDCBrushColor", "handle", $hdc, "dword", __rgb($irgb))
        If @error Or ($acall[0x0] = -1) Then Return SetError(@error, @extended, + -1)
        Return __rgb($acall[0x0])
    EndFunc    ; -> _WinAPI_SetDCBrushColor

    Func _WinAPI_SetDCPenColor($hdc, $irgb)
        Local $acall = DllCall("gdi32.dll", "dword", "SetDCPenColor", "handle", $hdc, "dword", __rgb($irgb))
        If @error Or ($acall[0x0] = -1) Then Return SetError(@error, @extended, + -1)
        Return __rgb($acall[0x0])
    EndFunc    ; -> _WinAPI_SetDCPenColor

    Func _WinAPI_SetDeviceGammaRamp($hdc, Const ByRef $aramp)
        If (UBound($aramp, $UBOUND_DIMENSIONS) <> 0x2) Or (UBound($aramp, $UBOUND_ROWS) <> 0x100) Or (UBound($aramp, $UBOUND_COLUMNS) <> 0x3) Then
            Return SetError(0xc, 0x0, 0x0)
        EndIf
        Local $tdata = DllStructCreate("ushort[256];ushort[256];ushort[256]")
        For $i = 0x0 To 0x2
            For $j = 0x0 To 0xff
                DllStructSetData($tdata, $i + 0x1, $aramp[$j][$i], $j + 0x1)
            Next
        Next
        Local $acall = DllCall("gdi32.dll", "bool", "SetDeviceGammaRamp", "handle", $hdc, "struct*", $tdata)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetDeviceGammaRamp

    Func _WinAPI_SetDIBColorTable($hbitmap, $tcolortable, $icolorcount)
        If $icolorcount > DllStructGetSize($tcolortable) / 0x4 Then Return SetError(0x1, 0x0, 0x0)
        Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
        Local $hsv = _WinAPI_SelectObject($hdc, $hbitmap)
        Local $ierror = 0x0
        Local $acall = DllCall("gdi32.dll", "uint", "SetDIBColorTable", "handle", $hdc, "uint", 0x0, "uint", $icolorcount, "struct*", $tcolortable)
        If @error Then $ierror = @error
        _WinAPI_SelectObject($hdc, $hsv)
        _WinAPI_DeleteDC($hdc)
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetDIBColorTable

    Func _WinAPI_SetDIBits($hdc, $hbitmap, $istartscan, $iscanlines, $pbits, $tbmi, $icoloruse = 0x0)
        Local $acall = DllCall("gdi32.dll", "int", "SetDIBits", "handle", $hdc, "handle", $hbitmap, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbmi, "INT", $icoloruse)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetDIBits

    Func _WinAPI_SetDIBitsToDevice($hdc, $ixdest, $iydest, $iwidth, $iheight, $ixsrc, $iysrc, $istartscan, $iscanlines, $tbitmapinfo, $iusage, $pbits)
        Local $acall = DllCall("gdi32.dll", "int", "SetDIBitsToDevice", "handle", $hdc, "int", $ixdest, "int", $iydest, "dword", $iwidth, "dword", $iheight, "int", $ixsrc, "int", $iysrc, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage)
        If @error Or ($acall[0x0] = + -1) Then Return SetError(@error + 0xa, $acall[0x0], 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetDIBitsToDevice

    Func _WinAPI_SetEnhMetaFileBits($pdata, $ilength)
        Local $acall = DllCall("gdi32.dll", "handle", "SetEnhMetaFileBits", "uint", $ilength, "struct*", $pdata)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetEnhMetaFileBits

    Func _WinAPI_SetGraphicsMode($hdc, $imode)
        Local $acall = DllCall("gdi32.dll", "int", "SetGraphicsMode", "handle", $hdc, "int", $imode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetGraphicsMode

    Func _WinAPI_SetMapMode($hdc, $imode)
        Local $acall = DllCall("gdi32.dll", "int", "SetMapMode", "handle", $hdc, "int", $imode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetMapMode

    Func _WinAPI_SetPixel($hdc, $ix, $iy, $irgb)
        Local $acall = DllCall("gdi32.dll", "bool", "SetPixelV", "handle", $hdc, "int", $ix, "int", $iy, "dword", __rgb($irgb))
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetPixel

    Func _WinAPI_SetPolyFillMode($hdc, $imode = 0x1)
        Local $acall = DllCall("gdi32.dll", "int", "SetPolyFillMode", "handle", $hdc, "int", $imode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetPolyFillMode

    Func _WinAPI_SetRectRgn($hrgn, $trect)
        Local $acall = DllCall("gdi32.dll", "bool", "SetRectRgn", "handle", $hrgn, "int", DllStructGetData($trect, 0x1), "int", DllStructGetData($trect, 0x2), "int", DllStructGetData($trect, 0x3), "int", DllStructGetData($trect, 0x4))
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetRectRgn

    Func _WinAPI_SetROP2($hdc, $imode)
        Local $acall = DllCall("gdi32.dll", "int", "SetROP2", "handle", $hdc, "int", $imode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetROP2

    Func _WinAPI_SetStretchBltMode($hdc, $imode)
        Local $acall = DllCall("gdi32.dll", "int", "SetStretchBltMode", "handle", $hdc, "int", $imode)
        If @error Or Not $acall[0x0] Or ($acall[0x0] = 0x57) Then Return SetError(@error + 0xa, $acall[0x0], 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetStretchBltMode

    Func _WinAPI_SetTextAlign($hdc, $imode = 0x0)
        Local $acall = DllCall("gdi32.dll", "uint", "SetTextAlign", "handle", $hdc, "uint", $imode)
        If @error Or ($acall[0x0] = -1) Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetTextAlign

    Func _WinAPI_SetTextCharacterExtra($hdc, $icharextra)
        Local $acall = DllCall("gdi32.dll", "int", "SetTextCharacterExtra", "handle", $hdc, "int", $icharextra)
        If @error Or ($acall[0x0] = -2147483648) Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetTextCharacterExtra

    Func _WinAPI_SetTextJustification($hdc, $ibreakextra, $ibreakcount)
        Local $acall = DllCall("gdi32.dll", "bool", "SetTextJustification", "handle", $hdc, "int", $ibreakextra, "int", $ibreakcount)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetTextJustification

    Func _WinAPI_SetUDFColorMode($imode)
        $__g_irgbmode = Not ($imode = 0x0)
    EndFunc    ; -> _WinAPI_SetUDFColorMode

    Func _WinAPI_SetWindowExt($hdc, $ixextent, $iyextent)
        $__g_vext = DllStructCreate($TAGSIZE)
        Local $acall = DllCall("gdi32.dll", "bool", "SetWindowExtEx", "handle", $hdc, "int", $ixextent, "int", $iyextent, "struct*", $__g_vext)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWindowExt

    Func _WinAPI_SetWindowOrg($hdc, $ix, $iy)
        $__g_vext = DllStructCreate($TAGPOINT)
        Local $acall = DllCall("gdi32.dll", "bool", "SetWindowOrgEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $__g_vext)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWindowOrg

    Func _WinAPI_SetWorldTransform($hdc, ByRef $txform)
        Local $acall = DllCall("gdi32.dll", "bool", "SetWorldTransform", "handle", $hdc, "struct*", $txform)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWorldTransform

    Func _WinAPI_StretchBlt($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $irop)
        Local $acall = DllCall("gdi32.dll", "bool", "StretchBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", $irop)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_StretchBlt

    Func _WinAPI_StretchDIBits($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $tbitmapinfo, $iusage, $pbits, $irop)
        Local $acall = DllCall("gdi32.dll", "int", "StretchDIBits", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage, "dword", $irop)
        If @error Or ($acall[0x0] = + -1) Then Return SetError(@error + 0xa, $acall[0x0], 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_StretchDIBits

    Func _WinAPI_StrokeAndFillPath($hdc)
        Local $acall = DllCall("gdi32.dll", "bool", "StrokeAndFillPath", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_StrokeAndFillPath

    Func _WinAPI_StrokePath($hdc)
        Local $acall = DllCall("gdi32.dll", "bool", "StrokePath", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_StrokePath

    Func _WinAPI_SubtractRect(ByRef $trect1, ByRef $trect2)
        Local $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("user32.dll", "bool", "SubtractRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_SubtractRect

    Func _WinAPI_TabbedTextOut($hdc, $ix, $iy, $stext, $atab = 0x0, $istart = 0x0, $IEND = + -1, $iorigin = 0x0)
        Local $itab, $icount
        If Not IsArray($atab) Then
            If $atab Then
                $itab = $atab
                Dim $atab[0x1] = [$itab]
                $istart = 0x0
                $IEND = 0x0
                $icount = 0x1
            Else
                $icount = 0x0
            EndIf
        Else
            $icount = 0x1
        EndIf
        Local $ttab = 0x0
        If $icount Then
            If __CheckErrorArrayBounds($atab, $istart, $IEND) Then Return SetError(@error + 0xa, @extended, 0x0)
            $icount = $IEND - $istart + 0x1
            $ttab = DllStructCreate("uint[" & $icount & "]")
            $itab = 0x1
            For $i = $istart To $IEND
                DllStructSetData($ttab, 0x1, $atab[$i], $itab)
                $itab += 0x1
            Next
        EndIf
        Local $acall = DllCall("user32.dll", "long", "TabbedTextOutW", "handle", $hdc, "int", $ix, "int", $iy, "wstr", $stext, "int", StringLen($stext), "int", $icount, "struct*", $ttab, "int", $iorigin)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        $__g_vext = _WinAPI_CreateSize(_WinAPI_LoWord($acall[0x0]), _WinAPI_HiWord($acall[0x0]))
        Return 0x1
    EndFunc    ; -> _WinAPI_TabbedTextOut

    Func _WinAPI_TextOut($hdc, $ix, $iy, $stext)
        Local $acall = DllCall("gdi32.dll", "bool", "TextOutW", "handle", $hdc, "int", $ix, "int", $iy, "wstr", $stext, "int", StringLen($stext))
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_TextOut

    Func _WinAPI_TransparentBlt($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $irgb)
        Local $acall = DllCall("gdi32.dll", "bool", "GdiTransparentBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", __rgb($irgb))
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_TransparentBlt

    Func _WinAPI_UnionRect(ByRef $trect1, ByRef $trect2)
        Local $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("user32.dll", "bool", "UnionRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, 0x0, 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_UnionRect

    Func _WinAPI_ValidateRect($hwnd, $trect = 0x0)
        Local $acall = DllCall("user32.dll", "bool", "ValidateRect", "hwnd", $hwnd, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ValidateRect

    Func _WinAPI_ValidateRgn($hwnd, $hrgn = 0x0)
        Local $acall = DllCall("user32.dll", "bool", "ValidateRgn", "hwnd", $hwnd, "handle", $hrgn)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ValidateRgn

    Func _WinAPI_WidenPath($hdc)
        Local $acall = DllCall("gdi32.dll", "bool", "WidenPath", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_WidenPath

    Func _WinAPI_WindowFromDC($hdc)
        Local $acall = DllCall("user32.dll", "hwnd", "WindowFromDC", "handle", $hdc)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_WindowFromDC

#EndRegion Public Functions
#Region Internal Functions
    Func __EnumDisplayMonitorsProc($hmonitor, $hdc, $PRECT, $lparam)
        #forceref $hDC, $lParam
        __Inc($__g_venum)
        $__g_venum[$__g_venum[0x0][0x0]][0x0] = $hmonitor
        If Not $PRECT Then
            $__g_venum[$__g_venum[0x0][0x0]][0x1] = 0x0
        Else
            $__g_venum[$__g_venum[0x0][0x0]][0x1] = DllStructCreate($TAGRECT)
            If Not _WinAPI_MoveMemory(DllStructGetPtr($__g_venum[$__g_venum[0x0][0x0]][0x1]), $PRECT, 0x10) Then Return 0x0
        EndIf
        Return 0x1
    EndFunc    ; -> __EnumDisplayMonitorsProc

    Func __EnumFontFamiliesProc($PELFEX, $PNTMEX, $IFONTTYPE, $PPATTERN)
        Local $telfex = DllStructCreate($TAGLOGFONT & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $PELFEX)
        Local $tntmex = DllStructCreate($TAGNEWTEXTMETRICEX, $PNTMEX)
        Local $tpattern = DllStructCreate("uint;uint;ptr", $PPATTERN)
        If $IFONTTYPE And Not BitAND($IFONTTYPE, DllStructGetData($tpattern, 0x1)) Then
            Return 0x1
        EndIf
        If DllStructGetData($tpattern, 0x3) Then
            Local $acall = DllCall("shlwapi.dll", "bool", "PathMatchSpecW", "ptr", DllStructGetPtr($telfex, 0xe), "ptr", DllStructGetData($tpattern, 0x3))
            If Not @error Then
                If DllStructGetData($tpattern, 0x2) Then
                    If $acall[0x0] Then
                        Return 0x1
                    Else
                    EndIf
                Else
                    If $acall[0x0] Then
                    Else
                        Return 0x1
                    EndIf
                EndIf
            EndIf
        EndIf
        __Inc($__g_venum)
        $__g_venum[$__g_venum[0x0][0x0]][0x0] = DllStructGetData($telfex, 0xe)
        $__g_venum[$__g_venum[0x0][0x0]][0x1] = DllStructGetData($telfex, 0x10)
        $__g_venum[$__g_venum[0x0][0x0]][0x2] = DllStructGetData($telfex, 0xf)
        $__g_venum[$__g_venum[0x0][0x0]][0x3] = DllStructGetData($telfex, 0x11)
        $__g_venum[$__g_venum[0x0][0x0]][0x4] = $IFONTTYPE
        $__g_venum[$__g_venum[0x0][0x0]][0x5] = DllStructGetData($tntmex, 0x13)
        $__g_venum[$__g_venum[0x0][0x0]][0x6] = DllStructGetData($tntmex, 0x14)
        $__g_venum[$__g_venum[0x0][0x0]][0x7] = DllStructGetData($tntmex, 0x15)
        Return 0x1
    EndFunc    ; -> __EnumFontFamiliesProc

    Func __EnumFontStylesProc($PELFEX, $PNTMEX, $IFONTTYPE, $PFN)
        #forceref $iFontType
        Local $telfex = DllStructCreate($TAGLOGFONT & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $PELFEX)
        Local $tntmex = DllStructCreate($TAGNEWTEXTMETRICEX, $PNTMEX)
        Local $tfn = DllStructCreate("dword;wchar[64]", $PFN)
        If BitAND(DllStructGetData($tntmex, "ntmFlags"), 0x61) = DllStructGetData($tfn, 0x1) Then
            DllStructSetData($tfn, 0x2, DllStructGetData($telfex, "FullName"))
            Return 0x0
        Else
            Return 0x1
        EndIf
    EndFunc    ; -> __EnumFontStylesProc

#EndRegion Internal Functions
Global $__g_hgdipbrush = 0x0
Global $__g_hgdipdll = 0x0
Global $__g_hgdippen = 0x0
Global $__g_igdipref = 0x0
Global $__g_igdiptoken = 0x0
Global $__g_bgdip_v1_0 = True
Func _GDIPlus_ArrowCapCreate($fheight, $fwidth, $bfilled = True)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateAdjustableArrowCap", "float", $fheight, "float", $fwidth, "bool", $bfilled, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x4]
EndFunc    ; -> _GDIPlus_ArrowCapCreate

Func _GDIPlus_ArrowCapDispose($hcap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeleteCustomLineCap", "handle", $hcap)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ArrowCapDispose

Func _GDIPlus_ArrowCapGetFillState($harrowcap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapFillState", "handle", $harrowcap, "bool*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ArrowCapGetFillState

Func _GDIPlus_ArrowCapGetHeight($harrowcap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapHeight", "handle", $harrowcap, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_ArrowCapGetHeight

Func _GDIPlus_ArrowCapGetMiddleInset($harrowcap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapMiddleInset", "handle", $harrowcap, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_ArrowCapGetMiddleInset

Func _GDIPlus_ArrowCapGetWidth($harrowcap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapWidth", "handle", $harrowcap, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_ArrowCapGetWidth

Func _GDIPlus_ArrowCapSetFillState($harrowcap, $bfilled = True)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapFillState", "handle", $harrowcap, "bool", $bfilled)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ArrowCapSetFillState

Func _GDIPlus_ArrowCapSetHeight($harrowcap, $fheight)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapHeight", "handle", $harrowcap, "float", $fheight)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ArrowCapSetHeight

Func _GDIPlus_ArrowCapSetMiddleInset($harrowcap, $finset)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapMiddleInset", "handle", $harrowcap, "float", $finset)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ArrowCapSetMiddleInset

Func _GDIPlus_ArrowCapSetWidth($harrowcap, $fwidth)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapWidth", "handle", $harrowcap, "float", $fwidth)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ArrowCapSetWidth

Func _GDIPlus_BitmapCloneArea($hbitmap, $nleft, $ntop, $nwidth, $nheight, $iformat = 0x21808)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCloneBitmapArea", "float", $nleft, "float", $ntop, "float", $nwidth, "float", $nheight, "int", $iformat, "handle", $hbitmap, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x7]
EndFunc    ; -> _GDIPlus_BitmapCloneArea

Func _GDIPlus_BitmapCreateDIBFromBitmap($hbitmap)
    Local $acall = DllCall($__g_hgdipdll, "uint", "GdipGetImageDimension", "handle", $hbitmap, "float*", 0x0, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $tdata = _GDIPlus_BitmapLockBits($hbitmap, 0x0, 0x0, $acall[0x2], $acall[0x3], $GDIP_ILMREAD, $GDIP_PXF32ARGB)
    Local $pbits = DllStructGetData($tdata, "Scan0")
    If Not $pbits Then Return 0x0
    Local $tbihdr = DllStructCreate($TAGBITMAPV5HEADER)
    DllStructSetData($tbihdr, "bV5Size", DllStructGetSize($tbihdr))
    DllStructSetData($tbihdr, "bV5Width", $acall[0x2])
    DllStructSetData($tbihdr, "bV5Height", $acall[0x3])
    DllStructSetData($tbihdr, "bV5Planes", 0x1)
    DllStructSetData($tbihdr, "bV5BitCount", 0x20)
    DllStructSetData($tbihdr, "bV5Compression", 0x0)
    DllStructSetData($tbihdr, "bV5SizeImage", $acall[0x3] * DllStructGetData($tdata, "Stride"))
    DllStructSetData($tbihdr, "bV5AlphaMask", -16777216)
    DllStructSetData($tbihdr, "bV5RedMask", 0xff0000)
    DllStructSetData($tbihdr, "bV5GreenMask", 0xff00)
    DllStructSetData($tbihdr, "bV5BlueMask", 0xff)
    DllStructSetData($tbihdr, "bV5CSType", 0x2)
    DllStructSetData($tbihdr, "bV5Intent", 0x4)
    Local $hhbitmapv5 = DllCall("gdi32.dll", "ptr", "CreateDIBSection", "hwnd", 0x0, "struct*", $tbihdr, "uint", 0x0, "ptr*", 0x0, "ptr", 0x0, "dword", 0x0)
    If Not @error And $hhbitmapv5[0x0] Then
        DllCall("gdi32.dll", "dword", "SetBitmapBits", "ptr", $hhbitmapv5[0x0], "dword", $acall[0x2] * $acall[0x3] * 0x4, "ptr", DllStructGetData($tdata, "Scan0"))
        $hhbitmapv5 = $hhbitmapv5[0x0]
    Else
        $hhbitmapv5 = 0x0
    EndIf
    _GDIPlus_BitmapUnlockBits($hbitmap, $tdata)
    $tdata = 0x0
    $tbihdr = 0x0
    Return $hhbitmapv5
EndFunc    ; -> _GDIPlus_BitmapCreateDIBFromBitmap

Func _GDIPlus_BitmapCreateFromFile($sfilename)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromFile", "wstr", $sfilename, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_BitmapCreateFromFile

Func _GDIPlus_BitmapCreateFromGraphics($iwidth, $iheight, $hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromGraphics", "int", $iwidth, "int", $iheight, "handle", $hgraphics, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x4]
EndFunc    ; -> _GDIPlus_BitmapCreateFromGraphics

Func _GDIPlus_BitmapCreateFromHBITMAP($hbitmap, $hpal = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromHBITMAP", "handle", $hbitmap, "handle", $hpal, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_BitmapCreateFromHBITMAP

Func _GDIPlus_BitmapCreateFromMemory($dimage, $bhbitmap = False)
    If Not IsBinary($dimage) Then Return SetError(0x1, 0x0, 0x0)
    Local Const $DMEMBITMAP = Binary($dimage)
    Local Const $ilen = BinaryLen($DMEMBITMAP)
    Local Const $GMEM_MOVEABLE = 0x2
    Local $acall = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $ilen)
    If @error Then Return SetError(0x4, 0x0, 0x0)
    Local Const $hdata = $acall[0x0]
    $acall = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hdata)
    If @error Then Return SetError(0x5, 0x0, 0x0)
    Local $tmem = DllStructCreate("byte[" & $ilen & "]", $acall[0x0])
    DllStructSetData($tmem, 0x1, $DMEMBITMAP)
    DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hdata)
    If @error Then Return SetError(0x6, 0x0, 0x0)
    Local Const $HSTREAM = _WinAPI_CreateStreamOnHGlobal($hdata)
    If @error Then Return SetError(0x2, 0x0, 0x0)
    Local Const $hbitmap = _GDIPlus_BitmapCreateFromStream($HSTREAM)
    If @error Then Return SetError(0x3, 0x0, 0x0)
    DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $HSTREAM, "ulong_ptr", 0x8 * (0x1 + @AutoItX64), "uint", 0x4, "ushort", 0x17, "uint", 0x0, "ptr", 0x0, "ptr", 0x0, "str", '')
    If $bhbitmap Then
        Local Const $HHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hbitmap)
        _GDIPlus_BitmapDispose($hbitmap)
        Return $HHBMP
    EndIf
    Return $hbitmap
EndFunc    ; -> _GDIPlus_BitmapCreateFromMemory

Func _GDIPlus_BitmapCreateFromResource($hinst, $vresourcename)
    Local $stype = "int"
    If IsString($vresourcename) Then $stype = "wstr"
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromResource", "handle", $hinst, $stype, $vresourcename, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_BitmapCreateFromResource

Func _GDIPlus_BitmapCreateFromScan0($iwidth, $iheight, $ipixelformat = $GDIP_PXF32ARGB, $istride = 0x0, $pscan0 = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "uint", "GdipCreateBitmapFromScan0", "int", $iwidth, "int", $iheight, "int", $istride, "int", $ipixelformat, "struct*", $pscan0, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x6]
EndFunc    ; -> _GDIPlus_BitmapCreateFromScan0

Func _GDIPlus_BitmapCreateFromStream($pstream)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromStream", "ptr", $pstream, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_BitmapCreateFromStream

Func _GDIPlus_BitmapCreateHBITMAPFromBitmap($hbitmap, $iargb = -16777216)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateHBITMAPFromBitmap", "handle", $hbitmap, "handle*", 0x0, "dword", $iargb)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_BitmapCreateHBITMAPFromBitmap

Func _GDIPlus_BitmapDispose($hbitmap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDisposeImage", "handle", $hbitmap)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_BitmapDispose

Func _GDIPlus_BitmapCreateFromHICON($hicon)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromHICON", "handle", $hicon, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_BitmapCreateFromHICON

Func _GDIPlus_BitmapCreateFromHICON32($hicon)
    Local $tsize = _WinAPI_GetIconDimension($hicon)
    Local $iwidth = DllStructGetData($tsize, "X")
    Local $iheight = DllStructGetData($tsize, "Y")
    If $iwidth <= 0x0 Or $iheight <= 0x0 Then Return SetError(0xa, + -1, 0x0)
    Local $tbitmapinfo = DllStructCreate("dword Size;long Width;long Height;word Planes;word BitCount;dword Compression;dword SizeImage;long XPelsPerMeter;long YPelsPerMeter;dword ClrUsed;dword ClrImpor" & _
        "tant;dword RGBQuad")
    DllStructSetData($tbitmapinfo, "Size", DllStructGetSize($tbitmapinfo) + -4)
    DllStructSetData($tbitmapinfo, "Width", $iwidth)
    DllStructSetData($tbitmapinfo, "Height", - $iheight)
    DllStructSetData($tbitmapinfo, "Planes", 0x1)
    DllStructSetData($tbitmapinfo, "BitCount", 0x20)
    DllStructSetData($tbitmapinfo, "Compression", 0x0)
    DllStructSetData($tbitmapinfo, "SizeImage", 0x0)
    Local $hdc = _WinAPI_CreateCompatibleDC(0x0)
    Local $pbits
    Local $hbmp = _WinAPI_CreateDIBSection(0x0, $tbitmapinfo, 0x0, $pbits)
    Local $horig = _WinAPI_SelectObject($hdc, $hbmp)
    _WinAPI_DrawIconEx($hdc, 0x0, 0x0, $hicon, $iwidth, $iheight)
    Local $hbitmapicon = _GDIPlus_BitmapCreateFromScan0($iwidth, $iheight, $GDIP_PXF32ARGB, $iwidth * 0x4, $pbits)
    Local $hbitmap = _GDIPlus_BitmapCreateFromScan0($iwidth, $iheight)
    Local $hcontext = _GDIPlus_ImageGetGraphicsContext($hbitmap)
    _GDIPlus_GraphicsDrawImage($hcontext, $hbitmapicon, 0x0, 0x0)
    _GDIPlus_GraphicsDispose($hcontext)
    _GDIPlus_BitmapDispose($hbitmapicon)
    _WinAPI_SelectObject($hdc, $horig)
    _WinAPI_DeleteDC($hdc)
    _WinAPI_DeleteObject($hbmp)
    Return $hbitmap
EndFunc    ; -> _GDIPlus_BitmapCreateFromHICON32

Func _GDIPlus_BitmapGetPixel($hbitmap, $ix, $iy)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipBitmapGetPixel", "handle", $hbitmap, "int", $ix, "int", $iy, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x4]
EndFunc    ; -> _GDIPlus_BitmapGetPixel

Func _GDIPlus_BitmapLockBits($hbitmap, $ileft, $itop, $iwidth, $iheight, $IFLAGS = $GDIP_ILMREAD, $iformat = $GDIP_PXF32RGB)
    Local $tdata = DllStructCreate($TAGGDIPBITMAPDATA)
    Local $trect = DllStructCreate($TAGRECT)
    DllStructSetData($trect, "Left", $ileft)
    DllStructSetData($trect, "Top", $itop)
    DllStructSetData($trect, "Right", $iwidth)
    DllStructSetData($trect, "Bottom", $iheight)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipBitmapLockBits", "handle", $hbitmap, "struct*", $trect, "uint", $IFLAGS, "int", $iformat, "struct*", $tdata)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $tdata
EndFunc    ; -> _GDIPlus_BitmapLockBits

Func _GDIPlus_BitmapSetPixel($hbitmap, $ix, $iy, $iargb)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipBitmapSetPixel", "handle", $hbitmap, "int", $ix, "int", $iy, "uint", $iargb)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_BitmapSetPixel

Func _GDIPlus_BitmapSetResolution($hbitmap, $fdpix, $fdpiy)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipBitmapSetResolution", "handle", $hbitmap, "float", $fdpix, "float", $fdpiy)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_BitmapSetResolution

Func _GDIPlus_BitmapUnlockBits($hbitmap, $tbitmapdata)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipBitmapUnlockBits", "handle", $hbitmap, "struct*", $tbitmapdata)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_BitmapUnlockBits

Func _GDIPlus_BrushClone($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCloneBrush", "handle", $hbrush, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_BrushClone

Func _GDIPlus_BrushCreateSolid($iargb = -16777216)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateSolidFill", "int", $iargb, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_BrushCreateSolid

Func _GDIPlus_BrushDispose($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeleteBrush", "handle", $hbrush)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_BrushDispose

Func _GDIPlus_BrushGetSolidColor($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetSolidFillColor", "handle", $hbrush, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_BrushGetSolidColor

Func _GDIPlus_BrushGetType($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetBrushType", "handle", $hbrush, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_BrushGetType

Func _GDIPlus_BrushSetSolidColor($hbrush, $iargb = -16777216)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetSolidFillColor", "handle", $hbrush, "dword", $iargb)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_BrushSetSolidColor

Func _GDIPlus_ColorMatrixCreate()
    Return _GDIPlus_ColorMatrixCreateScale(0x1, 0x1, 0x1, 0x1)
EndFunc    ; -> _GDIPlus_ColorMatrixCreate

Func _GDIPlus_ColorMatrixCreateGrayScale()
    Local $ii, $ij, $tcm, $alums[0x4] = [$GDIP_RLUM, $GDIP_GLUM, $GDIP_BLUM, 0x0]
    $tcm = DllStructCreate($TAGGDIPCOLORMATRIX)
    For $ii = 0x0 To 0x3
        For $ij = 0x1 To 0x3
            DllStructSetData($tcm, "m", $alums[$ii], $ii * 0x5 + $ij)
        Next
    Next
    DllStructSetData($tcm, "m", 0x1, 0x13)
    DllStructSetData($tcm, "m", 0x1, 0x19)
    Return $tcm
EndFunc    ; -> _GDIPlus_ColorMatrixCreateGrayScale

Func _GDIPlus_ColorMatrixCreateNegative()
    Local $ii, $tcm
    $tcm = _GDIPlus_ColorMatrixCreateScale(+ -1, + -1, + -1, 0x1)
    For $ii = 0x1 To 0x4
        DllStructSetData($tcm, "m", 0x1, 0x14 + $ii)
    Next
    Return $tcm
EndFunc    ; -> _GDIPlus_ColorMatrixCreateNegative

Func _GDIPlus_ColorMatrixCreateSaturation($fsat)
    Local $fsatcomp, $tcm
    $tcm = DllStructCreate($TAGGDIPCOLORMATRIX)
    $fsatcomp = (0x1 - $fsat)
    DllStructSetData($tcm, "m", $fsatcomp * $GDIP_RLUM + $fsat, 0x1)
    DllStructSetData($tcm, "m", $fsatcomp * $GDIP_RLUM, 0x2)
    DllStructSetData($tcm, "m", $fsatcomp * $GDIP_RLUM, 0x3)
    DllStructSetData($tcm, "m", $fsatcomp * $GDIP_GLUM, 0x6)
    DllStructSetData($tcm, "m", $fsatcomp * $GDIP_GLUM + $fsat, 0x7)
    DllStructSetData($tcm, "m", $fsatcomp * $GDIP_GLUM, 0x8)
    DllStructSetData($tcm, "m", $fsatcomp * $GDIP_BLUM, 0xb)
    DllStructSetData($tcm, "m", $fsatcomp * $GDIP_BLUM, 0xc)
    DllStructSetData($tcm, "m", $fsatcomp * $GDIP_BLUM + $fsat, 0xd)
    DllStructSetData($tcm, "m", 0x1, 0x13)
    DllStructSetData($tcm, "m", 0x1, 0x19)
    Return $tcm
EndFunc    ; -> _GDIPlus_ColorMatrixCreateSaturation

Func _GDIPlus_ColorMatrixCreateScale($fred, $fgreen, $fblue, $falpha = 0x1)
    Local $tcm
    $tcm = DllStructCreate($TAGGDIPCOLORMATRIX)
    DllStructSetData($tcm, "m", $fred, 0x1)
    DllStructSetData($tcm, "m", $fgreen, 0x7)
    DllStructSetData($tcm, "m", $fblue, 0xd)
    DllStructSetData($tcm, "m", $falpha, 0x13)
    DllStructSetData($tcm, "m", 0x1, 0x19)
    Return $tcm
EndFunc    ; -> _GDIPlus_ColorMatrixCreateScale

Func _GDIPlus_ColorMatrixCreateTranslate($fred, $fgreen, $fblue, $falpha = 0x0)
    Local $ii, $tcm, $afactors[0x4] = [$fred, $fgreen, $fblue, $falpha]
    $tcm = _GDIPlus_ColorMatrixCreate()
    For $ii = 0x0 To 0x3
        DllStructSetData($tcm, "m", $afactors[$ii], 0x15 + $ii)
    Next
    Return $tcm
EndFunc    ; -> _GDIPlus_ColorMatrixCreateTranslate

Func _GDIPlus_CustomLineCapClone($hcustomlinecap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCloneCustomLineCap", "handle", $hcustomlinecap, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_CustomLineCapClone

Func _GDIPlus_CustomLineCapCreate($hpathfill, $hpathstroke, $ilinecap = 0x0, $nbaseinset = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateCustomLineCap", "handle", $hpathfill, "handle", $hpathstroke, "int", $ilinecap, "float", $nbaseinset, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x5]
EndFunc    ; -> _GDIPlus_CustomLineCapCreate

Func _GDIPlus_CustomLineCapDispose($hcap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeleteCustomLineCap", "handle", $hcap)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_CustomLineCapDispose

Func _GDIPlus_CustomLineCapGetStrokeCaps($hcustomlinecap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetCustomLineCapStrokeCaps", "hwnd", $hcustomlinecap, "ptr*", 0x0, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then SetError(0xa, $acall[0x0], 0x0)
    Local $acaps[0x2]
    $acaps[0x0] = $acall[0x2]
    $acaps[0x1] = $acall[0x3]
    Return $acaps
EndFunc    ; -> _GDIPlus_CustomLineCapGetStrokeCaps

Func _GDIPlus_CustomLineCapSetStrokeCaps($hcustomlinecap, $istartcap, $iendcap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetCustomLineCapStrokeCaps", "handle", $hcustomlinecap, "int", $istartcap, "int", $iendcap)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_CustomLineCapSetStrokeCaps

Func _GDIPlus_Decoders()
    Local $icount = _GDIPlus_DecodersGetCount()
    Local $isize = _GDIPlus_DecodersGetSize()
    Local $tbuffer = DllStructCreate("byte[" & $isize & "]")
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageDecoders", "uint", $icount, "uint", $isize, "struct*", $tbuffer)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $pbuffer = DllStructGetPtr($tbuffer)
    Local $tcodec, $ainfo[$icount + 0x1][0xe]
    $ainfo[0x0][0x0] = $icount
    For $ii = 0x1 To $icount
        $tcodec = DllStructCreate($TAGGDIPIMAGECODECINFO, $pbuffer)
        $ainfo[$ii][0x1] = _WinAPI_StringFromGUID(DllStructGetPtr($tcodec, "CLSID"))
        $ainfo[$ii][0x2] = _WinAPI_StringFromGUID(DllStructGetPtr($tcodec, "FormatID"))
        $ainfo[$ii][0x3] = _WinAPI_GetString(DllStructGetData($tcodec, "CodecName"))
        $ainfo[$ii][0x4] = _WinAPI_GetString(DllStructGetData($tcodec, "DllName"))
        $ainfo[$ii][0x5] = _WinAPI_GetString(DllStructGetData($tcodec, "FormatDesc"))
        $ainfo[$ii][0x6] = _WinAPI_GetString(DllStructGetData($tcodec, "FileExt"))
        $ainfo[$ii][0x7] = _WinAPI_GetString(DllStructGetData($tcodec, "MimeType"))
        $ainfo[$ii][0x8] = DllStructGetData($tcodec, "Flags")
        $ainfo[$ii][0x9] = DllStructGetData($tcodec, "Version")
        $ainfo[$ii][0xa] = DllStructGetData($tcodec, "SigCount")
        $ainfo[$ii][0xb] = DllStructGetData($tcodec, "SigSize")
        $ainfo[$ii][0xc] = DllStructGetData($tcodec, "SigPattern")
        $ainfo[$ii][0xd] = DllStructGetData($tcodec, "SigMask")
        $pbuffer += DllStructGetSize($tcodec)
    Next
    Return $ainfo
EndFunc    ; -> _GDIPlus_Decoders

Func _GDIPlus_DecodersGetCount()
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageDecodersSize", "uint*", 0x0, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x1]
EndFunc    ; -> _GDIPlus_DecodersGetCount

Func _GDIPlus_DecodersGetSize()
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageDecodersSize", "uint*", 0x0, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_DecodersGetSize

Func _GDIPlus_DrawImagePoints($hgraphic, $himage, $nulx, $nuly, $nurx, $nury, $nllx, $nlly, $icount = 0x3)
    Local $tpoint = DllStructCreate("float X;float Y;float X2;float Y2;float X3;float Y3")
    DllStructSetData($tpoint, "X", $nulx)
    DllStructSetData($tpoint, "Y", $nuly)
    DllStructSetData($tpoint, "X2", $nurx)
    DllStructSetData($tpoint, "Y2", $nury)
    DllStructSetData($tpoint, "X3", $nllx)
    DllStructSetData($tpoint, "Y3", $nlly)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawImagePoints", "handle", $hgraphic, "handle", $himage, "struct*", $tpoint, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_DrawImagePoints

Func _GDIPlus_Encoders()
    Local $icount = _GDIPlus_EncodersGetCount()
    Local $isize = _GDIPlus_EncodersGetSize()
    Local $tbuffer = DllStructCreate("byte[" & $isize & "]")
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageEncoders", "uint", $icount, "uint", $isize, "struct*", $tbuffer)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $pbuffer = DllStructGetPtr($tbuffer)
    Local $tcodec, $ainfo[$icount + 0x1][0xe]
    $ainfo[0x0][0x0] = $icount
    For $ii = 0x1 To $icount
        $tcodec = DllStructCreate($TAGGDIPIMAGECODECINFO, $pbuffer)
        $ainfo[$ii][0x1] = _WinAPI_StringFromGUID(DllStructGetPtr($tcodec, "CLSID"))
        $ainfo[$ii][0x2] = _WinAPI_StringFromGUID(DllStructGetPtr($tcodec, "FormatID"))
        $ainfo[$ii][0x3] = _WinAPI_GetString(DllStructGetData($tcodec, "CodecName"))
        $ainfo[$ii][0x4] = _WinAPI_GetString(DllStructGetData($tcodec, "DllName"))
        $ainfo[$ii][0x5] = _WinAPI_GetString(DllStructGetData($tcodec, "FormatDesc"))
        $ainfo[$ii][0x6] = _WinAPI_GetString(DllStructGetData($tcodec, "FileExt"))
        $ainfo[$ii][0x7] = _WinAPI_GetString(DllStructGetData($tcodec, "MimeType"))
        $ainfo[$ii][0x8] = DllStructGetData($tcodec, "Flags")
        $ainfo[$ii][0x9] = DllStructGetData($tcodec, "Version")
        $ainfo[$ii][0xa] = DllStructGetData($tcodec, "SigCount")
        $ainfo[$ii][0xb] = DllStructGetData($tcodec, "SigSize")
        $ainfo[$ii][0xc] = DllStructGetData($tcodec, "SigPattern")
        $ainfo[$ii][0xd] = DllStructGetData($tcodec, "SigMask")
        $pbuffer += DllStructGetSize($tcodec)
    Next
    Return $ainfo
EndFunc    ; -> _GDIPlus_Encoders

Func _GDIPlus_EncodersGetCLSID($sfileextension)
    Local $aencoders = _GDIPlus_Encoders()
    If @error Then Return SetError(@error, 0x0, '')
    For $ii = 0x1 To $aencoders[0x0][0x0]
        If StringInStr($aencoders[$ii][0x6], "*." & $sfileextension) > 0x0 Then Return $aencoders[$ii][0x1]
    Next
    Return SetError(+ -1, + -1, '')
EndFunc    ; -> _GDIPlus_EncodersGetCLSID

Func _GDIPlus_EncodersGetCount()
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageEncodersSize", "uint*", 0x0, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x1]
EndFunc    ; -> _GDIPlus_EncodersGetCount

Func _GDIPlus_EncodersGetParamList($himage, $sencoder)
    Local $isize = _GDIPlus_EncodersGetParamListSize($himage, $sencoder)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $tguid = _WinAPI_GUIDFromString($sencoder)
    Local $iremainingsize = $isize + -4 - _GDIPlus_ParamSize()
    Local $tbuffer
    If $iremainingsize Then
        $tbuffer = DllStructCreate("dword Count;" & $TAGGDIPENCODERPARAM & ";byte [" & $iremainingsize & "]")
    Else
        $tbuffer = DllStructCreate("dword Count;" & $TAGGDIPENCODERPARAM)
    EndIf
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetEncoderParameterList", "handle", $himage, "struct*", $tguid, "uint", $isize, "struct*", $tbuffer)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $tbuffer
EndFunc    ; -> _GDIPlus_EncodersGetParamList

Func _GDIPlus_EncodersGetParamListSize($himage, $sencoder)
    Local $tguid = _WinAPI_GUIDFromString($sencoder)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetEncoderParameterListSize", "handle", $himage, "struct*", $tguid, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_EncodersGetParamListSize

Func _GDIPlus_EncodersGetSize()
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageEncodersSize", "uint*", 0x0, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_EncodersGetSize

Func _GDIPlus_FontCreate($hfamily, $fsize, $istyle = 0x0, $iunit = 0x3)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateFont", "handle", $hfamily, "float", $fsize, "int", $istyle, "int", $iunit, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x5]
EndFunc    ; -> _GDIPlus_FontCreate

Func _GDIPlus_FontDispose($hfont)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeleteFont", "handle", $hfont)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_FontDispose

Func _GDIPlus_FontFamilyCreate($sfamily, $pcollection = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateFontFamilyFromName", "wstr", $sfamily, "ptr", $pcollection, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_FontFamilyCreate

Func _GDIPlus_FontFamilyCreateFromCollection($sfontname, $hfontcollection)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateFontFamilyFromName", "wstr", $sfontname, "ptr", $hfontcollection, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, '')
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_FontFamilyCreateFromCollection

Func _GDIPlus_FontFamilyDispose($hfamily)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeleteFontFamily", "handle", $hfamily)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_FontFamilyDispose

Func _GDIPlus_FontFamilyGetCellAscent($hfontfamily, $istyle = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetCellAscent", "handle", $hfontfamily, "int", $istyle, "ushort*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_FontFamilyGetCellAscent

Func _GDIPlus_FontFamilyGetCellDescent($hfontfamily, $istyle = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetCellDescent", "handle", $hfontfamily, "int", $istyle, "ushort*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_FontFamilyGetCellDescent

Func _GDIPlus_FontFamilyGetEmHeight($hfontfamily, $istyle = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetEmHeight", "handle", $hfontfamily, "int", $istyle, "ushort*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_FontFamilyGetEmHeight

Func _GDIPlus_FontFamilyGetLineSpacing($hfontfamily, $istyle = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetLineSpacing", "handle", $hfontfamily, "int", $istyle, "ushort*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_FontFamilyGetLineSpacing

Func _GDIPlus_FontGetHeight($hfont, $hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetFontHeight", "handle", $hfont, "handle", $hgraphics, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_FontGetHeight

Func _GDIPlus_FontPrivateAddFont($hfontcollection, $sfontfile)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipPrivateAddFontFile", "ptr", $hfontcollection, "wstr", $sfontfile)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_FontPrivateAddFont

Func _GDIPlus_FontPrivateAddMemoryFont($hfontcollection, $tfont)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipPrivateAddMemoryFont", "handle", $hfontcollection, "struct*", $tfont, "int", DllStructGetSize($tfont))
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_FontPrivateAddMemoryFont

Func _GDIPlus_FontPrivateCollectionDispose($hfontcollection)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeletePrivateFontCollection", "handle*", $hfontcollection)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_FontPrivateCollectionDispose

Func _GDIPlus_FontPrivateCreateCollection()
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipNewPrivateFontCollection", "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x1]
EndFunc    ; -> _GDIPlus_FontPrivateCreateCollection

Func _GDIPlus_GraphicsClear($hgraphics, $iargb = -16777216)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGraphicsClear", "handle", $hgraphics, "dword", $iargb)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsClear

Func _GDIPlus_GraphicsCreateFromHDC($hdc)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateFromHDC", "handle", $hdc, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_GraphicsCreateFromHDC

Func _GDIPlus_GraphicsCreateFromHWND($hwnd)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateFromHWND", "hwnd", $hwnd, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_GraphicsCreateFromHWND

Func _GDIPlus_GraphicsDispose($hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeleteGraphics", "handle", $hgraphics)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDispose

Func _GDIPlus_GraphicsDrawArc($hgraphics, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle, $hpen = 0x0)
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawArc", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawArc

Func _GDIPlus_GraphicsDrawBezier($hgraphics, $nx1, $ny1, $nx2, $ny2, $nx3, $ny3, $nx4, $ny4, $hpen = 0x0)
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawBezier", "handle", $hgraphics, "handle", $hpen, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2, "float", $nx3, "float", $ny3, "float", $nx4, "float", $ny4)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawBezier

Func _GDIPlus_GraphicsDrawClosedCurve($hgraphics, $apoints, $hpen = 0x0)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawClosedCurve", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawClosedCurve

Func _GDIPlus_GraphicsDrawClosedCurve2($hgraphics, $apoints, $ntension, $hpen = 0x0)
    Local $ii, $icount, $tpoints, $acall
    __GDIPlus_PenDefCreate($hpen)
    $icount = $apoints[0x0][0x0]
    $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    $acall = DllCall($__g_hgdipdll, "int", "GdipDrawClosedCurve2", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount, "float", $ntension)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawClosedCurve2

Func _GDIPlus_GraphicsDrawCurve($hgraphics, $apoints, $hpen = 0x0)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawCurve", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawCurve

Func _GDIPlus_GraphicsDrawCurve2($hgraphics, $apoints, $ntension, $hpen = 0x0)
    Local $ii, $icount, $tpoints, $acall
    __GDIPlus_PenDefCreate($hpen)
    $icount = $apoints[0x0][0x0]
    $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    $acall = DllCall($__g_hgdipdll, "int", "GdipDrawCurve2", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount, "float", $ntension)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawCurve2

Func _GDIPlus_GraphicsDrawEllipse($hgraphics, $nx, $ny, $nwidth, $nheight, $hpen = 0x0)
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawEllipse", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawEllipse

Func _GDIPlus_GraphicsDrawImage($hgraphics, $himage, $nx, $ny)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawImage", "handle", $hgraphics, "handle", $himage, "float", $nx, "float", $ny)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawImage

Func _GDIPlus_GraphicsDrawImagePointsRect($hgraphics, $himage, $nulx, $nuly, $nurx, $nury, $nllx, $nlly, $nsrcx, $nsrcy, $nsrcwidth, $nsrcheight, $himageattributes = 0x0, $iunit = 0x2)
    Local $tpoints = DllStructCreate("float X; float Y; float X2; float Y2; float X3; float Y3;")
    DllStructSetData($tpoints, "X", $nulx)
    DllStructSetData($tpoints, "Y", $nuly)
    DllStructSetData($tpoints, "X2", $nurx)
    DllStructSetData($tpoints, "Y2", $nury)
    DllStructSetData($tpoints, "X3", $nllx)
    DllStructSetData($tpoints, "Y3", $nlly)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawImagePointsRect", "handle", $hgraphics, "handle", $himage, "struct*", $tpoints, "int", 0x3, "float", $nsrcx, "float", $nsrcy, "float", $nsrcwidth, "float", $nsrcheight, "int", $iunit, "handle", $himageattributes, "ptr", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawImagePointsRect

Func _GDIPlus_GraphicsDrawImageRect($hgraphics, $himage, $nx, $ny, $nw, $nh)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawImageRect", "handle", $hgraphics, "handle", $himage, "float", $nx, "float", $ny, "float", $nw, "float", $nh)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawImageRect

Func _GDIPlus_GraphicsDrawImageRectRect($hgraphics, $himage, $nsrcx, $nsrcy, $nsrcwidth, $nsrcheight, $ndstx, $ndsty, $ndstwidth, $ndstheight, $pattributes = 0x0, $iunit = 0x2)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawImageRectRect", "handle", $hgraphics, "handle", $himage, "float", $ndstx, "float", $ndsty, "float", $ndstwidth, "float", $ndstheight, "float", $nsrcx, "float", $nsrcy, "float", $nsrcwidth, "float", $nsrcheight, "int", $iunit, "handle", $pattributes, "ptr", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawImageRectRect

Func _GDIPlus_GraphicsDrawLine($hgraphics, $nx1, $ny1, $nx2, $ny2, $hpen = 0x0)
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawLine", "handle", $hgraphics, "handle", $hpen, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawLine

Func _GDIPlus_GraphicsDrawPath($hgraphics, $hpath, $hpen = 0x0)
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawPath", "handle", $hgraphics, "handle", $hpen, "handle", $hpath)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawPath

Func _GDIPlus_GraphicsDrawPie($hgraphics, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle, $hpen = 0x0)
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawPie", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawPie

Func _GDIPlus_GraphicsDrawPolygon($hgraphics, $apoints, $hpen = 0x0)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawPolygon", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawPolygon

Func _GDIPlus_GraphicsDrawRect($hgraphics, $nx, $ny, $nwidth, $nheight, $hpen = 0x0)
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawRectangle", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawRect

Func _GDIPlus_GraphicsDrawString($hgraphics, $sstring, $nx, $ny, $sfont = Default, $fsize = Default, $iformat = Default, $iargb = Default)
    If $sfont = Default Then $sfont = "Arial"
    If $fsize = Default Then $fsize = 0xa
    If $iformat = Default Then $iformat = 0x0
    If $iargb = Default Then $iargb = -16777216
    If BitAND($iargb, -16777216) = 0x0 Then $iargb = BitOR($iargb, -16777216)
    Local $hbrush = _GDIPlus_BrushCreateSolid($iargb)
    Local $hformat = _GDIPlus_StringFormatCreate($iformat)
    Local $hfamily = _GDIPlus_FontFamilyCreate($sfont)
    Local $hfont = _GDIPlus_FontCreate($hfamily, $fsize)
    Local $tlayout = _GDIPlus_RectFCreate($nx, $ny, 0, 0)
    Local $ainfo = _GDIPlus_GraphicsMeasureString($hgraphics, $sstring, $hfont, $tlayout, $hformat)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $aresult = _GDIPlus_GraphicsDrawStringEx($hgraphics, $sstring, $hfont, $ainfo[0x0], $hformat, $hbrush)
    Local $ierror = @error, $iextended = @extended
    _GDIPlus_FontDispose($hfont)
    _GDIPlus_FontFamilyDispose($hfamily)
    _GDIPlus_StringFormatDispose($hformat)
    _GDIPlus_BrushDispose($hbrush)
    Return SetError($ierror, $iextended, $aresult)
EndFunc    ; -> _GDIPlus_GraphicsDrawString

Func _GDIPlus_GraphicsDrawStringEx($hgraphics, $sstring, $hfont, $tlayout, $hformat, $hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawString", "handle", $hgraphics, "wstr", $sstring, "int", + -1, "handle", $hfont, "struct*", $tlayout, "handle", $hformat, "handle", $hbrush)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsDrawStringEx

Func _GDIPlus_GraphicsFillClosedCurve($hgraphics, $apoints, $hbrush = 0x0)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    __GDIPlus_BrushDefCreate($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipFillClosedCurve", "handle", $hgraphics, "handle", $hbrush, "struct*", $tpoints, "int", $icount)
    __GDIPlus_BrushDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsFillClosedCurve

Func _GDIPlus_GraphicsFillClosedCurve2($hgraphics, $apoints, $ntension, $hbrush = 0x0, $ifillmode = 0x0)
    Local $ii, $icount, $tpoints, $acall
    __GDIPlus_BrushDefCreate($hbrush)
    $icount = $apoints[0x0][0x0]
    $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    $acall = DllCall($__g_hgdipdll, "int", "GdipFillClosedCurve2", "handle", $hgraphics, "handle", $hbrush, "struct*", $tpoints, "int", $icount, "float", $ntension, "int", $ifillmode)
    __GDIPlus_BrushDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsFillClosedCurve2

Func _GDIPlus_GraphicsFillEllipse($hgraphics, $nx, $ny, $nwidth, $nheight, $hbrush = 0x0)
    __GDIPlus_BrushDefCreate($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipFillEllipse", "handle", $hgraphics, "handle", $hbrush, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
    __GDIPlus_BrushDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsFillEllipse

Func _GDIPlus_GraphicsFillPath($hgraphics, $hpath, $hbrush = 0x0)
    __GDIPlus_BrushDefCreate($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipFillPath", "handle", $hgraphics, "handle", $hbrush, "handle", $hpath)
    __GDIPlus_BrushDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsFillPath

Func _GDIPlus_GraphicsFillPie($hgraphics, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle, $hbrush = 0x0)
    __GDIPlus_BrushDefCreate($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipFillPie", "handle", $hgraphics, "handle", $hbrush, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
    __GDIPlus_BrushDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsFillPie

Func _GDIPlus_GraphicsFillPolygon($hgraphics, $apoints, $hbrush = 0x0)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    __GDIPlus_BrushDefCreate($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipFillPolygon", "handle", $hgraphics, "handle", $hbrush, "struct*", $tpoints, "int", $icount, "int", "FillModeAlternate")
    __GDIPlus_BrushDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsFillPolygon

Func _GDIPlus_GraphicsFillRect($hgraphics, $nx, $ny, $nwidth, $nheight, $hbrush = 0x0)
    __GDIPlus_BrushDefCreate($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipFillRectangle", "handle", $hgraphics, "handle", $hbrush, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
    __GDIPlus_BrushDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsFillRect

Func _GDIPlus_GraphicsFillRegion($hgraphics, $hregion, $hbrush = 0x0)
    __GDIPlus_BrushDefCreate($hbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipFillRegion", "handle", $hgraphics, "handle", $hbrush, "handle", $hregion)
    __GDIPlus_BrushDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsFillRegion

Func _GDIPlus_GraphicsGetCompositingMode($hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetCompositingMode", "handle", $hgraphics, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2] + -1
EndFunc    ; -> _GDIPlus_GraphicsGetCompositingMode

Func _GDIPlus_GraphicsGetCompositingQuality($hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetCompositingQuality", "handle", $hgraphics, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2] + -1
EndFunc    ; -> _GDIPlus_GraphicsGetCompositingQuality

Func _GDIPlus_GraphicsGetDC($hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetDC", "handle", $hgraphics, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_GraphicsGetDC

Func _GDIPlus_GraphicsGetInterpolationMode($hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetInterpolationMode", "handle", $hgraphics, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2] + -1
EndFunc    ; -> _GDIPlus_GraphicsGetInterpolationMode

Func _GDIPlus_GraphicsGetSmoothingMode($hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetSmoothingMode", "handle", $hgraphics, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Switch $acall[0x2]
    Case $GDIP_SMOOTHINGMODE_NONE
        Return 0x0
    Case $GDIP_SMOOTHINGMODE_HIGHQUALITY, $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
        Return 0x1
    Case $GDIP_SMOOTHINGMODE_ANTIALIAS8X8
        Return 0x2
    Case Else
        Return 0x0
    EndSwitch
EndFunc    ; -> _GDIPlus_GraphicsGetSmoothingMode

Func _GDIPlus_GraphicsGetTransform($hgraphics, $hmatrix)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetWorldTransform", "handle", $hgraphics, "handle", $hmatrix)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsGetTransform

Func _GDIPlus_GraphicsMeasureCharacterRanges($hgraphics, $sstring, $hfont, $tlayout, $hstringformat)
    Local $icount = _GDIPlus_StringFormatGetMeasurableCharacterRangeCount($hstringformat)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $tregions = DllStructCreate("handle[" & $icount & "]")
    Local $aregions[$icount + 0x1] = [$icount]
    For $ii = 0x1 To $icount
        $aregions[$ii] = _GDIPlus_RegionCreate()
        DllStructSetData($tregions, 0x1, $aregions[$ii], $ii)
    Next
    DllCall($__g_hgdipdll, "int", "GdipMeasureCharacterRanges", "handle", $hgraphics, "wstr", $sstring, "int", + -1, "hwnd", $hfont, "struct*", $tlayout, "handle", $hstringformat, "int", $icount, "struct*", $tregions)
    Local $ierror = @error, $iextended = @extended
    If $ierror Then
        For $ii = 0x1 To $icount
            _GDIPlus_RegionDispose($aregions[$ii])
        Next
        Return SetError($ierror + 0xa, $iextended, 0x0)
    EndIf
    Return $aregions
EndFunc    ; -> _GDIPlus_GraphicsMeasureCharacterRanges

Func _GDIPlus_GraphicsMeasureString($hgraphics, $sstring, $hfont, $tlayout, $hformat)
    Local $trectf = DllStructCreate($TAGGDIPRECTF)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipMeasureString", "handle", $hgraphics, "wstr", $sstring, "int", + -1, "handle", $hfont, "struct*", $tlayout, "handle", $hformat, "struct*", $trectf, "int*", 0x0, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $ainfo[0x3]
    $ainfo[0x0] = $trectf
    $ainfo[0x1] = $acall[0x8]
    $ainfo[0x2] = $acall[0x9]
    Return $ainfo
EndFunc    ; -> _GDIPlus_GraphicsMeasureString

Func _GDIPlus_GraphicsReleaseDC($hgraphics, $hdc)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipReleaseDC", "handle", $hgraphics, "handle", $hdc)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_GraphicsReleaseDC

Func _GDIPlus_GraphicsResetClip($hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipResetClip", "handle", $hgraphics)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsResetClip

Func _GDIPlus_GraphicsResetTransform($hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipResetWorldTransform", "handle", $hgraphics)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsResetTransform

Func _GDIPlus_GraphicsRestore($hgraphics, $istate)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipRestoreGraphics", "handle", $hgraphics, "uint", $istate)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsRestore

Func _GDIPlus_GraphicsRotateTransform($hgraphics, $fangle, $iorder = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipRotateWorldTransform", "handle", $hgraphics, "float", $fangle, "int", $iorder)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsRotateTransform

Func _GDIPlus_GraphicsSave($hgraphics)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSaveGraphics", "handle", $hgraphics, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_GraphicsSave

Func _GDIPlus_GraphicsScaleTransform($hgraphics, $fscalex, $fscaley, $iorder = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipScaleWorldTransform", "handle", $hgraphics, "float", $fscalex, "float", $fscaley, "int", $iorder)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsScaleTransform

Func _GDIPlus_GraphicsSetClipPath($hgraphics, $hpath, $icombinemode = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetClipPath", "handle", $hgraphics, "handle", $hpath, "int", $icombinemode)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsSetClipPath

Func _GDIPlus_GraphicsSetClipRect($hgraphics, $nx, $ny, $nwidth, $nheight, $icombinemode = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetClipRect", "handle", $hgraphics, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "int", $icombinemode)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsSetClipRect

Func _GDIPlus_GraphicsSetClipRegion($hgraphics, $hregion, $icombinemode = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetClipRegion", "handle", $hgraphics, "handle", $hregion, "int", $icombinemode)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsSetClipRegion

Func _GDIPlus_GraphicsSetCompositingMode($hgraphics, $icompositionmode)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetCompositingMode", "handle", $hgraphics, "int", $icompositionmode + 0x1)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsSetCompositingMode

Func _GDIPlus_GraphicsSetCompositingQuality($hgraphics, $icompositionquality)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetCompositingQuality", "handle", $hgraphics, "int", $icompositionquality + 0x1)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsSetCompositingQuality

Func _GDIPlus_GraphicsSetInterpolationMode($hgraphics, $iinterpolationmode)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetInterpolationMode", "handle", $hgraphics, "int", $iinterpolationmode + 0x1)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsSetInterpolationMode

Func _GDIPlus_GraphicsSetPixelOffsetMode($hgraphics, $ipixeloffsetmode)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPixelOffsetMode", "handle", $hgraphics, "int", $ipixeloffsetmode + 0x1)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsSetPixelOffsetMode

Func _GDIPlus_GraphicsSetSmoothingMode($hgraphics, $ismooth)
    If $ismooth < $GDIP_SMOOTHINGMODE_DEFAULT Or $ismooth > $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 Then $ismooth = $GDIP_SMOOTHINGMODE_DEFAULT
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetSmoothingMode", "handle", $hgraphics, "int", $ismooth)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsSetSmoothingMode

Func _GDIPlus_GraphicsSetTextRenderingHint($hgraphics, $itextrenderinghint)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetTextRenderingHint", "handle", $hgraphics, "int", $itextrenderinghint)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsSetTextRenderingHint

Func _GDIPlus_GraphicsSetTransform($hgraphics, $hmatrix)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetWorldTransform", "handle", $hgraphics, "handle", $hmatrix)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsSetTransform

Func _GDIPlus_GraphicsTransformPoints($hgraphics, ByRef $apoints, $icoordspaceto = 0x0, $icoordspacefrom = 0x1)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], ($ii + -1) * 0x2 + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], ($ii + -1) * 0x2 + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipTransformPoints", "handle", $hgraphics, "int", $icoordspaceto, "int", $icoordspacefrom, "struct*", $tpoints, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    For $ii = 0x1 To $icount
        $apoints[$ii][0x0] = DllStructGetData($tpoints, 0x1, ($ii + -1) * 0x2 + 0x1)
        $apoints[$ii][0x1] = DllStructGetData($tpoints, 0x1, ($ii + -1) * 0x2 + 0x2)
    Next
    Return True
EndFunc    ; -> _GDIPlus_GraphicsTransformPoints

Func _GDIPlus_GraphicsTranslateTransform($hgraphics, $ndx, $ndy, $iorder = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipTranslateWorldTransform", "handle", $hgraphics, "float", $ndx, "float", $ndy, "int", $iorder)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_GraphicsTranslateTransform

Func _GDIPlus_HatchBrushCreate($ihatchstyle = 0x0, $iargbforeground = -1, $iargbbackground = -1)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateHatchBrush", "int", $ihatchstyle, "uint", $iargbforeground, "uint", $iargbbackground, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x4]
EndFunc    ; -> _GDIPlus_HatchBrushCreate

Func _GDIPlus_HICONCreateFromBitmap($hbitmap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateHICONFromBitmap", "handle", $hbitmap, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_HICONCreateFromBitmap

Func _GDIPlus_ImageAttributesCreate()
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateImageAttributes", "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x1]
EndFunc    ; -> _GDIPlus_ImageAttributesCreate

Func _GDIPlus_ImageAttributesDispose($himageattributes)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDisposeImageAttributes", "handle", $himageattributes)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageAttributesDispose

Func _GDIPlus_ImageAttributesSetColorKeys($himageattributes, $icoloradjusttype = 0x0, $benable = False, $iargblow = 0x0, $iargbhigh = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesColorKeys", "handle", $himageattributes, "int", $icoloradjusttype, "int", $benable, "uint", $iargblow, "uint", $iargbhigh)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageAttributesSetColorKeys

Func _GDIPlus_ImageAttributesSetColorMatrix($himageattributes, $icoloradjusttype = 0x0, $benable = False, $tclrmatrix = 0x0, $tgraymatrix = 0x0, $icolormatrixflags = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesColorMatrix", "handle", $himageattributes, "int", $icoloradjusttype, "int", $benable, "struct*", $tclrmatrix, "struct*", $tgraymatrix, "int", $icolormatrixflags)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageAttributesSetColorMatrix

Func _GDIPlus_ImageAttributesSetRemapTable($himageattributes, $acolormap = 0x0, $icoloradjusttype = 0x0, $benable = True)
    Local $acall
    If IsArray($acolormap) Then
        Local $icount = $acolormap[0x0][0x0]
        Local $tcolormap = DllStructCreate("uint[" & $icount * 0x2 & "]")
        For $i = 0x1 To $icount
            DllStructSetData($tcolormap, 0x1, $acolormap[$i][0x0], ($i + -1) * 0x2 + 0x1)
            DllStructSetData($tcolormap, 0x1, $acolormap[$i][0x1], ($i + -1) * 0x2 + 0x2)
        Next
        $acall = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesRemapTable", "handle", $himageattributes, "int", $icoloradjusttype, "int", $benable, "int", $icount, "struct*", $tcolormap)
    Else
        $acall = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesRemapTable", "handle", $himageattributes, "int", $icoloradjusttype, "int", $benable, "int", 0x0, "struct*", 0x0)
    EndIf
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageAttributesSetRemapTable

Func _GDIPlus_ImageAttributesSetThreshold($himageattributes, $fthreshold, $icoloradjusttype = $GDIP_COLORADJUSTTYPE_DEFAULT, $benable = True)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesThreshold", "handle", $himageattributes, "int", $icoloradjusttype, "bool", $benable, "float", $fthreshold)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageAttributesSetThreshold

Func _GDIPlus_ImageClone($himage)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCloneImage", "handle", $himage, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_ImageClone

Func _GDIPlus_ImageDispose($himage)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDisposeImage", "handle", $himage)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageDispose

Func _GDIPlus_ImageGetDimension($himage)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageDimension", "handle", $himage, "float*", 0x0, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $aimgdim[0x2] = [$acall[0x2], $acall[0x3]]
    Return $aimgdim
EndFunc    ; -> _GDIPlus_ImageGetDimension

Func _GDIPlus_ImageGetFlags($himage)
    Local $aflag[0x2] = [0x0, '']
    If ($himage = + -1) Or (Not $himage) Then Return SetError(0xb, 0x0, $aflag)
    Local $aimageflags[0xd][0x2] = [["Pixel data Cacheable", $GDIP_IMAGEFLAGS_CACHING], ["Pixel data read-only", $GDIP_IMAGEFLAGS_READONLY], ["Pixel size in image", $GDIP_IMAGEFLAGS_HASREALPIXELSIZE], ["DPI info in image", $GDIP_IMAGEFLAGS_HASREALDPI], ["YCCK color space", $GDIP_IMAGEFLAGS_COLORSPACE_YCCK], ["YCBCR color space", $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR], ["Grayscale image", $GDIP_IMAGEFLAGS_COLORSPACE_GRAY], ["CMYK color space", $GDIP_IMAGEFLAGS_COLORSPACE_CMYK], ["RGB color space", $GDIP_IMAGEFLAGS_COLORSPACE_RGB], ["Partially scalable", $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE], ["Alpha values other than 0 (transparent) and 255 (opaque)", $GDIP_IMAGEFLAGS_HASTRANSLUCENT], ["Alpha values", $GDIP_IMAGEFLAGS_HASALPHA], ["Scalable", $GDIP_IMAGEFLAGS_SCALABLE]]
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageFlags", "handle", $himage, "long*", 0x0)
    If @error Then Return SetError(@error, @extended, $aflag)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], $aflag)
    If $acall[0x2] = $GDIP_IMAGEFLAGS_NONE Then
        $aflag[0x1] = "No pixel data"
        Return SetError(0xc, $acall[0x2], $aflag)
    EndIf
    $aflag[0x0] = $acall[0x2]
    For $i = 0x0 To 0xc
        If BitAND($acall[0x2], $aimageflags[$i][0x1]) = $aimageflags[$i][0x1] Then
            If StringLen($aflag[0x1]) Then $aflag[0x1]&= "|"
            $acall[0x2]-= $aimageflags[$i][0x1]
            $aflag[0x1]&= $aimageflags[$i][0x0]
        EndIf
    Next
    Return $aflag
EndFunc    ; -> _GDIPlus_ImageGetFlags

Func _GDIPlus_ImageGetFrameCount($himage, $sdimensionid)
    Local $tguid = _WinAPI_GUIDFromString($sdimensionid)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipImageGetFrameCount", "handle", $himage, "struct*", $tguid, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_ImageGetFrameCount

Func _GDIPlus_ImageGetGraphicsContext($himage)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageGraphicsContext", "handle", $himage, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_ImageGetGraphicsContext

Func _GDIPlus_ImageGetHeight($himage)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageHeight", "handle", $himage, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_ImageGetHeight

Func _GDIPlus_ImageGetHorizontalResolution($himage)
    If ($himage = + -1) Or (Not $himage) Then Return SetError(0xb, 0x0, 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageHorizontalResolution", "handle", $himage, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return Round($acall[0x2])
EndFunc    ; -> _GDIPlus_ImageGetHorizontalResolution

Func _GDIPlus_ImageGetPixelFormat($himage)
    Local $aformat[0x2] = [0x0, '']
    If ($himage = + -1) Or (Not $himage) Then Return SetError(0xb, 0x0, $aformat)
    Local $apixelformat[0xe][0x2] = [["1 Bpp Indexed", $GDIP_PXF01INDEXED], ["4 Bpp Indexed", $GDIP_PXF04INDEXED], ["8 Bpp Indexed", $GDIP_PXF08INDEXED], ["16 Bpp Grayscale", $GDIP_PXF16GRAYSCALE], ["16 Bpp RGB 555", $GDIP_PXF16RGB555], ["16 Bpp RGB 565", $GDIP_PXF16RGB565], ["16 Bpp ARGB 1555", $GDIP_PXF16ARGB1555], ["24 Bpp RGB", $GDIP_PXF24RGB], ["32 Bpp RGB", $GDIP_PXF32RGB], ["32 Bpp ARGB", $GDIP_PXF32ARGB], ["32 Bpp PARGB", $GDIP_PXF32PARGB], ["48 Bpp RGB", $GDIP_PXF48RGB], ["64 Bpp ARGB", $GDIP_PXF64ARGB], ["64 Bpp PARGB", $GDIP_PXF64PARGB]]
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImagePixelFormat", "handle", $himage, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, $aformat)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], $aformat)
    For $i = 0x0 To 0xd
        If $apixelformat[$i][0x1] = $acall[0x2] Then
            $aformat[0x0] = $apixelformat[$i][0x1]
            $aformat[0x1] = $apixelformat[$i][0x0]
            Return $aformat
        EndIf
    Next
    Return SetError(0xc, 0x0, $aformat)
EndFunc    ; -> _GDIPlus_ImageGetPixelFormat

Func __GDIPlus_ImageGetPropertyCount($himage)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPropertyCount", "handle", $himage, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> __GDIPlus_ImageGetPropertyCount

Func _GDIPlus_ImageGetPropertyIdList($himage)
    Local $icount = __GDIPlus_ImageGetPropertyCount($himage)
    If @error Then Return SetError(@error, @extended, False)
    Local $tproperties = DllStructCreate("uint[" & $icount & "]")
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPropertyIdList", "handle", $himage, "int", $icount, "struct*", $tproperties)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Local $spropertytaginfo = "0x0000=GpsVer;0x0001=GpsLatitudeRef;0x0002=GpsLatitude;0x0003=GpsLongitudeRef;0x0004=GpsLongitude;0x0005=GpsAltitudeRef;0x0006=GpsAltitude;0x0007=GpsGpsTime;0x0" & _
        "008=GpsGpsSatellites;0x0009=GpsGpsStatus;0x000A=GpsGpsMeasureMode;0x000B=GpsGpsDop;0x000C=GpsSpeedRef;0x000D=GpsSpeed;0x000E=GpsTrackRef;0x000F=GpsTrack;0x0010=" & _
        "GpsImgDirRef;0x0011=GpsImgDir;0x0012=GpsMapDatum;0x0013=GpsDestLatRef;0x0014=GpsDestLat;0x0015=GpsDestLongRef;0x0016=GpsDestLong;0x0017=GpsDestBearRef;0x0018=Gp" & _
        "sDestBear;0x0019=GpsDestDistRef;0x001A=GpsDestDist;0x00FE=NewSubfileType;0x00FF=SubfileType;0x0100=ImageWidth;0x0101=ImageHeight;0x0102=BitsPerSample;0x0103=Com" & _
        "pression;0x0106=PhotometricInterp;0x0107=ThreshHolding;0x0108=CellWidth;0x0109=CellHeight;0x010A=FillOrder;0x010D=DocumentName;0x010E=ImageDescription;0x010F=Eq" & _
        "uipMake;0x0110=EquipModel;0x0111=StripOffsets;0x0112=Orientation;0x0115=SamplesPerPixel;0x0116=RowsPerStrip;0x0117=StripBytesCount;0x0118=MinSampleValue;0x0119=" & _
        "MaxSampleValue;0x011A=XResolution;0x011B=YResolution;0x011C=PlanarConfig;0x011D=PageName;0x011E=XPosition;0x011F=YPosition;0x0120=FreeOffset;0x0121=FreeByteCoun" & _
        "ts;0x0122=GrayResponseUnit;0x0123=GrayResponseCurve;0x0124=T4Option;0x0125=T6Option;0x0128=ResolutionUnit;0x0129=PageNumber;0x012D=TransferFunction;0x0131=Softw" & _
        "areUsed;0x0132=DateTime;0x013B=Artist;0x013C=HostComputer;0x013D=Predictor;0x013E=WhitePoint;0x013F=PrimaryChromaticities;0x0140=ColorMap;0x0141=HalftoneHints;0" & _
        "x0142=TileWidth;0x0143=TileLength;0x0144=TileOffset;0x0145=TileByteCounts;0x014C=InkSet;0x014D=InkNames;0x014E=NumberOfInks;0x0150=DotRange;0x0151=TargetPrinter" & _
        ";0x0152=ExtraSamples;0x0153=SampleFormat;0x0154=SMinSampleValue;0x0155=SMaxSampleValue;0x0156=TransferRange;0x0200=JPEGProc;0x0201=JPEGInterFormat;0x0202=JPEGIn" & _
        "terLength;0x0203=JPEGRestartInterval;0x0205=JPEGLosslessPredictors;0x0206=JPEGPointTransforms;0x0207=JPEGQTables;0x0208=JPEGDCTables;0x0209=JPEGACTables;0x0211=" & _
        "YCbCrCoefficients;0x0212=YCbCrSubsampling;0x0213=YCbCrPositioning;0x0214=REFBlackWhite;0x0301=Gamma;0x0302=ICCProfileDescriptor;0x0303=SRGBRenderingIntent;0x032" & _
        "0=ImageTitle;0x5001=ResolutionXUnit;0x5002=ResolutionYUnit;0x5003=ResolutionXLengthUnit;0x5004=ResolutionYLengthUnit;0x5005=PrintFlags;0x5006=PrintFlagsVersion;" & _
        "0x5007=PrintFlagsCrop;0x5008=PrintFlagsBleedWidth;0x5009=PrintFlagsBleedWidthScale;0x500A=HalftoneLPI;0x500B=HalftoneLPIUnit;0x500C=HalftoneDegree;" & "0x500D=HalftoneShape;0x500E=HalftoneMisc;0x500F=HalftoneScreen;0x5010=JPEGQuality;0x5011=GridSize;0x5012=ThumbnailFormat;0x5013=ThumbnailWidth;0x5014=ThumbnailH" & _
        "eight;0x5015=ThumbnailColorDepth;0x5016=ThumbnailPlanes;0x5017=ThumbnailRawBytes;0x5018=ThumbnailSize;0x5019=ThumbnailCompressedSize;0x501A=ColorTransferFunctio" & _
        "n;0x501B=ThumbnailData;0x5020=ThumbnailImageWidth;0x5021=ThumbnailImageHeight;0x5022=ThumbnailBitsPerSample;0x5023=ThumbnailCompression;0x5024=ThumbnailPhotomet" & _
        "ricInterp;0x5025=ThumbnailImageDescription;0x5026=ThumbnailEquipMake;0x5027=ThumbnailEquipModel;0x5028=ThumbnailStripOffsets;0x5029=ThumbnailOrientation;0x502A=" & _
        "ThumbnailSamplesPerPixel;0x502B=ThumbnailRowsPerStrip;0x502C=ThumbnailStripBytesCount;0x502D=ThumbnailResolutionX;0x502E=ThumbnailResolutionY;0x502F=ThumbnailPl" & _
        "anarConfig;0x5030=ThumbnailResolutionUnit;0x5031=ThumbnailTransferFunction;0x5032=ThumbnailSoftwareUsed;0x5033=ThumbnailDateTime;0x5034=ThumbnailArtist;0x5035=T" & _
        "humbnailWhitePoint;0x5036=ThumbnailPrimaryChromaticities;0x5037=ThumbnailYCbCrCoefficients;0x5038=ThumbnailYCbCrSubsampling;0x5039=ThumbnailYCbCrPositioning;0x5" & _
        "03A=ThumbnailRefBlackWhite;0x503B=ThumbnailCopyRight;0x5090=LuminanceTable;0x5091=ChrominanceTable;0x5100=FrameDelay;0x5101=LoopCount;0x5102=GlobalPalette;0x510" & _
        "3=IndexBackground;0x5104=IndexTransparent;0x5110=PixelUnit;0x5111=PixelPerUnitX;0x5112=PixelPerUnitY;0x5113=PaletteHistogram;0x8298=Copyright;0x829A=ExifExposur" & _
        "eTime;0x829D=ExifFNumber;0x8769=ExifIFD;0x8773=ICCProfile;0x8822=ExifExposureProg;0x8824=ExifSpectralSense;0x8825=GpsIFD;0x8827=ExifISOSpeed;0x8828=ExifOECF;0x9" & _
        "000=ExifVer;0x9003=ExifDTOrig;0x9004=ExifDTDigitized;0x9101=ExifCompConfig;0x9102=ExifCompBPP;0x9201=ExifShutterSpeed;0x9202=ExifAperture;0x9203=ExifBrightness;" & _
        "0x9204=ExifExposureBias;0x9205=ExifMaxAperture;0x9206=ExifSubjectDist;0x9207=ExifMeteringMode;0x9208=ExifLightSource;0x9209=ExifFlash;0x920A=ExifFocalLength;0x9" & _
        "27C=ExifMakerNote;0x9286=ExifUserComment;0x9290=ExifDTSubsec;0x9291=ExifDTOrigSS;0x9292=ExifDTDigSS;0xA000=ExifFPXVer;0xA001=ExifColorSpace;0xA002=ExifPixXDim;0" & _
        "xA003=ExifPixYDim;0xA004=ExifRelatedWav;0xA005=ExifInterop;0xA20B=ExifFlashEnergy;0xA20C=ExifSpatialFR;0xA20E=ExifFocalXRes;0xA20F=ExifFocalYRes;0xA210=ExifFoca" & _
        "lResUnit;0xA214=ExifSubjectLoc;0xA215=ExifExposureIndex;0xA217=ExifSensingMethod;0xA300=ExifFileSource;0xA301=ExifSceneType;0xA302=ExifCfaPattern"
    Local $aproperties[$icount + 0x1][0x2] = [[$icount]]
    Local $aregexp
    For $i = 0x1 To $icount
        $aproperties[$i][0x0] = DllStructGetData($tproperties, 0x1, $i)
        $aregexp = StringRegExp($spropertytaginfo, "(?i)" & Hex(DllStructGetData($tproperties, 0x1, $i), 0x4) & "=(\\w+)", $STR_REGEXPARRAYGLOBALMATCH)
        Switch IsArray($aregexp)
        Case True
            $aproperties[$i][0x1] = $aregexp[0x0]
        Case Else
            $aproperties[$i][0x1] = "PropertyTagUnKnown"
        EndSwitch
    Next
    Return $aproperties
EndFunc    ; -> _GDIPlus_ImageGetPropertyIdList

Func __GDIPlus_ImageGetPropertyItemSize($himage, $ipropid)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPropertyItemSize", "handle", $himage, "uint", $ipropid, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x3]
EndFunc    ; -> __GDIPlus_ImageGetPropertyItemSize

Func _GDIPlus_ImageGetPropertyItem($himage, $ipropid)
    Local $isize = __GDIPlus_ImageGetPropertyItemSize($himage, $ipropid)
    If @error Then Return SetError(@error, @extended, False)
    Local $tbuffer = DllStructCreate("byte[" & $isize & "];")
    Local $pbuffer = DllStructGetPtr($tbuffer)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPropertyItem", "handle", $himage, "uint", $ipropid, "uint", $isize, "struct*", $tbuffer)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Local $tpropertyitem = DllStructCreate("int id; int length; short type; ptr value;", $pbuffer)
    Local $ibytes = DllStructGetData($tpropertyitem, "length")
    Local $pvalue = DllStructGetData($tpropertyitem, "value")
    Local $tvalues, $ivalues
    Switch DllStructGetData($tpropertyitem, "type")
    Case 0x2
        $ivalues = 0x1
        $tvalues = DllStructCreate("char[" & $ibytes & "];", $pvalue)
    Case 0x3
        $ivalues = Int($ibytes / 0x2)
        $tvalues = DllStructCreate("ushort[" & $ivalues & "];", $pvalue)
    Case 0x4, 0x5
        $ivalues = Int($ibytes / 0x4)
        $tvalues = DllStructCreate("uint[" & $ivalues & "];", $pvalue)
    Case 0x9, 0xa
        $ivalues = Int($ibytes / 0x4)
        $tvalues = DllStructCreate("int[" & $ivalues & "];", $pvalue)
    Case Else
        $ivalues = 0x1
        $tvalues = DllStructCreate("byte[" & $ibytes & "];", $pvalue)
    EndSwitch
    Local $avalues[$ivalues + 0x1] = [$ivalues]
    Switch DllStructGetData($tpropertyitem, "type")
    Case 0x5, 0xa
        $ivalues = Int($ivalues / 0x2)
        ReDim $avalues[$ivalues + 0x1]
        $avalues[0x0] = $ivalues
        For $j = 0x1 To $ivalues
            $avalues[$j] = DllStructGetData($tvalues, 0x1, ($j + -1) * 0x2 + 0x1) / DllStructGetData($tvalues, 0x1, ($j + -1) * 0x2 + 0x2)
        Next
    Case 0x3, 0x4, 0x9
        For $j = 0x1 To $ivalues
            $avalues[$j] = DllStructGetData($tvalues, 0x1, $j)
        Next
    Case Else
        $avalues[0x1] = DllStructGetData($tvalues, 0x1)
    EndSwitch
    Return $avalues
EndFunc    ; -> _GDIPlus_ImageGetPropertyItem

Func _GDIPlus_ImageGetRawFormat($himage)
    Local $aguid[0x2]
    If ($himage = + -1) Or (Not $himage) Then Return SetError(0xb, 0x0, $aguid)
    Local $aimagetype[0xb][0x2] = [["UNDEFINED", $GDIP_IMAGEFORMAT_UNDEFINED], ["MEMORYBMP", $GDIP_IMAGEFORMAT_MEMORYBMP], ["BMP", $GDIP_IMAGEFORMAT_BMP], ["EMF", $GDIP_IMAGEFORMAT_EMF], ["WMF", $GDIP_IMAGEFORMAT_WMF], ["JPEG", $GDIP_IMAGEFORMAT_JPEG], ["PNG", $GDIP_IMAGEFORMAT_PNG], ["GIF", $GDIP_IMAGEFORMAT_GIF], ["TIFF", $GDIP_IMAGEFORMAT_TIFF], ["EXIF", $GDIP_IMAGEFORMAT_EXIF], ["ICON", $GDIP_IMAGEFORMAT_ICON]]
    Local $tstruct = DllStructCreate("byte[16]")
    Local $acall1 = DllCall($__g_hgdipdll, "int", "GdipGetImageRawFormat", "handle", $himage, "struct*", $tstruct)
    If @error Then Return SetError(@error, @extended, $aguid)
    If $acall1[0x0] Then Return SetError(0xa, $acall1[0x0], $aguid)
    Local $sresult2 = _WinAPI_StringFromGUID($acall1[0x2])
    If @error Then Return SetError(@error + 0x14, @extended, $aguid)
    If $sresult2 = '' Then Return SetError(0xc, 0x0, $aguid)
    For $i = 0x0 To 0xa
        If $aimagetype[$i][0x1] == $sresult2 Then
            $aguid[0x0] = $aimagetype[$i][0x1]
            $aguid[0x1] = $aimagetype[$i][0x0]
            Return $aguid
        EndIf
    Next
    Return SetError(0xd, 0x0, $aguid)
EndFunc    ; -> _GDIPlus_ImageGetRawFormat

Func _GDIPlus_ImageGetThumbnail($himage, $iwidth = 0x0, $iheight = 0x0, $bkeepratio = True, $hcallback = Null, $hcallbackdata = Null)
    If $bkeepratio Then
        Local $aimgdim = _GDIPlus_ImageGetDimension($himage)
        If @error Then Return SetError(@error + 0x14, @extended, False)
        Local $f
        If $iwidth < 0x1 Or $iheight < 0x1 Then
            $iwidth = 0x0
            $iheight = 0x0
        Else
            If ($aimgdim[0x0] / $aimgdim[0x1]) > 0x1 Then
                $f = $aimgdim[0x0] / $iwidth
            Else
                $f = $aimgdim[0x1] / $iheight
            EndIf
            $iwidth = Int($aimgdim[0x0] / $f)
            $iheight = Int($aimgdim[0x1] / $f)
        EndIf
    EndIf
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageThumbnail", "handle", $himage, "uint", $iwidth, "uint", $iheight, "ptr*", 0x0, "ptr", $hcallback, "ptr", $hcallbackdata)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return $acall[0x4]
EndFunc    ; -> _GDIPlus_ImageGetThumbnail

Func _GDIPlus_ImageGetType($himage)
    If ($himage = + -1) Or (Not $himage) Then Return SetError(0xb, 0x0, + -1)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageType", "handle", $himage, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_ImageGetType

Func _GDIPlus_ImageGetVerticalResolution($himage)
    If ($himage = + -1) Or (Not $himage) Then Return SetError(0xb, 0x0, 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageVerticalResolution", "handle", $himage, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return Round($acall[0x2])
EndFunc    ; -> _GDIPlus_ImageGetVerticalResolution

Func _GDIPlus_ImageGetWidth($himage)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetImageWidth", "handle", $himage, "uint*", + -1)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_ImageGetWidth

Func _GDIPlus_ImageLoadFromFile($sfilename)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipLoadImageFromFile", "wstr", $sfilename, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_ImageLoadFromFile

Func _GDIPlus_ImageLoadFromStream($pstream)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipLoadImageFromStream", "ptr", $pstream, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_ImageLoadFromStream

Func _GDIPlus_ImageRotateFlip($himage, $irotatefliptype)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipImageRotateFlip", "handle", $himage, "int", $irotatefliptype)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageRotateFlip

Func _GDIPlus_ImageSaveAdd($himage, $tparams)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSaveAdd", "handle", $himage, "struct*", $tparams)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageSaveAdd

Func _GDIPlus_ImageSaveAddImage($himage, $himagenew, $tparams)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSaveAddImage", "handle", $himage, "handle", $himagenew, "struct*", $tparams)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageSaveAddImage

Func _GDIPlus_ImageSaveToFile($himage, $sfilename)
    Local $sext = __GDIPlus_ExtractFileExt($sfilename)
    Local $sclsid = _GDIPlus_EncodersGetCLSID($sext)
    If $sclsid = '' Then Return SetError(+ -1, 0x0, False)
    Local $bret = _GDIPlus_ImageSaveToFileEx($himage, $sfilename, $sclsid, 0x0)
    Return SetError(@error, @extended, $bret)
EndFunc    ; -> _GDIPlus_ImageSaveToFile

Func _GDIPlus_ImageSaveToFileEx($himage, $sfilename, $sencoder, $tparams = 0x0)
    Local $tguid = _WinAPI_GUIDFromString($sencoder)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSaveImageToFile", "handle", $himage, "wstr", $sfilename, "struct*", $tguid, "struct*", $tparams)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageSaveToFileEx

Func _GDIPlus_ImageSaveToStream($himage, $pstream, $tencoder, $tparams = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSaveImageToStream", "handle", $himage, "ptr", $pstream, "struct*", $tencoder, "struct*", $tparams)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageSaveToStream

Func _GDIPlus_ImageScale($himage, $iscalew, $iscaleh, $iinterpolationmode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
    Local $iwidth = _GDIPlus_ImageGetWidth($himage)
    If @error Then Return SetError(0x1, 0x0, 0x0)
    Local $iheight = _GDIPlus_ImageGetHeight($himage)
    If @error Then Return SetError(0x2, 0x0, 0x0)
    Local $inewwidth = $iwidth * $iscalew
    Local $inewheight = $iheight * $iscaleh
    Local $hbitmap = _GDIPlus_BitmapCreateFromScan0($inewwidth, $inewheight)
    If @error Then Return SetError(0x3, 0x0, 0x0)
    Local $hbmpctxt = _GDIPlus_ImageGetGraphicsContext($hbitmap)
    _GDIPlus_GraphicsSetInterpolationMode($hbmpctxt, $iinterpolationmode)
    _GDIPlus_GraphicsSetPixelOffsetMode($hbmpctxt, $GDIP_PIXELOFFSETMODE_HIGHQUALITY)
    Local $hia = _GDIPlus_ImageAttributesCreate()
    __gdiplus_imageattributessetimagewrapmode($hia)
    If @error Then
        _GDIPlus_ImageAttributesDispose($hia)
        _GDIPlus_GraphicsDispose($hbmpctxt)
        _GDIPlus_BitmapDispose($hbitmap)
        Return SetError(0x4, 0x0, 0x0)
    EndIf
    _GDIPlus_GraphicsDrawImageRectRect($hbmpctxt, $himage, 0x0, 0x0, $iwidth, $iheight, 0x0, 0x0, $inewwidth, $inewheight, $hia)
    _GDIPlus_ImageAttributesDispose($hia)
    _GDIPlus_GraphicsDispose($hbmpctxt)
    Return $hbitmap
EndFunc    ; -> _GDIPlus_ImageScale

Func __gdiplus_imageattributessetimagewrapmode($himageattributes, $iwrapmode = $GDIP_WRAPMODETILEFLIPXY, $icolor = -16777216)
    Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesWrapMode", "handle", $himageattributes, "long", $iwrapmode, "uint", $icolor, "bool", False)
    If @error Then Return SetError(@error, @extended, False)
    If $aresult[0x0] Then Return SetError(0xa, $aresult[0x0], False)
    Return True
EndFunc    ; -> __gdiplus_imageattributessetimagewrapmode

Func _GDIPlus_ImageSelectActiveFrame($himage, $sdimensionid, $iframeindex)
    Local $tguid = _WinAPI_GUIDFromString($sdimensionid)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipImageSelectActiveFrame", "handle", $himage, "struct*", $tguid, "uint", $iframeindex)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_ImageSelectActiveFrame

Func _GDIPlus_ImageResize($himage, $inewwidth, $inewheight, $iinterpolationmode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
    Local $iwidth = _GDIPlus_ImageGetWidth($himage)
    If @error Then Return SetError(0x1, 0x0, 0x0)
    Local $iheight = _GDIPlus_ImageGetHeight($himage)
    If @error Then Return SetError(0x2, 0x0, 0x0)
    Local $hbitmap = _GDIPlus_BitmapCreateFromScan0($inewwidth, $inewheight)
    If @error Then Return SetError(0x3, 0x0, 0x0)
    Local $hbmpctxt = _GDIPlus_ImageGetGraphicsContext($hbitmap)
    _GDIPlus_GraphicsSetInterpolationMode($hbmpctxt, $iinterpolationmode)
    _GDIPlus_GraphicsSetPixelOffsetMode($hbmpctxt, $GDIP_PIXELOFFSETMODE_HIGHQUALITY)
    Local $hia = _GDIPlus_ImageAttributesCreate()
    __gdiplus_imageattributessetimagewrapmode($hia)
    If @error Then
        _GDIPlus_ImageAttributesDispose($hia)
        _GDIPlus_GraphicsDispose($hbmpctxt)
        _GDIPlus_BitmapDispose($hbitmap)
        Return SetError(0x4, 0x0, 0x0)
    EndIf
    _GDIPlus_GraphicsDrawImageRectRect($hbmpctxt, $himage, 0x0, 0x0, $iwidth, $iheight, 0x0, 0x0, $inewwidth, $inewheight, $hia)
    _GDIPlus_GraphicsDispose($hbmpctxt)
    Return $hbitmap
EndFunc    ; -> _GDIPlus_ImageResize

Func _GDIPlus_LineBrushCreate($nx1, $ny1, $nx2, $ny2, $iargbclr1, $iargbclr2, $iwrapmode = 0x0)
    Local $tpointf1, $tpointf2, $acall
    $tpointf1 = DllStructCreate("float;float")
    $tpointf2 = DllStructCreate("float;float")
    DllStructSetData($tpointf1, 0x1, $nx1)
    DllStructSetData($tpointf1, 0x2, $ny1)
    DllStructSetData($tpointf2, 0x1, $nx2)
    DllStructSetData($tpointf2, 0x2, $ny2)
    $acall = DllCall($__g_hgdipdll, "int", "GdipCreateLineBrush", "struct*", $tpointf1, "struct*", $tpointf2, "uint", $iargbclr1, "uint", $iargbclr2, "int", $iwrapmode, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x6]
EndFunc    ; -> _GDIPlus_LineBrushCreate

Func _GDIPlus_LineBrushCreateFromRect($trectf, $iargbclr1, $iargbclr2, $igradientmode = 0x0, $iwrapmode = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateLineBrushFromRect", "struct*", $trectf, "uint", $iargbclr1, "uint", $iargbclr2, "int", $igradientmode, "int", $iwrapmode, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x6]
EndFunc    ; -> _GDIPlus_LineBrushCreateFromRect

Func _GDIPlus_LineBrushCreateFromRectWithAngle($trectf, $iargbclr1, $iargbclr2, $fangle, $bisanglescalable = True, $iwrapmode = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateLineBrushFromRectWithAngle", "struct*", $trectf, "uint", $iargbclr1, "uint", $iargbclr2, "float", $fangle, "int", $bisanglescalable, "int", $iwrapmode, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x7]
EndFunc    ; -> _GDIPlus_LineBrushCreateFromRectWithAngle

Func _GDIPlus_LineBrushGetColors($hlinegradientbrush)
    Local $targbs, $aargbs[0x2], $acall
    $targbs = DllStructCreate("uint;uint")
    $acall = DllCall($__g_hgdipdll, "uint", "GdipGetLineColors", "handle", $hlinegradientbrush, "struct*", $targbs)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    $aargbs[0x0] = DllStructGetData($targbs, 0x1)
    $aargbs[0x1] = DllStructGetData($targbs, 0x2)
    Return $aargbs
EndFunc    ; -> _GDIPlus_LineBrushGetColors

Func _GDIPlus_LineBrushGetRect($hlinegradientbrush)
    Local $trectf = DllStructCreate($TAGGDIPRECTF)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetLineRect", "handle", $hlinegradientbrush, "struct*", $trectf)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Local $arectf[0x4]
    For $ii = 0x1 To 0x4
        $arectf[$ii + -1] = DllStructGetData($trectf, $ii)
    Next
    Return $arectf
EndFunc    ; -> _GDIPlus_LineBrushGetRect

Func _GDIPlus_LineBrushMultiplyTransform($hlinegradientbrush, $hmatrix, $iorder = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipMultiplyLineTransform", "handle", $hlinegradientbrush, "handle", $hmatrix, "int", $iorder)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_LineBrushMultiplyTransform

Func _GDIPlus_LineBrushResetTransform($hlinegradientbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipResetLineTransform", "handle", $hlinegradientbrush)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_LineBrushResetTransform

Func _GDIPlus_LineBrushSetBlend($hlinegradientbrush, $ablends)
    Local $ii, $icount, $tfactors, $tpositions, $acall
    $icount = $ablends[0x0][0x0]
    $tfactors = DllStructCreate("float[" & $icount & "]")
    $tpositions = DllStructCreate("float[" & $icount & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tfactors, 0x1, $ablends[$ii][0x0], $ii)
        DllStructSetData($tpositions, 0x1, $ablends[$ii][0x1], $ii)
    Next
    $acall = DllCall($__g_hgdipdll, "int", "GdipSetLineBlend", "handle", $hlinegradientbrush, "struct*", $tfactors, "struct*", $tpositions, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_LineBrushSetBlend

Func _GDIPlus_LineBrushSetColors($hlinegradientbrush, $iargbstart, $iargbend)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetLineColors", "handle", $hlinegradientbrush, "uint", $iargbstart, "uint", $iargbend)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_LineBrushSetColors

Func _GDIPlus_LineBrushSetGammaCorrection($hlinegradientbrush, $busegammacorrection = True)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetLineGammaCorrection", "handle", $hlinegradientbrush, "int", $busegammacorrection)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_LineBrushSetGammaCorrection

Func _GDIPlus_LineBrushSetLinearBlend($hlinegradientbrush, $ffocus, $fscale = 0x1)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetLineLinearBlend", "handle", $hlinegradientbrush, "float", $ffocus, "float", $fscale)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_LineBrushSetLinearBlend

Func _GDIPlus_LineBrushSetPresetBlend($hlinegradientbrush, $ainterpolations)
    Local $ii, $icount, $tcolors, $tpositions, $acall
    $icount = $ainterpolations[0x0][0x0]
    $tcolors = DllStructCreate("uint[" & $icount & "]")
    $tpositions = DllStructCreate("float[" & $icount & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tcolors, 0x1, $ainterpolations[$ii][0x0], $ii)
        DllStructSetData($tpositions, 0x1, $ainterpolations[$ii][0x1], $ii)
    Next
    $acall = DllCall($__g_hgdipdll, "int", "GdipSetLinePresetBlend", "handle", $hlinegradientbrush, "struct*", $tcolors, "struct*", $tpositions, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_LineBrushSetPresetBlend

Func _GDIPlus_LineBrushSetSigmaBlend($hlinegradientbrush, $ffocus, $fscale = 0x1)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetLineSigmaBlend", "handle", $hlinegradientbrush, "float", $ffocus, "float", $fscale)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_LineBrushSetSigmaBlend

Func _GDIPlus_LineBrushSetTransform($hlinegradientbrush, $hmatrix)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetLineTransform", "handle", $hlinegradientbrush, "handle", $hmatrix)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_LineBrushSetTransform

Func _GDIPlus_MatrixCreate()
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateMatrix", "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x1]
EndFunc    ; -> _GDIPlus_MatrixCreate

Func _GDIPlus_MatrixCreate2($nm11 = 0x1, $nm12 = 0x1, $nm21 = 0x1, $nm22 = 0x1, $ndx = 0x0, $ndy = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateMatrix2", "float", $nm11, "float", $nm12, "float", $nm21, "float", $nm22, "float", $ndx, "float", $ndy, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x7]
EndFunc    ; -> _GDIPlus_MatrixCreate2

Func _GDIPlus_MatrixClone($hmatrix)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCloneMatrix", "handle", $hmatrix, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_MatrixClone

Func _GDIPlus_MatrixDispose($hmatrix)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeleteMatrix", "handle", $hmatrix)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_MatrixDispose

Func _GDIPlus_MatrixGetElements($hmatrix)
    Local $telements = DllStructCreate("float[6]")
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetMatrixElements", "handle", $hmatrix, "struct*", $telements)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Local $aelements[0x6]
    For $ii = 0x1 To 0x6
        $aelements[$ii + -1] = DllStructGetData($telements, 0x1, $ii)
    Next
    Return $aelements
EndFunc    ; -> _GDIPlus_MatrixGetElements

Func _GDIPlus_MatrixInvert($hmatrix)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipInvertMatrix", "handle", $hmatrix)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_MatrixInvert

Func _GDIPlus_MatrixMultiply($hmatrix1, $hmatrix2, $iorder = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipMultiplyMatrix", "handle", $hmatrix1, "handle", $hmatrix2, "int", $iorder)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_MatrixMultiply

Func _GDIPlus_MatrixRotate($hmatrix, $fangle, $bappend = False)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipRotateMatrix", "handle", $hmatrix, "float", $fangle, "int", $bappend)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_MatrixRotate

Func _GDIPlus_MatrixScale($hmatrix, $fscalex, $fscaley, $border = False)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipScaleMatrix", "handle", $hmatrix, "float", $fscalex, "float", $fscaley, "int", $border)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_MatrixScale

Func _GDIPlus_MatrixSetElements($hmatrix, $nm11 = 0x1, $nm12 = 0x0, $nm21 = 0x0, $nm22 = 0x1, $ndx = 0x0, $ndy = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetMatrixElements", "handle", $hmatrix, "float", $nm11, "float", $nm12, "float", $nm21, "float", $nm22, "float", $ndx, "float", $ndy)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_MatrixSetElements

Func _GDIPlus_MatrixShear($hmatrix, $fshearx, $fsheary, $iorder = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipShearMatrix", "handle", $hmatrix, "float", $fshearx, "float", $fsheary, "int", $iorder)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_MatrixShear

Func _GDIPlus_MatrixTransformPoints($hmatrix, ByRef $apoints)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], ($ii + -1) * 0x2 + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], ($ii + -1) * 0x2 + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipTransformMatrixPoints", "handle", $hmatrix, "struct*", $tpoints, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    For $ii = 0x1 To $icount
        $apoints[$ii][0x0] = DllStructGetData($tpoints, 0x1, ($ii + -1) * 0x2 + 0x1)
        $apoints[$ii][0x1] = DllStructGetData($tpoints, 0x1, ($ii + -1) * 0x2 + 0x2)
    Next
    Return True
EndFunc    ; -> _GDIPlus_MatrixTransformPoints

Func _GDIPlus_MatrixTranslate($hmatrix, $foffsetx, $foffsety, $bappend = False)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipTranslateMatrix", "handle", $hmatrix, "float", $foffsetx, "float", $foffsety, "int", $bappend)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_MatrixTranslate

Func _GDIPlus_ParamAdd(ByRef $tparams, $sguid, $inbofvalues, $itype, $pvalues)
    Local $icount = DllStructGetData($tparams, "Count")
    Local $pguid = DllStructGetPtr($tparams, "GUID") + ($icount * _GDIPlus_ParamSize())
    Local $tparam = DllStructCreate($TAGGDIPENCODERPARAM, $pguid)
    _WinAPI_GUIDFromStringEx($sguid, $pguid)
    DllStructSetData($tparam, "Type", $itype)
    DllStructSetData($tparam, "NumberOfValues", $inbofvalues)
    DllStructSetData($tparam, "Values", $pvalues)
    DllStructSetData($tparams, "Count", $icount + 0x1)
EndFunc    ; -> _GDIPlus_ParamAdd

Func _GDIPlus_ParamInit($icount)
    Local $sstruct = $TAGGDIPENCODERPARAMS
    For $i = 0x2 To $icount
        $sstruct &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
    Next
    Return DllStructCreate($sstruct)
EndFunc    ; -> _GDIPlus_ParamInit

Func _GDIPlus_ParamSize()
    Local $tparam = DllStructCreate($TAGGDIPENCODERPARAM)
    Return DllStructGetSize($tparam)
EndFunc    ; -> _GDIPlus_ParamSize

Func _GDIPlus_PathAddArc($hpath, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathArc", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddArc

Func _GDIPlus_PathAddBezier($hpath, $nx1, $ny1, $nx2, $ny2, $nx3, $ny3, $nx4, $ny4)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathBezier", "handle", $hpath, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2, "float", $nx3, "float", $ny3, "float", $nx4, "float", $ny4)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddBezier

Func _GDIPlus_PathAddClosedCurve($hpath, $apoints)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathClosedCurve", "handle", $hpath, "struct*", $tpoints, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddClosedCurve

Func _GDIPlus_PathAddClosedCurve2($hpath, $apoints, $ntension = 0.5)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathClosedCurve2", "handle", $hpath, "struct*", $tpoints, "int", $icount, "float", $ntension)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddClosedCurve2

Func _GDIPlus_PathAddCurve($hpath, $apoints)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathCurve", "handle", $hpath, "struct*", $tpoints, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddCurve

Func _GDIPlus_PathAddCurve2($hpath, $apoints, $ntension = 0.5)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathCurve2", "handle", $hpath, "struct*", $tpoints, "int", $icount, "float", $ntension)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddCurve2

Func _GDIPlus_PathAddCurve3($hpath, $apoints, $ioffset, $inumofsegments, $ntension = 0.5)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathCurve3", "handle", $hpath, "struct*", $tpoints, "int", $icount, "int", $ioffset, "int", $inumofsegments, "float", $ntension)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddCurve3

Func _GDIPlus_PathAddEllipse($hpath, $nx, $ny, $nwidth, $nheight)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathEllipse", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddEllipse

Func _GDIPlus_PathAddLine($hpath, $nx1, $ny1, $nx2, $ny2)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathLine", "handle", $hpath, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddLine

Func _GDIPlus_PathAddLine2($hpath, $apoints)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathLine2", "handle", $hpath, "struct*", $tpoints, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddLine2

Func _GDIPlus_PathAddPath($hpath1, $hpath2, $bconnect = True)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathPath", "handle", $hpath1, "handle", $hpath2, "int", $bconnect)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddPath

Func _GDIPlus_PathAddPie($hpath, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathPie", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddPie

Func _GDIPlus_PathAddPolygon($hpath, $apoints)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathPolygon", "handle", $hpath, "struct*", $tpoints, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddPolygon

Func _GDIPlus_PathAddRectangle($hpath, $nx, $ny, $nwidth, $nheight)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathRectangle", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddRectangle

Func _GDIPlus_PathAddString($hpath, $sstring, $tlayout, $hfamily, $istyle = 0x0, $fsize = 8.5, $hformat = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipAddPathString", "handle", $hpath, "wstr", $sstring, "int", + -1, "handle", $hfamily, "int", $istyle, "float", $fsize, "struct*", $tlayout, "handle", $hformat)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathAddString

Func _GDIPlus_PathBrushCreate($apoints, $iwrapmode = 0x0)
    Local $icount = $apoints[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreatePathGradient", "struct*", $tpoints, "int", $icount, "int", $iwrapmode, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x4]
EndFunc    ; -> _GDIPlus_PathBrushCreate

Func _GDIPlus_PathBrushCreateFromPath($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreatePathGradientFromPath", "handle", $hpath, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PathBrushCreateFromPath

Func _GDIPlus_PathBrushGetCenterPoint($hpathgradientbrush)
    Local $tpointf = DllStructCreate("float;float")
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientCenterPoint", "handle", $hpathgradientbrush, "struct*", $tpointf)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Local $apointf[0x2]
    $apointf[0x0] = DllStructGetData($tpointf, 0x1)
    $apointf[0x1] = DllStructGetData($tpointf, 0x2)
    Return $apointf
EndFunc    ; -> _GDIPlus_PathBrushGetCenterPoint

Func _GDIPlus_PathBrushGetFocusScales($hpathgradientbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientFocusScales", "handle", $hpathgradientbrush, "float*", 0x0, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Local $ascales[0x2]
    $ascales[0x0] = $acall[0x2]
    $ascales[0x1] = $acall[0x3]
    Return $ascales
EndFunc    ; -> _GDIPlus_PathBrushGetFocusScales

Func _GDIPlus_PathBrushGetPointCount($hpathgradientbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientPointCount", "handle", $hpathgradientbrush, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PathBrushGetPointCount

Func _GDIPlus_PathBrushGetRect($hpathgradientbrush)
    Local $trectf = DllStructCreate($TAGGDIPRECTF)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientRect", "handle", $hpathgradientbrush, "struct*", $trectf)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Local $arectf[0x4]
    For $ii = 0x1 To 0x4
        $arectf[$ii + -1] = DllStructGetData($trectf, $ii)
    Next
    Return $arectf
EndFunc    ; -> _GDIPlus_PathBrushGetRect

Func _GDIPlus_PathBrushGetWrapMode($hpathgradientbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientWrapMode", "handle", $hpathgradientbrush, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PathBrushGetWrapMode

Func _GDIPlus_PathBrushMultiplyTransform($hpathgradientbrush, $hmatrix, $iorder = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipMultiplyPathGradientTransform", "handle", $hpathgradientbrush, "handle", $hmatrix, "int", $iorder)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushMultiplyTransform

Func _GDIPlus_PathBrushResetTransform($hpathgradientbrush)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipResetPathGradientTransform", "handle", $hpathgradientbrush)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushResetTransform

Func _GDIPlus_PathBrushSetBlend($hpathgradientbrush, $ablends)
    Local $icount = $ablends[0x0][0x0]
    Local $tfactors = DllStructCreate("float[" & $icount & "]")
    Local $tpositions = DllStructCreate("float[" & $icount & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tfactors, 0x1, $ablends[$ii][0x0], $ii)
        DllStructSetData($tpositions, 0x1, $ablends[$ii][0x1], $ii)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientBlend", "handle", $hpathgradientbrush, "struct*", $tfactors, "struct*", $tpositions, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetBlend

Func _GDIPlus_PathBrushSetCenterColor($hpathgradientbrush, $iargb)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientCenterColor", "handle", $hpathgradientbrush, "uint", $iargb)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetCenterColor

Func _GDIPlus_PathBrushSetCenterPoint($hpathgradientbrush, $nx, $ny)
    Local $tpointf = DllStructCreate("float;float")
    DllStructSetData($tpointf, 0x1, $nx)
    DllStructSetData($tpointf, 0x2, $ny)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientCenterPoint", "handle", $hpathgradientbrush, "struct*", $tpointf)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetCenterPoint

Func _GDIPlus_PathBrushSetFocusScales($hpathgradientbrush, $fscalex, $fscaley)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientFocusScales", "handle", $hpathgradientbrush, "float", $fscalex, "float", $fscaley)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetFocusScales

Func _GDIPlus_PathBrushSetGammaCorrection($hpathgradientbrush, $busegammacorrection)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientGammaCorrection", "handle", $hpathgradientbrush, "int", $busegammacorrection)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetGammaCorrection

Func _GDIPlus_PathBrushSetLinearBlend($hpathgradientbrush, $ffocus, $fscale = 0x1)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientLinearBlend", "handle", $hpathgradientbrush, "float", $ffocus, "float", $fscale)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetLinearBlend

Func _GDIPlus_PathBrushSetPresetBlend($hpathgradientbrush, $ainterpolations)
    Local $icount = $ainterpolations[0x0][0x0]
    Local $tcolors = DllStructCreate("uint[" & $icount & "]")
    Local $tpositions = DllStructCreate("float[" & $icount & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tcolors, 0x1, $ainterpolations[$ii][0x0], $ii)
        DllStructSetData($tpositions, 0x1, $ainterpolations[$ii][0x1], $ii)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientPresetBlend", "handle", $hpathgradientbrush, "struct*", $tcolors, "struct*", $tpositions, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetPresetBlend

Func _GDIPlus_PathBrushSetSigmaBlend($hpathgradientbrush, $ffocus, $fscale = 0x1)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientSigmaBlend", "handle", $hpathgradientbrush, "float", $ffocus, "float", $fscale)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetSigmaBlend

Func _GDIPlus_PathBrushSetSurroundColor($hpathgradientbrush, $iargb)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hpathgradientbrush, "uint*", $iargb, "int*", 0x1)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetSurroundColor

Func _GDIPlus_PathBrushSetSurroundColorsWithCount($hpathgradientbrush, $acolors)
    Local $icount = $acolors[0x0]
    Local $icolors = _GDIPlus_PathBrushGetPointCount($hpathgradientbrush)
    If $icolors < $icount Then $icount = $icolors
    Local $tcolors = DllStructCreate("uint[" & $icount & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tcolors, 0x1, $acolors[$ii], $ii)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hpathgradientbrush, "struct*", $tcolors, "int*", $icount)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_PathBrushSetSurroundColorsWithCount

Func _GDIPlus_PathBrushSetTransform($hpathgradientbrush, $hmatrix)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientTransform", "handle", $hpathgradientbrush, "handle", $hmatrix)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetTransform

Func _GDIPlus_PathBrushSetWrapMode($hpathgradientbrush, $iwrapmode)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientWrapMode", "handle", $hpathgradientbrush, "int", $iwrapmode)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathBrushSetWrapMode

Func _GDIPlus_PathClone($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipClonePath", "handle", $hpath, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PathClone

Func _GDIPlus_PathCloseFigure($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipClosePathFigure", "handle", $hpath)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathCloseFigure

Func _GDIPlus_PathCreate($ifillmode = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreatePath", "int", $ifillmode, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PathCreate

Func _GDIPlus_PathCreate2($apathdata, $ifillmode = 0x0)
    Local $icount = $apathdata[0x0][0x0]
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    Local $ttypes = DllStructCreate("byte[" & $icount & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apathdata[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tpoints, 0x1, $apathdata[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
        DllStructSetData($ttypes, 0x1, $apathdata[$ii][0x2], $ii)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreatePath2", "struct*", $tpoints, "struct*", $ttypes, "int", $icount, "int", $ifillmode, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x5]
EndFunc    ; -> _GDIPlus_PathCreate2

Func _GDIPlus_PathDispose($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeletePath", "handle", $hpath)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathDispose

Func _GDIPlus_PathFlatten($hpath, $fflatness = 0.25, $hmatrix = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipFlattenPath", "handle", $hpath, "handle", $hmatrix, "float", $fflatness)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathFlatten

Func _GDIPlus_PathGetData($hpath)
    Local $icount = _GDIPlus_PathGetPointCount($hpath)
    Local $tpathdata = DllStructCreate("int Count; ptr Points; ptr Types;")
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    Local $ttypes = DllStructCreate("byte[" & $icount & "]")
    DllStructSetData($tpathdata, "Count", $icount)
    DllStructSetData($tpathdata, "Points", DllStructGetPtr($tpoints))
    DllStructSetData($tpathdata, "Types", DllStructGetPtr($ttypes))
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPathData", "handle", $hpath, "struct*", $tpathdata)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError($acall[0x0], $acall[0x0], + -1)
    Local $ADATA[$icount + 0x1][0x3]
    $ADATA[0x0][0x0] = $icount
    For $ii = 0x1 To $icount
        $ADATA[$ii][0x0] = DllStructGetData($tpoints, 0x1, (($ii + -1) * 0x2) + 0x1)
        $ADATA[$ii][0x1] = DllStructGetData($tpoints, 0x1, (($ii + -1) * 0x2) + 0x2)
        $ADATA[$ii][0x2] = DllStructGetData($ttypes, 0x1, $ii)
    Next
    Return $ADATA
EndFunc    ; -> _GDIPlus_PathGetData

Func _GDIPlus_PathGetFillMode($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPathFillMode", "handle", $hpath, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PathGetFillMode

Func _GDIPlus_PathGetLastPoint($hpath)
    Local $tpointf = DllStructCreate("float;float")
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPathLastPoint", "handle", $hpath, "struct*", $tpointf)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Local $apointf[0x2]
    $apointf[0x0] = DllStructGetData($tpointf, 0x1)
    $apointf[0x1] = DllStructGetData($tpointf, 0x2)
    Return $apointf
EndFunc    ; -> _GDIPlus_PathGetLastPoint

Func _GDIPlus_PathGetPointCount($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPointCount", "handle", $hpath, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PathGetPointCount

Func _GDIPlus_PathGetPoints($hpath)
    Local $ii, $icount, $tpoints, $apoints[0x1][0x1], $acall
    $icount = _GDIPlus_PathGetPointCount($hpath)
    If @error Then Return SetError(@error + 0xa, @extended, + -1)
    $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    $acall = DllCall($__g_hgdipdll, "int", "GdipGetPathPoints", "handle", $hpath, "struct*", $tpoints, "int", $icount)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Local $apoints[$icount + 0x1][0x2]
    $apoints[0x0][0x0] = $icount
    For $ii = 0x1 To $icount
        $apoints[$ii][0x0] = DllStructGetData($tpoints, 0x1, (($ii + -1) * 0x2) + 0x1)
        $apoints[$ii][0x1] = DllStructGetData($tpoints, 0x1, (($ii + -1) * 0x2) + 0x2)
    Next
    Return $apoints
EndFunc    ; -> _GDIPlus_PathGetPoints

Func _GDIPlus_PathGetWorldBounds($hpath, $hmatrix = 0x0, $hpen = 0x0)
    Local $trectf = DllStructCreate($TAGGDIPRECTF)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPathWorldBounds", "handle", $hpath, "struct*", $trectf, "handle", $hmatrix, "handle", $hpen)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Local $arectf[0x4]
    For $ii = 0x1 To 0x4
        $arectf[$ii + -1] = DllStructGetData($trectf, $ii)
    Next
    Return $arectf
EndFunc    ; -> _GDIPlus_PathGetWorldBounds

Func _GDIPlus_PathIsOutlineVisiblePoint($hpath, $nx, $ny, $hpen = 0x0, $hgraphics = 0x0)
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipIsOutlineVisiblePathPoint", "handle", $hpath, "float", $nx, "float", $ny, "handle", $hpen, "handle", $hgraphics, "int*", 0x0)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return $acall[0x6] <> 0x0
EndFunc    ; -> _GDIPlus_PathIsOutlineVisiblePoint

Func _GDIPlus_PathIsVisiblePoint($hpath, $nx, $ny, $hgraphics = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipIsVisiblePathPoint", "handle", $hpath, "float", $nx, "float", $ny, "handle", $hgraphics, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return $acall[0x5] <> 0x0
EndFunc    ; -> _GDIPlus_PathIsVisiblePoint

Func _GDIPlus_PathIterCreate($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreatePathIter", "handle*", 0x0, "handle", $hpath)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x1]
EndFunc    ; -> _GDIPlus_PathIterCreate

Func _GDIPlus_PathIterDispose($hpathiter)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeletePathIter", "handle", $hpathiter)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathIterDispose

Func _GDIPlus_PathIterGetSubpathCount($hpathiter)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipPathIterGetSubpathCount", "handle", $hpathiter, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PathIterGetSubpathCount

Func _GDIPlus_PathIterNextMarkerPath($hpathiter, $hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipPathIterNextMarkerPath", "handle", $hpathiter, "int*", 0x0, "handle", $hpath)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PathIterNextMarkerPath

Func _GDIPlus_PathIterNextSubpathPath($hpathiter, $hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipPathIterNextSubpathPath", "handle", $hpathiter, "int*", 0x0, "handle", $hpath, "bool*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Local $aret[0x2]
    $aret[0x0] = $acall[0x2]
    $aret[0x1] = $acall[0x4]
    Return $aret
EndFunc    ; -> _GDIPlus_PathIterNextSubpathPath

Func _GDIPlus_PathIterRewind($hpathiter)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipPathIterRewind", "handle", $hpathiter)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathIterRewind

Func _GDIPlus_PathReset($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipResetPath", "handle", $hpath)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathReset

Func _GDIPlus_PathReverse($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipReversePath", "handle", $hpath)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathReverse

Func _GDIPlus_PathSetFillMode($hpath, $ifillmode)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathFillMode", "handle", $hpath, "int", $ifillmode)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathSetFillMode

Func _GDIPlus_PathSetMarker($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPathMarker", "handle", $hpath)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathSetMarker

Func _GDIPlus_PathStartFigure($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipStartPathFigure", "handle", $hpath)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathStartFigure

Func _GDIPlus_PathTransform($hpath, $hmatrix)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipTransformPath", "handle", $hpath, "handle", $hmatrix)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathTransform

Func _GDIPlus_PathWarp($hpath, $hmatrix, $apoints, $nx, $ny, $nwidth, $nheight, $iwarpmode = 0x0, $fflatness = 0.25)
    Local $icount = $apoints[0x0][0x0]
    If $icount <> 0x3 And $icount <> 0x4 Then Return SetError(0xb, 0x0, False)
    Local $tpoints = DllStructCreate("float[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x0], ($ii + -1) * 0x2 + 0x1)
        DllStructSetData($tpoints, 0x1, $apoints[$ii][0x1], ($ii + -1) * 0x2 + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipWarpPath", "handle", $hpath, "handle", $hmatrix, "struct*", $tpoints, "int", $icount, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "int", $iwarpmode, "float", $fflatness)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathWarp

Func _GDIPlus_PathWiden($hpath, $hpen, $hmatrix = 0x0, $fflatness = 0.25)
    __GDIPlus_PenDefCreate($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipWidenPath", "handle", $hpath, "handle", $hpen, "handle", $hmatrix, "float", $fflatness)
    __GDIPlus_PenDefDispose()
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathWiden

Func _GDIPlus_PathWindingModeOutline($hpath, $hmatrix = 0x0, $fflatness = 0.25)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipWindingModeOutline", "handle", $hpath, "handle", $hmatrix, "float", $fflatness)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PathWindingModeOutline

Func _GDIPlus_PenCreate($iargb = -16777216, $nwidth = 0x1, $iunit = 0x2)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreatePen1", "dword", $iargb, "float", $nwidth, "int", $iunit, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x4]
EndFunc    ; -> _GDIPlus_PenCreate

Func _GDIPlus_PenCreate2($hbrush, $nwidth = 0x1, $iunit = 0x2)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreatePen2", "handle", $hbrush, "float", $nwidth, "int", $iunit, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x4]
EndFunc    ; -> _GDIPlus_PenCreate2

Func _GDIPlus_PenDispose($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeletePen", "handle", $hpen)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenDispose

Func _GDIPlus_PenGetAlignment($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPenMode", "handle", $hpen, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PenGetAlignment

Func _GDIPlus_PenGetColor($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPenColor", "handle", $hpen, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PenGetColor

Func _GDIPlus_PenGetCustomEndCap($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPenCustomEndCap", "handle", $hpen, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PenGetCustomEndCap

Func _GDIPlus_PenGetDashCap($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPenDashCap197819", "handle", $hpen, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PenGetDashCap

Func _GDIPlus_PenGetDashStyle($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPenDashStyle", "handle", $hpen, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PenGetDashStyle

Func _GDIPlus_PenGetEndCap($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPenEndCap", "handle", $hpen, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PenGetEndCap

Func _GDIPlus_PenGetMiterLimit($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPenMiterLimit", "handle", $hpen, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PenGetMiterLimit

Func _GDIPlus_PenGetWidth($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetPenWidth", "handle", $hpen, "float*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_PenGetWidth

Func _GDIPlus_PenResetTransform($hpen)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipResetPenTransform", "handle", $hpen)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenResetTransform

Func _GDIPlus_PenRotateTransform($hpen, $fangle, $iorder = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipRotatePenTransform", "handle", $hpen, "float", $fangle, "int", $iorder)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenRotateTransform

Func _GDIPlus_PenScaleTransform($hpen, $fscalex, $fscaley, $iorder = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipScalePenTransform", "handle", $hpen, "float", $fscalex, "float", $fscaley, "int", $iorder)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenScaleTransform

Func _GDIPlus_PenSetAlignment($hpen, $ialignment = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenMode", "handle", $hpen, "int", $ialignment)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetAlignment

Func _GDIPlus_PenSetColor($hpen, $iargb)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenColor", "handle", $hpen, "dword", $iargb)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetColor

Func _GDIPlus_PenSetCompound($hpen, $acompounds)
    Local $icount = $acompounds[0x0]
    Local $tcompounds = DllStructCreate("float[" & $icount & "];")
    For $i = 0x1 To $icount
        DllStructSetData($tcompounds, 0x1, $acompounds[$i], $i)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenCompoundArray", "handle", $hpen, "struct*", $tcompounds, "int", $icount)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetCompound

Func _GDIPlus_PenSetCustomEndCap($hpen, $hendcap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenCustomEndCap", "handle", $hpen, "handle", $hendcap)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetCustomEndCap

Func _GDIPlus_PenSetDashCap($hpen, $idash = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenDashCap197819", "handle", $hpen, "int", $idash)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetDashCap

Func _GDIPlus_PenSetDashStyle($hpen, $istyle = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenDashStyle", "handle", $hpen, "int", $istyle)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetDashStyle

Func _GDIPlus_PenSetEndCap($hpen, $iendcap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenEndCap", "handle", $hpen, "int", $iendcap)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetEndCap

Func _GDIPlus_PenSetLineCap($hpen, $istartcap, $iendcap, $idashcap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenLineCap197819", "handle", $hpen, "int", $istartcap, "int", $iendcap, "int", $idashcap)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetLineCap

Func _GDIPlus_PenSetLineJoin($hpen, $ilinejoin)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenLineJoin", "handle", $hpen, "int", $ilinejoin)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetLineJoin

Func _GDIPlus_PenSetMiterLimit($hpen, $fmiterlimit)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenMiterLimit", "handle", $hpen, "float", $fmiterlimit)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetMiterLimit

Func _GDIPlus_PenSetStartCap($hpen, $ilinecap)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenStartCap", "handle", $hpen, "int", $ilinecap)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetStartCap

Func _GDIPlus_PenSetTransform($hpen, $hmatrix)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenTransform", "handle", $hpen, "handle", $hmatrix)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetTransform

Func _GDIPlus_PenSetWidth($hpen, $fwidth)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetPenWidth", "handle", $hpen, "float", $fwidth)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_PenSetWidth

Func _GDIPlus_RectFCreate($nx = 0x0, $ny = 0x0, $nwidth = 0x0, $nheight = 0x0)
    Local $trectf = DllStructCreate($TAGGDIPRECTF)
    DllStructSetData($trectf, "X", $nx)
    DllStructSetData($trectf, "Y", $ny)
    DllStructSetData($trectf, "Width", $nwidth)
    DllStructSetData($trectf, "Height", $nheight)
    Return $trectf
EndFunc    ; -> _GDIPlus_RectFCreate

Func _GDIPlus_RegionClone($hregion)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCloneRegion", "handle", $hregion, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_RegionClone

Func _GDIPlus_RegionCombinePath($hregion, $hpath, $icombinemode = 0x2)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCombineRegionPath", "handle", $hregion, "handle", $hpath, "int", $icombinemode)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_RegionCombinePath

Func _GDIPlus_RegionCombineRect($hregion, $nx, $ny, $nwidth, $nheight, $icombinemode = 0x2)
    Local $trectf = _GDIPlus_RectFCreate($nx, $ny, $nwidth, $nheight)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCombineRegionRect", "handle", $hregion, "struct*", $trectf, "int", $icombinemode)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_RegionCombineRect

Func _GDIPlus_RegionCombineRegion($hregiondst, $hregionsrc, $icombinemode = 0x2)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCombineRegionRegion", "handle", $hregiondst, "handle", $hregionsrc, "int", $icombinemode)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_RegionCombineRegion

Func _GDIPlus_RegionCreate()
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateRegion", "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x1]
EndFunc    ; -> _GDIPlus_RegionCreate

Func _GDIPlus_RegionCreateFromPath($hpath)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateRegionPath", "handle", $hpath, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_RegionCreateFromPath

Func _GDIPlus_RegionCreateFromRect($nx, $ny, $nwidth, $nheight)
    Local $trectf = _GDIPlus_RectFCreate($nx, $ny, $nwidth, $nheight)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateRegionRect", "struct*", $trectf, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_RegionCreateFromRect

Func _GDIPlus_RegionDispose($hregion)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeleteRegion", "handle", $hregion)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_RegionDispose

Func _GDIPlus_RegionGetBounds($hregion, $hgraphics)
    Local $trectf = DllStructCreate($TAGGDIPRECTF)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetRegionBounds", "handle", $hregion, "handle", $hgraphics, "struct*", $trectf)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Local $abounds[0x4]
    For $ii = 0x1 To 0x4
        $abounds[$ii + -1] = DllStructGetData($trectf, $ii)
    Next
    Return $abounds
EndFunc    ; -> _GDIPlus_RegionGetBounds

Func _GDIPlus_RegionGetHRgn($hregion, $hgraphics = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetRegionHRgn", "handle", $hregion, "handle", $hgraphics, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_RegionGetHRgn

Func _GDIPlus_RegionSetEmpty($hregion)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetEmpty", "handle", $hregion)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_RegionSetEmpty

Func _GDIPlus_RegionSetInfinite($hregion)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetInfinite", "handle", $hregion)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_RegionSetInfinite

Func _GDIPlus_RegionTransform($hregion, $hmatrix)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipTransformRegion", "handle", $hregion, "handle", $hmatrix)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_RegionTransform

Func _GDIPlus_RegionTranslate($hregion, $ndx, $ndy)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipTranslateRegion", "handle", $hregion, "float", $ndx, "float", $ndy)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_RegionTranslate

Func _GDIPlus_Shutdown()
    If $__g_hgdipdll = 0x0 Then Return SetError(+ -1, + -1, False)
    $__g_igdipref -= 0x1
    If $__g_igdipref = 0x0 Then
        DllCall($__g_hgdipdll, "none", "GdiplusShutdown", "ulong_ptr", $__g_igdiptoken)
        DllClose($__g_hgdipdll)
        $__g_hgdipdll = 0x0
    EndIf
    Return True
EndFunc    ; -> _GDIPlus_Shutdown

Func _GDIPlus_Startup($sgdipdll = Default, $bretdllhandle = False)
    $__g_igdipref += 0x1
    If $__g_igdipref > 0x1 Then Return True
    If $sgdipdll = Default Then $sgdipdll = "gdiplus.dll"
    $__g_hgdipdll = DllOpen($sgdipdll)
    If $__g_hgdipdll = + -1 Then
        $__g_igdipref = 0x0
        Return SetError(0x1, 0x2, False)
    EndIf
    Local $sver = FileGetVersion($sgdipdll)
    $sver = StringSplit($sver, ".")
    If $sver[0x1] > 0x5 Then $__g_bgdip_v1_0 = False
    Local $tinput = DllStructCreate($TAGGDIPSTARTUPINPUT)
    Local $ttoken = DllStructCreate("ulong_ptr Data")
    DllStructSetData($tinput, "Version", 0x1)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdiplusStartup", "struct*", $ttoken, "struct*", $tinput, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    $__g_igdiptoken = DllStructGetData($ttoken, "Data")
    If $bretdllhandle Then Return $__g_hgdipdll
    Return SetExtended($sver[0x1], True)
EndFunc    ; -> _GDIPlus_Startup

Func _GDIPlus_StringFormatCreate($iformat = 0x0, $ilangid = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateStringFormat", "int", $iformat, "word", $ilangid, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_StringFormatCreate

Func _GDIPlus_StringFormatDispose($hformat)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeleteStringFormat", "handle", $hformat)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_StringFormatDispose

Func _GDIPlus_StringFormatGetMeasurableCharacterRangeCount($hstringformat)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetStringFormatMeasurableCharacterRangeCount", "handle", $hstringformat, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_StringFormatGetMeasurableCharacterRangeCount

Func _GDIPlus_StringFormatSetAlign($hstringformat, $IFLAG)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetStringFormatAlign", "handle", $hstringformat, "int", $IFLAG)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_StringFormatSetAlign

Func _GDIPlus_StringFormatSetLineAlign($hstringformat, $istringalign)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetStringFormatLineAlign", "handle", $hstringformat, "int", $istringalign)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_StringFormatSetLineAlign

Func _GDIPlus_StringFormatSetMeasurableCharacterRanges($hstringformat, $aranges)
    Local $icount = $aranges[0x0][0x0]
    Local $tcharacterranges = DllStructCreate("int[" & $icount * 0x2 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tcharacterranges, 0x1, $aranges[$ii][0x0], (($ii + -1) * 0x2) + 0x1)
        DllStructSetData($tcharacterranges, 0x1, $aranges[$ii][0x1], (($ii + -1) * 0x2) + 0x2)
    Next
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetStringFormatMeasurableCharacterRanges", "handle", $hstringformat, "int", $icount, "struct*", $tcharacterranges)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_StringFormatSetMeasurableCharacterRanges

Func _GDIPlus_TextureCreate($himage, $iwrapmode = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateTexture", "handle", $himage, "int", $iwrapmode, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_TextureCreate

Func _GDIPlus_TextureCreate2($himage, $nx, $ny, $nwidth, $nheight, $iwrapmode = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateTexture2", "handle", $himage, "int", $iwrapmode, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x7]
EndFunc    ; -> _GDIPlus_TextureCreate2

Func _GDIPlus_TextureCreateIA($himage, $nx, $ny, $nwidth, $nheight, $pimageattributes = 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipCreateTextureIA", "handle", $himage, "handle", $pimageattributes, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x7]
EndFunc    ; -> _GDIPlus_TextureCreateIA

Func __GDIPlus_BrushDefCreate(ByRef $hbrush)
    If $hbrush = 0x0 Then
        $__g_hgdipbrush = _GDIPlus_BrushCreateSolid()
        $hbrush = $__g_hgdipbrush
    EndIf
EndFunc    ; -> __GDIPlus_BrushDefCreate

Func __GDIPlus_BrushDefDispose($icurerror = @error, $icurextended = @extended)
    If $__g_hgdipbrush <> 0x0 Then
        _GDIPlus_BrushDispose($__g_hgdipbrush)
        $__g_hgdipbrush = 0x0
    EndIf
    Return SetError($icurerror, $icurextended)
EndFunc    ; -> __GDIPlus_BrushDefDispose

Func __GDIPlus_ExtractFileExt($sfilename, $bnodot = True)
    Local $iindex = __GDIPlus_LastDelimiter(".\\:", $sfilename)
    If ($iindex > 0x0) And (StringMid($sfilename, $iindex, 0x1) = ".") Then
        If $bnodot Then
            Return StringMid($sfilename, $iindex + 0x1)
        Else
            Return StringMid($sfilename, $iindex)
        EndIf
    Else
        Return ''
    EndIf
EndFunc    ; -> __GDIPlus_ExtractFileExt

Func __GDIPlus_LastDelimiter($sdelimiters, $sstring)
    Local $SDELIMITER, $in
    For $ii = 0x1 To StringLen($sdelimiters)
        $SDELIMITER = StringMid($sdelimiters, $ii, 0x1)
        $in = StringInStr($sstring, $SDELIMITER, $STR_NOCASESENSEBASIC, + -1)
        If $in > 0x0 Then Return $in
    Next
EndFunc    ; -> __GDIPlus_LastDelimiter

Func __GDIPlus_PenDefCreate(ByRef $hpen)
    If $hpen = 0x0 Then
        $__g_hgdippen = _GDIPlus_PenCreate()
        $hpen = $__g_hgdippen
    EndIf
EndFunc    ; -> __GDIPlus_PenDefCreate

Func __GDIPlus_PenDefDispose($icurerror = @error, $icurextended = @extended)
    If $__g_hgdippen <> 0x0 Then
        _GDIPlus_PenDispose($__g_hgdippen)
        $__g_hgdippen = 0x0
    EndIf
    Return SetError($icurerror, $icurextended)
EndFunc    ; -> __GDIPlus_PenDefDispose

Func _GDIPlus_BitmapApplyEffect($hbitmap, $heffect, $trect = Null)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, False)
    If Not IsPtr($heffect) Then Return SetError(0xa, 0x0, False)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipBitmapApplyEffect", "handle", $hbitmap, "handle", $heffect, "struct*", $trect, "int", 0x0, "ptr*", 0x0, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_BitmapApplyEffect

Func _GDIPlus_BitmapApplyEffectEx($hbitmap, $heffect, $ix = 0x0, $iy = 0x0, $iw = 0x0, $ih = 0x0)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, False)
    Local $trect = 0x0
    If BitOR($ix, $iy, $iw, $ih) Then
        $trect = DllStructCreate("int Left; int Top; int Right; int Bottom;")
        DllStructSetData($trect, "Right", $iw + DllStructSetData($trect, "Left", $ix))
        DllStructSetData($trect, "Bottom", $ih + DllStructSetData($trect, "Top", $iy))
    EndIf
    Local $istatus = _GDIPlus_BitmapApplyEffect($hbitmap, $heffect, $trect)
    If Not $istatus Then Return SetError(@error, @extended, False)
    Return True
EndFunc    ; -> _GDIPlus_BitmapApplyEffectEx

Func _GDIPlus_BitmapConvertFormat($hbitmap, $ipixelformat, $idithertype, $ipalettetype, $tpalette, $falphathresholdpercent = 0)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, False)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipBitmapConvertFormat", "handle", $hbitmap, "uint", $ipixelformat, "uint", $idithertype, "uint", $ipalettetype, "struct*", $tpalette, "float", $falphathresholdpercent)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_BitmapConvertFormat

Func _GDIPlus_BitmapCreateApplyEffect($hbitmap, $heffect, $trect = Null, $toutrect = Null)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipBitmapCreateApplyEffect", "handle*", $hbitmap, "int", 0x1, "handle", $heffect, "struct*", $trect, "struct*", $toutrect, "handle*", 0x0, "int", 0x0, "ptr*", 0x0, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x6]
EndFunc    ; -> _GDIPlus_BitmapCreateApplyEffect

Func _GDIPlus_BitmapCreateApplyEffectEx($hbitmap, $heffect, $ix = 0x0, $iy = 0x0, $iw = 0x0, $ih = 0x0)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $trect = 0x0
    If BitOR($ix, $iy, $iw, $ih) Then
        $trect = DllStructCreate("int Left; int Top; int Right; int Bottom;")
        DllStructSetData($trect, "Right", $iw + DllStructSetData($trect, "Left", $ix))
        DllStructSetData($trect, "Bottom", $ih + DllStructSetData($trect, "Top", $iy))
    EndIf
    Local $hbitmap_fx = _GDIPlus_BitmapCreateApplyEffect($hbitmap, $heffect, $trect, Null)
    Return SetError(@error, @extended, $hbitmap_fx)
EndFunc    ; -> _GDIPlus_BitmapCreateApplyEffectEx

Func _GDIPlus_BitmapGetHistogram($hbitmap, $ihistogramformat, $ihistogramsize, $tchannel_0, $tchannel_1 = 0x0, $tchannel_2 = 0x0, $tchannel_3 = 0x0)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, False)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipBitmapGetHistogram", "handle", $hbitmap, "uint", $ihistogramformat, "uint", $ihistogramsize, "struct*", $tchannel_0, "struct*", $tchannel_1, "struct*", $tchannel_2, "struct*", $tchannel_3)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_BitmapGetHistogram

Func _GDIPlus_BitmapGetHistogramEx($hbitmap)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $isize = _GDIPlus_BitmapGetHistogramSize($GDIP_HISTOGRAMFORMATARGB)
    Local $thistogram = DllStructCreate("int Size; uint Red[" & $isize & "]; uint MaxRed; uint Green[" & $isize & "]; uint MaxGreen; uint Blue[" & $isize & "]; uint MaxBlue; uint Alpha[" & $isize & "]; uint MaxAlpha; uint Grey[" & $isize & "]; uint MaxGrey;")
    DllStructSetData($thistogram, "Size", $isize)
    Local $istatus = _GDIPlus_BitmapGetHistogram($hbitmap, $GDIP_HISTOGRAMFORMATARGB, $isize, DllStructGetPtr($thistogram, "Alpha"), DllStructGetPtr($thistogram, "Red"), DllStructGetPtr($thistogram, "Green"), DllStructGetPtr($thistogram, "Blue"))
    If Not $istatus Then Return SetError(@error, @extended, 0x0)
    $istatus = _GDIPlus_BitmapGetHistogram($hbitmap, $GDIP_HISTOGRAMFORMATGRAY, $isize, DllStructGetPtr($thistogram, "Grey"))
    If Not $istatus Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $imaxred = 0x0, $imaxgreen = 0x0, $imaxblue = 0x0, $imaxalpha = 0x0, $imaxgrey = 0x0
    For $i = 0x1 To $isize
        If DllStructGetData($thistogram, "Red", $i) > $imaxred Then $imaxred = DllStructGetData($thistogram, "Red", $i)
        If DllStructGetData($thistogram, "Green", $i) > $imaxgreen Then $imaxgreen = DllStructGetData($thistogram, "Green", $i)
        If DllStructGetData($thistogram, "Blue", $i) > $imaxblue Then $imaxblue = DllStructGetData($thistogram, "Blue", $i)
        If DllStructGetData($thistogram, "Alpha", $i) > $imaxalpha Then $imaxalpha = DllStructGetData($thistogram, "Alpha", $i)
        If DllStructGetData($thistogram, "Grey", $i) > $imaxgrey Then $imaxgrey = DllStructGetData($thistogram, "Grey", $i)
    Next
    DllStructSetData($thistogram, "MaxRed", $imaxred)
    DllStructSetData($thistogram, "MaxGreen", $imaxgreen)
    DllStructSetData($thistogram, "MaxBlue", $imaxblue)
    DllStructSetData($thistogram, "MaxAlpha", $imaxalpha)
    DllStructSetData($thistogram, "MaxGrey", $imaxgrey)
    Return $thistogram
EndFunc    ; -> _GDIPlus_BitmapGetHistogramEx

Func _GDIPlus_BitmapGetHistogramSize($iformat)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipBitmapGetHistogramSize", "uint", $iformat, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x2]
EndFunc    ; -> _GDIPlus_BitmapGetHistogramSize

Func _GDIPlus_DrawImageFX($hgraphics, $himage, $heffect, $trectf = 0x0, $hmatrix = 0x0, $himgattributes = 0x0, $iunit = 0x2)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, False)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDrawImageFX", "handle", $hgraphics, "handle", $himage, "struct*", $trectf, "handle", $hmatrix, "handle", $heffect, "handle", $himgattributes, "uint", $iunit)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_DrawImageFX

Func _GDIPlus_DrawImageFXEx($hgraphics, $himage, $heffect, $nx = 0x0, $ny = 0x0, $nw = 0x0, $nh = 0x0, $hmatrix = 0x0, $himgattributes = 0x0, $iunit = 0x2)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, False)
    Local $trectf = 0x0
    If BitOR($nx, $ny, $nw, $nh) Then $trectf = _GDIPlus_RectFCreate($nx, $ny, $nw, $nh)
    Local $istatus = _GDIPlus_DrawImageFX($hgraphics, $himage, $heffect, $trectf, $hmatrix, $himgattributes, $iunit)
    Return SetError(@error, @extended, $istatus)
EndFunc    ; -> _GDIPlus_DrawImageFXEx

Func _GDIPlus_EffectCreate($seffectguid)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $tguid = _WinAPI_GUIDFromString($seffectguid)
    Local $acall
    If @AutoItX64 Then
        $acall = DllCall($__g_hgdipdll, "int", "GdipCreateEffect", "struct*", $tguid, "handle*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x2]
    EndIf
    Local $telem = DllStructCreate("uint64[2];", DllStructGetPtr($tguid))
    $acall = DllCall($__g_hgdipdll, "int", "GdipCreateEffect", "uint64", DllStructGetData($telem, 0x1, 0x1), "uint64", DllStructGetData($telem, 0x1, 0x2), "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $acall[0x3]
EndFunc    ; -> _GDIPlus_EffectCreate

Func _GDIPlus_EffectCreateBlur($fradius = 10, $bexpandedge = False)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $teffectparameters = DllStructCreate($TAGGDIP_EFFECTPARAMS_BLUR)
    DllStructSetData($teffectparameters, "Radius", $fradius)
    DllStructSetData($teffectparameters, "ExpandEdge", $bexpandedge)
    Local $heffect = _GDIPlus_EffectCreate($GDIP_BLUREFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $teffectparameters)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateBlur

Func _GDIPlus_EffectCreateBrightnessContrast($ibrightnesslevel = 0x0, $icontrastlevel = 0x0)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $teffectparameters = DllStructCreate($TAGGDIP_EFFECTPARAMS_BRIGHTNESSCONTRAST)
    DllStructSetData($teffectparameters, "BrightnessLevel", $ibrightnesslevel)
    DllStructSetData($teffectparameters, "ContrastLevel", $icontrastlevel)
    Local $heffect = _GDIPlus_EffectCreate($GDIP_BRIGHTNESSCONTRASTEFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $teffectparameters)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateBrightnessContrast

Func _GDIPlus_EffectCreateColorBalance($icyanred = 0x0, $imagentagreen = 0x0, $iyellowblue = 0x0)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $teffectparameters = DllStructCreate($TAGGDIP_EFFECTPARAMS_COLORBALANCE)
    DllStructSetData($teffectparameters, "CyanRed", $icyanred)
    DllStructSetData($teffectparameters, "MagentaGreen", $imagentagreen)
    DllStructSetData($teffectparameters, "YellowBlue", $iyellowblue)
    Local $heffect = _GDIPlus_EffectCreate($GDIP_COLORBALANCEEFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $teffectparameters)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateColorBalance

Func _GDIPlus_EffectCreateColorCurve($iadjustment, $ichannel, $iadjustvalue)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $teffectparameters = DllStructCreate($TAGGDIP_EFFECTPARAMS_COLORCURVE)
    DllStructSetData($teffectparameters, "Adjustment", $iadjustment)
    DllStructSetData($teffectparameters, "Channel", $ichannel)
    DllStructSetData($teffectparameters, "AdjustValue", $iadjustvalue)
    Local $heffect = _GDIPlus_EffectCreate($GDIP_COLORCURVEEFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $teffectparameters)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateColorCurve

Func _GDIPlus_EffectCreateColorLUT($acolorlut)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $teffectparameters = DllStructCreate($TAGGDIP_EFFECTPARAMS_COLORLUT)
    For $ii = 0x0 To 0xff
        DllStructSetData($teffectparameters, "LutA", $acolorlut[$ii][0x0], $ii + 0x1)
        DllStructSetData($teffectparameters, "LutR", $acolorlut[$ii][0x1], $ii + 0x1)
        DllStructSetData($teffectparameters, "LutG", $acolorlut[$ii][0x2], $ii + 0x1)
        DllStructSetData($teffectparameters, "LutB", $acolorlut[$ii][0x3], $ii + 0x1)
    Next
    Local $heffect = _GDIPlus_EffectCreate($GDIP_COLORLUTEFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $teffectparameters)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateColorLUT

Func _GDIPlus_EffectCreateColorMatrix($tcolormatrix)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $heffect = _GDIPlus_EffectCreate($GDIP_COLORMATRIXEFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $tcolormatrix)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateColorMatrix

Func _GDIPlus_EffectCreateHueSaturationLightness($ihuelevel = 0x0, $isaturationlevel = 0x0, $ilightnesslevel = 0x0)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $teffectparameters = DllStructCreate($TAGGDIP_EFFECTPARAMS_HUESATURATIONLIGHTNESS)
    DllStructSetData($teffectparameters, "HueLevel", $ihuelevel)
    DllStructSetData($teffectparameters, "SaturationLevel", $isaturationlevel)
    DllStructSetData($teffectparameters, "LightnessLevel", $ilightnesslevel)
    Local $heffect = _GDIPlus_EffectCreate($GDIP_HUESATURATIONLIGHTNESSEFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $teffectparameters)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateHueSaturationLightness

Func _GDIPlus_EffectCreateLevels($ihighlight = 0x64, $imidtone = 0x0, $ishadow = 0x0)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $teffectparameters = DllStructCreate($TAGGDIP_EFFECTPARAMS_LEVELS)
    DllStructSetData($teffectparameters, "Highlight", $ihighlight)
    DllStructSetData($teffectparameters, "Midtone", $imidtone)
    DllStructSetData($teffectparameters, "Shadow", $ishadow)
    Local $heffect = _GDIPlus_EffectCreate($GDIP_LEVELSEFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $teffectparameters)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateLevels

Func _GDIPlus_EffectCreateRedEyeCorrection($aareas)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $icount = $aareas[0x0][0x0]
    Local $tareas = DllStructCreate("long[" & $icount * 0x4 & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($tareas, 0x1, DllStructSetData($tareas, 0x1, $aareas[$ii][0x0], (($ii + -1) * 0x4) + 0x1) + $aareas[$ii][0x2], (($ii + -1) * 0x4) + 0x3)
        DllStructSetData($tareas, 0x1, DllStructSetData($tareas, 0x1, $aareas[$ii][0x1], (($ii + -1) * 0x4) + 0x2) + $aareas[$ii][0x3], (($ii + -1) * 0x4) + 0x4)
    Next
    Local $teffectparameters = DllStructCreate($TAGGDIP_EFFECTPARAMS_REDEYECORRECTION)
    DllStructSetData($teffectparameters, "NumberOfAreas", $icount)
    DllStructSetData($teffectparameters, "Areas", DllStructGetPtr($tareas))
    Local $heffect = _GDIPlus_EffectCreate($GDIP_REDEYECORRECTIONEFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $teffectparameters, (DllStructGetSize($tareas) + DllStructGetSize($teffectparameters)) / DllStructGetSize($teffectparameters))
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateRedEyeCorrection

Func _GDIPlus_EffectCreateSharpen($fradius = 10, $famount = 50)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $teffectparameters = DllStructCreate($TAGGDIP_EFFECTPARAMS_SHARPEN)
    DllStructSetData($teffectparameters, "Radius", $fradius)
    DllStructSetData($teffectparameters, "Amount", $famount)
    Local $heffect = _GDIPlus_EffectCreate($GDIP_SHARPENEFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $teffectparameters)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateSharpen

Func _GDIPlus_EffectCreateTint($ihue = 0x0, $iamount = 0x0)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    Local $teffectparameters = DllStructCreate($TAGGDIP_EFFECTPARAMS_TINT)
    DllStructSetData($teffectparameters, "Hue", $ihue)
    DllStructSetData($teffectparameters, "Amount", $iamount)
    Local $heffect = _GDIPlus_EffectCreate($GDIP_TINTEFFECTGUID)
    If @error Then Return SetError(@error, @extended, 0x0)
    _GDIPlus_EffectSetParameters($heffect, $teffectparameters)
    If @error Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $heffect
EndFunc    ; -> _GDIPlus_EffectCreateTint

Func _GDIPlus_EffectDispose($heffect)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, False)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipDeleteEffect", "handle", $heffect)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_EffectDispose

Func _GDIPlus_EffectGetParameters($heffect, $teffectparameters)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, False)
    If DllStructGetSize($teffectparameters) < __GDIPlus_EffectGetParameterSize($heffect) Then Return SetError(0x2, 0x5, False)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetEffectParameters", "handle", $heffect, "uint*", DllStructGetSize($teffectparameters), "struct*", $teffectparameters)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_EffectGetParameters

Func __GDIPlus_EffectGetParameterSize($heffect)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, + -1)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipGetEffectParameterSize", "handle", $heffect, "uint*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x2]
EndFunc    ; -> __GDIPlus_EffectGetParameterSize

Func _GDIPlus_EffectSetParameters($heffect, $teffectparameters, $isizeadjust = 0x1)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, False)
    Local $isize = __GDIPlus_EffectGetParameterSize($heffect)
    If @error Then Return SetError(@error, @extended, False)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipSetEffectParameters", "handle", $heffect, "struct*", $teffectparameters, "uint", $isize * $isizeadjust)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _GDIPlus_EffectSetParameters

Func _GDIPlus_PaletteInitialize($ientries, $ipalettetype = $GDIP_PALETTETYPEOPTIMAL, $ioptimalcolors = 0x0, $busetransparentcolor = True, $hbitmap = Null)
    If $__g_bgdip_v1_0 Then Return SetError(+ -1, 0x0, 0x0)
    If $ioptimalcolors > 0x0 Then $ipalettetype = $GDIP_PALETTETYPEOPTIMAL
    Local $tpalette = DllStructCreate("uint Flags; uint Count; uint ARGB[" & $ientries & "];")
    DllStructSetData($tpalette, "Flags", $ipalettetype)
    DllStructSetData($tpalette, "Count", $ientries)
    Local $acall = DllCall($__g_hgdipdll, "int", "GdipInitializePalette", "struct*", $tpalette, "uint", $ipalettetype, "uint", $ioptimalcolors, "bool", $busetransparentcolor, "handle", $hbitmap)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Return $tpalette
EndFunc    ; -> _GDIPlus_PaletteInitialize

#Region Global Variables and Constants
    Global $__g_hguictrl_lastwnd
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
Func __guictrl_sendmsg($hwnd, $imsg, $iindex, ByRef $titem, $tbuffer = 0x0, $bretitem = False, $ielement = + -1, $bretbuffer = False, $ielementmax = $ielement)
    If $ielement > 0x0 Then
        DllStructSetData($titem, $ielement, DllStructGetPtr($tbuffer))
        If $ielement = $ielementmax Then DllStructSetData($titem, $ielement + 0x1, DllStructGetSize($tbuffer))
    EndIf
    Local $iret
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            $iret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", $imsg, "wparam", $iindex, "struct*", $titem)[0x0]
        Else
            Local $iitem = DllStructGetSize($titem)
            Local $tmemmap, $ptext
            Local $ibuffer = 0x0
            If ($ielement > 0x0) Or ($ielementmax = 0x0) Then $ibuffer = DllStructGetSize($tbuffer)
            Local $pmemory = _MemInit($hwnd, $iitem + $ibuffer, $tmemmap)
            If $ibuffer Then
                $ptext = $pmemory + $iitem
                If $ielementmax Then
                    DllStructSetData($titem, $ielement, $ptext)
                Else
                    $iindex = $ptext
                EndIf
                _MemWrite($tmemmap, $tbuffer, $ptext, $ibuffer)
            EndIf
            _MemWrite($tmemmap, $titem, $pmemory, $iitem)
            $iret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", $imsg, "wparam", $iindex, "ptr", $pmemory)[0x0]
            If $ibuffer And $bretbuffer Then _MemRead($tmemmap, $ptext, $tbuffer, $ibuffer)
            If $bretitem Then _MemRead($tmemmap, $pmemory, $titem, $iitem)
            _MemFree($tmemmap)
        EndIf
    Else
        $iret = GUICtrlSendMsg($hwnd, $imsg, $iindex, DllStructGetPtr($titem))
    EndIf
    Return $iret
EndFunc    ; -> __guictrl_sendmsg

Func __guictrl_sendmsg_init($hwnd, $imsg, $iindex, ByRef $titem, $tbuffer = 0x0, $bretitem = False, $ielement = + -1, $bretbuffer = False, $ielementmax = $ielement)
    #forceref $iMsg, $iIndex, $bRetItem, $bRetBuffer
    DllStructSetData($titem, $ielement, DllStructGetPtr($tbuffer))
    If $ielement = $ielementmax Then DllStructSetData($titem, $ielement + 0x1, DllStructGetSize($tbuffer))
    Local $pfunc
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            $pfunc = __guictrl_sendmsg_inprocess
            SetExtended(0x1)
        Else
            $pfunc = __guictrl_sendmsg_outprocess
            SetExtended(0x2)
        EndIf
    Else
        $pfunc = __guictrl_sendmsg_internal
        SetExtended(0x3)
    EndIf
    Return $pfunc
EndFunc    ; -> __guictrl_sendmsg_init

Func __guictrl_sendmsg_inprocess($hwnd, $imsg, $iindex, ByRef $titem, $tbuffer = 0x0, $bretitem = False, $ielement = + -1, $bretbuffer = False, $ielementmax = $ielement)
    #forceref $tBuffer, $bRetItem, $bRetBuffer, $iElementMax
    Return DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", $imsg, "wparam", $iindex, "struct*", $titem)[0x0]
EndFunc    ; -> __guictrl_sendmsg_inprocess

Func __guictrl_sendmsg_outprocess($hwnd, $imsg, $iindex, ByRef $titem, $tbuffer = 0x0, $bretitem = False, $ielement = + -1, $bretbuffer = False, $ielementmax = $ielement)
    Local $iitem = DllStructGetSize($titem)
    Local $tmemmap, $ptext
    Local $ibuffer = 0x0
    If ($ielement > 0x0) Or ($ielementmax = 0x0) Then $ibuffer = DllStructGetSize($tbuffer)
    Local $pmemory = _MemInit($hwnd, $iitem + $ibuffer, $tmemmap)
    If $ibuffer Then
        $ptext = $pmemory + $iitem
        If $ielementmax Then
            DllStructSetData($titem, $ielement, $ptext)
        Else
            $iindex = $ptext
        EndIf
        _MemWrite($tmemmap, $tbuffer, $ptext, $ibuffer)
    EndIf
    _MemWrite($tmemmap, $titem, $pmemory, $iitem)
    Local $iret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hwnd, "uint", $imsg, "wparam", $iindex, "ptr", $pmemory)[0x0]
    If $ibuffer And $bretbuffer Then _MemRead($tmemmap, $ptext, $tbuffer, $ibuffer)
    If $bretitem Then _MemRead($tmemmap, $pmemory, $titem, $iitem)
    _MemFree($tmemmap)
    Return $iret
EndFunc    ; -> __guictrl_sendmsg_outprocess

Func __guictrl_sendmsg_internal($hwnd, $imsg, $iindex, ByRef $titem, $tbuffer = 0x0, $bretitem = False, $ielement = + -1, $bretbuffer = False, $ielementmax = $ielement)
    #forceref $tBuffer, $bRetItem, $bRetBuffer, $iElementMax
    Return GUICtrlSendMsg($hwnd, $imsg, $iindex, DllStructGetPtr($titem))
EndFunc    ; -> __guictrl_sendmsg_internal

Global Const $_UDF_GLOBALIDS_OFFSET = 0x2
Global Const $_UDF_GLOBALID_MAX_WIN = 0x10
Global Const $_UDF_STARTID = 0x2710
Global Const $_UDF_GLOBALID_MAX_IDS = 0xd8ef
Global Const $__UDFGUICONSTANT_WS_TABSTOP = 0x10000
Global Const $__UDFGUICONSTANT_WS_VISIBLE = 0x10000000
Global Const $__UDFGUICONSTANT_WS_CHILD = 0x40000000
Global $__g_audf_globalids_used[$_UDF_GLOBALID_MAX_WIN][$_UDF_GLOBALID_MAX_IDS + $_UDF_GLOBALIDS_OFFSET + 0x1]
Func __UDF_GetNextGlobalID($hwnd)
    Local $nctrlid, $iusedindex = + -1, $ballused = True
    If Not WinExists($hwnd) Then Return SetError(+ -1, + -1, 0x0)
    For $iindex = 0x0 To $_UDF_GLOBALID_MAX_WIN + -1
        If $__g_audf_globalids_used[$iindex][0x0] <> 0x0 Then
            If Not WinExists($__g_audf_globalids_used[$iindex][0x0]) Then
                For $x = 0x0 To UBound($__g_audf_globalids_used, $UBOUND_COLUMNS) + -1
                    $__g_audf_globalids_used[$iindex][$x] = 0x0
                Next
                $__g_audf_globalids_used[$iindex][0x1] = $_UDF_STARTID
                $ballused = False
            EndIf
        EndIf
    Next
    For $iindex = 0x0 To $_UDF_GLOBALID_MAX_WIN + -1
        If $__g_audf_globalids_used[$iindex][0x0] = $hwnd Then
            $iusedindex = $iindex
            ExitLoop
        EndIf
    Next
    If $iusedindex = + -1 Then
        For $iindex = 0x0 To $_UDF_GLOBALID_MAX_WIN + -1
            If $__g_audf_globalids_used[$iindex][0x0] = 0x0 Then
                $__g_audf_globalids_used[$iindex][0x0] = $hwnd
                $__g_audf_globalids_used[$iindex][0x1] = $_UDF_STARTID
                $ballused = False
                $iusedindex = $iindex
                ExitLoop
            EndIf
        Next
    EndIf
    If $iusedindex = + -1 And $ballused Then Return SetError(0x10, 0x0, 0x0)
    If $__g_audf_globalids_used[$iusedindex][0x1] = $_UDF_STARTID + $_UDF_GLOBALID_MAX_IDS Then
        For $iidindex = $_UDF_GLOBALIDS_OFFSET To UBound($__g_audf_globalids_used, $UBOUND_COLUMNS) + -1
            If $__g_audf_globalids_used[$iusedindex][$iidindex] = 0x0 Then
                $nctrlid = ($iidindex - $_UDF_GLOBALIDS_OFFSET) + 0x2710
                $__g_audf_globalids_used[$iusedindex][$iidindex] = $nctrlid
                Return $nctrlid
            EndIf
        Next
        Return SetError(+ -1, $_UDF_GLOBALID_MAX_IDS, 0x0)
    EndIf
    $nctrlid = $__g_audf_globalids_used[$iusedindex][0x1]
    $__g_audf_globalids_used[$iusedindex][0x1]+= 0x1
    $__g_audf_globalids_used[$iusedindex][($nctrlid + -10000) + $_UDF_GLOBALIDS_OFFSET] = $nctrlid
    Return $nctrlid
EndFunc    ; -> __UDF_GetNextGlobalID

Func __UDF_FreeGlobalID($hwnd, $iglobalid)
    If $iglobalid - $_UDF_STARTID < 0x0 Or $iglobalid - $_UDF_STARTID > $_UDF_GLOBALID_MAX_IDS Then Return SetError(+ -1, 0x0, False)
    For $iindex = 0x0 To $_UDF_GLOBALID_MAX_WIN + -1
        If $__g_audf_globalids_used[$iindex][0x0] = $hwnd Then
            For $x = $_UDF_GLOBALIDS_OFFSET To UBound($__g_audf_globalids_used, $UBOUND_COLUMNS) + -1
                If $__g_audf_globalids_used[$iindex][$x] = $iglobalid Then
                    $__g_audf_globalids_used[$iindex][$x] = 0x0
                    Return True
                EndIf
            Next
            Return SetError(+ -3, 0x0, False)
        EndIf
    Next
    Return SetError(+ -2, 0x0, False)
EndFunc    ; -> __UDF_FreeGlobalID

Global Const $__AVICONSTANT_CLASSNAME = "SysAnimate32"
Func _GUICtrlAVI_Close($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $iret = _SendMessage($hwnd, $ACM_OPENA)
    Return SetError(@error, @extended, $iret <> 0x0)
EndFunc    ; -> _GUICtrlAVI_Close

Func _GUICtrlAVI_Create($hwnd, $sfilepath = '', $isubfileid = + -1, $ix = 0x0, $iy = 0x0, $iwidth = 0x0, $iheight = 0x0, $istyle = 0x6, $iexstyle = 0x0)
    If Not IsHWnd($hwnd) Then Return SetError(0x1, 0x0, 0x0)
    If Not IsString($sfilepath) Then Return SetError(0x2, 0x0, 0x0)
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $havi = _WinAPI_CreateWindowEx($iexstyle, $__AVICONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    If $isubfileid <> + -1 And $sfilepath <> '' Then
        _GUICtrlAVI_OpenEx($havi, $sfilepath, $isubfileid)
    ElseIf $sfilepath <> '' Then
        _GUICtrlAVI_Open($havi, $sfilepath)
    EndIf
    Return $havi
EndFunc    ; -> _GUICtrlAVI_Create

Func _GUICtrlAVI_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__AVICONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlAVI_Destroy

Func _GUICtrlAVI_IsPlaying($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $ACM_ISPLAYING) <> 0x0
EndFunc    ; -> _GUICtrlAVI_IsPlaying

Func _GUICtrlAVI_Open($hwnd, $sfilename)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tbuffer = DllStructCreate("wchar Text[" & StringLen($sfilename) + 0x1 & "]")
    DllStructSetData($tbuffer, "Text", $sfilename)
    Local $iret = __guictrl_sendmsg($hwnd, $ACM_OPENW, 0x0, $tbuffer)
    If $iret <> 0x0 Then _GUICtrlAVI_Seek($hwnd, 0x0)
    Return SetError(@error, @extended, $iret <> 0x0)
EndFunc    ; -> _GUICtrlAVI_Open

Func _GUICtrlAVI_OpenEx($hwnd, $sfilename, $iresourceid)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $hinst = _WinAPI_LoadLibrary($sfilename)
    If @error Then Return SetError(@error, @extended, False)
    Local $iret = _SendMessage($hwnd, $ACM_OPENW, $hinst, $iresourceid)
    _WinAPI_FreeLibrary($hinst)
    If $iret <> 0x0 Then _GUICtrlAVI_Seek($hwnd, 0x0)
    Return SetError(@error, @extended, $iret <> 0x0)
EndFunc    ; -> _GUICtrlAVI_OpenEx

Func _GUICtrlAVI_Play($hwnd, $ifrom = 0x0, $ito = + -1, $irepeat = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $iret = _SendMessage($hwnd, $ACM_PLAY, $irepeat, _WinAPI_MakeLong($ifrom, $ito))
    Return SetError(@error, @extended, $iret <> 0x0)
EndFunc    ; -> _GUICtrlAVI_Play

Func _GUICtrlAVI_Seek($hwnd, $iframe)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $iret = _SendMessage($hwnd, $ACM_PLAY, 0x1, _WinAPI_MakeLong($iframe, $iframe))
    Return SetError(@error, @extended, $iret <> 0x0)
EndFunc    ; -> _GUICtrlAVI_Seek

Func _GUICtrlAVI_Show($hwnd, $istate)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If $istate <> @SW_HIDE And $istate <> @SW_SHOW Then Return SetError(0x1, 0x1, 0x0)
    Return _WinAPI_ShowWindow($hwnd, $istate)
EndFunc    ; -> _GUICtrlAVI_Show

Func _GUICtrlAVI_Stop($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $iret = _SendMessage($hwnd, $ACM_STOP)
    Return SetError(@error, @extended, $iret <> 0x0)
EndFunc    ; -> _GUICtrlAVI_Stop

Global $__g_hbuttonlastwnd
Global Const $TAGBUTTON_IMAGELIST = "ptr ImageList;" & $TAGRECT & ";uint Align"
Global Const $TAGBUTTON_SPLITINFO = "uint mask;handle himlGlyph;uint uSplitStyle;" & $TAGSIZE
Global Const $__BUTTONCONSTANT_CLASSNAME = "Button"
Global Const $__BUTTONCONSTANT_GWL_STYLE = -16
Global Const $__BUTTONCONSTANT_WM_SETFONT = 0x30
Global Const $__BUTTONCONSTANT_DEFAULT_GUI_FONT = 0x11
Func _GUICtrlButton_Click($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $BM_CLICK)
EndFunc    ; -> _GUICtrlButton_Click

Func _GUICtrlButton_Create($hwnd, $stext, $ix, $iy, $iwidth, $iheight, $istyle = + -1, $iexstyle = + -1)
    If Not IsHWnd($hwnd) Then
        Return SetError(0x1, 0x0, 0x0)
    EndIf
    If Not IsString($stext) Then
        Return SetError(0x2, 0x0, 0x0)
    EndIf
    Local $iforcedstyle = BitOR($__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_CHILD, $BS_NOTIFY)
    If $istyle = + -1 Then
        $istyle = $iforcedstyle
    Else
        $istyle = BitOR($istyle, $iforcedstyle)
    EndIf
    If $iexstyle = + -1 Then $iexstyle = 0x0
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hbutton = _WinAPI_CreateWindowEx($iexstyle, $__BUTTONCONSTANT_CLASSNAME, $stext, $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    _SendMessage($hbutton, $__BUTTONCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__BUTTONCONSTANT_DEFAULT_GUI_FONT), True)
    Return $hbutton
EndFunc    ; -> _GUICtrlButton_Create

Func _GUICtrlButton_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__BUTTONCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hbuttonlastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlButton_Destroy

Func _GUICtrlButton_Enable($hwnd, $benable = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If _WinAPI_IsClassName($hwnd, $__BUTTONCONSTANT_CLASSNAME) Then Return _WinAPI_EnableWindow($hwnd, $benable) = $benable
EndFunc    ; -> _GUICtrlButton_Enable

Func _GUICtrlButton_GetCheck($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $BM_GETCHECK)
EndFunc    ; -> _GUICtrlButton_GetCheck

Func _GUICtrlButton_GetFocus($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If _WinAPI_IsClassName($hwnd, $__BUTTONCONSTANT_CLASSNAME) Then Return _WinAPI_GetFocus() = $hwnd
EndFunc    ; -> _GUICtrlButton_GetFocus

Func _GUICtrlButton_GetIdealSize($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tsize = DllStructCreate($TAGSIZE), $asize[0x2]
    Local $iret = _SendMessage($hwnd, $BCM_GETIDEALSIZE, 0x0, $tsize, 0x0, "wparam", "struct*")
    If Not $iret Then Return SetError(+ -1, + -1, $asize)
    $asize[0x0] = DllStructGetData($tsize, "X")
    $asize[0x1] = DllStructGetData($tsize, "Y")
    Return $asize
EndFunc    ; -> _GUICtrlButton_GetIdealSize

Func _GUICtrlButton_GetImage($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $iret = _SendMessage($hwnd, $BM_GETIMAGE, 0x0, 0x0, 0x0, "wparam", "lparam", "hwnd")
    If $iret <> 0x0 Then Return $iret
    $iret = _SendMessage($hwnd, $BM_GETIMAGE, 0x1, 0x0, 0x0, "wparam", "lparam", "hwnd")
    If $iret = 0x0 Then Return 0x0
    Return $iret
EndFunc    ; -> _GUICtrlButton_GetImage

Func _GUICtrlButton_GetImageList($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tbutton_imagelist = DllStructCreate($TAGBUTTON_IMAGELIST), $aimagelist[0x6]
    If Not _SendMessage($hwnd, $BCM_GETIMAGELIST, 0x0, $tbutton_imagelist, 0x0, "wparam", "struct*") Then Return SetError(+ -1, + -1, $aimagelist)
    $aimagelist[0x0] = DllStructGetData($tbutton_imagelist, "ImageList")
    $aimagelist[0x1] = DllStructGetData($tbutton_imagelist, "Left")
    $aimagelist[0x2] = DllStructGetData($tbutton_imagelist, "Right")
    $aimagelist[0x3] = DllStructGetData($tbutton_imagelist, "Top")
    $aimagelist[0x4] = DllStructGetData($tbutton_imagelist, "Bottom")
    $aimagelist[0x5] = DllStructGetData($tbutton_imagelist, "Align")
    Return $aimagelist
EndFunc    ; -> _GUICtrlButton_GetImageList

Func _GUICtrlButton_GetNote($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ilen = _GUICtrlButton_GetNoteLength($hwnd) + 0x1
    Local $tnote = DllStructCreate("wchar Note[" & $ilen & "]")
    Local $tlen = DllStructCreate("dword")
    DllStructSetData($tlen, 0x1, $ilen)
    If Not _SendMessage($hwnd, $BCM_GETNOTE, $tlen, $tnote, 0x0, "struct*", "struct*") Then Return SetError(+ -1, 0x0, '')
    Return DllStructGetData($tnote, 0x1)
EndFunc    ; -> _GUICtrlButton_GetNote

Func _GUICtrlButton_GetNoteLength($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $BCM_GETNOTELENGTH)
EndFunc    ; -> _GUICtrlButton_GetNoteLength

Func _GUICtrlButton_GetSplitInfo($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tsplitinfo = DllStructCreate($TAGBUTTON_SPLITINFO), $ainfo[0x4]
    DllStructSetData($tsplitinfo, "mask", BitOR($BCSIF_GLYPH, $BCSIF_IMAGE, $BCSIF_SIZE, $BCSIF_STYLE))
    If Not _SendMessage($hwnd, $BCM_GETSPLITINFO, 0x0, $tsplitinfo, 0x0, "wparam", "struct*") Then Return SetError(+ -1, 0x0, $ainfo)
    $ainfo[0x0] = DllStructGetData($tsplitinfo, "himlGlyph")
    $ainfo[0x1] = DllStructGetData($tsplitinfo, "uSplitStyle")
    $ainfo[0x2] = DllStructGetData($tsplitinfo, "X")
    $ainfo[0x3] = DllStructGetData($tsplitinfo, "Y")
    Return $ainfo
EndFunc    ; -> _GUICtrlButton_GetSplitInfo

Func _GUICtrlButton_GetState($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $BM_GETSTATE)
EndFunc    ; -> _GUICtrlButton_GetState

Func _GUICtrlButton_GetText($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If _WinAPI_IsClassName($hwnd, $__BUTTONCONSTANT_CLASSNAME) Then Return _WinAPI_GetWindowText($hwnd)
    Return ''
EndFunc    ; -> _GUICtrlButton_GetText

Func _GUICtrlButton_GetTextMargin($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $trect = DllStructCreate($TAGRECT), $arect[0x4]
    If Not _SendMessage($hwnd, $BCM_GETTEXTMARGIN, 0x0, $trect, 0x0, "wparam", "struct*") Then Return SetError(+ -1, + -1, $arect)
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlButton_GetTextMargin

Func _GUICtrlButton_SetCheck($hwnd, $istate = $BST_CHECKED)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $BM_SETCHECK, $istate)
EndFunc    ; -> _GUICtrlButton_SetCheck

Func _GUICtrlButton_SetDontClick($hwnd, $bstate = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $BM_SETDONTCLICK, $bstate)
EndFunc    ; -> _GUICtrlButton_SetDontClick

Func _GUICtrlButton_SetDropDownState($hwnd, $bstate = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $BCM_SETDROPDOWNSTATE, $bstate) <> 0x0
EndFunc    ; -> _GUICtrlButton_SetDropDownState

Func _GUICtrlButton_SetFocus($hwnd, $bfocus = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If _WinAPI_IsClassName($hwnd, $__BUTTONCONSTANT_CLASSNAME) Then
        If $bfocus Then
            Return _WinAPI_SetFocus($hwnd) <> 0x0
        Else
            Return _WinAPI_SetFocus(_WinAPI_GetParent($hwnd)) <> 0x0
        EndIf
    EndIf
EndFunc    ; -> _GUICtrlButton_SetFocus

Func _GUICtrlButton_SetImage($hwnd, $simagefile, $iiconid = + -1, $blarge = False)
    Local $himage, $hprevimage
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If StringUpper(StringMid($simagefile, StringLen($simagefile) + -2)) = "BMP" Then
        If BitAND(_WinAPI_GetWindowLong($hwnd, $__BUTTONCONSTANT_GWL_STYLE), $BS_BITMAP) = $BS_BITMAP Then
            $himage = _WinAPI_LoadImage(0x0, $simagefile, 0x0, 0x0, 0x0, BitOR($LR_LOADFROMFILE, $LR_CREATEDIBSECTION))
            If Not $himage Then Return SetError(+ -1, + -1, False)
            $hprevimage = _SendMessage($hwnd, $BM_SETIMAGE, 0x0, $himage)
            If $hprevimage Then
                If Not _WinAPI_DeleteObject($hprevimage) Then _WinAPI_DestroyIcon($hprevimage)
            EndIf
            _WinAPI_UpdateWindow($hwnd)
            Return True
        EndIf
    Else
        If $iiconid = + -1 Then
            $himage = _WinAPI_LoadImage(0x0, $simagefile, 0x1, 0x0, 0x0, BitOR($LR_LOADFROMFILE, $LR_CREATEDIBSECTION))
            If Not $himage Then Return SetError(+ -1, + -1, False)
            $hprevimage = _SendMessage($hwnd, $BM_SETIMAGE, 0x1, $himage)
            If $hprevimage Then
                If Not _WinAPI_DeleteObject($hprevimage) Then _WinAPI_DestroyIcon($hprevimage)
            EndIf
            _WinAPI_UpdateWindow($hwnd)
            Return True
        Else
            Local $ticon = DllStructCreate("handle Handle")
            Local $iret
            If $blarge Then
                $iret = _WinAPI_ExtractIconEx($simagefile, $iiconid, $ticon, 0x0, 0x1)
            Else
                $iret = _WinAPI_ExtractIconEx($simagefile, $iiconid, 0x0, $ticon, 0x1)
            EndIf
            If Not $iret Then Return SetError(+ -1, + -1, False)
            $hprevimage = _SendMessage($hwnd, $BM_SETIMAGE, 0x1, DllStructGetData($ticon, "Handle"))
            If $hprevimage Then
                If Not _WinAPI_DeleteObject($hprevimage) Then _WinAPI_DestroyIcon($hprevimage)
            EndIf
            _WinAPI_UpdateWindow($hwnd)
            Return True
        EndIf
    EndIf
    Return False
EndFunc    ; -> _GUICtrlButton_SetImage

Func _GUICtrlButton_SetImageList($hwnd, $himage, $ialign = 0x0, $ileft = 0x1, $itop = 0x1, $iright = 0x1, $ibottom = 0x1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If $ialign < 0x0 Or $ialign > 0x4 Then $ialign = 0x0
    Local $tbutton_imagelist = DllStructCreate($TAGBUTTON_IMAGELIST)
    DllStructSetData($tbutton_imagelist, "ImageList", $himage)
    DllStructSetData($tbutton_imagelist, "Left", $ileft)
    DllStructSetData($tbutton_imagelist, "Top", $itop)
    DllStructSetData($tbutton_imagelist, "Right", $iright)
    DllStructSetData($tbutton_imagelist, "Bottom", $ibottom)
    DllStructSetData($tbutton_imagelist, "Align", $ialign)
    Local $benabled = _GUICtrlButton_Enable($hwnd, False)
    Local $iret = _SendMessage($hwnd, $BCM_SETIMAGELIST, 0x0, $tbutton_imagelist, 0x0, "wparam", "struct*") <> 0x0
    _GUICtrlButton_Enable($hwnd)
    If Not $benabled Then _GUICtrlButton_Enable($hwnd, False)
    Return $iret
EndFunc    ; -> _GUICtrlButton_SetImageList

Func _GUICtrlButton_SetNote($hwnd, $snote)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tnote = _WinAPI_MultiByteToWideChar($snote)
    Return _SendMessage($hwnd, $BCM_SETNOTE, 0x0, $tnote, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlButton_SetNote

Func _GUICtrlButton_SetShield($hwnd, $brequired = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $BCM_SETSHIELD, 0x0, $brequired) = 0x1
EndFunc    ; -> _GUICtrlButton_SetShield

Func _GUICtrlButton_SetSize($hwnd, $iwidth, $iheight)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__BUTTONCONSTANT_CLASSNAME) Then Return SetError(+ -1, + -1, False)
    Local $hparent = _WinAPI_GetParent($hwnd)
    If Not $hparent Then Return SetError(+ -1, + -1, False)
    Local $apos = WinGetPos($hwnd)
    If Not IsArray($apos) Then Return SetError(+ -1, + -1, False)
    Local $tpoint = DllStructCreate($TAGPOINT)
    DllStructSetData($tpoint, "X", $apos[0x0])
    DllStructSetData($tpoint, "Y", $apos[0x1])
    If Not _WinAPI_ScreenToClient($hparent, $tpoint) Then Return SetError(+ -1, + -1, False)
    Local $iret = WinMove($hwnd, '', DllStructGetData($tpoint, "X"), DllStructGetData($tpoint, "Y"), $iwidth, $iheight)
    Return SetError($iret + -1, $iret + -1, $iret <> 0x0)
EndFunc    ; -> _GUICtrlButton_SetSize

Func _GUICtrlButton_SetSplitInfo($hwnd, $himlglyph = + -1, $isplitstyle = $BCSS_ALIGNLEFT, $iwidth = 0x0, $iheight = 0x0)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tsplitinfo = DllStructCreate($TAGBUTTON_SPLITINFO), $imask = 0x0
    If $himlglyph <> + -1 Then
        $imask = BitOR($imask, $BCSIF_GLYPH)
        DllStructSetData($tsplitinfo, "himlGlyph", $himlglyph)
    EndIf
    $imask = BitOR($imask, $BCSIF_STYLE)
    If BitAND($isplitstyle, $BCSS_IMAGE) = $BCSS_IMAGE Then $imask = BitOR($imask, $BCSIF_IMAGE)
    DllStructSetData($tsplitinfo, "uSplitStyle", $isplitstyle)
    If $iwidth > 0x0 Or $iheight > 0x0 Then
        $imask = BitOR($imask, $BCSIF_SIZE)
        DllStructSetData($tsplitinfo, "X", $iwidth)
        DllStructSetData($tsplitinfo, "Y", $iheight)
    EndIf
    DllStructSetData($tsplitinfo, "mask", $imask)
    Return _SendMessage($hwnd, $BCM_SETSPLITINFO, 0x0, $tsplitinfo, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlButton_SetSplitInfo

Func _GUICtrlButton_SetState($hwnd, $bhighlighted = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $BM_SETSTATE, $bhighlighted)
EndFunc    ; -> _GUICtrlButton_SetState

Func _GUICtrlButton_SetStyle($hwnd, $istyle)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $BM_SETSTYLE, $istyle, True)
    _WinAPI_UpdateWindow($hwnd)
EndFunc    ; -> _GUICtrlButton_SetStyle

Func _GUICtrlButton_SetText($hwnd, $stext)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If _WinAPI_IsClassName($hwnd, $__BUTTONCONSTANT_CLASSNAME) Then Return _WinAPI_SetWindowText($hwnd, $stext)
EndFunc    ; -> _GUICtrlButton_SetText

Func _GUICtrlButton_SetTextMargin($hwnd, $ileft = 0x1, $itop = 0x1, $iright = 0x1, $ibottom = 0x1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $trect = DllStructCreate($TAGRECT)
    DllStructSetData($trect, "Left", $ileft)
    DllStructSetData($trect, "Top", $itop)
    DllStructSetData($trect, "Right", $iright)
    DllStructSetData($trect, "Bottom", $ibottom)
    Return _SendMessage($hwnd, $BCM_SETTEXTMARGIN, 0x0, $trect, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlButton_SetTextMargin

Func _GUICtrlButton_Show($hwnd, $bshow = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If _WinAPI_IsClassName($hwnd, $__BUTTONCONSTANT_CLASSNAME) Then
        If $bshow Then
            Return _WinAPI_ShowWindow($hwnd, @SW_SHOW)
        Else
            Return _WinAPI_ShowWindow($hwnd, @SW_HIDE)
        EndIf
    EndIf
EndFunc    ; -> _GUICtrlButton_Show

Global $__g_hcblastwnd
Global Const $__COMBOBOXCONSTANT_CLASSNAME = "ComboBox"
Global Const $__COMBOBOXCONSTANT_EM_GETLINE = 0xc4
Global Const $__COMBOBOXCONSTANT_EM_LINEINDEX = 0xbb
Global Const $__COMBOBOXCONSTANT_EM_LINELENGTH = 0xc1
Global Const $__COMBOBOXCONSTANT_EM_REPLACESEL = 0xc2
Global Const $__COMBOBOXCONSTANT_WM_SETREDRAW = 0xb
Global Const $__COMBOBOXCONSTANT_DEFAULT_GUI_FONT = 0x11
Global Const $TAGCOMBOBOXINFO = "dword Size;struct;long EditLeft;long EditTop;long EditRight;long EditBottom;endstruct;" & "struct;long BtnLeft;long BtnTop;long BtnRight;long BtnBottom;endstruct;dword BtnState;hwnd hCombo;hwnd hEdit;hwnd hList"
Func _GUICtrlComboBox_AddDir($hwnd, $sfilepath, $iattributes = 0x0, $bbrackets = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If BitAND($iattributes, $DDL_DRIVES) = $DDL_DRIVES And Not $bbrackets Then
        Local $stext
        Local $hgui_no_brackets = GUICreate("no brackets")
        Local $idcombo_no_brackets = GUICtrlCreateCombo('', 0xf0, 0x28, 0x78, 0x78)
        Local $iret = GUICtrlSendMsg($idcombo_no_brackets, $CB_DIR, $iattributes, $sfilepath)
        For $i = 0x0 To _GUICtrlComboBox_GetCount($idcombo_no_brackets) + -1
            _GUICtrlComboBox_GetLBText($idcombo_no_brackets, $i, $stext)
            $stext = StringReplace(StringReplace(StringReplace($stext, "[", ''), "]", ":"), "-", '')
            _GUICtrlComboBox_InsertString($hwnd, $stext)
        Next
        GUIDelete($hgui_no_brackets)
        Return $iret
    Else
        Return _SendMessage($hwnd, $CB_DIR, $iattributes, $sfilepath, 0x0, "wparam", "wstr")
    EndIf
EndFunc    ; -> _GUICtrlComboBox_AddDir

Func _GUICtrlComboBox_AddString($hwnd, $stext)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_ADDSTRING, 0x0, $stext, 0x0, "wparam", "wstr")
EndFunc    ; -> _GUICtrlComboBox_AddString

Func _GUICtrlComboBox_AutoComplete($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If Not __GUICtrlComboBox_IsPressed("08") And Not __GUICtrlComboBox_IsPressed("2E") Then
        Local $sedittext = _GUICtrlComboBox_GetEditText($hwnd)
        If StringLen($sedittext) Then
            Local $sinputtext
            Local $iret = _GUICtrlComboBox_FindString($hwnd, $sedittext)
            If ($iret <> $CB_ERR) Then
                _GUICtrlComboBox_GetLBText($hwnd, $iret, $sinputtext)
                _GUICtrlComboBox_SetEditText($hwnd, $sinputtext)
                _GUICtrlComboBox_SetEditSel($hwnd, StringLen($sedittext), StringLen($sinputtext))
            EndIf
        EndIf
    EndIf
EndFunc    ; -> _GUICtrlComboBox_AutoComplete

Func _GUICtrlComboBox_BeginUpdate($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $__COMBOBOXCONSTANT_WM_SETREDRAW, False) = 0x0
EndFunc    ; -> _GUICtrlComboBox_BeginUpdate

Func _GUICtrlComboBox_Create($hwnd, $stext, $ix, $iy, $iwidth = 0x64, $iheight = 0x78, $istyle = 0x200042, $iexstyle = 0x0)
    If Not IsHWnd($hwnd) Then Return SetError(0x1, 0x0, 0x0)
    If Not IsString($stext) Then Return SetError(0x2, 0x0, 0x0)
    Local $atext, $SDELIMITER = Opt("GUIDataSeparatorChar")
    If $iwidth = + -1 Then $iwidth = 0x64
    If $iheight = + -1 Then $iheight = 0x78
    Local Const $WS_VSCROLL = 0x200000
    If $istyle = + -1 Then $istyle = BitOR($WS_VSCROLL, $CBS_AUTOHSCROLL, $CBS_DROPDOWN)
    If $iexstyle = + -1 Then $iexstyle = 0x0
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_VISIBLE)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hcombo = _WinAPI_CreateWindowEx($iexstyle, $__COMBOBOXCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    _WinAPI_SetFont($hcombo, _WinAPI_GetStockObject($__COMBOBOXCONSTANT_DEFAULT_GUI_FONT))
    If StringLen($stext) Then
        $atext = StringSplit($stext, $SDELIMITER)
        For $x = 0x1 To $atext[0x0]
            _GUICtrlComboBox_AddString($hcombo, $atext[$x])
        Next
    EndIf
    Return $hcombo
EndFunc    ; -> _GUICtrlComboBox_Create

Func _GUICtrlComboBox_DeleteString($hwnd, $iindex)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_DELETESTRING, $iindex)
EndFunc    ; -> _GUICtrlComboBox_DeleteString

Func _GUICtrlComboBox_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__COMBOBOXCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hcblastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlComboBox_Destroy

Func _GUICtrlComboBox_EndUpdate($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $__COMBOBOXCONSTANT_WM_SETREDRAW, True) = 0x0
EndFunc    ; -> _GUICtrlComboBox_EndUpdate

Func _GUICtrlComboBox_FindString($hwnd, $stext, $iindex = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_FINDSTRING, $iindex, $stext, 0x0, "int", "wstr")
EndFunc    ; -> _GUICtrlComboBox_FindString

Func _GUICtrlComboBox_FindStringExact($hwnd, $stext, $iindex = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_FINDSTRINGEXACT, $iindex, $stext, 0x0, "wparam", "wstr")
EndFunc    ; -> _GUICtrlComboBox_FindStringExact

Func _GUICtrlComboBox_GetComboBoxInfo($hwnd, ByRef $tinfo)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    $tinfo = DllStructCreate($TAGCOMBOBOXINFO)
    Local $iinfo = DllStructGetSize($tinfo)
    DllStructSetData($tinfo, "Size", $iinfo)
    Return _SendMessage($hwnd, $CB_GETCOMBOBOXINFO, 0x0, $tinfo, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlComboBox_GetComboBoxInfo

Func _GUICtrlComboBox_GetCount($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETCOUNT)
EndFunc    ; -> _GUICtrlComboBox_GetCount

Func _GUICtrlComboBox_GetCueBanner($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ttext = DllStructCreate("wchar[4096]")
    If _SendMessage($hwnd, $CB_GETCUEBANNER, $ttext, 0x1000, 0x0, "struct*") <> 0x1 Then Return SetError(+ -1, 0x0, '')
    Return DllStructGetData($ttext, 0x1)
EndFunc    ; -> _GUICtrlComboBox_GetCueBanner

Func _GUICtrlComboBox_GetCurSel($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETCURSEL)
EndFunc    ; -> _GUICtrlComboBox_GetCurSel

Func _GUICtrlComboBox_GetDroppedControlRect($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $arect[0x4]
    Local $trect = _GUICtrlComboBox_GetDroppedControlRectEx($hwnd)
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlComboBox_GetDroppedControlRect

Func _GUICtrlComboBox_GetDroppedControlRectEx($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $trect = DllStructCreate($TAGRECT)
    _SendMessage($hwnd, $CB_GETDROPPEDCONTROLRECT, 0x0, $trect, 0x0, "wparam", "struct*")
    Return $trect
EndFunc    ; -> _GUICtrlComboBox_GetDroppedControlRectEx

Func _GUICtrlComboBox_GetDroppedState($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETDROPPEDSTATE) <> 0x0
EndFunc    ; -> _GUICtrlComboBox_GetDroppedState

Func _GUICtrlComboBox_GetDroppedWidth($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETDROPPEDWIDTH)
EndFunc    ; -> _GUICtrlComboBox_GetDroppedWidth

Func _GUICtrlComboBox_GetEditSel($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tstart = DllStructCreate("dword Start")
    Local $tend = DllStructCreate("dword End")
    Local $iret = _SendMessage($hwnd, $CB_GETEDITSEL, $tstart, $tend, 0x0, "struct*", "struct*")
    If $iret = 0x0 Then Return SetError($CB_ERR, $CB_ERR, $CB_ERR)
    Local $asel[0x2]
    $asel[0x0] = DllStructGetData($tstart, "Start")
    $asel[0x1] = DllStructGetData($tend, "End")
    Return $asel
EndFunc    ; -> _GUICtrlComboBox_GetEditSel

Func _GUICtrlComboBox_GetEditText($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tinfo
    If _GUICtrlComboBox_GetComboBoxInfo($hwnd, $tinfo) Then
        Local $hedit = DllStructGetData($tinfo, "hEdit")
        Local $iline = 0x0
        Local $iindex = _SendMessage($hedit, $__COMBOBOXCONSTANT_EM_LINEINDEX, $iline)
        Local $ilength = _SendMessage($hedit, $__COMBOBOXCONSTANT_EM_LINELENGTH, $iindex)
        If $ilength = 0x0 Then Return ''
        Local $tbuffer = DllStructCreate("short Len;wchar Text[" & $ilength & "]")
        DllStructSetData($tbuffer, "Len", $ilength)
        Local $iret = _SendMessage($hedit, $__COMBOBOXCONSTANT_EM_GETLINE, $iline, $tbuffer, 0x0, "wparam", "struct*")
        If $iret = 0x0 Then Return SetError(+ -1, + -1, '')
        Local $ttext = DllStructCreate("wchar Text[" & $ilength & "]", DllStructGetPtr($tbuffer))
        Return DllStructGetData($ttext, "Text")
    Else
        Return SetError(+ -1, + -1, '')
    EndIf
EndFunc    ; -> _GUICtrlComboBox_GetEditText

Func _GUICtrlComboBox_GetExtendedUI($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETEXTENDEDUI) <> 0x0
EndFunc    ; -> _GUICtrlComboBox_GetExtendedUI

Func _GUICtrlComboBox_GetHorizontalExtent($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETHORIZONTALEXTENT)
EndFunc    ; -> _GUICtrlComboBox_GetHorizontalExtent

Func _GUICtrlComboBox_GetItemHeight($hwnd, $iindex = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETITEMHEIGHT, $iindex)
EndFunc    ; -> _GUICtrlComboBox_GetItemHeight

Func _GUICtrlComboBox_GetLBText($hwnd, $iindex, ByRef $stext)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ilen = _GUICtrlComboBox_GetLBTextLen($hwnd, $iindex)
    Local $tbuffer = DllStructCreate("wchar Text[" & $ilen + 0x1 & "]")
    Local $iret = _SendMessage($hwnd, $CB_GETLBTEXT, $iindex, $tbuffer, 0x0, "wparam", "struct*")
    If ($iret == $CB_ERR) Then Return SetError($CB_ERR, $CB_ERR, $CB_ERR)
    $stext = DllStructGetData($tbuffer, "Text")
    Return $iret
EndFunc    ; -> _GUICtrlComboBox_GetLBText

Func _GUICtrlComboBox_GetLBTextLen($hwnd, $iindex)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETLBTEXTLEN, $iindex)
EndFunc    ; -> _GUICtrlComboBox_GetLBTextLen

Func _GUICtrlComboBox_GetList($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $SDELIMITER = Opt("GUIDataSeparatorChar")
    Local $sresult = '', $sitem
    For $i = 0x0 To _GUICtrlComboBox_GetCount($hwnd) + -1
        _GUICtrlComboBox_GetLBText($hwnd, $i, $sitem)
        $sresult &= $sitem & $SDELIMITER
    Next
    Return StringTrimRight($sresult, StringLen($SDELIMITER))
EndFunc    ; -> _GUICtrlComboBox_GetList

Func _GUICtrlComboBox_GetListArray($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $SDELIMITER = Opt("GUIDataSeparatorChar")
    Return StringSplit(_GUICtrlComboBox_GetList($hwnd), $SDELIMITER)
EndFunc    ; -> _GUICtrlComboBox_GetListArray

Func _GUICtrlComboBox_GetLocale($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETLOCALE)
EndFunc    ; -> _GUICtrlComboBox_GetLocale

Func _GUICtrlComboBox_GetLocaleCountry($hwnd)
    Return _WinAPI_HiWord(_GUICtrlComboBox_GetLocale($hwnd))
EndFunc    ; -> _GUICtrlComboBox_GetLocaleCountry

Func _GUICtrlComboBox_GetLocaleLang($hwnd)
    Return _WinAPI_LoWord(_GUICtrlComboBox_GetLocale($hwnd))
EndFunc    ; -> _GUICtrlComboBox_GetLocaleLang

Func _GUICtrlComboBox_GetLocalePrimLang($hwnd)
    Return _WinAPI_PrimaryLangId(_GUICtrlComboBox_GetLocaleLang($hwnd))
EndFunc    ; -> _GUICtrlComboBox_GetLocalePrimLang

Func _GUICtrlComboBox_GetLocaleSubLang($hwnd)
    Return _WinAPI_SubLangId(_GUICtrlComboBox_GetLocaleLang($hwnd))
EndFunc    ; -> _GUICtrlComboBox_GetLocaleSubLang

Func _GUICtrlComboBox_GetMinVisible($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETMINVISIBLE)
EndFunc    ; -> _GUICtrlComboBox_GetMinVisible

Func _GUICtrlComboBox_GetTopIndex($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_GETTOPINDEX)
EndFunc    ; -> _GUICtrlComboBox_GetTopIndex

Func _GUICtrlComboBox_InitStorage($hwnd, $inum, $ibytes)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_INITSTORAGE, $inum, $ibytes)
EndFunc    ; -> _GUICtrlComboBox_InitStorage

Func _GUICtrlComboBox_InsertString($hwnd, $stext, $iindex = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_INSERTSTRING, $iindex, $stext, 0x0, "wparam", "wstr")
EndFunc    ; -> _GUICtrlComboBox_InsertString

Func _GUICtrlComboBox_LimitText($hwnd, $ilimit = 0x0)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $CB_LIMITTEXT, $ilimit)
EndFunc    ; -> _GUICtrlComboBox_LimitText

Func _GUICtrlComboBox_ReplaceEditSel($hwnd, $stext)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tinfo
    If _GUICtrlComboBox_GetComboBoxInfo($hwnd, $tinfo) Then
        Local $hedit = DllStructGetData($tinfo, "hEdit")
        _SendMessage($hedit, $__COMBOBOXCONSTANT_EM_REPLACESEL, True, $stext, 0x0, "wparam", "wstr")
    EndIf
EndFunc    ; -> _GUICtrlComboBox_ReplaceEditSel

Func _GUICtrlComboBox_ResetContent($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $CB_RESETCONTENT)
EndFunc    ; -> _GUICtrlComboBox_ResetContent

Func _GUICtrlComboBox_SelectString($hwnd, $stext, $iindex = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_SELECTSTRING, $iindex, $stext, 0x0, "wparam", "wstr")
EndFunc    ; -> _GUICtrlComboBox_SelectString

Func _GUICtrlComboBox_SetCueBanner($hwnd, $stext)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ttext = _WinAPI_MultiByteToWideChar($stext)
    Return _SendMessage($hwnd, $CB_SETCUEBANNER, 0x0, $ttext, 0x0, "wparam", "struct*") = 0x1
EndFunc    ; -> _GUICtrlComboBox_SetCueBanner

Func _GUICtrlComboBox_SetCurSel($hwnd, $iindex = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_SETCURSEL, $iindex)
EndFunc    ; -> _GUICtrlComboBox_SetCurSel

Func _GUICtrlComboBox_SetDroppedWidth($hwnd, $iwidth)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_SETDROPPEDWIDTH, $iwidth)
EndFunc    ; -> _GUICtrlComboBox_SetDroppedWidth

Func _GUICtrlComboBox_SetEditSel($hwnd, $istart, $istop)
    If Not HWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_SETEDITSEL, 0x0, _WinAPI_MakeLong($istart, $istop)) <> + -1
EndFunc    ; -> _GUICtrlComboBox_SetEditSel

Func _GUICtrlComboBox_SetEditText($hwnd, $stext)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _GUICtrlComboBox_SetEditSel($hwnd, 0x0, + -1)
    _GUICtrlComboBox_ReplaceEditSel($hwnd, $stext)
EndFunc    ; -> _GUICtrlComboBox_SetEditText

Func _GUICtrlComboBox_SetExtendedUI($hwnd, $bextended = False)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_SETEXTENDEDUI, $bextended) = 0x0
EndFunc    ; -> _GUICtrlComboBox_SetExtendedUI

Func _GUICtrlComboBox_SetHorizontalExtent($hwnd, $iwidth)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $CB_SETHORIZONTALEXTENT, $iwidth)
EndFunc    ; -> _GUICtrlComboBox_SetHorizontalExtent

Func _GUICtrlComboBox_SetItemHeight($hwnd, $iheight, $icomponent = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_SETITEMHEIGHT, $icomponent, $iheight)
EndFunc    ; -> _GUICtrlComboBox_SetItemHeight

Func _GUICtrlComboBox_SetLocale($hwnd, $ilocal)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_SETLOCALE, $ilocal)
EndFunc    ; -> _GUICtrlComboBox_SetLocale

Func _GUICtrlComboBox_SetMinVisible($hwnd, $iminimum)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_SETMINVISIBLE, $iminimum) <> 0x0
EndFunc    ; -> _GUICtrlComboBox_SetMinVisible

Func _GUICtrlComboBox_SetTopIndex($hwnd, $iindex)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $CB_SETTOPINDEX, $iindex) = 0x0
EndFunc    ; -> _GUICtrlComboBox_SetTopIndex

Func _GUICtrlComboBox_ShowDropDown($hwnd, $bshow = False)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $CB_SHOWDROPDOWN, $bshow)
EndFunc    ; -> _GUICtrlComboBox_ShowDropDown

Func __GUICtrlComboBox_IsPressed($shexkey, $vdll = "user32.dll")
    Local $a_r = DllCall($vdll, "short", "GetAsyncKeyState", "int", "0x" & $shexkey)
    If @error Then Return SetError(@error, @extended, False)
    Return BitAND($a_r[0x0], 0x8000) <> 0x0
EndFunc    ; -> __GUICtrlComboBox_IsPressed

Global $__g_tcbexbuffer, $__g_tcbexbufferansi
Global Const $__COMBOBOXEXCONSTANT_CLASSNAME = "ComboBoxEx32"
Global Const $__COMBOBOXEXCONSTANT_WM_SIZE = 0x5
Func _GUICtrlComboBoxEx_AddDir($hwnd, $sfilepath, $iattributes = 0x0, $bbrackets = True)
    Local $hgui = GUICreate("combo gui")
    Local $idcombo = GUICtrlCreateCombo('', 0xf0, 0x28, 0x78, 0x78)
    Local $iret = GUICtrlSendMsg($idcombo, $CB_DIR, $iattributes, $sfilepath)
    If $iret = + -1 Then
        GUIDelete($hgui)
        Return SetError(+ -1, + -1, + -1)
    EndIf
    Local $stext
    For $i = 0x0 To _GUICtrlComboBox_GetCount($idcombo) + -1
        _GUICtrlComboBox_GetLBText($idcombo, $i, $stext)
        If BitAND($iattributes, $DDL_DRIVES) = $DDL_DRIVES And Not $bbrackets Then $stext = StringReplace(StringReplace(StringReplace($stext, "[", ''), "]", ":"), "-", '')
        _GUICtrlComboBoxEx_InsertString($hwnd, $stext)
    Next
    GUIDelete($hgui)
    Return $iret
EndFunc    ; -> _GUICtrlComboBoxEx_AddDir

Func _GUICtrlComboBoxEx_AddString($hwnd, $stext, $iimage = + -1, $iselectedimage = + -1, $ioverlayimage = + -1, $iindent = + -1, $iparam = + -1)
    Return _GUICtrlComboBoxEx_InsertString($hwnd, $stext, + -1, $iimage, $iselectedimage, $ioverlayimage, $iindent, $iparam)
EndFunc    ; -> _GUICtrlComboBoxEx_AddString

Func _GUICtrlComboBoxEx_BeginUpdate($hwnd)
    Return _SendMessage($hwnd, $__COMBOBOXCONSTANT_WM_SETREDRAW, False) = 0x0
EndFunc    ; -> _GUICtrlComboBoxEx_BeginUpdate

Func _GUICtrlComboBoxEx_Create($hwnd, $stext, $ix, $iy, $iwidth = 0x64, $iheight = 0xc8, $istyle = 0x200002, $iexstyle = 0x0)
    If Not IsHWnd($hwnd) Then Return SetError(0x1, 0x0, 0x0)
    If Not IsString($stext) Then Return SetError(0x2, 0x0, 0x0)
    Local $SDELIMITER = Opt("GUIDataSeparatorChar")
    If $iwidth = + -1 Then $iwidth = 0x64
    If $iheight = + -1 Then $iheight = 0xc8
    Local Const $WS_VSCROLL = 0x200000
    If $istyle = + -1 Then $istyle = BitOR($WS_VSCROLL, $CBS_DROPDOWN)
    If $iexstyle = + -1 Then $iexstyle = 0x0
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_VISIBLE)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hcombo = _WinAPI_CreateWindowEx($iexstyle, $__COMBOBOXEXCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    _WinAPI_SetFont($hcombo, _WinAPI_GetStockObject($__COMBOBOXCONSTANT_DEFAULT_GUI_FONT))
    If StringLen($stext) Then
        Local $atext = StringSplit($stext, $SDELIMITER)
        For $x = 0x1 To $atext[0x0]
            _GUICtrlComboBoxEx_AddString($hcombo, $atext[$x])
        Next
    EndIf
    Return $hcombo
EndFunc    ; -> _GUICtrlComboBoxEx_Create

Func _GUICtrlComboBoxEx_CreateSolidBitMap($hwnd, $icolor, $iwidth, $iheight)
    Return _WinAPI_CreateSolidBitmap($hwnd, $icolor, $iwidth, $iheight)
EndFunc    ; -> _GUICtrlComboBoxEx_CreateSolidBitMap

Func _GUICtrlComboBoxEx_DeleteString($hwnd, $iindex)
    Return _SendMessage($hwnd, $CBEM_DELETEITEM, $iindex)
EndFunc    ; -> _GUICtrlComboBoxEx_DeleteString

Func _GUICtrlComboBoxEx_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__COMBOBOXEXCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
        Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
        Local $hparent = _WinAPI_GetParent($hwnd)
        $idestroyed = _WinAPI_DestroyWindow($hwnd)
        Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
        If Not $iret Then
        EndIf
    Else
        Return SetError(0x1, 0x1, False)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlComboBoxEx_Destroy

Func _GUICtrlComboBoxEx_EndUpdate($hwnd)
    Return _SendMessage($hwnd, $__COMBOBOXCONSTANT_WM_SETREDRAW, True) = 0x0
EndFunc    ; -> _GUICtrlComboBoxEx_EndUpdate

Func _GUICtrlComboBoxEx_FindStringExact($hwnd, $stext, $iindex = + -1)
    Return _SendMessage($hwnd, $CB_FINDSTRINGEXACT, $iindex, $stext, 0x0, "wparam", "wstr")
EndFunc    ; -> _GUICtrlComboBoxEx_FindStringExact

Func _GUICtrlComboBoxEx_GetComboBoxInfo($hwnd, ByRef $tinfo)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_GetComboBoxInfo($hcombo, $tinfo)
EndFunc    ; -> _GUICtrlComboBoxEx_GetComboBoxInfo

Func _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return HWnd(_SendMessage($hwnd, $CBEM_GETCOMBOCONTROL))
EndFunc    ; -> _GUICtrlComboBoxEx_GetComboControl

Func _GUICtrlComboBoxEx_GetCount($hwnd)
    Return _SendMessage($hwnd, $CB_GETCOUNT)
EndFunc    ; -> _GUICtrlComboBoxEx_GetCount

Func _GUICtrlComboBoxEx_GetCurSel($hwnd)
    Return _SendMessage($hwnd, $CB_GETCURSEL)
EndFunc    ; -> _GUICtrlComboBoxEx_GetCurSel

Func _GUICtrlComboBoxEx_GetDroppedControlRect($hwnd)
    Local $trect = _GUICtrlComboBox_GetDroppedControlRectEx($hwnd)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlComboBoxEx_GetDroppedControlRect

Func _GUICtrlComboBoxEx_GetDroppedControlRectEx($hwnd)
    Local $trect = DllStructCreate($TAGRECT)
    _SendMessage($hwnd, $CB_GETDROPPEDCONTROLRECT, 0x0, $trect, 0x0, "wparam", "struct*")
    Return $trect
EndFunc    ; -> _GUICtrlComboBoxEx_GetDroppedControlRectEx

Func _GUICtrlComboBoxEx_GetDroppedState($hwnd)
    Return _SendMessage($hwnd, $CB_GETDROPPEDSTATE) <> 0x0
EndFunc    ; -> _GUICtrlComboBoxEx_GetDroppedState

Func _GUICtrlComboBoxEx_GetDroppedWidth($hwnd)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_GetDroppedWidth($hcombo)
EndFunc    ; -> _GUICtrlComboBoxEx_GetDroppedWidth

Func _GUICtrlComboBoxEx_GetEditControl($hwnd)
    Return HWnd(_SendMessage($hwnd, $CBEM_GETEDITCONTROL))
EndFunc    ; -> _GUICtrlComboBoxEx_GetEditControl

Func _GUICtrlComboBoxEx_GetEditSel($hwnd)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Local $aret = _GUICtrlComboBox_GetEditSel($hcombo)
    Return SetError(@error, @extended, $aret)
EndFunc    ; -> _GUICtrlComboBoxEx_GetEditSel

Func _GUICtrlComboBoxEx_GetEditText($hwnd)
    Local $hcombobox = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_GetEditText($hcombobox)
EndFunc    ; -> _GUICtrlComboBoxEx_GetEditText

Func _GUICtrlComboBoxEx_GetExtendedStyle($hwnd)
    Return _SendMessage($hwnd, $CBEM_GETEXTENDEDSTYLE)
EndFunc    ; -> _GUICtrlComboBoxEx_GetExtendedStyle

Func _GUICtrlComboBoxEx_GetExtendedUI($hwnd)
    Return _GUICtrlComboBox_GetExtendedUI($hwnd)
EndFunc    ; -> _GUICtrlComboBoxEx_GetExtendedUI

Func _GUICtrlComboBoxEx_GetImageList($hwnd)
    Return Ptr(_SendMessage($hwnd, $CBEM_GETIMAGELIST))
EndFunc    ; -> _GUICtrlComboBoxEx_GetImageList

Func _GUICtrlComboBoxEx_GetItem($hwnd, $iindex)
    Local $aitem[0x7], $stext
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", BitOR($CBEIF_IMAGE, $CBEIF_INDENT, $CBEIF_LPARAM, $CBEIF_SELECTEDIMAGE, $CBEIF_OVERLAY))
    DllStructSetData($titem, "Item", $iindex)
    _GUICtrlComboBoxEx_GetItemEx($hwnd, $titem)
    Local $ilen = _GUICtrlComboBoxEx_GetItemText($hwnd, $iindex, $stext)
    $aitem[0x0] = $stext
    $aitem[0x1] = $ilen
    $aitem[0x2] = DllStructGetData($titem, "Indent")
    $aitem[0x3] = DllStructGetData($titem, "Image")
    $aitem[0x4] = DllStructGetData($titem, "SelectedImage")
    $aitem[0x5] = DllStructGetData($titem, "OverlayImage")
    $aitem[0x6] = DllStructGetData($titem, "Param")
    Return $aitem
EndFunc    ; -> _GUICtrlComboBoxEx_GetItem

Func _GUICtrlComboBoxEx_GetItemEx($hwnd, ByRef $titem)
    Local $imsg
    If _GUICtrlComboBoxEx_GetUnicode($hwnd) Then
        $imsg = $CBEM_GETITEMW
    Else
        $imsg = $CBEM_GETITEMA
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, 0x0, True)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlComboBoxEx_GetItemEx

Func _GUICtrlComboBoxEx_GetItemHeight($hwnd, $icomponent = + -1)
    Return _GUICtrlComboBox_GetItemHeight($hwnd, $icomponent)
EndFunc    ; -> _GUICtrlComboBoxEx_GetItemHeight

Func _GUICtrlComboBoxEx_GetItemImage($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $CBEIF_IMAGE)
    DllStructSetData($titem, "Item", $iindex)
    _GUICtrlComboBoxEx_GetItemEx($hwnd, $titem)
    Return DllStructGetData($titem, "Image")
EndFunc    ; -> _GUICtrlComboBoxEx_GetItemImage

Func _GUICtrlComboBoxEx_GetItemIndent($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $CBEIF_INDENT)
    DllStructSetData($titem, "Item", $iindex)
    _GUICtrlComboBoxEx_GetItemEx($hwnd, $titem)
    Return DllStructGetData($titem, "Indent")
EndFunc    ; -> _GUICtrlComboBoxEx_GetItemIndent

Func _GUICtrlComboBoxEx_GetItemOverlayImage($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $CBEIF_OVERLAY)
    DllStructSetData($titem, "Item", $iindex)
    _GUICtrlComboBoxEx_GetItemEx($hwnd, $titem)
    Return DllStructGetData($titem, "OverlayImage")
EndFunc    ; -> _GUICtrlComboBoxEx_GetItemOverlayImage

Func _GUICtrlComboBoxEx_GetItemParam($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $CBEIF_LPARAM)
    DllStructSetData($titem, "Item", $iindex)
    _GUICtrlComboBoxEx_GetItemEx($hwnd, $titem)
    Return DllStructGetData($titem, "Param")
EndFunc    ; -> _GUICtrlComboBoxEx_GetItemParam

Func _GUICtrlComboBoxEx_GetItemSelectedImage($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $CBEIF_SELECTEDIMAGE)
    DllStructSetData($titem, "Item", $iindex)
    _GUICtrlComboBoxEx_GetItemEx($hwnd, $titem)
    Return DllStructGetData($titem, "SelectedImage")
EndFunc    ; -> _GUICtrlComboBoxEx_GetItemSelectedImage

Func _GUICtrlComboBoxEx_GetItemText($hwnd, $iindex, ByRef $stext)
    Return _GUICtrlComboBox_GetLBText($hwnd, $iindex, $stext)
EndFunc    ; -> _GUICtrlComboBoxEx_GetItemText

Func _GUICtrlComboBoxEx_GetItemTextLen($hwnd, $iindex)
    Return _GUICtrlComboBox_GetLBTextLen($hwnd, $iindex)
EndFunc    ; -> _GUICtrlComboBoxEx_GetItemTextLen

Func _GUICtrlComboBoxEx_GetList($hwnd)
    Return _GUICtrlComboBox_GetList($hwnd)
EndFunc    ; -> _GUICtrlComboBoxEx_GetList

Func _GUICtrlComboBoxEx_GetListArray($hwnd)
    Local $SDELIMITER = Opt("GUIDataSeparatorChar")
    Return StringSplit(_GUICtrlComboBoxEx_GetList($hwnd), $SDELIMITER)
EndFunc    ; -> _GUICtrlComboBoxEx_GetListArray

Func _GUICtrlComboBoxEx_GetLocale($hwnd)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_GetLocale($hcombo)
EndFunc    ; -> _GUICtrlComboBoxEx_GetLocale

Func _GUICtrlComboBoxEx_GetLocaleCountry($hwnd)
    Return _WinAPI_HiWord(_GUICtrlComboBoxEx_GetLocale($hwnd))
EndFunc    ; -> _GUICtrlComboBoxEx_GetLocaleCountry

Func _GUICtrlComboBoxEx_GetLocaleLang($hwnd)
    Return _WinAPI_LoWord(_GUICtrlComboBoxEx_GetLocale($hwnd))
EndFunc    ; -> _GUICtrlComboBoxEx_GetLocaleLang

Func _GUICtrlComboBoxEx_GetLocalePrimLang($hwnd)
    Return _WinAPI_PrimaryLangId(_GUICtrlComboBoxEx_GetLocaleLang($hwnd))
EndFunc    ; -> _GUICtrlComboBoxEx_GetLocalePrimLang

Func _GUICtrlComboBoxEx_GetLocaleSubLang($hwnd)
    Return _WinAPI_SubLangId(_GUICtrlComboBoxEx_GetLocaleLang($hwnd))
EndFunc    ; -> _GUICtrlComboBoxEx_GetLocaleSubLang

Func _GUICtrlComboBoxEx_GetMinVisible($hwnd)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_GetMinVisible($hcombo)
EndFunc    ; -> _GUICtrlComboBoxEx_GetMinVisible

Func _GUICtrlComboBoxEx_GetTopIndex($hwnd)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_GetTopIndex($hcombo)
EndFunc    ; -> _GUICtrlComboBoxEx_GetTopIndex

Func _GUICtrlComboBoxEx_GetUnicode($hwnd)
    If Not IsDllStruct($__g_tcbexbuffer) Then
        $__g_tcbexbuffer = DllStructCreate("wchar Text[4096]")
        $__g_tcbexbufferansi = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_tcbexbuffer))
    EndIf
    Return _SendMessage($hwnd, $CBEM_GETUNICODEFORMAT) <> 0x0
EndFunc    ; -> _GUICtrlComboBoxEx_GetUnicode

Func _GUICtrlComboBoxEx_HasEditChanged($hwnd)
    Local $tinfo
    If _GUICtrlComboBoxEx_GetComboBoxInfo($hwnd, $tinfo) Then
        Local $hedit = DllStructGetData($tinfo, "hEdit")
        Return _SendMessage($hedit, $CBEM_HASEDITCHANGED) <> 0x0
    Else
        Return False
    EndIf
EndFunc    ; -> _GUICtrlComboBoxEx_HasEditChanged

Func _GUICtrlComboBoxEx_InitStorage($hwnd, $inum, $ibytes)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_InitStorage($hcombo, $inum, $ibytes)
EndFunc    ; -> _GUICtrlComboBoxEx_InitStorage

Func _GUICtrlComboBoxEx_InsertString($hwnd, $stext, $iindex = + -1, $iimage = + -1, $iselectedimage = + -1, $ioverlayimage = + -1, $iindent = + -1, $iparam = + -1)
    Local $tbuffer, $imsg
    If _GUICtrlComboBoxEx_GetUnicode($hwnd) Then
        $tbuffer = $__g_tcbexbuffer
        $imsg = $CBEM_INSERTITEMW
    Else
        $tbuffer = $__g_tcbexbufferansi
        $imsg = $CBEM_INSERTITEMW
    EndIf
    Local $imask
    If $stext <> + -1 Then
        $imask = BitOR($CBEIF_TEXT, $CBEIF_LPARAM)
        DllStructSetData($tbuffer, "Text", $stext)
    Else
        $imask = BitOR($CBEIF_DI_SETITEM, $CBEIF_LPARAM)
        $tbuffer = 0x0
    EndIf
    If $iimage >= 0x0 Then $imask = BitOR($imask, $CBEIF_IMAGE)
    If $iselectedimage >= 0x0 Then $imask = BitOR($imask, $CBEIF_SELECTEDIMAGE)
    If $ioverlayimage >= 0x0 Then $imask = BitOR($imask, $CBEIF_OVERLAY)
    If $iindent >= 0x1 Then $imask = BitOR($imask, $CBEIF_INDENT)
    If $iparam = + -1 Then $iparam = _GUICtrlComboBoxEx_GetCount($hwnd)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $imask)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "Image", $iimage)
    DllStructSetData($titem, "SelectedImage", $iselectedimage)
    DllStructSetData($titem, "OverlayImage", $ioverlayimage)
    DllStructSetData($titem, "Indent", $iindent)
    DllStructSetData($titem, "Param", $iparam)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, $tbuffer, False, 0x3)
    Return $iret
EndFunc    ; -> _GUICtrlComboBoxEx_InsertString

Func _GUICtrlComboBoxEx_LimitText($hwnd, $ilimit = 0x0)
    _SendMessage($hwnd, $CB_LIMITTEXT, $ilimit)
EndFunc    ; -> _GUICtrlComboBoxEx_LimitText

Func _GUICtrlComboBoxEx_ReplaceEditSel($hwnd, $stext)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    _GUICtrlComboBox_ReplaceEditSel($hcombo, $stext)
EndFunc    ; -> _GUICtrlComboBoxEx_ReplaceEditSel

Func _GUICtrlComboBoxEx_ResetContent($hwnd)
    _SendMessage($hwnd, $CB_RESETCONTENT)
EndFunc    ; -> _GUICtrlComboBoxEx_ResetContent

Func _GUICtrlComboBoxEx_SetCurSel($hwnd, $iindex = + -1)
    Return _SendMessage($hwnd, $CB_SETCURSEL, $iindex)
EndFunc    ; -> _GUICtrlComboBoxEx_SetCurSel

Func _GUICtrlComboBoxEx_SetDroppedWidth($hwnd, $iwidth)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_SetDroppedWidth($hcombo, $iwidth)
EndFunc    ; -> _GUICtrlComboBoxEx_SetDroppedWidth

Func _GUICtrlComboBoxEx_SetEditSel($hwnd, $istart, $istop)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_SetEditSel($hcombo, $istart, $istop)
EndFunc    ; -> _GUICtrlComboBoxEx_SetEditSel

Func _GUICtrlComboBoxEx_SetEditText($hwnd, $stext)
    Local $hcombobox = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    _GUICtrlComboBox_SetEditSel($hcombobox, 0x0, + -1)
    _GUICtrlComboBox_ReplaceEditSel($hcombobox, $stext)
EndFunc    ; -> _GUICtrlComboBoxEx_SetEditText

Func _GUICtrlComboBoxEx_SetExtendedStyle($hwnd, $iexstyle, $iexmask = 0x0)
    Local $iret = _SendMessage($hwnd, $CBEM_SETEXTENDEDSTYLE, $iexmask, $iexstyle)
    _WinAPI_InvalidateRect($hwnd)
    Return $iret
EndFunc    ; -> _GUICtrlComboBoxEx_SetExtendedStyle

Func _GUICtrlComboBoxEx_SetExtendedUI($hwnd, $bextended = False)
    Local $hcombobox = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _SendMessage($hcombobox, $CB_SETEXTENDEDUI, $bextended) = 0x0
EndFunc    ; -> _GUICtrlComboBoxEx_SetExtendedUI

Func _GUICtrlComboBoxEx_SetImageList($hwnd, $hhandle)
    Local $hresult = _SendMessage($hwnd, $CBEM_SETIMAGELIST, 0x0, $hhandle, 0x0, "wparam", "handle", "handle")
    _SendMessage($hwnd, $__COMBOBOXEXCONSTANT_WM_SIZE)
    Return $hresult
EndFunc    ; -> _GUICtrlComboBoxEx_SetImageList

Func _GUICtrlComboBoxEx_SetItem($hwnd, $stext, $iindex = 0x0, $iimage = + -1, $iselectedimage = + -1, $ioverlayimage = + -1, $iindent = + -1, $iparam = + -1)
    Local $imask = $CBEIF_TEXT
    If $iimage <> + -1 Then $imask = BitOR($imask, $CBEIF_IMAGE)
    If $iselectedimage <> + -1 Then $imask = BitOR($imask, $CBEIF_SELECTEDIMAGE)
    If $ioverlayimage <> + -1 Then $imask = BitOR($imask, $CBEIF_OVERLAY)
    If $iparam <> + -1 Then $imask = BitOR($imask, $CBEIF_LPARAM)
    If $iindent <> + -1 Then $imask = BitOR($imask, $CBEIF_INDENT)
    Local $ibuffer, $pbuffer, $tbuffer
    If $stext <> + -1 Then
        $tbuffer = $__g_tcbexbuffer
        $ibuffer = DllStructGetSize($tbuffer)
        $pbuffer = DllStructGetPtr($tbuffer)
        DllStructSetData($tbuffer, "Text", $stext)
    Else
        $tbuffer = 0x0
        $ibuffer = 0x0
        $pbuffer = + -1
    EndIf
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $imask)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "Text", $pbuffer)
    DllStructSetData($titem, "TextMax", $ibuffer)
    DllStructSetData($titem, "Image", $iimage)
    DllStructSetData($titem, "Param", $iparam)
    DllStructSetData($titem, "Indent", $iindent)
    DllStructSetData($titem, "SelectedImage", $iselectedimage)
    DllStructSetData($titem, "OverlayImage", $ioverlayimage)
    Return _GUICtrlComboBoxEx_SetItemEx($hwnd, $titem, $tbuffer)
EndFunc    ; -> _GUICtrlComboBoxEx_SetItem

Func _GUICtrlComboBoxEx_SetItemEx($hwnd, ByRef $titem, $tbuffer = 0x0)
    Local $imsg
    If _GUICtrlComboBoxEx_GetUnicode($hwnd) Then
        $imsg = $CBEM_SETITEMW
    Else
        $imsg = $CBEM_SETITEMA
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, $tbuffer, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlComboBoxEx_SetItemEx

Func _GUICtrlComboBoxEx_SetItemHeight($hwnd, $icomponent, $iheight)
    Return _SendMessage($hwnd, $CB_SETITEMHEIGHT, $icomponent, $iheight)
EndFunc    ; -> _GUICtrlComboBoxEx_SetItemHeight

Func _GUICtrlComboBoxEx_SetItemImage($hwnd, $iindex, $iimage)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $CBEIF_IMAGE)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "Image", $iimage)
    Return _GUICtrlComboBoxEx_SetItemEx($hwnd, $titem)
EndFunc    ; -> _GUICtrlComboBoxEx_SetItemImage

Func _GUICtrlComboBoxEx_SetItemIndent($hwnd, $iindex, $iindent)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $CBEIF_INDENT)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "Indent", $iindent)
    Return _GUICtrlComboBoxEx_SetItemEx($hwnd, $titem)
EndFunc    ; -> _GUICtrlComboBoxEx_SetItemIndent

Func _GUICtrlComboBoxEx_SetItemOverlayImage($hwnd, $iindex, $iimage)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $CBEIF_OVERLAY)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "OverlayImage", $iimage)
    Return _GUICtrlComboBoxEx_SetItemEx($hwnd, $titem)
EndFunc    ; -> _GUICtrlComboBoxEx_SetItemOverlayImage

Func _GUICtrlComboBoxEx_SetItemParam($hwnd, $iindex, $iparam)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $CBEIF_LPARAM)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "Param", $iparam)
    Return _GUICtrlComboBoxEx_SetItemEx($hwnd, $titem)
EndFunc    ; -> _GUICtrlComboBoxEx_SetItemParam

Func _GUICtrlComboBoxEx_SetItemSelectedImage($hwnd, $iindex, $iimage)
    Local $titem = DllStructCreate($TAGCOMBOBOXEXITEM)
    DllStructSetData($titem, "Mask", $CBEIF_SELECTEDIMAGE)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SelectedImage", $iimage)
    Return _GUICtrlComboBoxEx_SetItemEx($hwnd, $titem)
EndFunc    ; -> _GUICtrlComboBoxEx_SetItemSelectedImage

Func _GUICtrlComboBoxEx_SetMinVisible($hwnd, $iminimum)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_SetMinVisible($hcombo, $iminimum)
EndFunc    ; -> _GUICtrlComboBoxEx_SetMinVisible

Func _GUICtrlComboBoxEx_SetTopIndex($hwnd, $iindex)
    Local $hcombo = _GUICtrlComboBoxEx_GetComboControl($hwnd)
    Return _GUICtrlComboBox_SetTopIndex($hcombo, $iindex)
EndFunc    ; -> _GUICtrlComboBoxEx_SetTopIndex

Func _GUICtrlComboBoxEx_SetUnicode($hwnd, $bunicode = True)
    Local $iunicode = _SendMessage($hwnd, $CBEM_SETUNICODEFORMAT, $bunicode) <> 0x0
    Return $iunicode <> $bunicode
EndFunc    ; -> _GUICtrlComboBoxEx_SetUnicode

Func _GUICtrlComboBoxEx_ShowDropDown($hwnd, $bshow = False)
    _GUICtrlComboBox_ShowDropDown($hwnd, $bshow)
EndFunc    ; -> _GUICtrlComboBoxEx_ShowDropDown

Global Const $__DTPCONSTANT_CLASSNAME = "SysDateTimePick32"
Func _GUICtrlDTP_Create($hwnd, $ix, $iy, $iwidth = 0x78, $iheight = 0x15, $istyle = 0x0, $iexstyle = 0x0)
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return _WinAPI_CreateWindowEx($iexstyle, $__DTPCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
EndFunc    ; -> _GUICtrlDTP_Create

Func _GUICtrlDTP_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__DTPCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlDTP_Destroy

Func _GUICtrlDTP_GetMCColor($hwnd, $iindex)
    Return _SendMessage($hwnd, $DTM_GETMCCOLOR, $iindex)
EndFunc    ; -> _GUICtrlDTP_GetMCColor

Func _GUICtrlDTP_GetMCFont($hwnd)
    Return Ptr(_SendMessage($hwnd, $DTM_GETMCFONT))
EndFunc    ; -> _GUICtrlDTP_GetMCFont

Func _GUICtrlDTP_GetMonthCal($hwnd)
    Return HWnd(_SendMessage($hwnd, $DTM_GETMONTHCAL))
EndFunc    ; -> _GUICtrlDTP_GetMonthCal

Func _GUICtrlDTP_GetRange($hwnd)
    Local $arange[0xe]
    Local $trange = _GUICtrlDTP_GetRangeEx($hwnd)
    $arange[0x0] = DllStructGetData($trange, "MinValid")
    $arange[0x1] = DllStructGetData($trange, "MinYear")
    $arange[0x2] = DllStructGetData($trange, "MinMonth")
    $arange[0x3] = DllStructGetData($trange, "MinDay")
    $arange[0x4] = DllStructGetData($trange, "MinHour")
    $arange[0x5] = DllStructGetData($trange, "MinMinute")
    $arange[0x6] = DllStructGetData($trange, "MinSecond")
    $arange[0x7] = DllStructGetData($trange, "MaxValid")
    $arange[0x8] = DllStructGetData($trange, "MaxYear")
    $arange[0x9] = DllStructGetData($trange, "MaxMonth")
    $arange[0xa] = DllStructGetData($trange, "MaxDay")
    $arange[0xb] = DllStructGetData($trange, "MaxHour")
    $arange[0xc] = DllStructGetData($trange, "MaxMinute")
    $arange[0xd] = DllStructGetData($trange, "MaxSecond")
    Return $arange
EndFunc    ; -> _GUICtrlDTP_GetRange

Func _GUICtrlDTP_GetRangeEx($hwnd)
    Local $trange = DllStructCreate($TAGDTPRANGE)
    Local $iret = __guictrl_sendmsg($hwnd, $DTM_GETRANGE, 0x0, $trange, 0x0, True)
    DllStructSetData($trange, "MinValid", BitAND($iret, $GDTR_MIN) <> 0x0)
    DllStructSetData($trange, "MaxValid", BitAND($iret, $GDTR_MAX) <> 0x0)
    Return $trange
EndFunc    ; -> _GUICtrlDTP_GetRangeEx

Func _GUICtrlDTP_GetSystemTime($hwnd)
    Local $adate[0x6]
    Local $tdate = _GUICtrlDTP_GetSystemTimeEx($hwnd)
    $adate[0x0] = DllStructGetData($tdate, "Year")
    $adate[0x1] = DllStructGetData($tdate, "Month")
    $adate[0x2] = DllStructGetData($tdate, "Day")
    $adate[0x3] = DllStructGetData($tdate, "Hour")
    $adate[0x4] = DllStructGetData($tdate, "Minute")
    $adate[0x5] = DllStructGetData($tdate, "Second")
    Return $adate
EndFunc    ; -> _GUICtrlDTP_GetSystemTime

Func _GUICtrlDTP_GetSystemTimeEx($hwnd)
    Local $tdate = DllStructCreate($TAGSYSTEMTIME)
    Local $iret = __guictrl_sendmsg($hwnd, $DTM_GETSYSTEMTIME, 0x0, $tdate, 0x0, True)
    Return SetError($iret, $iret, $tdate)
EndFunc    ; -> _GUICtrlDTP_GetSystemTimeEx

Func _GUICtrlDTP_SetFormat($hwnd, $sformat)
    Local $tformat = DllStructCreate("wchar[" & StringLen($sformat) + 0x1 & "]")
    DllStructSetData($tformat, 0x1, $sformat)
    Local $iret = __guictrl_sendmsg($hwnd, $DTM_SETFORMATW, 0x0, $tformat)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlDTP_SetFormat

Func _GUICtrlDTP_SetMCColor($hwnd, $iindex, $icolor)
    Return _SendMessage($hwnd, $DTM_SETMCCOLOR, $iindex, $icolor)
EndFunc    ; -> _GUICtrlDTP_SetMCColor

Func _GUICtrlDTP_SetMCFont($hwnd, $hfont, $bredraw = True)
    _SendMessage($hwnd, $DTM_SETMCFONT, $hfont, $bredraw, 0x0, "handle")
EndFunc    ; -> _GUICtrlDTP_SetMCFont

Func _GUICtrlDTP_SetRange($hwnd, ByRef $arange)
    Local $trange = DllStructCreate($TAGDTPRANGE)
    DllStructSetData($trange, "MinValid", $arange[0x0])
    DllStructSetData($trange, "MinYear", $arange[0x1])
    DllStructSetData($trange, "MinMonth", $arange[0x2])
    DllStructSetData($trange, "MinDay", $arange[0x3])
    DllStructSetData($trange, "MinHour", $arange[0x4])
    DllStructSetData($trange, "MinMinute", $arange[0x5])
    DllStructSetData($trange, "MinSecond", $arange[0x6])
    DllStructSetData($trange, "MaxValid", $arange[0x7])
    DllStructSetData($trange, "MaxYear", $arange[0x8])
    DllStructSetData($trange, "MaxMonth", $arange[0x9])
    DllStructSetData($trange, "MaxDay", $arange[0xa])
    DllStructSetData($trange, "MaxHour", $arange[0xb])
    DllStructSetData($trange, "MaxMinute", $arange[0xc])
    DllStructSetData($trange, "MaxSecond", $arange[0xd])
    Return _GUICtrlDTP_SetRangeEx($hwnd, $trange)
EndFunc    ; -> _GUICtrlDTP_SetRange

Func _GUICtrlDTP_SetRangeEx($hwnd, ByRef $trange)
    Local $IFLAGS = 0x0
    If DllStructGetData($trange, "MinValid") Then $IFLAGS = BitOR($IFLAGS, $GDTR_MIN)
    If DllStructGetData($trange, "MaxValid") Then $IFLAGS = BitOR($IFLAGS, $GDTR_MAX)
    Local $iret = __guictrl_sendmsg($hwnd, $DTM_SETRANGE, $IFLAGS, $trange)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlDTP_SetRangeEx

Func _GUICtrlDTP_SetSystemTime($hwnd, ByRef $adate)
    Local $tdate = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($tdate, "Year", $adate[0x1])
    DllStructSetData($tdate, "Month", $adate[0x2])
    DllStructSetData($tdate, "Day", $adate[0x3])
    DllStructSetData($tdate, "Hour", $adate[0x4])
    DllStructSetData($tdate, "Minute", $adate[0x5])
    DllStructSetData($tdate, "Second", $adate[0x6])
    Return _GUICtrlDTP_SetSystemTimeEx($hwnd, $tdate, $adate[0x0])
EndFunc    ; -> _GUICtrlDTP_SetSystemTime

Func _GUICtrlDTP_SetSystemTimeEx($hwnd, ByRef $tdate, $bflag = False)
    Local $IFLAG
    If $bflag Then
        $IFLAG = $GDT_NONE
    Else
        $IFLAG = $GDT_VALID
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $DTM_SETSYSTEMTIME, $IFLAG, $tdate)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlDTP_SetSystemTimeEx

Global Const $SBARS_SIZEGRIP = 0x100
Global Const $SBT_TOOLTIPS = 0x800
Global Const $SBARS_TOOLTIPS = 0x800
Global Const $SBT_SUNKEN = 0x0
Global Const $SBT_NOBORDERS = 0x100
Global Const $SBT_POPOUT = 0x200
Global Const $SBT_RTLREADING = 0x400
Global Const $SBT_NOTABPARSING = 0x800
Global Const $SBT_OWNERDRAW = 0x1000
Global Const $__STATUSBARCONSTANT_WM_USER = 0x400
Global Const $SB_GETBORDERS = ($__STATUSBARCONSTANT_WM_USER + 0x7)
Global Const $SB_GETICON = ($__STATUSBARCONSTANT_WM_USER + 0x14)
Global Const $SB_GETPARTS = ($__STATUSBARCONSTANT_WM_USER + 0x6)
Global Const $SB_GETRECT = ($__STATUSBARCONSTANT_WM_USER + 0xa)
Global Const $SB_GETTEXTA = ($__STATUSBARCONSTANT_WM_USER + 0x2)
Global Const $SB_GETTEXTW = ($__STATUSBARCONSTANT_WM_USER + 0xd)
Global Const $SB_GETTEXT = $SB_GETTEXTA
Global Const $SB_GETTEXTLENGTHA = ($__STATUSBARCONSTANT_WM_USER + 0x3)
Global Const $SB_GETTEXTLENGTHW = ($__STATUSBARCONSTANT_WM_USER + 0xc)
Global Const $SB_GETTEXTLENGTH = $SB_GETTEXTLENGTHA
Global Const $SB_GETTIPTEXTA = ($__STATUSBARCONSTANT_WM_USER + 0x12)
Global Const $SB_GETTIPTEXTW = ($__STATUSBARCONSTANT_WM_USER + 0x13)
Global Const $SB_GETUNICODEFORMAT = 0x2000 + 0x6
Global Const $SB_ISSIMPLE = ($__STATUSBARCONSTANT_WM_USER + 0xe)
Global Const $SB_SETBKCOLOR = 0x2000 + 0x1
Global Const $SB_SETICON = ($__STATUSBARCONSTANT_WM_USER + 0xf)
Global Const $SB_SETMINHEIGHT = ($__STATUSBARCONSTANT_WM_USER + 0x8)
Global Const $SB_SETPARTS = ($__STATUSBARCONSTANT_WM_USER + 0x4)
Global Const $SB_SETTEXTA = ($__STATUSBARCONSTANT_WM_USER + 0x1)
Global Const $SB_SETTEXTW = ($__STATUSBARCONSTANT_WM_USER + 0xb)
Global Const $SB_SETTEXT = $SB_SETTEXTA
Global Const $SB_SETTIPTEXTA = ($__STATUSBARCONSTANT_WM_USER + 0x10)
Global Const $SB_SETTIPTEXTW = ($__STATUSBARCONSTANT_WM_USER + 0x11)
Global Const $SB_SETUNICODEFORMAT = 0x2000 + 0x5
Global Const $SB_SIMPLE = ($__STATUSBARCONSTANT_WM_USER + 0x9)
Global Const $SB_SIMPLEID = 0xff
Global Const $SBN_FIRST = + -880
Global Const $SBN_SIMPLEMODECHANGE = $SBN_FIRST + 0x0
Global $__g_tsbbuffer, $__g_tsbbufferansi
Global Const $__STATUSBARCONSTANT_CLASSNAME = "msctls_statusbar32"
Global Const $__STATUSBARCONSTANT_WM_SIZE = 0x5
Global Const $__STATUSBARCONSTANT_CLR_DEFAULT = -16777216
Global Const $TAGBORDERS = "int BX;int BY;int RX"
Func _GUICtrlStatusBar_Create($hwnd, $vpartedge = + -1, $vparttext = '', $istyles = + -1, $iexstyles = 0x0)
    If Not IsHWnd($hwnd) Then Return SetError(0x1, 0x0, 0x0)
    Local $istyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
    If $istyles = + -1 Then $istyles = 0x0
    If $iexstyles = + -1 Then $iexstyles = 0x0
    Local $apartwidth[0x1], $aparttext[0x1]
    If @NumParams > 0x1 Then
        If IsArray($vpartedge) Then
            $apartwidth = $vpartedge
        Else
            $apartwidth[0x0] = $vpartedge
        EndIf
        If @NumParams = 0x2 Then
            ReDim $aparttext[UBound($apartwidth)]
        Else
            If IsArray($vparttext) Then
                $aparttext = $vparttext
            Else
                $aparttext[0x0] = $vparttext
            EndIf
            If UBound($apartwidth) <> UBound($aparttext) Then
                Local $ilast
                If UBound($apartwidth) > UBound($aparttext) Then
                    $ilast = UBound($aparttext)
                    ReDim $aparttext[UBound($apartwidth)]
                Else
                    $ilast = UBound($apartwidth)
                    ReDim $apartwidth[UBound($aparttext)]
                    For $x = $ilast To UBound($apartwidth) + -1
                        $apartwidth[$x] = $apartwidth[$x + -1] + 0x4b
                    Next
                    $apartwidth[UBound($aparttext) + -1] = + -1
                EndIf
            EndIf
        EndIf
        If Not IsHWnd($hwnd) Then $hwnd = HWnd($hwnd)
        If @NumParams > 0x3 Then $istyle = BitOR($istyle, $istyles)
    EndIf
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hwndsbar = _WinAPI_CreateWindowEx($iexstyles, $__STATUSBARCONSTANT_CLASSNAME, '', $istyle, 0x0, 0x0, 0x0, 0x0, $hwnd, $nctrlid)
    If @error Then Return SetError(@error, @extended, 0x0)
    If @NumParams > 0x1 Then
        _GUICtrlStatusBar_SetParts($hwndsbar, UBound($apartwidth), $apartwidth)
        For $x = 0x0 To UBound($aparttext) + -1
            _GUICtrlStatusBar_SetText($hwndsbar, $aparttext[$x], $x)
        Next
    EndIf
    Return $hwndsbar
EndFunc    ; -> _GUICtrlStatusBar_Create

Func _GUICtrlStatusBar_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__STATUSBARCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlStatusBar_Destroy

Func _GUICtrlStatusBar_EmbedControl($hwnd, $ipart, $hcontrol, $ifit = 0x4)
    Local $arect = _GUICtrlStatusBar_GetRect($hwnd, $ipart)
    Local $ibarx = $arect[0x0]
    Local $ibary = $arect[0x1]
    Local $ibarw = $arect[0x2] - $ibarx
    Local $ibarh = $arect[0x3] - $ibary
    Local $iconx = $ibarx
    Local $icony = $ibary
    Local $iconw = _WinAPI_GetWindowWidth($hcontrol)
    Local $iconh = _WinAPI_GetWindowHeight($hcontrol)
    If $iconw > $ibarw Then $iconw = $ibarw
    If $iconh > $ibarh Then $iconh = $ibarh
    Local $ipadx = ($ibarw - $iconw) / 0x2
    Local $ipady = ($ibarh - $iconh) / 0x2
    If $ipadx < 0x0 Then $ipadx = 0x0
    If $ipady < 0x0 Then $ipady = 0x0
    If BitAND($ifit, 0x1) = 0x1 Then $iconx = $ibarx + $ipadx
    If BitAND($ifit, 0x2) = 0x2 Then $icony = $ibary + $ipady
    If BitAND($ifit, 0x4) = 0x4 Then
        $ipadx = _GUICtrlStatusBar_GetBordersRect($hwnd)
        $ipady = _GUICtrlStatusBar_GetBordersVert($hwnd)
        $iconx = $ibarx
        If _GUICtrlStatusBar_IsSimple($hwnd) Then $iconx += $ipadx
        $icony = $ibary + $ipady
        $iconw = $ibarw - ($ipadx * 0x2)
        $iconh = $ibarh - ($ipady * 0x2)
    EndIf
    _WinAPI_SetParent($hcontrol, $hwnd)
    _WinAPI_MoveWindow($hcontrol, $iconx, $icony, $iconw, $iconh)
EndFunc    ; -> _GUICtrlStatusBar_EmbedControl

Func _GUICtrlStatusBar_GetBorders($hwnd)
    Local $tborders = DllStructCreate($TAGBORDERS)
    Local $iret = __guictrl_sendmsg($hwnd, $SB_GETBORDERS, 0x0, $tborders, 0x0, True)
    Local $aborders[0x3]
    If $iret = 0x0 Then Return SetError(+ -1, + -1, $aborders)
    $aborders[0x0] = DllStructGetData($tborders, "BX")
    $aborders[0x1] = DllStructGetData($tborders, "BY")
    $aborders[0x2] = DllStructGetData($tborders, "RX")
    Return $aborders
EndFunc    ; -> _GUICtrlStatusBar_GetBorders

Func _GUICtrlStatusBar_GetBordersHorz($hwnd)
    Local $aborders = _GUICtrlStatusBar_GetBorders($hwnd)
    Return SetError(@error, @extended, $aborders[0x0])
EndFunc    ; -> _GUICtrlStatusBar_GetBordersHorz

Func _GUICtrlStatusBar_GetBordersRect($hwnd)
    Local $aborders = _GUICtrlStatusBar_GetBorders($hwnd)
    Return SetError(@error, @extended, $aborders[0x2])
EndFunc    ; -> _GUICtrlStatusBar_GetBordersRect

Func _GUICtrlStatusBar_GetBordersVert($hwnd)
    Local $aborders = _GUICtrlStatusBar_GetBorders($hwnd)
    Return SetError(@error, @extended, $aborders[0x1])
EndFunc    ; -> _GUICtrlStatusBar_GetBordersVert

Func _GUICtrlStatusBar_GetCount($hwnd)
    Return _SendMessage($hwnd, $SB_GETPARTS)
EndFunc    ; -> _GUICtrlStatusBar_GetCount

Func _GUICtrlStatusBar_GetHeight($hwnd)
    Local $trect = _GUICtrlStatusBar_GetRectEx($hwnd, 0x0)
    Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top") - (_GUICtrlStatusBar_GetBordersVert($hwnd) * 0x2)
EndFunc    ; -> _GUICtrlStatusBar_GetHeight

Func _GUICtrlStatusBar_GetIcon($hwnd, $iindex = 0x0)
    Return _SendMessage($hwnd, $SB_GETICON, $iindex, 0x0, 0x0, "wparam", "lparam", "handle")
EndFunc    ; -> _GUICtrlStatusBar_GetIcon

Func _GUICtrlStatusBar_GetParts($hwnd)
    Local $icount = _GUICtrlStatusBar_GetCount($hwnd)
    Local $tparts = DllStructCreate("int[" & $icount & "]")
    Local $aparts[$icount + 0x1]
    $aparts[0x0] = __guictrl_sendmsg($hwnd, $SB_GETPARTS, $icount, $tparts, 0x0, True)
    For $ii = 0x1 To $icount
        $aparts[$ii] = DllStructGetData($tparts, 0x1, $ii)
    Next
    Return $aparts
EndFunc    ; -> _GUICtrlStatusBar_GetParts

Func _GUICtrlStatusBar_GetRect($hwnd, $ipart)
    Local $trect = _GUICtrlStatusBar_GetRectEx($hwnd, $ipart)
    If @error Then Return SetError(@error, 0x0, 0x0)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlStatusBar_GetRect

Func _GUICtrlStatusBar_GetRectEx($hwnd, $ipart)
    Local $trect = DllStructCreate($TAGRECT)
    Local $iret = __guictrl_sendmsg($hwnd, $SB_GETRECT, $ipart, $trect, 0x0, True)
    Return SetError($iret = 0x0, 0x0, $trect)
EndFunc    ; -> _GUICtrlStatusBar_GetRectEx

Func _GUICtrlStatusBar_GetText($hwnd, $ipart)
    Local $ibuffer = _GUICtrlStatusBar_GetTextLength($hwnd, $ipart) + 0x1
    If $ibuffer = 0x1 Then Return SetError(0x1, 0x0, '')
    Local $tbuffer, $imsg
    If _GUICtrlStatusBar_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tsbbuffer
        $imsg = $SB_GETTEXTW
    Else
        $tbuffer = $__g_tsbbufferansi
        $imsg = $SB_GETTEXT
    EndIf
    __guictrl_sendmsg($hwnd, $imsg, $ipart, $tbuffer, 0x0, True)
    Return DllStructGetData($tbuffer, "Text")
EndFunc    ; -> _GUICtrlStatusBar_GetText

Func _GUICtrlStatusBar_GetTextFlags($hwnd, $ipart)
    If _GUICtrlStatusBar_GetUnicodeFormat($hwnd) Then
        Return _SendMessage($hwnd, $SB_GETTEXTLENGTHW, $ipart)
    Else
        Return _SendMessage($hwnd, $SB_GETTEXTLENGTH, $ipart)
    EndIf
EndFunc    ; -> _GUICtrlStatusBar_GetTextFlags

Func _GUICtrlStatusBar_GetTextLength($hwnd, $ipart)
    Return _WinAPI_LoWord(_GUICtrlStatusBar_GetTextFlags($hwnd, $ipart))
EndFunc    ; -> _GUICtrlStatusBar_GetTextLength

Func _GUICtrlStatusBar_GetTextLengthEx($hwnd, $ipart)
    Return _WinAPI_HiWord(_GUICtrlStatusBar_GetTextFlags($hwnd, $ipart))
EndFunc    ; -> _GUICtrlStatusBar_GetTextLengthEx

Func _GUICtrlStatusBar_GetTipText($hwnd, $ipart)
    Local $tbuffer, $imsg
    If _GUICtrlStatusBar_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tsbbuffer
        $imsg = $SB_GETTIPTEXTW
    Else
        $tbuffer = $__g_tsbbufferansi
        $imsg = $SB_GETTIPTEXTA
    EndIf
    __guictrl_sendmsg($hwnd, $imsg, _WinAPI_MakeLong($ipart, 0x1000), $tbuffer, 0x0, True)
    Return DllStructGetData($tbuffer, "Text")
EndFunc    ; -> _GUICtrlStatusBar_GetTipText

Func _GUICtrlStatusBar_GetUnicodeFormat($hwnd)
    If Not IsDllStruct($__g_tsbbuffer) Then
        $__g_tsbbuffer = DllStructCreate("wchar Text[4096]")
        $__g_tsbbufferansi = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_tsbbuffer))
    EndIf
    Return _SendMessage($hwnd, $SB_GETUNICODEFORMAT) <> 0x0
EndFunc    ; -> _GUICtrlStatusBar_GetUnicodeFormat

Func _GUICtrlStatusBar_GetWidth($hwnd, $ipart)
    Local $trect = _GUICtrlStatusBar_GetRectEx($hwnd, $ipart)
    Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left") - (_GUICtrlStatusBar_GetBordersHorz($hwnd) * 0x2)
EndFunc    ; -> _GUICtrlStatusBar_GetWidth

Func _GUICtrlStatusBar_IsSimple($hwnd)
    Return _SendMessage($hwnd, $SB_ISSIMPLE) <> 0x0
EndFunc    ; -> _GUICtrlStatusBar_IsSimple

Func _GUICtrlStatusBar_Resize($hwnd)
    _SendMessage($hwnd, $__STATUSBARCONSTANT_WM_SIZE)
EndFunc    ; -> _GUICtrlStatusBar_Resize

Func _GUICtrlStatusBar_SetBkColor($hwnd, $icolor)
    $icolor = _SendMessage($hwnd, $SB_SETBKCOLOR, 0x0, $icolor)
EndFunc    ; -> _GUICtrlStatusBar_SetBkColor

Func _GUICtrlStatusBar_SetIcon($hwnd, $ipart, $hicon = + -1, $siconfile = '')
    If $hicon = + -1 Then Return _SendMessage($hwnd, $SB_SETICON, $ipart, $hicon, 0x0, "wparam", "handle") <> 0x0
    If StringLen($siconfile) <= 0x0 Then Return _SendMessage($hwnd, $SB_SETICON, $ipart, $hicon) <> 0x0
    Local $ticon = DllStructCreate("handle")
    Local $vresult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $siconfile, "int", $hicon, "ptr", 0x0, "struct*", $ticon, "uint", 0x1)
    If @error Then Return SetError(@error, @extended, False)
    $vresult = $vresult[0x0]
    If $vresult > 0x0 Then $vresult = _SendMessage($hwnd, $SB_SETICON, $ipart, DllStructGetData($ticon, 0x1), 0x0, "wparam", "handle")
    DllCall("user32.dll", "bool", "DestroyIcon", "handle", DllStructGetData($ticon, 0x1))
    Return $vresult
EndFunc    ; -> _GUICtrlStatusBar_SetIcon

Func _GUICtrlStatusBar_SetMinHeight($hwnd, $iminheight)
    _SendMessage($hwnd, $SB_SETMINHEIGHT, $iminheight)
    _GUICtrlStatusBar_Resize($hwnd)
EndFunc    ; -> _GUICtrlStatusBar_SetMinHeight

Func _GUICtrlStatusBar_SetParts($hwnd, $vpartedge = + -1, $vpartwidth = 0x19)
    If IsArray($vpartedge) And IsArray($vpartwidth) Then Return False
    Local $tparts, $iparts
    If IsArray($vpartedge) Then
        $vpartedge[UBound($vpartedge) + -1] = + -1
        $iparts = UBound($vpartedge)
        $tparts = DllStructCreate("int[" & $iparts & "]")
        For $x = 0x0 To $iparts + -2
            DllStructSetData($tparts, 0x1, $vpartedge[$x], $x + 0x1)
        Next
        DllStructSetData($tparts, 0x1, + -1, $iparts)
    Else
        If $vpartedge < + -1 Then Return False
        If IsArray($vpartwidth) Then
            $iparts = UBound($vpartwidth)
            $tparts = DllStructCreate("int[" & $iparts & "]")
            Local $ipartrightedge = 0x0
            For $x = 0x0 To $iparts + -2
                $ipartrightedge += $vpartwidth[$x]
                If $vpartwidth[$x] <= 0x0 Then Return False
                DllStructSetData($tparts, 0x1, $ipartrightedge, $x + 0x1)
            Next
            DllStructSetData($tparts, 0x1, + -1, $iparts)
        ElseIf $vpartedge > 0x1 Then
            $iparts = $vpartedge
            $tparts = DllStructCreate("int[" & $iparts & "]")
            For $x = 0x1 To $iparts + -1
                DllStructSetData($tparts, 0x1, $vpartwidth * $x, $x)
            Next
            DllStructSetData($tparts, 0x1, + -1, $iparts)
        Else
            $iparts = 0x1
            $tparts = DllStructCreate("int")
            DllStructSetData($tparts, 0x1, + -1)
        EndIf
    EndIf
    __guictrl_sendmsg($hwnd, $SB_SETPARTS, $iparts, $tparts)
    _GUICtrlStatusBar_Resize($hwnd)
    Return True
EndFunc    ; -> _GUICtrlStatusBar_SetParts

Func _GUICtrlStatusBar_SetSimple($hwnd, $bsimple = True)
    _SendMessage($hwnd, $SB_SIMPLE, $bsimple)
EndFunc    ; -> _GUICtrlStatusBar_SetSimple

Func _GUICtrlStatusBar_SetText($hwnd, $stext = '', $ipart = 0x0, $iuflag = 0x0)
    Local $ibuffer = StringLen($stext) + 0x1
    Local $ttext, $imsg
    If _GUICtrlStatusBar_GetUnicodeFormat($hwnd) Then
        $ttext = DllStructCreate("wchar Text[" & $ibuffer & "]")
        $imsg = $SB_SETTEXTW
    Else
        $ttext = DllStructCreate("char Text[" & $ibuffer & "]")
        $imsg = $SB_SETTEXT
    EndIf
    DllStructSetData($ttext, "Text", $stext)
    If _GUICtrlStatusBar_IsSimple($hwnd) Then $ipart = $SB_SIMPLEID
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, BitOR($ipart, $iuflag), $ttext)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlStatusBar_SetText

Func _GUICtrlStatusBar_SetTipText($hwnd, $ipart, $stext)
    Local $ibuffer = StringLen($stext) + 0x1
    Local $ttext, $imsg
    If _GUICtrlStatusBar_GetUnicodeFormat($hwnd) Then
        $ttext = DllStructCreate("wchar TipText[" & $ibuffer & "]")
        $imsg = $SB_SETTIPTEXTW
    Else
        $ttext = DllStructCreate("char TipText[" & $ibuffer & "]")
        $imsg = $SB_SETTIPTEXTA
    EndIf
    DllStructSetData($ttext, "TipText", $stext)
    __guictrl_sendmsg($hwnd, $imsg, $ipart, $ttext)
EndFunc    ; -> _GUICtrlStatusBar_SetTipText

Func _GUICtrlStatusBar_SetUnicodeFormat($hwnd, $bunicode = True)
    Return _SendMessage($hwnd, $SB_SETUNICODEFORMAT, $bunicode)
EndFunc    ; -> _GUICtrlStatusBar_SetUnicodeFormat

Func _GUICtrlStatusBar_ShowHide($hwnd, $istate)
    If $istate <> @SW_HIDE And $istate <> @SW_SHOW Then Return SetError(0x1, 0x1, False)
    Return _WinAPI_ShowWindow($hwnd, $istate)
EndFunc    ; -> _GUICtrlStatusBar_ShowHide

Global Const $TTF_IDISHWND = 0x1
Global Const $TTF_CENTERTIP = 0x2
Global Const $TTF_RTLREADING = 0x4
Global Const $TTF_SUBCLASS = 0x10
Global Const $TTF_TRACK = 0x20
Global Const $TTF_ABSOLUTE = 0x80
Global Const $TTF_TRANSPARENT = 0x100
Global Const $TTF_PARSELINKS = 0x1000
Global Const $TTF_DI_SETITEM = 0x8000
Global Const $__TOOLTIPCONSTANTS_WM_USER = 0x400
Global Const $TTM_ACTIVATE = $__TOOLTIPCONSTANTS_WM_USER + 0x1
Global Const $TTM_SETDELAYTIME = $__TOOLTIPCONSTANTS_WM_USER + 0x3
Global Const $TTM_ADDTOOL = $__TOOLTIPCONSTANTS_WM_USER + 0x4
Global Const $TTM_DELTOOL = $__TOOLTIPCONSTANTS_WM_USER + 0x5
Global Const $TTM_NEWTOOLRECT = $__TOOLTIPCONSTANTS_WM_USER + 0x6
Global Const $TTM_GETTOOLINFO = $__TOOLTIPCONSTANTS_WM_USER + 0x8
Global Const $TTM_SETTOOLINFO = $__TOOLTIPCONSTANTS_WM_USER + 0x9
Global Const $TTM_HITTEST = $__TOOLTIPCONSTANTS_WM_USER + 0xa
Global Const $TTM_GETTEXT = $__TOOLTIPCONSTANTS_WM_USER + 0xb
Global Const $TTM_UPDATETIPTEXT = $__TOOLTIPCONSTANTS_WM_USER + 0xc
Global Const $TTM_GETTOOLCOUNT = $__TOOLTIPCONSTANTS_WM_USER + 0xd
Global Const $TTM_ENUMTOOLS = $__TOOLTIPCONSTANTS_WM_USER + 0xe
Global Const $TTM_GETCURRENTTOOL = $__TOOLTIPCONSTANTS_WM_USER + 0xf
Global Const $TTM_WINDOWFROMPOINT = $__TOOLTIPCONSTANTS_WM_USER + 0x10
Global Const $TTM_TRACKACTIVATE = $__TOOLTIPCONSTANTS_WM_USER + 0x11
Global Const $TTM_TRACKPOSITION = $__TOOLTIPCONSTANTS_WM_USER + 0x12
Global Const $TTM_SETTIPBKCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 0x13
Global Const $TTM_SETTIPTEXTCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 0x14
Global Const $TTM_GETDELAYTIME = $__TOOLTIPCONSTANTS_WM_USER + 0x15
Global Const $TTM_GETTIPBKCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 0x16
Global Const $TTM_GETTIPTEXTCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 0x17
Global Const $TTM_SETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 0x18
Global Const $TTM_GETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 0x19
Global Const $TTM_SETMARGIN = $__TOOLTIPCONSTANTS_WM_USER + 0x1a
Global Const $TTM_GETMARGIN = $__TOOLTIPCONSTANTS_WM_USER + 0x1b
Global Const $TTM_POP = $__TOOLTIPCONSTANTS_WM_USER + 0x1c
Global Const $TTM_UPDATE = $__TOOLTIPCONSTANTS_WM_USER + 0x1d
Global Const $TTM_GETBUBBLESIZE = $__TOOLTIPCONSTANTS_WM_USER + 0x1e
Global Const $TTM_ADJUSTRECT = $__TOOLTIPCONSTANTS_WM_USER + 0x1f
Global Const $TTM_SETTITLE = $__TOOLTIPCONSTANTS_WM_USER + 0x20
Global Const $TTM_SETTITLEW = $__TOOLTIPCONSTANTS_WM_USER + 0x21
Global Const $TTM_POPUP = $__TOOLTIPCONSTANTS_WM_USER + 0x22
Global Const $TTM_GETTITLE = $__TOOLTIPCONSTANTS_WM_USER + 0x23
Global Const $TTM_ADDTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 0x32
Global Const $TTM_DELTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 0x33
Global Const $TTM_NEWTOOLRECTW = $__TOOLTIPCONSTANTS_WM_USER + 0x34
Global Const $TTM_GETTOOLINFOW = $__TOOLTIPCONSTANTS_WM_USER + 0x35
Global Const $TTM_SETTOOLINFOW = $__TOOLTIPCONSTANTS_WM_USER + 0x36
Global Const $TTM_HITTESTW = $__TOOLTIPCONSTANTS_WM_USER + 0x37
Global Const $TTM_GETTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 0x38
Global Const $TTM_UPDATETIPTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 0x39
Global Const $TTM_ENUMTOOLSW = $__TOOLTIPCONSTANTS_WM_USER + 0x3a
Global Const $TTM_GETCURRENTTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 0x3b
Global Const $TTM_SETWINDOWTHEME = 0x2000 + 0xb
Global Const $TTN_FIRST = + -520
Global Const $TTN_GETDISPINFO = $TTN_FIRST + 0x0
Global Const $TTN_SHOW = $TTN_FIRST + -1
Global Const $TTN_POP = $TTN_FIRST + -2
Global Const $TTN_LINKCLICK = $TTN_FIRST + -3
Global Const $TTN_GETDISPINFOW = $TTN_FIRST + -10
Global Const $TTS_ALWAYSTIP = 0x1
Global Const $TTS_NOPREFIX = 0x2
Global Const $TTS_NOANIMATE = 0x10
Global Const $TTS_NOFADE = 0x20
Global Const $TTS_BALLOON = 0x40
Global Const $TTS_CLOSE = 0x80
Global Const $TTS_USEVISUALSTYLE = 0x100
Global Const $TTDT_AUTOMATIC = 0x0
Global Const $TTDT_RESHOW = 0x1
Global Const $TTDT_AUTOPOP = 0x2
Global Const $TTDT_INITIAL = 0x3
Global Enum $TTI_NONE, $TTI_INFO, $TTI_WARNING, $TTI_ERROR, $TTI_INFO_LARGE, $TTI_WARNING_LARGE, $TTI_ERROR_LARGE
Global Const $__EDITCONSTANT_CLASSNAME = "Edit"
Global Const $__EDITCONSTANT_GUI_CHECKED = 0x1
Global Const $__EDITCONSTANT_GUI_HIDE = 0x20
Global Const $__EDITCONSTANT_GUI_EVENT_CLOSE = + -3
Global Const $__EDITCONSTANT_GUI_ENABLE = 0x40
Global Const $__EDITCONSTANT_GUI_DISABLE = 0x80
Global Const $__EDITCONSTANT_SS_CENTER = 0x1
Global Const $__EDITCONSTANT_WM_SETREDRAW = 0xb
Global Const $__EDITCONSTANT_WS_CAPTION = 0xc00000
Global Const $__EDITCONSTANT_WS_POPUP = -2147483648
Global Const $__EDITCONSTANT_WS_SYSMENU = 0x80000
Global Const $__EDITCONSTANT_WS_MINIMIZEBOX = 0x20000
Global Const $__EDITCONSTANT_DEFAULT_GUI_FONT = 0x11
Global Const $__EDITCONSTANT_WM_SETFONT = 0x30
Global Const $__EDITCONSTANT_WM_GETTEXTLENGTH = 0xe
Global Const $__EDITCONSTANT_WM_GETTEXT = 0xd
Global Const $__EDITCONSTANT_WM_SETTEXT = 0xc
Global Const $__EDITCONSTANT_SB_LINEUP = 0x0
Global Const $__EDITCONSTANT_SB_LINEDOWN = 0x1
Global Const $__EDITCONSTANT_SB_PAGEDOWN = 0x3
Global Const $__EDITCONSTANT_SB_PAGEUP = 0x2
Global Const $__EDITCONSTANT_SB_SCROLLCARET = 0x4
Global Const $__TAGEDITBALLOONTIP = "dword Size;ptr Title;ptr Text;int Icon"
Func _GUICtrlEdit_AppendText($hwnd, $stext)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ilength = _GUICtrlEdit_GetTextLen($hwnd)
    _GUICtrlEdit_SetSel($hwnd, $ilength, $ilength)
    _SendMessage($hwnd, $EM_REPLACESEL, True, $stext, 0x0, "wparam", "wstr")
EndFunc    ; -> _GUICtrlEdit_AppendText

Func _GUICtrlEdit_BeginUpdate($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $__EDITCONSTANT_WM_SETREDRAW, False) = 0x0
EndFunc    ; -> _GUICtrlEdit_BeginUpdate

Func _GUICtrlEdit_CanUndo($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_CANUNDO) <> 0x0
EndFunc    ; -> _GUICtrlEdit_CanUndo

Func _GUICtrlEdit_CharFromPos($hwnd, $ix, $iy)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $aret[0x2]
    Local $iret = _SendMessage($hwnd, $EM_CHARFROMPOS, 0x0, _WinAPI_MakeLong($ix, $iy))
    $aret[0x0] = _WinAPI_LoWord($iret)
    $aret[0x1] = _WinAPI_HiWord($iret)
    Return $aret
EndFunc    ; -> _GUICtrlEdit_CharFromPos

Func _GUICtrlEdit_Create($hwnd, $stext, $ix, $iy, $iwidth = 0x96, $iheight = 0x96, $istyle = 0x3010c4, $iexstyle = 0x200)
    If Not IsHWnd($hwnd) Then Return SetError(0x1, 0x0, 0x0)
    If Not IsString($stext) Then Return SetError(0x2, 0x0, 0x0)
    If $iwidth = + -1 Then $iwidth = 0x96
    If $iheight = + -1 Then $iheight = 0x96
    If $istyle = + -1 Then $istyle = 0x3010c4
    If $iexstyle = + -1 Then $iexstyle = 0x200
    If BitAND($istyle, $ES_READONLY) = $ES_READONLY Then
        $istyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $istyle)
    Else
        $istyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_TABSTOP, $istyle)
    EndIf
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hedit = _WinAPI_CreateWindowEx($iexstyle, $__EDITCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    _SendMessage($hedit, $__EDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__EDITCONSTANT_DEFAULT_GUI_FONT), True)
    _GUICtrlEdit_SetText($hedit, $stext)
    _GUICtrlEdit_SetLimitText($hedit, 0x0)
    Return $hedit
EndFunc    ; -> _GUICtrlEdit_Create

Func _GUICtrlEdit_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__EDITCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlEdit_Destroy

Func _GUICtrlEdit_EmptyUndoBuffer($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_EMPTYUNDOBUFFER)
EndFunc    ; -> _GUICtrlEdit_EmptyUndoBuffer

Func _GUICtrlEdit_EndUpdate($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $__EDITCONSTANT_WM_SETREDRAW, True) = 0x0
EndFunc    ; -> _GUICtrlEdit_EndUpdate

Func _GUICtrlEdit_FmtLines($hwnd, $bsoftbreak = False)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_FMTLINES, $bsoftbreak)
EndFunc    ; -> _GUICtrlEdit_FmtLines

Func _GUICtrlEdit_Find($hwnd, $breplace = False)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ipos = 0x0, $ICASE, $ioccurance = 0x0, $ireplacements = 0x0
    Local $apartsrightedge[0x3] = [0x7d, 0xe1, + -1]
    Local $ioldmode = Opt("GUIOnEventMode", 0x0)
    Local $asel = _GUICtrlEdit_GetSel($hwnd)
    Local $stext = _GUICtrlEdit_GetText($hwnd)
    Local $hguisearch = GUICreate("Find", 0x15d, 0xb1, + -1, + -1, BitOR($__UDFGUICONSTANT_WS_CHILD, $__EDITCONSTANT_WS_MINIMIZEBOX, $__EDITCONSTANT_WS_CAPTION, $__EDITCONSTANT_WS_POPUP, $__EDITCONSTANT_WS_SYSMENU))
    Local $idstatusbar1 = _GUICtrlStatusBar_Create($hguisearch, $apartsrightedge)
    _GUICtrlStatusBar_SetText($idstatusbar1, "Find: ")
    GUISetIcon(@SystemDir & "\\shell32.dll", 0x16, $hguisearch)
    GUICtrlCreateLabel("Find what:", 0x9, 0xa, 0x35, 0x10, $__EDITCONSTANT_SS_CENTER)
    Local $idinputsearch = GUICtrlCreateInput('', 0x50, 0x8, 0x101, 0x15)
    Local $idlblreplace = GUICtrlCreateLabel("Replace with:", 0x9, 0x2a, 0x45, 0x11, $__EDITCONSTANT_SS_CENTER)
    Local $idinputreplace = GUICtrlCreateInput('', 0x50, 0x28, 0x101, 0x15)
    Local $idchkwholeonly = GUICtrlCreateCheckbox("Match whole word only", 0x9, 0x48, 0x91, 0x11)
    Local $idchkmatchcase = GUICtrlCreateCheckbox("Match case", 0x9, 0x60, 0x91, 0x11)
    Local $idbtnfindnext = GUICtrlCreateButton("Find Next", 0xa8, 0x48, 0xa1, 0x15, 0x0)
    Local $idbtnreplace = GUICtrlCreateButton("Replace", 0xa8, 0x60, 0xa1, 0x15, 0x0)
    Local $idbtnclose = GUICtrlCreateButton("Close", 0x68, 0x82, 0xa1, 0x15, 0x0)
    If (IsArray($asel) And $asel <> $EC_ERR) Then
        GUICtrlSetData($idinputsearch, StringMid($stext, $asel[0x0] + 0x1, $asel[0x1] - $asel[0x0]))
        If $asel[0x0] <> $asel[0x1] Then
            $ipos = $asel[0x0]
            If BitAND(GUICtrlRead($idchkmatchcase), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $ICASE = 0x1
            $ioccurance = 0x1
            Local $itpose
            While 0x1
                $itpose = StringInStr($stext, GUICtrlRead($idinputsearch), $ICASE, $ioccurance)
                If Not $itpose Then
                    $ioccurance = 0x0
                    ExitLoop
                ElseIf $itpose = $ipos + 0x1 Then
                    ExitLoop
                EndIf
                $ioccurance += 0x1
            WEnd
        EndIf
        _GUICtrlStatusBar_SetText($idstatusbar1, "Find: " & GUICtrlRead($idinputsearch))
    EndIf
    If $breplace = False Then
        GUICtrlSetState($idlblreplace, $__EDITCONSTANT_GUI_HIDE)
        GUICtrlSetState($idinputreplace, $__EDITCONSTANT_GUI_HIDE)
        GUICtrlSetState($idbtnreplace, $__EDITCONSTANT_GUI_HIDE)
    Else
        _GUICtrlStatusBar_SetText($idstatusbar1, "Replacements: " & $ireplacements, 0x1)
        _GUICtrlStatusBar_SetText($idstatusbar1, "With: ", 0x2)
    EndIf
    GUISetState(@SW_SHOW)
    Local $imsgfind
    While 0x1
        $imsgfind = GUIGetMsg()
        Select
        Case $imsgfind = $__EDITCONSTANT_GUI_EVENT_CLOSE Or $imsgfind = $idbtnclose
            ExitLoop
        Case $imsgfind = $idbtnfindnext
            GUICtrlSetState($idbtnfindnext, $__EDITCONSTANT_GUI_DISABLE)
            GUICtrlSetCursor($idbtnfindnext, 0xf)
            Sleep(0x64)
            _GUICtrlStatusBar_SetText($idstatusbar1, "Find: " & GUICtrlRead($idinputsearch))
            If $breplace = True Then
                _GUICtrlStatusBar_SetText($idstatusbar1, "Find: " & GUICtrlRead($idinputsearch))
                _GUICtrlStatusBar_SetText($idstatusbar1, "With: " & GUICtrlRead($idinputreplace), 0x2)
            EndIf
            __GUICtrlEdit_FindText($hwnd, $idinputsearch, $idchkmatchcase, $idchkwholeonly, $ipos, $ioccurance, $ireplacements)
            Sleep(0x64)
            GUICtrlSetState($idbtnfindnext, $__EDITCONSTANT_GUI_ENABLE)
            GUICtrlSetCursor($idbtnfindnext, 0x2)
        Case $imsgfind = $idbtnreplace
            GUICtrlSetState($idbtnreplace, $__EDITCONSTANT_GUI_DISABLE)
            GUICtrlSetCursor($idbtnreplace, 0xf)
            Sleep(0x64)
            _GUICtrlStatusBar_SetText($idstatusbar1, "Find: " & GUICtrlRead($idinputsearch))
            _GUICtrlStatusBar_SetText($idstatusbar1, "With: " & GUICtrlRead($idinputreplace), 0x2)
            If $ipos Then
                _GUICtrlEdit_ReplaceSel($hwnd, GUICtrlRead($idinputreplace))
                $ireplacements += 0x1
                $ioccurance -= 0x1
                _GUICtrlStatusBar_SetText($idstatusbar1, "Replacements: " & $ireplacements, 0x1)
            EndIf
            __GUICtrlEdit_FindText($hwnd, $idinputsearch, $idchkmatchcase, $idchkwholeonly, $ipos, $ioccurance, $ireplacements)
            Sleep(0x64)
            GUICtrlSetState($idbtnreplace, $__EDITCONSTANT_GUI_ENABLE)
            GUICtrlSetCursor($idbtnreplace, 0x2)
        EndSelect
    WEnd
    GUIDelete($hguisearch)
    Opt("GUIOnEventMode", $ioldmode)
EndFunc    ; -> _GUICtrlEdit_Find

Func _GUICtrlEdit_GetCueBanner($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ttext = DllStructCreate("wchar[4096]")
    If _SendMessage($hwnd, $EM_GETCUEBANNER, $ttext, 0x1000, 0x0, "struct*") <> 0x1 Then Return SetError(+ -1, 0x0, '')
    Return DllStructGetData($ttext, 0x1)
EndFunc    ; -> _GUICtrlEdit_GetCueBanner

Func __GUICtrlEdit_FindText($hwnd, $idinputsearch, $idchkmatchcase, $idchkwholeonly, ByRef $ipos, ByRef $ioccurance, ByRef $ireplacements)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ICASE = 0x0, $iwhole = 0x0
    Local $bexact = False
    Local $sfind = GUICtrlRead($idinputsearch)
    Local $stext = _GUICtrlEdit_GetText($hwnd)
    If BitAND(GUICtrlRead($idchkmatchcase), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $ICASE = 0x1
    If BitAND(GUICtrlRead($idchkwholeonly), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $iwhole = 0x1
    If $sfind <> '' Then
        $ioccurance += 0x1
        $ipos = StringInStr($stext, $sfind, $ICASE, $ioccurance)
        If $iwhole And $ipos Then
            Local $s_compare2 = StringMid($stext, $ipos + StringLen($sfind), 0x1)
            If $ipos = 0x1 Then
                If ($ipos + StringLen($sfind)) + -1 = StringLen($stext) Or ($s_compare2 = " " Or $s_compare2 = @LF Or $s_compare2 = @CR Or $s_compare2 = @CRLF Or $s_compare2 = @TAB) Then $bexact = True
            Else
                Local $s_compare1 = StringMid($stext, $ipos + -1, 0x1)
                If ($ipos + StringLen($sfind)) + -1 = StringLen($stext) Then
                    If ($s_compare1 = " " Or $s_compare1 = @LF Or $s_compare1 = @CR Or $s_compare1 = @CRLF Or $s_compare1 = @TAB) Then $bexact = True
                Else
                    If ($s_compare1 = " " Or $s_compare1 = @LF Or $s_compare1 = @CR Or $s_compare1 = @CRLF Or $s_compare1 = @TAB) And ($s_compare2 = " " Or $s_compare2 = @LF Or $s_compare2 = @CR Or $s_compare2 = @CRLF Or $s_compare2 = @TAB) Then $bexact = True
                EndIf
            EndIf
            If $bexact = False Then
                __GUICtrlEdit_FindText($hwnd, $idinputsearch, $idchkmatchcase, $idchkwholeonly, $ipos, $ioccurance, $ireplacements)
            Else
                _GUICtrlEdit_SetSel($hwnd, $ipos + -1, ($ipos + StringLen($sfind)) + -1)
                _GUICtrlEdit_Scroll($hwnd, $__EDITCONSTANT_SB_SCROLLCARET)
            EndIf
        ElseIf $iwhole And Not $ipos Then
            $ioccurance = 0x0
            MsgBox($MB_SYSTEMMODAL, "Find", "Reached End of document, Can not find the string '" & $sfind & "'")
        ElseIf Not $iwhole Then
            If Not $ipos Then
                $ioccurance = 0x1
                _GUICtrlEdit_SetSel($hwnd, + -1, 0x0)
                _GUICtrlEdit_Scroll($hwnd, $__EDITCONSTANT_SB_SCROLLCARET)
                $ipos = StringInStr($stext, $sfind, $ICASE, $ioccurance)
                If Not $ipos Then
                    $ioccurance = 0x0
                    MsgBox($MB_SYSTEMMODAL, "Find", "Reached End of document, Can not find the string  '" & $sfind & "'")
                Else
                    _GUICtrlEdit_SetSel($hwnd, $ipos + -1, ($ipos + StringLen($sfind)) + -1)
                    _GUICtrlEdit_Scroll($hwnd, $__EDITCONSTANT_SB_SCROLLCARET)
                EndIf
            Else
                _GUICtrlEdit_SetSel($hwnd, $ipos + -1, ($ipos + StringLen($sfind)) + -1)
                _GUICtrlEdit_Scroll($hwnd, $__EDITCONSTANT_SB_SCROLLCARET)
            EndIf
        EndIf
    EndIf
EndFunc    ; -> __GUICtrlEdit_FindText

Func _GUICtrlEdit_GetFirstVisibleLine($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_GETFIRSTVISIBLELINE)
EndFunc    ; -> _GUICtrlEdit_GetFirstVisibleLine

Func _GUICtrlEdit_GetHandle($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return Ptr(_SendMessage($hwnd, $EM_GETHANDLE))
EndFunc    ; -> _GUICtrlEdit_GetHandle

Func _GUICtrlEdit_GetIMEStatus($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_GETIMESTATUS, $EMSIS_COMPOSITIONSTRING)
EndFunc    ; -> _GUICtrlEdit_GetIMEStatus

Func _GUICtrlEdit_GetLimitText($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_GETLIMITTEXT)
EndFunc    ; -> _GUICtrlEdit_GetLimitText

Func _GUICtrlEdit_GetLine($hwnd, $iline)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ilength = _GUICtrlEdit_LineLength($hwnd, $iline)
    If $ilength = 0x0 Then Return ''
    Local $tbuffer = DllStructCreate("short Len;wchar Text[" & $ilength & "]")
    DllStructSetData($tbuffer, "Len", $ilength + 0x1)
    Local $iret = _SendMessage($hwnd, $EM_GETLINE, $iline, $tbuffer, 0x0, "wparam", "struct*")
    If $iret = 0x0 Then Return SetError($EC_ERR, $EC_ERR, '')
    Local $ttext = DllStructCreate("wchar Text[" & $ilength & "]", DllStructGetPtr($tbuffer))
    Return DllStructGetData($ttext, "Text")
EndFunc    ; -> _GUICtrlEdit_GetLine

Func _GUICtrlEdit_GetLineCount($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_GETLINECOUNT)
EndFunc    ; -> _GUICtrlEdit_GetLineCount

Func _GUICtrlEdit_GetMargins($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $amargins[0x2]
    Local $imargins = _SendMessage($hwnd, $EM_GETMARGINS)
    $amargins[0x0] = _WinAPI_LoWord($imargins)
    $amargins[0x1] = _WinAPI_HiWord($imargins)
    Return $amargins
EndFunc    ; -> _GUICtrlEdit_GetMargins

Func _GUICtrlEdit_GetModify($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_GETMODIFY) <> 0x0
EndFunc    ; -> _GUICtrlEdit_GetModify

Func _GUICtrlEdit_GetPasswordChar($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_GETPASSWORDCHAR)
EndFunc    ; -> _GUICtrlEdit_GetPasswordChar

Func _GUICtrlEdit_GetRECT($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $arect[0x4]
    Local $trect = _GUICtrlEdit_GetRECTEx($hwnd)
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlEdit_GetRECT

Func _GUICtrlEdit_GetRECTEx($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $trect = DllStructCreate($TAGRECT)
    _SendMessage($hwnd, $EM_GETRECT, 0x0, $trect, 0x0, "wparam", "struct*")
    Return $trect
EndFunc    ; -> _GUICtrlEdit_GetRECTEx

Func _GUICtrlEdit_GetSel($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $asel[0x2]
    Local $tstart = DllStructCreate("uint Start")
    Local $tend = DllStructCreate("uint End")
    _SendMessage($hwnd, $EM_GETSEL, $tstart, $tend, 0x0, "struct*", "struct*")
    $asel[0x0] = DllStructGetData($tstart, "Start")
    $asel[0x1] = DllStructGetData($tend, "End")
    Return $asel
EndFunc    ; -> _GUICtrlEdit_GetSel

Func _GUICtrlEdit_GetText($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $itextlen = _GUICtrlEdit_GetTextLen($hwnd) + 0x1
    Local $ttext = DllStructCreate("wchar Text[" & $itextlen & "]")
    _SendMessage($hwnd, $__EDITCONSTANT_WM_GETTEXT, $itextlen, $ttext, 0x0, "wparam", "struct*")
    Return DllStructGetData($ttext, "Text")
EndFunc    ; -> _GUICtrlEdit_GetText

Func _GUICtrlEdit_GetTextLen($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $__EDITCONSTANT_WM_GETTEXTLENGTH)
EndFunc    ; -> _GUICtrlEdit_GetTextLen

Func _GUICtrlEdit_GetThumb($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_GETTHUMB)
EndFunc    ; -> _GUICtrlEdit_GetThumb

Func _GUICtrlEdit_GetWordBreakProc($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_GETWORDBREAKPROC)
EndFunc    ; -> _GUICtrlEdit_GetWordBreakProc

Func _GUICtrlEdit_HideBalloonTip($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_HIDEBALLOONTIP) <> 0x0
EndFunc    ; -> _GUICtrlEdit_HideBalloonTip

Func _GUICtrlEdit_InsertText($hwnd, $stext, $iindex = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If $iindex = + -1 Then
        _GUICtrlEdit_AppendText($hwnd, $stext)
    Else
        _GUICtrlEdit_SetSel($hwnd, $iindex, $iindex)
        _SendMessage($hwnd, $EM_REPLACESEL, True, $stext, 0x0, "wparam", "wstr")
    EndIf
EndFunc    ; -> _GUICtrlEdit_InsertText

Func _GUICtrlEdit_LineFromChar($hwnd, $iindex = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_LINEFROMCHAR, $iindex)
EndFunc    ; -> _GUICtrlEdit_LineFromChar

Func _GUICtrlEdit_LineIndex($hwnd, $iindex = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_LINEINDEX, $iindex)
EndFunc    ; -> _GUICtrlEdit_LineIndex

Func _GUICtrlEdit_LineLength($hwnd, $iindex = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $icharindex = _GUICtrlEdit_LineIndex($hwnd, $iindex)
    Return _SendMessage($hwnd, $EM_LINELENGTH, $icharindex)
EndFunc    ; -> _GUICtrlEdit_LineLength

Func _GUICtrlEdit_LineScroll($hwnd, $ihoriz, $ivert)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_LINESCROLL, $ihoriz, $ivert) <> 0x0
EndFunc    ; -> _GUICtrlEdit_LineScroll

Func _GUICtrlEdit_PosFromChar($hwnd, $iindex)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $acoord[0x2]
    Local $iret = _SendMessage($hwnd, $EM_POSFROMCHAR, $iindex)
    $acoord[0x0] = _WinAPI_LoWord($iret)
    $acoord[0x1] = _WinAPI_HiWord($iret)
    Return $acoord
EndFunc    ; -> _GUICtrlEdit_PosFromChar

Func _GUICtrlEdit_ReplaceSel($hwnd, $stext, $bundo = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_REPLACESEL, $bundo, $stext, 0x0, "wparam", "wstr")
EndFunc    ; -> _GUICtrlEdit_ReplaceSel

Func _GUICtrlEdit_Scroll($hwnd, $idirection)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If BitAND($idirection, $__EDITCONSTANT_SB_LINEDOWN) <> $__EDITCONSTANT_SB_LINEDOWN And BitAND($idirection, $__EDITCONSTANT_SB_LINEUP) <> $__EDITCONSTANT_SB_LINEUP And BitAND($idirection, $__EDITCONSTANT_SB_PAGEDOWN) <> $__EDITCONSTANT_SB_PAGEDOWN And BitAND($idirection, $__EDITCONSTANT_SB_PAGEUP) <> $__EDITCONSTANT_SB_PAGEUP And BitAND($idirection, $__EDITCONSTANT_SB_SCROLLCARET) <> $__EDITCONSTANT_SB_SCROLLCARET Then Return 0x0
    If $idirection == $__EDITCONSTANT_SB_SCROLLCARET Then
        Return _SendMessage($hwnd, $EM_SCROLLCARET)
    Else
        Return _SendMessage($hwnd, $EM_SCROLL, $idirection)
    EndIf
EndFunc    ; -> _GUICtrlEdit_Scroll

Func _GUICtrlEdit_SetCueBanner($hwnd, $stext, $bonfocus = False)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ttext = _WinAPI_MultiByteToWideChar($stext)
    Return _SendMessage($hwnd, $EM_SETCUEBANNER, $bonfocus, $ttext, 0x0, "wparam", "struct*") = 0x1
EndFunc    ; -> _GUICtrlEdit_SetCueBanner

Func _GUICtrlEdit_SetHandle($hwnd, $hmemory)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_SETHANDLE, $hmemory, 0x0, 0x0, "handle")
EndFunc    ; -> _GUICtrlEdit_SetHandle

Func _GUICtrlEdit_SetIMEStatus($hwnd, $icomposition)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_SETIMESTATUS, $EMSIS_COMPOSITIONSTRING, $icomposition)
EndFunc    ; -> _GUICtrlEdit_SetIMEStatus

Func _GUICtrlEdit_SetLimitText($hwnd, $ilimit)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_SETLIMITTEXT, $ilimit)
EndFunc    ; -> _GUICtrlEdit_SetLimitText

Func _GUICtrlEdit_SetMargins($hwnd, $imargin = 0x1, $ileft = 0xffff, $iright = 0xffff)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_SETMARGINS, $imargin, _WinAPI_MakeLong($ileft, $iright))
EndFunc    ; -> _GUICtrlEdit_SetMargins

Func _GUICtrlEdit_SetModify($hwnd, $bmodified)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_SETMODIFY, $bmodified)
EndFunc    ; -> _GUICtrlEdit_SetModify

Func _guictrledit_setpadding($hwnd, $icx, $icy)
    Local $trect = DllStructCreate($TAGRECT)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_GETRECT, 0x0, $trect, 0x0, "wparam", "struct*")
    $trect.left += $icx
    $trect.right -= $icx
    $trect.top += $icy
    $trect.bottom -= $icy
    Return _SendMessage($hwnd, $EM_SETRECT, 0x0, $trect, 0x0, "wparam", "struct*")
EndFunc    ; -> _guictrledit_setpadding

Func _GUICtrlEdit_SetPasswordChar($hwnd, $sdisplaychar = "0")
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    $sdisplaychar = StringLeft($sdisplaychar, 0x1)
    If Asc($sdisplaychar) = 0x30 Then
        _SendMessage($hwnd, $EM_SETPASSWORDCHAR)
    Else
        _SendMessage($hwnd, $EM_SETPASSWORDCHAR, Asc($sdisplaychar))
    EndIf
EndFunc    ; -> _GUICtrlEdit_SetPasswordChar

Func _GUICtrlEdit_SetReadOnly($hwnd, $breadonly)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_SETREADONLY, $breadonly) <> 0x0
EndFunc    ; -> _GUICtrlEdit_SetReadOnly

Func _GUICtrlEdit_SetRECT($hwnd, $arect)
    Local $trect = DllStructCreate($TAGRECT)
    DllStructSetData($trect, "Left", $arect[0x0])
    DllStructSetData($trect, "Top", $arect[0x1])
    DllStructSetData($trect, "Right", $arect[0x2])
    DllStructSetData($trect, "Bottom", $arect[0x3])
    _GUICtrlEdit_SetRECTEx($hwnd, $trect)
EndFunc    ; -> _GUICtrlEdit_SetRECT

Func _GUICtrlEdit_SetRECTEx($hwnd, $trect)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_SETRECT, 0x0, $trect, 0x0, "wparam", "struct*")
EndFunc    ; -> _GUICtrlEdit_SetRECTEx

Func _GUICtrlEdit_SetRECTNP($hwnd, $arect)
    Local $trect = DllStructCreate($TAGRECT)
    DllStructSetData($trect, "Left", $arect[0x0])
    DllStructSetData($trect, "Top", $arect[0x1])
    DllStructSetData($trect, "Right", $arect[0x2])
    DllStructSetData($trect, "Bottom", $arect[0x3])
    _GUICtrlEdit_SetRectNPEx($hwnd, $trect)
EndFunc    ; -> _GUICtrlEdit_SetRECTNP

Func _GUICtrlEdit_SetRectNPEx($hwnd, $trect)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_SETRECTNP, 0x0, $trect, 0x0, "wparam", "struct*")
EndFunc    ; -> _GUICtrlEdit_SetRectNPEx

Func _GUICtrlEdit_SetSel($hwnd, $istart, $IEND)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_SETSEL, $istart, $IEND)
EndFunc    ; -> _GUICtrlEdit_SetSel

Func _GUICtrlEdit_SetTabStops($hwnd, $atabstops)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If Not IsArray($atabstops) Then Return SetError(+ -1, + -1, False)
    Local $stabstops = ''
    Local $inumtabstops = UBound($atabstops)
    For $x = 0x0 To $inumtabstops + -1
        $stabstops &= "int;"
    Next
    $stabstops = StringTrimRight($stabstops, 0x1)
    Local $ttabstops = DllStructCreate($stabstops)
    For $x = 0x0 To $inumtabstops + -1
        DllStructSetData($ttabstops, $x + 0x1, $atabstops[$x])
    Next
    Local $iret = _SendMessage($hwnd, $EM_SETTABSTOPS, $inumtabstops, $ttabstops, 0x0, "wparam", "struct*") <> 0x0
    _WinAPI_InvalidateRect($hwnd)
    Return $iret
EndFunc    ; -> _GUICtrlEdit_SetTabStops

Func _GUICtrlEdit_SetText($hwnd, $stext)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $__EDITCONSTANT_WM_SETTEXT, 0x0, $stext, 0x0, "wparam", "wstr")
EndFunc    ; -> _GUICtrlEdit_SetText

Func _GUICtrlEdit_SetWordBreakProc($hwnd, $iaddressfunc)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $EM_SETWORDBREAKPROC, 0x0, $iaddressfunc)
EndFunc    ; -> _GUICtrlEdit_SetWordBreakProc

Func _GUICtrlEdit_ShowBalloonTip($hwnd, $STITLE, $stext, $iicon)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tbuffer = DllStructCreate("wchar Title[" & StringLen($STITLE) + 0x1 & "];wchar Text[" & StringLen($stext) + 0x1 & "]")
    DllStructSetData($tbuffer, "Title", $STITLE)
    DllStructSetData($tbuffer, "Text", $stext)
    Local $ttt = DllStructCreate($__TAGEDITBALLOONTIP)
    DllStructSetData($ttt, "Size", DllStructGetSize($ttt))
    DllStructSetData($ttt, "Title", DllStructGetPtr($tbuffer, "Title"))
    DllStructSetData($ttt, "Text", DllStructGetPtr($tbuffer, "Text"))
    DllStructSetData($ttt, "Icon", $iicon)
    Return _SendMessage($hwnd, $EM_SHOWBALLOONTIP, 0x0, $ttt, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlEdit_ShowBalloonTip

Func _GUICtrlEdit_Undo($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $EM_UNDO) <> 0x0
EndFunc    ; -> _GUICtrlEdit_Undo

Global Const $HDF_LEFT = 0x0
Global Const $HDF_RIGHT = 0x1
Global Const $HDF_CENTER = 0x2
Global Const $HDF_JUSTIFYMASK = 0x3
Global Const $HDF_BITMAP_ON_RIGHT = 0x1000
Global Const $HDF_BITMAP = 0x2000
Global Const $HDF_STRING = 0x4000
Global Const $HDF_OWNERDRAW = 0x8000
Global Const $HDF_DISPLAYMASK = 0xf000
Global Const $HDF_RTLREADING = 0x4
Global Const $HDF_SORTDOWN = 0x200
Global Const $HDF_IMAGE = 0x800
Global Const $HDF_SORTUP = 0x400
Global Const $HDF_FLAGMASK = 0xe04
Global Const $HDI_WIDTH = 0x1
Global Const $HDI_TEXT = 0x2
Global Const $HDI_FORMAT = 0x4
Global Const $HDI_PARAM = 0x8
Global Const $HDI_BITMAP = 0x10
Global Const $HDI_IMAGE = 0x20
Global Const $HDI_DI_SETITEM = 0x40
Global Const $HDI_ORDER = 0x80
Global Const $HDI_FILTER = 0x100
Global Const $HHT_NOWHERE = 0x1
Global Const $HHT_ONHEADER = 0x2
Global Const $HHT_ONDIVIDER = 0x4
Global Const $HHT_ONDIVOPEN = 0x8
Global Const $HHT_ONFILTER = 0x10
Global Const $HHT_ONFILTERBUTTON = 0x20
Global Const $HHT_ABOVE = 0x100
Global Const $HHT_BELOW = 0x200
Global Const $HHT_TORIGHT = 0x400
Global Const $HHT_TOLEFT = 0x800
Global Const $HDM_FIRST = 0x1200
Global Const $HDM_CLEARFILTER = $HDM_FIRST + 0x18
Global Const $HDM_CREATEDRAGIMAGE = $HDM_FIRST + 0x10
Global Const $HDM_DELETEITEM = $HDM_FIRST + 0x2
Global Const $HDM_EDITFILTER = $HDM_FIRST + 0x17
Global Const $HDM_GETBITMAPMARGIN = $HDM_FIRST + 0x15
Global Const $HDM_GETFOCUSEDITEM = $HDM_FIRST + 0x1b
Global Const $HDM_GETIMAGELIST = $HDM_FIRST + 0x9
Global Const $HDM_GETITEMA = $HDM_FIRST + 0x3
Global Const $HDM_GETITEMW = $HDM_FIRST + 0xb
Global Const $HDM_GETITEMCOUNT = $HDM_FIRST + 0x0
Global Const $HDM_GETITEMDROPDOWNRECT = $HDM_FIRST + 0x19
Global Const $HDM_GETITEMRECT = $HDM_FIRST + 0x7
Global Const $HDM_GETORDERARRAY = $HDM_FIRST + 0x11
Global Const $HDM_GETOVERFLOWRECT = $HDM_FIRST + 0x1a
Global Const $HDM_GETUNICODEFORMAT = 0x2000 + 0x6
Global Const $HDM_HITTEST = $HDM_FIRST + 0x6
Global Const $HDM_INSERTITEMA = $HDM_FIRST + 0x1
Global Const $HDM_INSERTITEMW = $HDM_FIRST + 0xa
Global Const $HDM_LAYOUT = $HDM_FIRST + 0x5
Global Const $HDM_ORDERTOINDEX = $HDM_FIRST + 0xf
Global Const $HDM_SETBITMAPMARGIN = $HDM_FIRST + 0x14
Global Const $HDM_SETFILTERCHANGETIMEOUT = $HDM_FIRST + 0x16
Global Const $HDM_SETFOCUSEDITEM = $HDM_FIRST + 0x1c
Global Const $HDM_SETHOTDIVIDER = $HDM_FIRST + 0x13
Global Const $HDM_SETIMAGELIST = $HDM_FIRST + 0x8
Global Const $HDM_SETITEMA = $HDM_FIRST + 0x4
Global Const $HDM_SETITEMW = $HDM_FIRST + 0xc
Global Const $HDM_SETORDERARRAY = $HDM_FIRST + 0x12
Global Const $HDM_SETUNICODEFORMAT = 0x2000 + 0x5
Global Const $HDN_FIRST = + -300
Global Const $HDN_BEGINDRAG = $HDN_FIRST + -10
Global Const $HDN_BEGINTRACK = $HDN_FIRST + -6
Global Const $HDN_DIVIDERDBLCLICK = $HDN_FIRST + -5
Global Const $HDN_ENDDRAG = $HDN_FIRST + -11
Global Const $HDN_ENDTRACK = $HDN_FIRST + -7
Global Const $HDN_FILTERBTNCLICK = $HDN_FIRST + -13
Global Const $HDN_FILTERCHANGE = $HDN_FIRST + -12
Global Const $HDN_GETDISPINFO = $HDN_FIRST + -9
Global Const $HDN_ITEMCHANGED = $HDN_FIRST + -1
Global Const $HDN_ITEMCHANGING = $HDN_FIRST + 0x0
Global Const $HDN_ITEMCLICK = $HDN_FIRST + -2
Global Const $HDN_ITEMDBLCLICK = $HDN_FIRST + -3
Global Const $HDN_TRACK = $HDN_FIRST + -8
Global Const $HDN_BEGINTRACKW = $HDN_FIRST + -26
Global Const $HDN_DIVIDERDBLCLICKW = $HDN_FIRST + -25
Global Const $HDN_ENDTRACKW = $HDN_FIRST + -27
Global Const $HDN_GETDISPINFOW = $HDN_FIRST + -29
Global Const $HDN_ITEMCHANGEDW = $HDN_FIRST + -21
Global Const $HDN_ITEMCHANGINGW = $HDN_FIRST + -20
Global Const $HDN_ITEMCLICKW = $HDN_FIRST + -22
Global Const $HDN_ITEMDBLCLICKW = $HDN_FIRST + -23
Global Const $HDN_TRACKW = $HDN_FIRST + -28
Global Const $HDS_BUTTONS = 0x2
Global Const $HDS_CHECKBOXES = 0x400
Global Const $HDS_DRAGDROP = 0x40
Global Const $HDS_FILTERBAR = 0x100
Global Const $HDS_FLAT = 0x200
Global Const $HDS_FULLDRAG = 0x80
Global Const $HDS_HIDDEN = 0x8
Global Const $HDS_HORZ = 0x0
Global Const $HDS_HOTTRACK = 0x4
Global Const $HDS_NOSIZING = 0x800
Global Const $HDS_OVERFLOW = 0x1000
Global Const $HDS_DEFAULT = 0x46
Global $__g_theaderbuffer, $__g_theaderbufferansi
Global Const $__HEADERCONSTANT_CLASSNAME = "SysHeader32"
Global Const $__HEADERCONSTANT_DEFAULT_GUI_FONT = 0x11
Global Const $__HEADERCONSTANT_SWP_SHOWWINDOW = 0x40
Global Const $TAGHDHITTESTINFO = $TAGPOINT & ";uint Flags;int Item"
Global Const $TAGHDLAYOUT = "ptr Rect;ptr WindowPos"
Global Const $TAGHDTEXTFILTER = "ptr Text;int TextMax"
Func _GUICtrlHeader_AddItem($hwnd, $stext, $iwidth = 0x32, $ialign = 0x0, $iimage = + -1, $bonright = False)
    Return _GUICtrlHeader_InsertItem($hwnd, _GUICtrlHeader_GetItemCount($hwnd), $stext, $iwidth, $ialign, $iimage, $bonright)
EndFunc    ; -> _GUICtrlHeader_AddItem

Func _GUICtrlHeader_ClearFilter($hwnd, $iindex)
    Return _SendMessage($hwnd, $HDM_CLEARFILTER, $iindex) <> 0x0
EndFunc    ; -> _GUICtrlHeader_ClearFilter

Func _GUICtrlHeader_ClearFilterAll($hwnd)
    Return _SendMessage($hwnd, $HDM_CLEARFILTER, + -1) <> 0x0
EndFunc    ; -> _GUICtrlHeader_ClearFilterAll

Func _GUICtrlHeader_Create($hwnd, $istyle = 0x46)
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hheader = _WinAPI_CreateWindowEx(0x0, $__HEADERCONSTANT_CLASSNAME, '', $istyle, 0x0, 0x0, 0x0, 0x0, $hwnd, $nctrlid)
    Local $trect = _WinAPI_GetClientRect($hwnd)
    Local $twindowpos = _GUICtrlHeader_Layout($hheader, $trect)
    Local $IFLAGS = BitOR(DllStructGetData($twindowpos, "Flags"), $__HEADERCONSTANT_SWP_SHOWWINDOW)
    _WinAPI_SetWindowPos($hheader, DllStructGetData($twindowpos, "InsertAfter"), DllStructGetData($twindowpos, "X"), DllStructGetData($twindowpos, "Y"), DllStructGetData($twindowpos, "CX"), DllStructGetData($twindowpos, "CY"), $IFLAGS)
    _WinAPI_SetFont($hheader, _WinAPI_GetStockObject($__HEADERCONSTANT_DEFAULT_GUI_FONT))
    Return $hheader
EndFunc    ; -> _GUICtrlHeader_Create

Func _GUICtrlHeader_CreateDragImage($hwnd, $iindex)
    Return Ptr(_SendMessage($hwnd, $HDM_CREATEDRAGIMAGE, $iindex))
EndFunc    ; -> _GUICtrlHeader_CreateDragImage

Func _GUICtrlHeader_DeleteItem($hwnd, $iindex)
    Return _SendMessage($hwnd, $HDM_DELETEITEM, $iindex) <> 0x0
EndFunc    ; -> _GUICtrlHeader_DeleteItem

Func _GUICtrlHeader_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__HEADERCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlHeader_Destroy

Func _GUICtrlHeader_EditFilter($hwnd, $iindex, $bdiscard = True)
    Return _SendMessage($hwnd, $HDM_EDITFILTER, $iindex, $bdiscard) <> 0x0
EndFunc    ; -> _GUICtrlHeader_EditFilter

Func _guictrlheader_getfiltertext($hwnd, $iindex)
    Local $tbuffer, $imsg
    If _GUICtrlHeader_GetUnicodeFormat($hwnd) Then
        $tbuffer = DllStructCreate("wchar Text[64]")
        $imsg = $HDM_GETITEMW
    Else
        $tbuffer = DllStructCreate("char Text[64]")
        $imsg = $HDM_GETITEMA
    EndIf
    Local $tfilter = DllStructCreate($TAGHDTEXTFILTER)
    DllStructSetData($tfilter, "Text", DllStructGetPtr($tbuffer))
    DllStructSetData($tfilter, "TextMax", DllStructGetSize($tbuffer))
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_FILTER)
    DllStructSetData($titem, "Type", 0x0)
    DllStructSetData($titem, "pFilter", DllStructGetPtr($tfilter))
    __guictrl_sendmsg($hwnd, $imsg, $iindex, $titem, $tbuffer, False, + -1, True)
    Return DllStructGetData($tbuffer, "Text")
EndFunc    ; -> _guictrlheader_getfiltertext

Func _GUICtrlHeader_GetBitmapMargin($hwnd)
    Return _SendMessage($hwnd, $HDM_GETBITMAPMARGIN)
EndFunc    ; -> _GUICtrlHeader_GetBitmapMargin

Func _GUICtrlHeader_GetImageList($hwnd)
    Return Ptr(_SendMessage($hwnd, $HDM_GETIMAGELIST))
EndFunc    ; -> _GUICtrlHeader_GetImageList

Func _GUICtrlHeader_GetItem($hwnd, $iindex, ByRef $titem)
    Local $imsg
    If _GUICtrlHeader_GetUnicodeFormat($hwnd) Then
        $imsg = $HDM_GETITEMW
    Else
        $imsg = $HDM_GETITEMA
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $titem, 0x0, True)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlHeader_GetItem

Func _GUICtrlHeader_GetItemAlign($hwnd, $iindex)
    Switch BitAND(_GUICtrlHeader_GetItemFormat($hwnd, $iindex), $HDF_JUSTIFYMASK)
    Case $HDF_LEFT
        Return 0x0
    Case $HDF_RIGHT
        Return 0x1
    Case $HDF_CENTER
        Return 0x2
    Case Else
        Return + -1
    EndSwitch
EndFunc    ; -> _GUICtrlHeader_GetItemAlign

Func _GUICtrlHeader_GetItemBitmap($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_BITMAP)
    _GUICtrlHeader_GetItem($hwnd, $iindex, $titem)
    Return DllStructGetData($titem, "hBmp")
EndFunc    ; -> _GUICtrlHeader_GetItemBitmap

Func _GUICtrlHeader_GetItemCount($hwnd)
    Return _SendMessage($hwnd, $HDM_GETITEMCOUNT)
EndFunc    ; -> _GUICtrlHeader_GetItemCount

Func _GUICtrlHeader_GetItemDisplay($hwnd, $iindex)
    Local $iret = 0x0
    Local $iformat = _GUICtrlHeader_GetItemFormat($hwnd, $iindex)
    If BitAND($iformat, $HDF_BITMAP) <> 0x0 Then $iret = BitOR($iret, 0x1)
    If BitAND($iformat, $HDF_BITMAP_ON_RIGHT) <> 0x0 Then $iret = BitOR($iret, 0x2)
    If BitAND($iformat, $HDF_OWNERDRAW) <> 0x0 Then $iret = BitOR($iret, 0x4)
    If BitAND($iformat, $HDF_STRING) <> 0x0 Then $iret = BitOR($iret, 0x8)
    Return $iret
EndFunc    ; -> _GUICtrlHeader_GetItemDisplay

Func _GUICtrlHeader_GetItemFlags($hwnd, $iindex)
    Local $iret = 0x0
    Local $iformat = _GUICtrlHeader_GetItemFormat($hwnd, $iindex)
    If BitAND($iformat, $HDF_IMAGE) <> 0x0 Then $iret = BitOR($iret, 0x1)
    If BitAND($iformat, $HDF_RTLREADING) <> 0x0 Then $iret = BitOR($iret, 0x2)
    If BitAND($iformat, $HDF_SORTDOWN) <> 0x0 Then $iret = BitOR($iret, 0x4)
    If BitAND($iformat, $HDF_SORTUP) <> 0x0 Then $iret = BitOR($iret, 0x8)
    Return $iret
EndFunc    ; -> _GUICtrlHeader_GetItemFlags

Func _GUICtrlHeader_GetItemFormat($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_FORMAT)
    _GUICtrlHeader_GetItem($hwnd, $iindex, $titem)
    Return DllStructGetData($titem, "Fmt")
EndFunc    ; -> _GUICtrlHeader_GetItemFormat

Func _GUICtrlHeader_GetItemImage($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_IMAGE)
    _GUICtrlHeader_GetItem($hwnd, $iindex, $titem)
    Return DllStructGetData($titem, "Image")
EndFunc    ; -> _GUICtrlHeader_GetItemImage

Func _GUICtrlHeader_GetItemOrder($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_ORDER)
    _GUICtrlHeader_GetItem($hwnd, $iindex, $titem)
    Return DllStructGetData($titem, "Order")
EndFunc    ; -> _GUICtrlHeader_GetItemOrder

Func _GUICtrlHeader_GetItemParam($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_PARAM)
    _GUICtrlHeader_GetItem($hwnd, $iindex, $titem)
    Return DllStructGetData($titem, "Param")
EndFunc    ; -> _GUICtrlHeader_GetItemParam

Func _GUICtrlHeader_GetItemRect($hwnd, $iindex)
    Local $arect[0x4]
    Local $trect = _GUICtrlHeader_GetItemRectEx($hwnd, $iindex)
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlHeader_GetItemRect

Func _GUICtrlHeader_GetItemRectEx($hwnd, $iindex)
    Local $trect = DllStructCreate($TAGRECT)
    __guictrl_sendmsg($hwnd, $HDM_GETITEMRECT, $iindex, $trect, 0x0, True)
    Return $trect
EndFunc    ; -> _GUICtrlHeader_GetItemRectEx

Func _GUICtrlHeader_GetItemText($hwnd, $iindex)
    Local $tbuffer, $imsg
    If _GUICtrlHeader_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_theaderbuffer
        $imsg = $HDM_GETITEMW
    Else
        $tbuffer = $__g_theaderbufferansi
        $imsg = $HDM_GETITEMA
    EndIf
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_TEXT)
    DllStructSetData($titem, "TextMax", DllStructGetSize($tbuffer))
    __guictrl_sendmsg($hwnd, $imsg, $iindex, $titem, $tbuffer, False, 0x3, True, 0x5)
    Return DllStructGetData($tbuffer, "Text")
EndFunc    ; -> _GUICtrlHeader_GetItemText

Func _GUICtrlHeader_GetItemWidth($hwnd, $iindex)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_WIDTH)
    _GUICtrlHeader_GetItem($hwnd, $iindex, $titem)
    Return DllStructGetData($titem, "XY")
EndFunc    ; -> _GUICtrlHeader_GetItemWidth

Func _GUICtrlHeader_GetOrderArray($hwnd)
    Local $iitems = _GUICtrlHeader_GetItemCount($hwnd)
    Local $tbuffer = DllStructCreate("int[" & $iitems & "]")
    __guictrl_sendmsg($hwnd, $HDM_GETORDERARRAY, $iitems, $tbuffer, 0x0, True)
    Local $abuffer[$iitems + 0x1]
    $abuffer[0x0] = $iitems
    For $ii = 0x1 To $iitems
        $abuffer[$ii] = DllStructGetData($tbuffer, 0x1, $ii)
    Next
    Return $abuffer
EndFunc    ; -> _GUICtrlHeader_GetOrderArray

Func _GUICtrlHeader_GetUnicodeFormat($hwnd)
    If Not IsDllStruct($__g_theaderbuffer) Then
        $__g_theaderbuffer = DllStructCreate("wchar Text[4096]")
        $__g_theaderbufferansi = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_theaderbuffer))
    EndIf
    Return _SendMessage($hwnd, $HDM_GETUNICODEFORMAT) <> 0x0
EndFunc    ; -> _GUICtrlHeader_GetUnicodeFormat

Func _GUICtrlHeader_HitTest($hwnd, $ix, $iy)
    Local $ttest = DllStructCreate($TAGHDHITTESTINFO)
    DllStructSetData($ttest, "X", $ix)
    DllStructSetData($ttest, "Y", $iy)
    Local $atest[0xb]
    $atest[0x0] = __guictrl_sendmsg($hwnd, $HDM_HITTEST, 0x0, $ttest, 0x0, True)
    Local $IFLAGS = DllStructGetData($ttest, "Flags")
    $atest[0x1] = BitAND($IFLAGS, $HHT_NOWHERE) <> 0x0
    $atest[0x2] = BitAND($IFLAGS, $HHT_ONHEADER) <> 0x0
    $atest[0x3] = BitAND($IFLAGS, $HHT_ONDIVIDER) <> 0x0
    $atest[0x4] = BitAND($IFLAGS, $HHT_ONDIVOPEN) <> 0x0
    $atest[0x5] = BitAND($IFLAGS, $HHT_ONFILTER) <> 0x0
    $atest[0x6] = BitAND($IFLAGS, $HHT_ONFILTERBUTTON) <> 0x0
    $atest[0x7] = BitAND($IFLAGS, $HHT_ABOVE) <> 0x0
    $atest[0x8] = BitAND($IFLAGS, $HHT_BELOW) <> 0x0
    $atest[0x9] = BitAND($IFLAGS, $HHT_TORIGHT) <> 0x0
    $atest[0xa] = BitAND($IFLAGS, $HHT_TOLEFT) <> 0x0
    Return $atest
EndFunc    ; -> _GUICtrlHeader_HitTest

Func _GUICtrlHeader_InsertItem($hwnd, $iindex, $stext, $iwidth = 0x32, $ialign = 0x0, $iimage = + -1, $bonright = False)
    Local $aalign[0x3] = [$HDF_LEFT, $HDF_RIGHT, $HDF_CENTER]
    Local $tbuffer, $pbuffer, $imsg
    If _GUICtrlHeader_GetUnicodeFormat($hwnd) Then
        $imsg = $HDM_INSERTITEMW
        $tbuffer = $__g_theaderbuffer
    Else
        $tbuffer = $__g_theaderbufferansi
        $imsg = $HDM_INSERTITEMA
    EndIf
    Local $ibuffer
    If $stext <> + -1 Then
        $ibuffer = StringLen($stext) + 0x1
        DllStructSetData($tbuffer, "Text", $stext)
        $pbuffer = DllStructGetPtr($tbuffer)
    Else
        $ibuffer = 0x0
        $tbuffer = 0x0
        $pbuffer = + -1
    EndIf
    Local $ifmt = $aalign[$ialign]
    Local $imask = BitOR($HDI_WIDTH, $HDI_FORMAT)
    If $stext <> '' Then
        $imask = BitOR($imask, $HDI_TEXT)
        $ifmt = BitOR($ifmt, $HDF_STRING)
    EndIf
    If $iimage <> + -1 Then
        $imask = BitOR($imask, $HDI_IMAGE)
        $ifmt = BitOR($ifmt, $HDF_IMAGE)
    EndIf
    If $bonright Then $ifmt = BitOR($ifmt, $HDF_BITMAP_ON_RIGHT)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $imask)
    DllStructSetData($titem, "XY", $iwidth)
    DllStructSetData($titem, "Fmt", $ifmt)
    DllStructSetData($titem, "Image", $iimage)
    DllStructSetData($titem, "Text", $pbuffer)
    DllStructSetData($titem, "TextMax", $ibuffer)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $titem, $tbuffer, False, + -1)
    Return $iret
EndFunc    ; -> _GUICtrlHeader_InsertItem

Func _GUICtrlHeader_Layout($hwnd, ByRef $trect)
    Local $tlayout = DllStructCreate($TAGHDLAYOUT)
    Local $twindowpos = DllStructCreate($TAGWINDOWPOS)
    If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
        DllStructSetData($tlayout, "Rect", DllStructGetPtr($trect))
        DllStructSetData($tlayout, "WindowPos", DllStructGetPtr($twindowpos))
        _SendMessage($hwnd, $HDM_LAYOUT, 0x0, $tlayout, 0x0, "wparam", "struct*")
    Else
        Local $ilayout = DllStructGetSize($tlayout)
        Local $irect = DllStructGetSize($trect)
        Local $iwindowpos = DllStructGetSize($twindowpos)
        Local $tmemmap
        Local $pmemory = _MemInit($hwnd, $ilayout + $irect + $iwindowpos, $tmemmap)
        DllStructSetData($tlayout, "Rect", $pmemory + $ilayout)
        DllStructSetData($tlayout, "WindowPos", $pmemory + $ilayout + $irect)
        _MemWrite($tmemmap, $tlayout, $pmemory, $ilayout)
        _MemWrite($tmemmap, $trect, $pmemory + $ilayout, $irect)
        _SendMessage($hwnd, $HDM_LAYOUT, 0x0, $pmemory, 0x0, "wparam", "ptr")
        _MemRead($tmemmap, $pmemory + $ilayout + $irect, $twindowpos, $iwindowpos)
        _MemFree($tmemmap)
    EndIf
    Return $twindowpos
EndFunc    ; -> _GUICtrlHeader_Layout

Func _GUICtrlHeader_OrderToIndex($hwnd, $iorder)
    Return _SendMessage($hwnd, $HDM_ORDERTOINDEX, $iorder)
EndFunc    ; -> _GUICtrlHeader_OrderToIndex

Func _GUICtrlHeader_SetBitmapMargin($hwnd, $iwidth)
    Return _SendMessage($hwnd, $HDM_SETBITMAPMARGIN, $iwidth)
EndFunc    ; -> _GUICtrlHeader_SetBitmapMargin

Func _GUICtrlHeader_SetFilterChangeTimeout($hwnd, $itimeout)
    Return _SendMessage($hwnd, $HDM_SETFILTERCHANGETIMEOUT, 0x0, $itimeout)
EndFunc    ; -> _GUICtrlHeader_SetFilterChangeTimeout

Func _GUICtrlHeader_SetHotDivider($hwnd, $IFLAG, $iinputvalue)
    Return _SendMessage($hwnd, $HDM_SETHOTDIVIDER, $IFLAG, $iinputvalue)
EndFunc    ; -> _GUICtrlHeader_SetHotDivider

Func _GUICtrlHeader_SetImageList($hwnd, $himage)
    Return _SendMessage($hwnd, $HDM_SETIMAGELIST, 0x0, $himage, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlHeader_SetImageList

Func _GUICtrlHeader_SetItem($hwnd, $iindex, ByRef $titem)
    Local $imsg
    If _GUICtrlHeader_GetUnicodeFormat($hwnd) Then
        $imsg = $HDM_SETITEMW
    Else
        $imsg = $HDM_SETITEMA
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $titem)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlHeader_SetItem

Func _GUICtrlHeader_SetItemAlign($hwnd, $iindex, $ialign)
    Local $aalign[0x3] = [$HDF_LEFT, $HDF_RIGHT, $HDF_CENTER]
    Local $iformat = _GUICtrlHeader_GetItemFormat($hwnd, $iindex)
    $iformat = BitAND($iformat, BitNOT($HDF_JUSTIFYMASK))
    $iformat = BitOR($iformat, $aalign[$ialign])
    Return _GUICtrlHeader_SetItemFormat($hwnd, $iindex, $iformat)
EndFunc    ; -> _GUICtrlHeader_SetItemAlign

Func _GUICtrlHeader_SetItemBitmap($hwnd, $iindex, $hbitmap)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", BitOR($HDI_FORMAT, $HDI_BITMAP))
    DllStructSetData($titem, "Fmt", $HDF_BITMAP)
    DllStructSetData($titem, "hBMP", $hbitmap)
    Return _GUICtrlHeader_SetItem($hwnd, $iindex, $titem)
EndFunc    ; -> _GUICtrlHeader_SetItemBitmap

Func _GUICtrlHeader_SetItemDisplay($hwnd, $iindex, $idisplay)
    Local $iformat = BitAND(_GUICtrlHeader_GetItemFormat($hwnd, $iindex), Not $HDF_DISPLAYMASK)
    If BitAND($idisplay, 0x1) <> 0x0 Then $iformat = BitOR($iformat, $HDF_BITMAP)
    If BitAND($idisplay, 0x2) <> 0x0 Then $iformat = BitOR($iformat, $HDF_BITMAP_ON_RIGHT)
    If BitAND($idisplay, 0x4) <> 0x0 Then $iformat = BitOR($iformat, $HDF_OWNERDRAW)
    If BitAND($idisplay, 0x8) <> 0x0 Then $iformat = BitOR($iformat, $HDF_STRING)
    Return _GUICtrlHeader_SetItemFormat($hwnd, $iindex, $iformat)
EndFunc    ; -> _GUICtrlHeader_SetItemDisplay

Func _GUICtrlHeader_SetItemFlags($hwnd, $iindex, $IFLAGS)
    Local $iformat = _GUICtrlHeader_GetItemFormat($hwnd, $iindex)
    $iformat = BitAND($iformat, BitNOT($HDF_FLAGMASK))
    If BitAND($IFLAGS, 0x1) <> 0x0 Then $iformat = BitOR($iformat, $HDF_IMAGE)
    If BitAND($IFLAGS, 0x2) <> 0x0 Then $iformat = BitOR($iformat, $HDF_RTLREADING)
    If BitAND($IFLAGS, 0x4) <> 0x0 Then $iformat = BitOR($iformat, $HDF_SORTDOWN)
    If BitAND($IFLAGS, 0x8) <> 0x0 Then $iformat = BitOR($iformat, $HDF_SORTUP)
    Return _GUICtrlHeader_SetItemFormat($hwnd, $iindex, $iformat)
EndFunc    ; -> _GUICtrlHeader_SetItemFlags

Func _GUICtrlHeader_SetItemFormat($hwnd, $iindex, $iformat)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_FORMAT)
    DllStructSetData($titem, "Fmt", $iformat)
    Return _GUICtrlHeader_SetItem($hwnd, $iindex, $titem)
EndFunc    ; -> _GUICtrlHeader_SetItemFormat

Func _GUICtrlHeader_SetItemImage($hwnd, $iindex, $iimage)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_IMAGE)
    DllStructSetData($titem, "Image", $iimage)
    Return _GUICtrlHeader_SetItem($hwnd, $iindex, $titem)
EndFunc    ; -> _GUICtrlHeader_SetItemImage

Func _GUICtrlHeader_SetItemOrder($hwnd, $iindex, $iorder)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_ORDER)
    DllStructSetData($titem, "Order", $iorder)
    Return _GUICtrlHeader_SetItem($hwnd, $iindex, $titem)
EndFunc    ; -> _GUICtrlHeader_SetItemOrder

Func _GUICtrlHeader_SetItemParam($hwnd, $iindex, $iparam)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_PARAM)
    DllStructSetData($titem, "Param", $iparam)
    Return _GUICtrlHeader_SetItem($hwnd, $iindex, $titem)
EndFunc    ; -> _GUICtrlHeader_SetItemParam

Func _GUICtrlHeader_SetItemText($hwnd, $iindex, $stext)
    Local $tbuffer, $imsg
    If _GUICtrlHeader_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_theaderbuffer
        $imsg = $HDM_SETITEMW
    Else
        $tbuffer = $__g_theaderbufferansi
        $imsg = $HDM_SETITEMA
    EndIf
    Local $ibuffer, $pbuffer
    If $stext <> + -1 Then
        $ibuffer = StringLen($stext) + 0x1
        DllStructSetData($tbuffer, "Text", $stext)
        $pbuffer = DllStructGetPtr($tbuffer)
    Else
        $ibuffer = 0x0
        $tbuffer = 0x0
        $pbuffer = + -1
    EndIf
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_TEXT)
    DllStructSetData($titem, "Text", $pbuffer)
    DllStructSetData($titem, "TextMax", $ibuffer)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $titem, $tbuffer, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlHeader_SetItemText

Func _GUICtrlHeader_SetItemWidth($hwnd, $iindex, $iwidth)
    Local $titem = DllStructCreate($TAGHDITEM)
    DllStructSetData($titem, "Mask", $HDI_WIDTH)
    DllStructSetData($titem, "XY", $iwidth)
    Return _GUICtrlHeader_SetItem($hwnd, $iindex, $titem)
EndFunc    ; -> _GUICtrlHeader_SetItemWidth

Func _GUICtrlHeader_SetOrderArray($hwnd, ByRef $aorder)
    Local $tbuffer = DllStructCreate("int[" & $aorder[0x0] & "]")
    For $ii = 0x1 To $aorder[0x0]
        DllStructSetData($tbuffer, 0x1, $aorder[$ii], $ii)
    Next
    Local $iret = __guictrl_sendmsg($hwnd, $HDM_SETORDERARRAY, $aorder[0x0], $tbuffer)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlHeader_SetOrderArray

Func _GUICtrlHeader_SetUnicodeFormat($hwnd, $bunicode)
    Return _SendMessage($hwnd, $HDM_SETUNICODEFORMAT, $bunicode)
EndFunc    ; -> _GUICtrlHeader_SetUnicodeFormat

Global Const $ILC_MASK = 0x1
Global Const $ILC_COLOR = 0x0
Global Const $ILC_COLORDDB = 0xfe
Global Const $ILC_COLOR4 = 0x4
Global Const $ILC_COLOR8 = 0x8
Global Const $ILC_COLOR16 = 0x10
Global Const $ILC_COLOR24 = 0x18
Global Const $ILC_COLOR32 = 0x20
Global Const $ILC_PALETTE = 0x800
Global Const $ILC_MIRROR = 0x2000
Global Const $ILC_PERITEMMIRROR = 0x8000
Global Const $ILCF_MOVE = 0x0
Global Const $ILCF_SWAP = 0x1
Global Const $ILD_NORMAL = 0x0
Global Const $ILD_TRANSPARENT = 0x1
Global Const $ILD_BLEND25 = 0x2
Global Const $ILD_BLEND50 = 0x4
Global Const $ILD_MASK = 0x10
Global Const $ILD_IMAGE = 0x20
Global Const $ILD_ROP = 0x40
Global Const $ILD_OVERLAYMASK = 0xf00
Global Const $ILS_NORMAL = 0x0
Global Const $ILS_GLOW = 0x1
Global Const $ILS_SHADOW = 0x2
Global Const $ILS_SATURATE = 0x4
Global Const $ILS_ALPHA = 0x8
Global Const $__IMAGELISTCONSTANT_IMAGE_BITMAP = 0x0
Func _GUIImageList_Add($hwnd, $himage, $hmask = 0x0)
    Local $acall = DllCall("comctl32.dll", "int", "ImageList_Add", "handle", $hwnd, "handle", $himage, "handle", $hmask)
    If @error Then Return SetError(@error, @extended, + -1)
    Return $acall[0x0]
EndFunc    ; -> _GUIImageList_Add

Func _GUIImageList_AddMasked($hwnd, $himage, $imask = 0x0)
    Local $acall = DllCall("comctl32.dll", "int", "ImageList_AddMasked", "handle", $hwnd, "handle", $himage, "dword", $imask)
    If @error Then Return SetError(@error, @extended, + -1)
    Return $acall[0x0]
EndFunc    ; -> _GUIImageList_AddMasked

Func _GUIImageList_AddBitmap($hwnd, $simage, $smask = '')
    Local $asize = _GUIImageList_GetIconSize($hwnd)
    Local $himage = _WinAPI_LoadImage(0x0, $simage, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $asize[0x0], $asize[0x1], $LR_LOADFROMFILE)
    If $himage = 0x0 Then Return SetError(_WinAPI_GetLastError(), 0x1, + -1)
    Local $hmask = 0x0
    If $smask <> '' Then
        $hmask = _WinAPI_LoadImage(0x0, $smask, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $asize[0x0], $asize[0x1], $LR_LOADFROMFILE)
        If $hmask = 0x0 Then Return SetError(_WinAPI_GetLastError(), 0x2, + -1)
    EndIf
    Local $iret = _GUIImageList_Add($hwnd, $himage, $hmask)
    _WinAPI_DeleteObject($himage)
    If $hmask <> 0x0 Then _WinAPI_DeleteObject($hmask)
    Return $iret
EndFunc    ; -> _GUIImageList_AddBitmap

Func _GUIImageList_AddIcon($hwnd, $sfilepath, $iindex = 0x0, $blarge = False)
    Local $iret, $ticon = DllStructCreate("handle Handle")
    If $blarge Then
        $iret = _WinAPI_ExtractIconEx($sfilepath, $iindex, $ticon, 0x0, 0x1)
    Else
        $iret = _WinAPI_ExtractIconEx($sfilepath, $iindex, 0x0, $ticon, 0x1)
    EndIf
    If $iret <= 0x0 Then Return SetError(+ -1, $iret, + -1)
    Local $hicon = DllStructGetData($ticon, "Handle")
    $iret = _GUIImageList_ReplaceIcon($hwnd, + -1, $hicon)
    _WinAPI_DestroyIcon($hicon)
    If $iret = + -1 Then Return SetError(+ -2, $iret, + -1)
    Return $iret
EndFunc    ; -> _GUIImageList_AddIcon

Func _GUIImageList_BeginDrag($hwnd, $itrack, $ixhotspot, $iyhotspot)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_BeginDrag", "handle", $hwnd, "int", $itrack, "int", $ixhotspot, "int", $iyhotspot)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_BeginDrag

Func _GUIImageList_Copy($hwnd, $isource, $idestination)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_Copy", "handle", $hwnd, "int", $idestination, "handle", $hwnd, "int", $isource, "uint", $ILCF_MOVE)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_Copy

Func _GUIImageList_Create($icx = 0x10, $icy = 0x10, $icolor = 0x4, $ioptions = 0x0, $iinitial = 0x4, $igrow = 0x4)
    Local Const $acolor[0x7] = [$ILC_COLOR, $ILC_COLOR4, $ILC_COLOR8, $ILC_COLOR16, $ILC_COLOR24, $ILC_COLOR32, $ILC_COLORDDB]
    Local $IFLAGS = 0x0
    If BitAND($ioptions, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILC_MASK)
    If BitAND($ioptions, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILC_MIRROR)
    If BitAND($ioptions, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILC_PERITEMMIRROR)
    $IFLAGS = BitOR($IFLAGS, $acolor[$icolor])
    Local $acall = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", $icx, "int", $icy, "uint", $IFLAGS, "int", $iinitial, "int", $igrow)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUIImageList_Create

Func _GUIImageList_Destroy($hwnd)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_Destroy

Func _GUIImageList_DestroyIcon($hicon)
    Return _WinAPI_DestroyIcon($hicon)
EndFunc    ; -> _GUIImageList_DestroyIcon

Func _GUIImageList_DragEnter($hwnd, $ix, $iy)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_DragEnter", "hwnd", $hwnd, "int", $ix, "int", $iy)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_DragEnter

Func _GUIImageList_DragLeave($hwnd)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_DragLeave", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_DragLeave

Func _GUIImageList_DragMove($ix, $iy)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_DragMove", "int", $ix, "int", $iy)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_DragMove

Func _GUIImageList_DragShowNolock($bshow)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_DragShowNolock", "bool", $bshow)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_DragShowNolock

Func _GUIImageList_Draw($hwnd, $iindex, $hdc, $ix, $iy, $istyle = 0x0)
    Local $IFLAGS = 0x0
    If BitAND($istyle, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_TRANSPARENT)
    If BitAND($istyle, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_BLEND25)
    If BitAND($istyle, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_BLEND50)
    If BitAND($istyle, 0x8) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_MASK)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_Draw", "handle", $hwnd, "int", $iindex, "handle", $hdc, "int", $ix, "int", $iy, "uint", $IFLAGS)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_Draw

Func _GUIImageList_DrawEx($hwnd, $iindex, $hdc, $ix, $iy, $idx = 0x0, $idy = 0x0, $irgbbk = -1, $irgbfg = -1, $istyle = 0x0)
    If $idx = + -1 Then $idx = 0x0
    If $idy = + -1 Then $idy = 0x0
    If $irgbbk = + -1 Then $irgbbk = -1
    If $irgbfg = + -1 Then $irgbfg = -1
    Local $IFLAGS = 0x0
    If BitAND($istyle, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_TRANSPARENT)
    If BitAND($istyle, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_BLEND25)
    If BitAND($istyle, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_BLEND50)
    If BitAND($istyle, 0x8) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_MASK)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_DrawEx", "handle", $hwnd, "int", $iindex, "handle", $hdc, "int", $ix, "int", $iy, "int", $idx, "int", $idy, "dword", $irgbbk, "dword", $irgbfg, "uint", $IFLAGS)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_DrawEx

Func _GUIImageList_Duplicate($hwnd)
    Local $acall = DllCall("comctl32.dll", "handle", "ImageList_Duplicate", "handle", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUIImageList_Duplicate

Func _GUIImageList_EndDrag()
    DllCall("comctl32.dll", "none", "ImageList_EndDrag")
    If @error Then Return SetError(@error, @extended)
EndFunc    ; -> _GUIImageList_EndDrag

Func _GUIImageList_GetBkColor($hwnd)
    Local $acall = DllCall("comctl32.dll", "dword", "ImageList_GetBkColor", "handle", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUIImageList_GetBkColor

Func _GUIImageList_GetIcon($hwnd, $iindex, $istyle = 0x0)
    Local $IFLAGS = 0x0
    If BitAND($istyle, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_TRANSPARENT)
    If BitAND($istyle, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_BLEND25)
    If BitAND($istyle, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_BLEND50)
    If BitAND($istyle, 0x8) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $ILD_MASK)
    Local $acall = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $hwnd, "int", $iindex, "uint", $IFLAGS)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUIImageList_GetIcon

Func _GUIImageList_GetIconHeight($hwnd)
    Local $asize = _GUIImageList_GetIconSize($hwnd)
    Return $asize[0x1]
EndFunc    ; -> _GUIImageList_GetIconHeight

Func _GUIImageList_GetIconSize($hwnd)
    Local $asize[0x2]
    Local $tpoint = _GUIImageList_GetIconSizeEx($hwnd)
    $asize[0x0] = DllStructGetData($tpoint, "X")
    $asize[0x1] = DllStructGetData($tpoint, "Y")
    Return $asize
EndFunc    ; -> _GUIImageList_GetIconSize

Func _GUIImageList_GetIconSizeEx($hwnd)
    Local $tpoint = DllStructCreate($TAGPOINT)
    Local $ppointx = DllStructGetPtr($tpoint, "X")
    Local $ppointy = DllStructGetPtr($tpoint, "Y")
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_GetIconSize", "hwnd", $hwnd, "struct*", $ppointx, "struct*", $ppointy)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $tpoint)
EndFunc    ; -> _GUIImageList_GetIconSizeEx

Func _GUIImageList_GetIconWidth($hwnd)
    Local $asize = _GUIImageList_GetIconSize($hwnd)
    Return $asize[0x0]
EndFunc    ; -> _GUIImageList_GetIconWidth

Func _GUIImageList_GetImageCount($hwnd)
    Local $acall = DllCall("comctl32.dll", "int", "ImageList_GetImageCount", "handle", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUIImageList_GetImageCount

Func _GUIImageList_GetImageInfoEx($hwnd, $iindex)
    Local $timage = DllStructCreate($TAGIMAGEINFO)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_GetImageInfo", "handle", $hwnd, "int", $iindex, "struct*", $timage)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $timage)
EndFunc    ; -> _GUIImageList_GetImageInfoEx

Func _GUIImageList_Merge($hwnd1, $iindex1, $hwnd2, $iindex2, $idx, $idy)
    Local $acall = DllCall("comctl32.dll", "handle", "ImageList_Merge", "handle", $hwnd1, "int", $iindex1, "handle", $hwnd2, "int", $iindex2, "int", $idx, "int", $idy)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUIImageList_Merge

Func _GUIImageList_Remove($hwnd, $iindex = + -1)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_Remove", "handle", $hwnd, "int", $iindex)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_Remove

Func _GUIImageList_Replace($hwnd, $iindex, $himage, $hmask = 0x0)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_Replace", "handle", $hwnd, "int", $iindex, "handle", $himage, "handle", $hmask)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_Replace

Func _GUIImageList_ReplaceIcon($hwnd, $iindex, $hicon)
    Local $acall = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hwnd, "int", $iindex, "handle", $hicon)
    If @error Then Return SetError(@error, @extended, + -1)
    Return $acall[0x0]
EndFunc    ; -> _GUIImageList_ReplaceIcon

Func _GUIImageList_SetBkColor($hwnd, $iclrbk)
    Local $acall = DllCall("comctl32.dll", "dword", "ImageList_SetBkColor", "handle", $hwnd, "dword", $iclrbk)
    If @error Then Return SetError(@error, @extended, $CLR_NONE)
    Return $acall[0x0]
EndFunc    ; -> _GUIImageList_SetBkColor

Func _GUIImageList_SetDragCursorImage($hwnd, $idrag, $idxhotspot, $idyhotspot)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_SetDragCursorImage", "handle", $hwnd, "int", $idrag, "int", $idxhotspot, "int", $idyhotspot)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_SetDragCursorImage

Func _GUIImageList_SetIconSize($hwnd, $icx, $icy)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_SetIconSize", "handle", $hwnd, "int", $icx, "int", $icy)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_SetIconSize

Func _GUIImageList_SetImageCount($hwnd, $inewcount)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_SetImageCount", "handle", $hwnd, "uint", $inewcount)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_SetImageCount

Func _GUIImageList_SetOverlayImage($hwnd, $iimage, $ioverlay)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $hwnd, "int", $iimage, "int", $ioverlay)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_SetOverlayImage

Func _GUIImageList_Swap($hwnd, $isource, $idestination)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_Copy", "handle", $hwnd, "int", $idestination, "handle", $hwnd, "int", $isource, "uint", $ILCF_SWAP)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _GUIImageList_Swap

Global Const $__IPADDRESSCONSTANT_WM_USER = 0x400
Global Const $IPM_CLEARADDRESS = ($__IPADDRESSCONSTANT_WM_USER + 0x64)
Global Const $IPM_SETADDRESS = ($__IPADDRESSCONSTANT_WM_USER + 0x65)
Global Const $IPM_GETADDRESS = ($__IPADDRESSCONSTANT_WM_USER + 0x66)
Global Const $IPM_SETRANGE = ($__IPADDRESSCONSTANT_WM_USER + 0x67)
Global Const $IPM_SETFOCUS = ($__IPADDRESSCONSTANT_WM_USER + 0x68)
Global Const $IPM_ISBLANK = ($__IPADDRESSCONSTANT_WM_USER + 0x69)
Global Const $IPN_FIRST = (+ -860)
Global Const $IPN_FIELDCHANGED = ($IPN_FIRST + 0x0)
Global Const $__IPADDRESSCONSTANT_CLASSNAME = "SysIPAddress32"
Global Const $__IPADDRESSCONSTANT_DEFAULT_GUI_FONT = 0x11
Global Const $__IPADDRESSCONSTANT_LOGPIXELSX = 0x58
Global Const $__IPADDRESSCONSTANT_PROOF_QUALITY = 0x2
Func _GUICtrlIpAddress_Create($hwnd, $ix, $iy, $iwidth = 0x7d, $iheight = 0x19, $istyles = 0x0, $iexstyles = 0x0)
    If Not IsHWnd($hwnd) Then Return SetError(0x1, 0x0, 0x0)
    If $istyles = + -1 Then $istyles = 0x0
    If $iexstyles = + -1 Then $iexstyles = 0x0
    Local $istyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_TABSTOP, $istyles)
    Local Const $ICC_INTERNET_CLASSES = 0x800
    Local $ticce = DllStructCreate("dword dwSize;dword dwICC")
    DllStructSetData($ticce, "dwSize", DllStructGetSize($ticce))
    DllStructSetData($ticce, "dwICC", $ICC_INTERNET_CLASSES)
    DllCall("comctl32.dll", "bool", "InitCommonControlsEx", "struct*", $ticce)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hipaddress = _WinAPI_CreateWindowEx($iexstyles, $__IPADDRESSCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    _WinAPI_SetFont($hipaddress, _WinAPI_GetStockObject($__IPADDRESSCONSTANT_DEFAULT_GUI_FONT))
    Return $hipaddress
EndFunc    ; -> _GUICtrlIpAddress_Create

Func _GUICtrlIpAddress_ClearAddress($hwnd)
    _SendMessage($hwnd, $IPM_CLEARADDRESS)
EndFunc    ; -> _GUICtrlIpAddress_ClearAddress

Func _GUICtrlIpAddress_Destroy($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__IPADDRESSCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
        Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
        Local $hparent = _WinAPI_GetParent($hwnd)
        $idestroyed = _WinAPI_DestroyWindow($hwnd)
        Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
        If Not $iret Then
        EndIf
    Else
        Return SetError(0x1, 0x1, False)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlIpAddress_Destroy

Func _GUICtrlIpAddress_Get($hwnd)
    Local $tip = _GUICtrlIpAddress_GetEx($hwnd)
    If @error Then Return SetError(0x2, 0x2, '')
    Return StringFormat("%d.%d.%d.%d", DllStructGetData($tip, "Field1"), DllStructGetData($tip, "Field2"), DllStructGetData($tip, "Field3"), DllStructGetData($tip, "Field4"))
EndFunc    ; -> _GUICtrlIpAddress_Get

Func _GUICtrlIpAddress_GetArray($hwnd)
    Local $tip = _GUICtrlIpAddress_GetEx($hwnd)
    Local $aip[0x4]
    $aip[0x0] = DllStructGetData($tip, "Field1")
    $aip[0x1] = DllStructGetData($tip, "Field2")
    $aip[0x2] = DllStructGetData($tip, "Field3")
    $aip[0x3] = DllStructGetData($tip, "Field4")
    Return $aip
EndFunc    ; -> _GUICtrlIpAddress_GetArray

Func _GUICtrlIpAddress_GetEx($hwnd)
    Local $tip = DllStructCreate($TAGGETIPADDRESS)
    __guictrl_sendmsg($hwnd, $IPM_GETADDRESS, 0x0, $tip, 0x0, True)
    Return $tip
EndFunc    ; -> _GUICtrlIpAddress_GetEx

Func _GUICtrlIpAddress_IsBlank($hwnd)
    Return _SendMessage($hwnd, $IPM_ISBLANK) <> 0x0
EndFunc    ; -> _GUICtrlIpAddress_IsBlank

Func _GUICtrlIpAddress_Set($hwnd, $saddress)
    Local $aaddress = StringSplit($saddress, ".")
    If $aaddress[0x0] = 0x4 Then
        Local $tip = DllStructCreate($TAGGETIPADDRESS)
        For $x = 0x1 To 0x4
            DllStructSetData($tip, "Field" & $x, $aaddress[$x])
        Next
        _GUICtrlIpAddress_SetEx($hwnd, $tip)
    EndIf
EndFunc    ; -> _GUICtrlIpAddress_Set

Func _GUICtrlIpAddress_SetArray($hwnd, $aaddress)
    If UBound($aaddress) = 0x4 Then
        Local $tip = DllStructCreate($TAGGETIPADDRESS)
        For $x = 0x0 To 0x3
            DllStructSetData($tip, "Field" & $x + 0x1, $aaddress[$x])
        Next
        _GUICtrlIpAddress_SetEx($hwnd, $tip)
    EndIf
EndFunc    ; -> _GUICtrlIpAddress_SetArray

Func _GUICtrlIpAddress_SetEx($hwnd, $tip)
    _SendMessage($hwnd, $IPM_SETADDRESS, 0x0, _WinAPI_MakeLong(BitOR(DllStructGetData($tip, "Field4"), 0x100 * DllStructGetData($tip, "Field3")), BitOR(DllStructGetData($tip, "Field2"), 0x100 * DllStructGetData($tip, "Field1"))))
EndFunc    ; -> _GUICtrlIpAddress_SetEx

Func _GUICtrlIpAddress_SetFocus($hwnd, $iindex)
    _SendMessage($hwnd, $IPM_SETFOCUS, $iindex)
EndFunc    ; -> _GUICtrlIpAddress_SetFocus

Func _GUICtrlIpAddress_SetFont($hwnd, $sfacename = "Arial", $ifontsize = 0xc, $ifontweight = 0x190, $bfontitalic = False)
    Local $hdc = _WinAPI_GetDC(0x0)
    Local $iheight = Round(($ifontsize * _WinAPI_GetDeviceCaps($hdc, $__IPADDRESSCONSTANT_LOGPIXELSX)) / 0x48, 0x0)
    _WinAPI_ReleaseDC(0x0, $hdc)
    Local $tfont = DllStructCreate($TAGLOGFONT)
    DllStructSetData($tfont, "Height", $iheight)
    DllStructSetData($tfont, "Weight", $ifontweight)
    DllStructSetData($tfont, "Italic", $bfontitalic)
    DllStructSetData($tfont, "Underline", False)
    DllStructSetData($tfont, "Strikeout", False)
    DllStructSetData($tfont, "Quality", $__IPADDRESSCONSTANT_PROOF_QUALITY)
    DllStructSetData($tfont, "FaceName", $sfacename)
    Local $hfont = _WinAPI_CreateFontIndirect($tfont)
    _WinAPI_SetFont($hwnd, $hfont)
EndFunc    ; -> _GUICtrlIpAddress_SetFont

Func _GUICtrlIpAddress_SetRange($hwnd, $iindex, $ilowrange = 0x0, $ihighrange = 0xff)
    If ($ilowrange < 0x0 Or $ilowrange > $ihighrange) Or $ihighrange > 0xff Or ($iindex < 0x0 Or $iindex > 0x3) Then Return SetError(+ -1, + -1, False)
    Return _SendMessage($hwnd, $IPM_SETRANGE, $iindex, BitOR($ilowrange, 0x100 * $ihighrange)) <> 0x0
EndFunc    ; -> _GUICtrlIpAddress_SetRange

Func _GUICtrlIpAddress_ShowHide($hwnd, $istate)
    If $istate <> @SW_HIDE And $istate <> @SW_SHOW Then Return SetError(0x1, 0x1, 0x0)
    Return _WinAPI_ShowWindow($hwnd, $istate) <> 0x0
EndFunc    ; -> _GUICtrlIpAddress_ShowHide

Global $__g_hlblastwnd
Global Const $__LISTBOXCONSTANT_CLASSNAME = "ListBox"
Global Const $__LISTBOXCONSTANT_CLASSNAMES = $__LISTBOXCONSTANT_CLASSNAME & "|TListbox"
Global Const $__LISTBOXCONSTANT_DEFAULT_GUI_FONT = 0x11
Global Const $__LISTBOXCONSTANT_WM_SETREDRAW = 0xb
Global Const $__LISTBOXCONSTANT_WM_GETFONT = 0x31
Func _GUICtrlListBox_AddFile($hwnd, $sfilepath)
    If Not IsString($sfilepath) Then $sfilepath = String($sfilepath)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_ADDFILE, 0x0, $sfilepath, 0x0, "wparam", "wstr")
    Else
        Return GUICtrlSendMsg($hwnd, $LB_ADDFILE, 0x0, $sfilepath)
    EndIf
EndFunc    ; -> _GUICtrlListBox_AddFile

Func _GUICtrlListBox_AddString($hwnd, $stext)
    If Not IsString($stext) Then $stext = String($stext)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_ADDSTRING, 0x0, $stext, 0x0, "wparam", "wstr")
    Else
        Return GUICtrlSendMsg($hwnd, $LB_ADDSTRING, 0x0, $stext)
    EndIf
EndFunc    ; -> _GUICtrlListBox_AddString

Func _GUICtrlListBox_BeginUpdate($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $__LISTBOXCONSTANT_WM_SETREDRAW, False) = 0x0
EndFunc    ; -> _GUICtrlListBox_BeginUpdate

Func _GUICtrlListBox_ClickItem($hwnd, $iindex, $sbutton = "left", $bmove = False, $iclicks = 0x1, $ispeed = 0x0)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $trect = _GUICtrlListBox_GetItemRectEx($hwnd, $iindex)
    Local $tpoint = _WinAPI_PointFromRect($trect)
    $tpoint = _WinAPI_ClientToScreen($hwnd, $tpoint)
    Local $ix, $iy
    _WinAPI_GetXYFromPoint($tpoint, $ix, $iy)
    Local $imode = Opt("MouseCoordMode", 0x1)
    If Not $bmove Then
        Local $apos = MouseGetPos()
        _WinAPI_ShowCursor(False)
        MouseClick($sbutton, $ix, $iy, $iclicks, $ispeed)
        MouseMove($apos[0x0], $apos[0x1], 0x0)
        _WinAPI_ShowCursor(True)
    Else
        MouseClick($sbutton, $ix, $iy, $iclicks, $ispeed)
    EndIf
    Opt("MouseCoordMode", $imode)
EndFunc    ; -> _GUICtrlListBox_ClickItem

Func _GUICtrlListBox_Create($hwnd, $stext, $ix, $iy, $iwidth = 0x64, $iheight = 0xc8, $istyle = 0xb00002, $iexstyle = 0x200)
    If Not IsHWnd($hwnd) Then
        Return SetError(0x1, 0x0, 0x0)
    EndIf
    If Not IsString($stext) Then
        Return SetError(0x2, 0x0, 0x0)
    EndIf
    If $iwidth = + -1 Then $iwidth = 0x64
    If $iheight = + -1 Then $iheight = 0xc8
    Local Const $WS_VSCROLL = 0x200000, $WS_HSCROLL = 0x100000, $WS_BORDER = 0x800000
    If $istyle = + -1 Then $istyle = BitOR($WS_BORDER, $WS_VSCROLL, $WS_HSCROLL, $LBS_SORT)
    If $iexstyle = + -1 Then $iexstyle = 0x200
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_CHILD, $LBS_NOTIFY)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hlist = _WinAPI_CreateWindowEx($iexstyle, $__LISTBOXCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    _WinAPI_SetFont($hlist, _WinAPI_GetStockObject($__LISTBOXCONSTANT_DEFAULT_GUI_FONT))
    If StringLen($stext) Then _GUICtrlListBox_AddString($hlist, $stext)
    Return $hlist
EndFunc    ; -> _GUICtrlListBox_Create

Func _GUICtrlListBox_DeleteString($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_DELETESTRING, $iindex)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_DELETESTRING, $iindex, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_DeleteString

Func _GUICtrlListBox_Destroy(ByRef $hwnd)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hlblastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlListBox_Destroy

Func _GUICtrlListBox_Dir($hwnd, $sfilepath, $iattributes = 0x0, $bbrackets = True)
    If Not IsString($sfilepath) Then $sfilepath = String($sfilepath)
    If BitAND($iattributes, $DDL_DRIVES) = $DDL_DRIVES And Not $bbrackets Then
        Local $stext
        Local $hgui_no_brackets = GUICreate("no brackets")
        Local $idlist_no_brackets = GUICtrlCreateList('', 0xf0, 0x28, 0x78, 0x78)
        Local $iret = GUICtrlSendMsg($idlist_no_brackets, $LB_DIR, $iattributes, $sfilepath)
        For $i = 0x0 To _GUICtrlListBox_GetCount($idlist_no_brackets) + -1
            $stext = _GUICtrlListBox_GetText($idlist_no_brackets, $i)
            $stext = StringReplace(StringReplace(StringReplace($stext, "[", ''), "]", ":"), "-", '')
            _GUICtrlListBox_InsertString($hwnd, $stext)
        Next
        GUIDelete($hgui_no_brackets)
        Return $iret
    Else
        If IsHWnd($hwnd) Then
            Return _SendMessage($hwnd, $LB_DIR, $iattributes, $sfilepath, 0x0, "wparam", "wstr")
        Else
            Return GUICtrlSendMsg($hwnd, $LB_DIR, $iattributes, $sfilepath)
        EndIf
    EndIf
EndFunc    ; -> _GUICtrlListBox_Dir

Func _GUICtrlListBox_EndUpdate($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $__LISTBOXCONSTANT_WM_SETREDRAW, True) = 0x0
EndFunc    ; -> _GUICtrlListBox_EndUpdate

Func _GUICtrlListBox_FindString($hwnd, $stext, $bexact = False)
    If Not IsString($stext) Then $stext = String($stext)
    If IsHWnd($hwnd) Then
        If ($bexact) Then
            Return _SendMessage($hwnd, $LB_FINDSTRINGEXACT, + -1, $stext, 0x0, "wparam", "wstr")
        Else
            Return _SendMessage($hwnd, $LB_FINDSTRING, + -1, $stext, 0x0, "wparam", "wstr")
        EndIf
    Else
        If ($bexact) Then
            Return GUICtrlSendMsg($hwnd, $LB_FINDSTRINGEXACT, + -1, $stext)
        Else
            Return GUICtrlSendMsg($hwnd, $LB_FINDSTRING, + -1, $stext)
        EndIf
    EndIf
EndFunc    ; -> _GUICtrlListBox_FindString

Func _GUICtrlListBox_FindInText($hwnd, $stext, $istart = + -1, $bwrapok = True)
    Local $slist
    Local $icount = _GUICtrlListBox_GetCount($hwnd)
    For $ii = $istart + 0x1 To $icount + -1
        $slist = _GUICtrlListBox_GetText($hwnd, $ii)
        If StringInStr($slist, $stext) Then Return $ii
    Next
    If ($istart = + -1) Or Not $bwrapok Then Return + -1
    For $ii = 0x0 To $istart + -1
        $slist = _GUICtrlListBox_GetText($hwnd, $ii)
        If StringInStr($slist, $stext) Then Return $ii
    Next
    Return + -1
EndFunc    ; -> _GUICtrlListBox_FindInText

Func _GUICtrlListBox_GetAnchorIndex($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETANCHORINDEX)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETANCHORINDEX, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetAnchorIndex

Func _GUICtrlListBox_GetCaretIndex($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETCARETINDEX)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETCARETINDEX, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetCaretIndex

Func _GUICtrlListBox_GetCount($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETCOUNT)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETCOUNT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetCount

Func _GUICtrlListBox_GetCurSel($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETCURSEL)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETCURSEL, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetCurSel

Func _GUICtrlListBox_GetHorizontalExtent($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETHORIZONTALEXTENT)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETHORIZONTALEXTENT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetHorizontalExtent

Func _GUICtrlListBox_GetItemData($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETITEMDATA, $iindex)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETITEMDATA, $iindex, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetItemData

Func _GUICtrlListBox_GetItemHeight($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETITEMHEIGHT)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETITEMHEIGHT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetItemHeight

Func _GUICtrlListBox_GetItemRect($hwnd, $iindex)
    Local $arect[0x4]
    Local $trect = _GUICtrlListBox_GetItemRectEx($hwnd, $iindex)
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlListBox_GetItemRect

Func _GUICtrlListBox_GetItemRectEx($hwnd, $iindex)
    Local $trect = DllStructCreate($TAGRECT)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $LB_GETITEMRECT, $iindex, $trect, 0x0, "wparam", "struct*")
    Else
        GUICtrlSendMsg($hwnd, $LB_GETITEMRECT, $iindex, DllStructGetPtr($trect))
    EndIf
    Return $trect
EndFunc    ; -> _GUICtrlListBox_GetItemRectEx

Func _GUICtrlListBox_GetListBoxInfo($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETLISTBOXINFO)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETLISTBOXINFO, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetListBoxInfo

Func _GUICtrlListBox_GetLocale($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETLOCALE)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETLOCALE, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetLocale

Func _GUICtrlListBox_GetLocaleCountry($hwnd)
    Return _WinAPI_HiWord(_GUICtrlListBox_GetLocale($hwnd))
EndFunc    ; -> _GUICtrlListBox_GetLocaleCountry

Func _GUICtrlListBox_GetLocaleLang($hwnd)
    Return _WinAPI_LoWord(_GUICtrlListBox_GetLocale($hwnd))
EndFunc    ; -> _GUICtrlListBox_GetLocaleLang

Func _GUICtrlListBox_GetLocalePrimLang($hwnd)
    Return _WinAPI_PrimaryLangId(_GUICtrlListBox_GetLocaleLang($hwnd))
EndFunc    ; -> _GUICtrlListBox_GetLocalePrimLang

Func _GUICtrlListBox_GetLocaleSubLang($hwnd)
    Return _WinAPI_SubLangId(_GUICtrlListBox_GetLocaleLang($hwnd))
EndFunc    ; -> _GUICtrlListBox_GetLocaleSubLang

Func _GUICtrlListBox_GetSel($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETSEL, $iindex) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETSEL, $iindex, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetSel

Func _GUICtrlListBox_GetSelCount($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETSELCOUNT)
    EndIf
    If IsHWnd(GUICtrlGetHandle($hwnd)) Then
        Return GUICtrlSendMsg($hwnd, $LB_GETSELCOUNT, 0x0, 0x0)
    EndIf
    Return + -1
EndFunc    ; -> _GUICtrlListBox_GetSelCount

Func _GUICtrlListBox_GetSelItems($hwnd)
    Local $AARRAY[0x1] = [0x0]
    Local $icount = _GUICtrlListBox_GetSelCount($hwnd)
    If $icount > 0x0 Then
        ReDim $AARRAY[$icount + 0x1]
        Local $tarray = DllStructCreate("int[" & $icount & "]")
        If IsHWnd($hwnd) Then
            _SendMessage($hwnd, $LB_GETSELITEMS, $icount, $tarray, 0x0, "wparam", "struct*")
        Else
            GUICtrlSendMsg($hwnd, $LB_GETSELITEMS, $icount, DllStructGetPtr($tarray))
        EndIf
        $AARRAY[0x0] = $icount
        For $ii = 0x1 To $icount
            $AARRAY[$ii] = DllStructGetData($tarray, 0x1, $ii)
        Next
    EndIf
    Return $AARRAY
EndFunc    ; -> _GUICtrlListBox_GetSelItems

Func _GUICtrlListBox_GetSelItemsText($hwnd)
    Local $atext[0x1] = [0x0], $icount = _GUICtrlListBox_GetSelCount($hwnd)
    If $icount > 0x0 Then
        Local $aindices = _GUICtrlListBox_GetSelItems($hwnd)
        ReDim $atext[UBound($aindices)]
        $atext[0x0] = $aindices[0x0]
        For $i = 0x1 To $aindices[0x0]
            $atext[$i] = _GUICtrlListBox_GetText($hwnd, $aindices[$i])
        Next
    EndIf
    Return $atext
EndFunc    ; -> _GUICtrlListBox_GetSelItemsText

Func _GUICtrlListBox_GetText($hwnd, $iindex)
    Local $ttext = DllStructCreate("wchar Text[" & _GUICtrlListBox_GetTextLen($hwnd, $iindex) + 0x1 & "]")
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $LB_GETTEXT, $iindex, $ttext, 0x0, "wparam", "struct*")
    Return DllStructGetData($ttext, "Text")
EndFunc    ; -> _GUICtrlListBox_GetText

Func _GUICtrlListBox_GetTextLen($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETTEXTLEN, $iindex)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETTEXTLEN, $iindex, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetTextLen

Func _GUICtrlListBox_GetTopIndex($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_GETTOPINDEX)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_GETTOPINDEX, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_GetTopIndex

Func _GUICtrlListBox_InitStorage($hwnd, $iitems, $ibytes)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_INITSTORAGE, $iitems, $ibytes)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_INITSTORAGE, $iitems, $ibytes)
    EndIf
EndFunc    ; -> _GUICtrlListBox_InitStorage

Func _GUICtrlListBox_InsertString($hwnd, $stext, $iindex = + -1)
    If Not IsString($stext) Then $stext = String($stext)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_INSERTSTRING, $iindex, $stext, 0x0, "wparam", "wstr")
    Else
        Return GUICtrlSendMsg($hwnd, $LB_INSERTSTRING, $iindex, $stext)
    EndIf
EndFunc    ; -> _GUICtrlListBox_InsertString

Func _GUICtrlListBox_ItemFromPoint($hwnd, $ix, $iy)
    Local $iret
    If IsHWnd($hwnd) Then
        $iret = _SendMessage($hwnd, $LB_ITEMFROMPOINT, 0x0, _WinAPI_MakeLong($ix, $iy))
    Else
        $iret = GUICtrlSendMsg($hwnd, $LB_ITEMFROMPOINT, 0x0, _WinAPI_MakeLong($ix, $iy))
    EndIf
    If _WinAPI_HiWord($iret) <> 0x0 Then $iret = + -1
    Return $iret
EndFunc    ; -> _GUICtrlListBox_ItemFromPoint

Func _GUICtrlListBox_ReplaceString($hwnd, $iindex, $stext)
    If (_GUICtrlListBox_DeleteString($hwnd, $iindex) == $LB_ERR) Then Return SetError($LB_ERR, $LB_ERR, False)
    If (_GUICtrlListBox_InsertString($hwnd, $stext, $iindex) == $LB_ERR) Then Return SetError($LB_ERR, $LB_ERR, False)
    Return True
EndFunc    ; -> _GUICtrlListBox_ReplaceString

Func _GUICtrlListBox_ResetContent($hwnd)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $LB_RESETCONTENT)
    Else
        GUICtrlSendMsg($hwnd, $LB_RESETCONTENT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_ResetContent

Func _GUICtrlListBox_SelectString($hwnd, $stext, $iindex = + -1)
    If Not IsString($stext) Then $stext = String($stext)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_SELECTSTRING, $iindex, $stext, 0x0, "wparam", "wstr")
    Else
        Return GUICtrlSendMsg($hwnd, $LB_SELECTSTRING, $iindex, $stext)
    EndIf
EndFunc    ; -> _GUICtrlListBox_SelectString

Func _GUICtrlListBox_SelItemRange($hwnd, $ifirst, $ilast, $bselect = True)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_SELITEMRANGE, $bselect, _WinAPI_MakeLong($ifirst, $ilast)) = 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LB_SELITEMRANGE, $bselect, _WinAPI_MakeLong($ifirst, $ilast)) = 0x0
    EndIf
EndFunc    ; -> _GUICtrlListBox_SelItemRange

Func _GUICtrlListBox_SelItemRangeEx($hwnd, $ifirst, $ilast)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_SELITEMRANGEEX, $ifirst, $ilast) = 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LB_SELITEMRANGEEX, $ifirst, $ilast) = 0x0
    EndIf
EndFunc    ; -> _GUICtrlListBox_SelItemRangeEx

Func _GUICtrlListBox_SetAnchorIndex($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_SETANCHORINDEX, $iindex) = 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LB_SETANCHORINDEX, $iindex, 0x0) = 0x0
    EndIf
EndFunc    ; -> _GUICtrlListBox_SetAnchorIndex

Func _GUICtrlListBox_SetCaretIndex($hwnd, $iindex, $bpartial = False)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_SETCARETINDEX, $iindex, $bpartial) = 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LB_SETCARETINDEX, $iindex, $bpartial) = 0x0
    EndIf
EndFunc    ; -> _GUICtrlListBox_SetCaretIndex

Func _GUICtrlListBox_SetColumnWidth($hwnd, $iwidth)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $LB_SETCOLUMNWIDTH, $iwidth)
    Else
        GUICtrlSendMsg($hwnd, $LB_SETCOLUMNWIDTH, $iwidth, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_SetColumnWidth

Func _GUICtrlListBox_SetCurSel($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_SETCURSEL, $iindex)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_SETCURSEL, $iindex, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_SetCurSel

Func _GUICtrlListBox_SetHorizontalExtent($hwnd, $iwidth)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $LB_SETHORIZONTALEXTENT, $iwidth)
    Else
        GUICtrlSendMsg($hwnd, $LB_SETHORIZONTALEXTENT, $iwidth, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_SetHorizontalExtent

Func _GUICtrlListBox_SetItemData($hwnd, $iindex, $ivalue)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_SETITEMDATA, $iindex, $ivalue) <> + -1
    Else
        Return GUICtrlSendMsg($hwnd, $LB_SETITEMDATA, $iindex, $ivalue) <> + -1
    EndIf
EndFunc    ; -> _GUICtrlListBox_SetItemData

Func _GUICtrlListBox_SetItemHeight($hwnd, $iheight, $iindex = 0x0)
    Local $iret
    If IsHWnd($hwnd) Then
        $iret = _SendMessage($hwnd, $LB_SETITEMHEIGHT, $iindex, $iheight)
        _WinAPI_InvalidateRect($hwnd)
    Else
        $iret = GUICtrlSendMsg($hwnd, $LB_SETITEMHEIGHT, $iindex, $iheight)
        _WinAPI_InvalidateRect(GUICtrlGetHandle($hwnd))
    EndIf
    Return $iret <> + -1
EndFunc    ; -> _GUICtrlListBox_SetItemHeight

Func _GUICtrlListBox_SetLocale($hwnd, $ilocal)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_SETLOCALE, $ilocal)
    Else
        Return GUICtrlSendMsg($hwnd, $LB_SETLOCALE, $ilocal, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListBox_SetLocale

Func _GUICtrlListBox_SetSel($hwnd, $iindex = + -1, $iselect = + -1)
    Local $i_ret = 0x1
    If IsHWnd($hwnd) Then
        If $iindex == + -1 Then
            For $iindex = 0x0 To _GUICtrlListBox_GetCount($hwnd) + -1
                $i_ret = _GUICtrlListBox_GetSel($hwnd, $iindex)
                If ($i_ret == $LB_ERR) Then Return SetError($LB_ERR, $LB_ERR, False)
                If ($i_ret > 0x0) Then
                    $i_ret = _SendMessage($hwnd, $LB_SETSEL, False, $iindex) <> + -1
                Else
                    $i_ret = _SendMessage($hwnd, $LB_SETSEL, True, $iindex) <> + -1
                EndIf
                If ($i_ret == False) Then Return SetError($LB_ERR, $LB_ERR, False)
            Next
        ElseIf $iselect == + -1 Then
            If _GUICtrlListBox_GetSel($hwnd, $iindex) Then
                Return _SendMessage($hwnd, $LB_SETSEL, False, $iindex) <> + -1
            Else
                Return _SendMessage($hwnd, $LB_SETSEL, True, $iindex) <> + -1
            EndIf
        Else
            Return _SendMessage($hwnd, $LB_SETSEL, $iselect, $iindex) <> + -1
        EndIf
    Else
        If $iindex == + -1 Then
            For $iindex = 0x0 To _GUICtrlListBox_GetCount($hwnd) + -1
                $i_ret = _GUICtrlListBox_GetSel($hwnd, $iindex)
                If ($i_ret == $LB_ERR) Then Return SetError($LB_ERR, $LB_ERR, False)
                If ($i_ret > 0x0) Then
                    $i_ret = GUICtrlSendMsg($hwnd, $LB_SETSEL, False, $iindex) <> + -1
                Else
                    $i_ret = GUICtrlSendMsg($hwnd, $LB_SETSEL, True, $iindex) <> + -1
                EndIf
                If ($i_ret == 0x0) Then Return SetError($LB_ERR, $LB_ERR, False)
            Next
        ElseIf $iselect == + -1 Then
            If _GUICtrlListBox_GetSel($hwnd, $iindex) Then
                Return GUICtrlSendMsg($hwnd, $LB_SETSEL, False, $iindex) <> + -1
            Else
                Return GUICtrlSendMsg($hwnd, $LB_SETSEL, True, $iindex) <> + -1
            EndIf
        Else
            Return GUICtrlSendMsg($hwnd, $LB_SETSEL, $iselect, $iindex) <> + -1
        EndIf
    EndIf
    Return $i_ret <> 0x0
EndFunc    ; -> _GUICtrlListBox_SetSel

Func _GUICtrlListBox_SetTabStops($hwnd, $atabstops)
    Local $icount = $atabstops[0x0]
    Local $ttabstops = DllStructCreate("int[" & $icount & "]")
    For $ii = 0x1 To $icount
        DllStructSetData($ttabstops, 0x1, $atabstops[$ii], $ii)
    Next
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_SETTABSTOPS, $icount, $ttabstops, 0x0, "wparam", "struct*") = 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LB_SETTABSTOPS, $icount, DllStructGetPtr($ttabstops)) = 0x0
    EndIf
EndFunc    ; -> _GUICtrlListBox_SetTabStops

Func _GUICtrlListBox_SetTopIndex($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LB_SETTOPINDEX, $iindex) <> + -1
    Else
        Return GUICtrlSendMsg($hwnd, $LB_SETTOPINDEX, $iindex, 0x0) <> + -1
    EndIf
EndFunc    ; -> _GUICtrlListBox_SetTopIndex

Func _GUICtrlListBox_Sort($hwnd)
    Local $sbak = _GUICtrlListBox_GetText($hwnd, 0x0)
    If ($sbak == + -1) Then Return SetError($LB_ERR, $LB_ERR, False)
    If (_GUICtrlListBox_DeleteString($hwnd, 0x0) == + -1) Then Return SetError($LB_ERR, $LB_ERR, False)
    Return _GUICtrlListBox_AddString($hwnd, $sbak) <> + -1
EndFunc    ; -> _GUICtrlListBox_Sort

Func _GUICtrlListBox_SwapString($hwnd, $iindexa, $iindexb)
    Local $sitema = _GUICtrlListBox_GetText($hwnd, $iindexa)
    Local $sitemb = _GUICtrlListBox_GetText($hwnd, $iindexb)
    If (_GUICtrlListBox_DeleteString($hwnd, $iindexa) == + -1) Then Return SetError($LB_ERR, $LB_ERR, False)
    If (_GUICtrlListBox_InsertString($hwnd, $sitemb, $iindexa) == + -1) Then Return SetError($LB_ERR, $LB_ERR, False)
    If (_GUICtrlListBox_DeleteString($hwnd, $iindexb) == + -1) Then Return SetError($LB_ERR, $LB_ERR, False)
    If (_GUICtrlListBox_InsertString($hwnd, $sitema, $iindexb) == + -1) Then Return SetError($LB_ERR, $LB_ERR, False)
    Return True
EndFunc    ; -> _GUICtrlListBox_SwapString

Func _GUICtrlListBox_UpdateHScroll($hwnd)
    Local $hdc, $hfont, $tsize, $stext
    Local $imax = 0x0
    If IsHWnd($hwnd) Then
        $hfont = _SendMessage($hwnd, $__LISTBOXCONSTANT_WM_GETFONT)
        $hdc = _WinAPI_GetDC($hwnd)
        _WinAPI_SelectObject($hdc, $hfont)
        For $ii = 0x0 To _GUICtrlListBox_GetCount($hwnd) + -1
            $stext = _GUICtrlListBox_GetText($hwnd, $ii)
            $tsize = _WinAPI_GetTextExtentPoint32($hdc, $stext & "W")
            If DllStructGetData($tsize, "X") > $imax Then
                $imax = DllStructGetData($tsize, "X")
            EndIf
        Next
        _GUICtrlListBox_SetHorizontalExtent($hwnd, $imax)
        _WinAPI_SelectObject($hdc, $hfont)
        _WinAPI_ReleaseDC($hwnd, $hdc)
    Else
        $hfont = GUICtrlSendMsg($hwnd, $__LISTBOXCONSTANT_WM_GETFONT, 0x0, 0x0)
        Local $hwnd_t = GUICtrlGetHandle($hwnd)
        $hdc = _WinAPI_GetDC($hwnd_t)
        _WinAPI_SelectObject($hdc, $hfont)
        For $ii = 0x0 To _GUICtrlListBox_GetCount($hwnd) + -1
            $stext = _GUICtrlListBox_GetText($hwnd, $ii)
            $tsize = _WinAPI_GetTextExtentPoint32($hdc, $stext & "W")
            If DllStructGetData($tsize, "X") > $imax Then
                $imax = DllStructGetData($tsize, "X")
            EndIf
        Next
        _GUICtrlListBox_SetHorizontalExtent($hwnd, $imax)
        _WinAPI_SelectObject($hdc, $hfont)
        _WinAPI_ReleaseDC($hwnd_t, $hdc)
    EndIf
EndFunc    ; -> _GUICtrlListBox_UpdateHScroll

Global Const $__LISTVIEWCONSTANT_SORTINFOSIZE = 0xb
Global $__g_alistviewsortinfo[0x1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
Global $__g_tlistviewbuffer, $__g_tlistviewbufferansi
Global $__g_tlistviewitem = DllStructCreate($TAGLVITEM)
Global Const $__LISTVIEWCONSTANT_CLASSNAME = "SysListView32"
Global Const $__LISTVIEWCONSTANT_WM_SETREDRAW = 0xb
Global Const $__LISTVIEWCONSTANT_WM_SETFONT = 0x30
Global Const $__LISTVIEWCONSTANT_DEFAULT_GUI_FONT = 0x11
Global Const $__LISTVIEWCONSTANT_ILD_TRANSPARENT = 0x1
Global Const $__LISTVIEWCONSTANT_ILD_BLEND25 = 0x2
Global Const $__LISTVIEWCONSTANT_ILD_BLEND50 = 0x4
Global Const $__LISTVIEWCONSTANT_ILD_MASK = 0x10
Global Const $__LISTVIEWCONSTANT_VK_DOWN = 0x28
Global Const $__LISTVIEWCONSTANT_VK_END = 0x23
Global Const $__LISTVIEWCONSTANT_VK_HOME = 0x24
Global Const $__LISTVIEWCONSTANT_VK_LEFT = 0x25
Global Const $__LISTVIEWCONSTANT_VK_NEXT = 0x22
Global Const $__LISTVIEWCONSTANT_VK_PRIOR = 0x21
Global Const $__LISTVIEWCONSTANT_VK_RIGHT = 0x27
Global Const $__LISTVIEWCONSTANT_VK_UP = 0x26
Global Const $TAGLVBKIMAGE = "ulong Flags;hwnd hBmp;ptr Image;uint ImageMax;int XOffPercent;int YOffPercent"
Global Const $TAGLVCOLUMN = "uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal"
Global Const $TAGLVGROUP = "uint Size;uint Mask;ptr Header;int HeaderMax;ptr Footer;int FooterMax;int GroupID;uint StateMask;uint State;uint Align;" & "ptr  pszSubtitle;uint cchSubtitle;ptr pszTask;uint cchTask;ptr pszDescriptionTop;uint cchDescriptionTop;ptr pszDescriptionBottom;" & "uint cchDescriptionBottom;int iTitleImage;int iExtendedImage;int iFirstItem;uint cItems;ptr pszSubsetTitle;uint cchSubsetTitle"
Global Const $TAGLVINSERTMARK = "uint Size;dword Flags;int Item;dword Reserved"
Global Const $TAGLVSETINFOTIP = "uint Size;dword Flags;ptr Text;int Item;int SubItem"
Func _GUICtrlListView_AddArray($hwnd, ByRef $aitems)
    Local $tbuffer, $imsg, $imsgset
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_INSERTITEMW
        $imsgset = $LVM_SETITEMW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_INSERTITEMA
        $imsgset = $LVM_SETITEMA
    EndIf
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_TEXT)
    Local $ilastitem = _GUICtrlListView_GetItemCount($hwnd)
    _GUICtrlListView_BeginUpdate($hwnd)
    Local $psendmsg = __guictrl_sendmsg_init($hwnd, $imsg, 0x0, $titem, $tbuffer, False, 0x6)
    For $ii = 0x0 To UBound($aitems) + -1
        DllStructSetData($titem, "Item", $ii + $ilastitem)
        DllStructSetData($titem, "SubItem", 0x0)
        DllStructSetData($tbuffer, 0x1, $aitems[$ii][0x0])
        $psendmsg($hwnd, $imsg, 0x0, $titem, $tbuffer, False, 0x6)
        For $ij = 0x1 To UBound($aitems, $UBOUND_COLUMNS) + -1
            DllStructSetData($titem, "SubItem", $ij)
            DllStructSetData($tbuffer, 0x1, $aitems[$ii][$ij])
            $psendmsg($hwnd, $imsgset, 0x0, $titem, $tbuffer, False, 0x6)
        Next
    Next
    _GUICtrlListView_EndUpdate($hwnd)
EndFunc    ; -> _GUICtrlListView_AddArray

Func _GUICtrlListView_AddColumn($hwnd, $stext, $iwidth = 0x32, $ialign = + -1, $iimage = + -1, $bonright = False)
    Return _GUICtrlListView_InsertColumn($hwnd, _GUICtrlListView_GetColumnCount($hwnd), $stext, $iwidth, $ialign, $iimage, $bonright)
EndFunc    ; -> _GUICtrlListView_AddColumn

Func _GUICtrlListView_AddItem($hwnd, $stext, $iimage = + -1, $iparam = 0x0)
    Return _GUICtrlListView_InsertItem($hwnd, $stext, + -1, $iimage, $iparam)
EndFunc    ; -> _GUICtrlListView_AddItem

Func _GUICtrlListView_AddSubItem($hwnd, $iindex, $stext, $isubitem, $iimage = + -1)
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_SETITEMW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_SETITEMA
    EndIf
    Local $titem = $__g_tlistviewitem
    Local $imask = $LVIF_TEXT
    If $iimage <> + -1 Then $imask = BitOR($imask, $LVIF_IMAGE)
    DllStructSetData($tbuffer, 0x1, $stext)
    DllStructSetData($titem, "Mask", $imask)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", $isubitem)
    DllStructSetData($titem, "Image", $iimage)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, $tbuffer, False, 0x6, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_AddSubItem

Func _GUICtrlListView_ApproximateViewHeight($hwnd, $icount = + -1, $icx = + -1, $icy = + -1)
    If IsHWnd($hwnd) Then
        Return BitShift((_SendMessage($hwnd, $LVM_APPROXIMATEVIEWRECT, $icount, _WinAPI_MakeLong($icx, $icy))), 0x10)
    Else
        Return BitShift((GUICtrlSendMsg($hwnd, $LVM_APPROXIMATEVIEWRECT, $icount, _WinAPI_MakeLong($icx, $icy))), 0x10)
    EndIf
EndFunc    ; -> _GUICtrlListView_ApproximateViewHeight

Func _GUICtrlListView_ApproximateViewRect($hwnd, $icount = + -1, $icx = + -1, $icy = + -1)
    Local $iview
    If IsHWnd($hwnd) Then
        $iview = _SendMessage($hwnd, $LVM_APPROXIMATEVIEWRECT, $icount, _WinAPI_MakeLong($icx, $icy))
    Else
        $iview = GUICtrlSendMsg($hwnd, $LVM_APPROXIMATEVIEWRECT, $icount, _WinAPI_MakeLong($icx, $icy))
    EndIf
    Local $aview[0x2]
    $aview[0x0] = BitAND($iview, 0xffff)
    $aview[0x1] = BitShift($iview, 0x10)
    Return $aview
EndFunc    ; -> _GUICtrlListView_ApproximateViewRect

Func _GUICtrlListView_ApproximateViewWidth($hwnd, $icount = + -1, $icx = + -1, $icy = + -1)
    If IsHWnd($hwnd) Then
        Return BitAND((_SendMessage($hwnd, $LVM_APPROXIMATEVIEWRECT, $icount, _WinAPI_MakeLong($icx, $icy))), 0xffff)
    Else
        Return BitAND((GUICtrlSendMsg($hwnd, $LVM_APPROXIMATEVIEWRECT, $icount, _WinAPI_MakeLong($icx, $icy))), 0xffff)
    EndIf
EndFunc    ; -> _GUICtrlListView_ApproximateViewWidth

Func _GUICtrlListView_Arrange($hwnd, $iarrange = 0x0)
    Local $aarrange[0x4] = [$LVA_DEFAULT, $LVA_ALIGNLEFT, $LVA_ALIGNTOP, $LVA_SNAPTOGRID]
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_ARRANGE, $aarrange[$iarrange]) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_ARRANGE, $aarrange[$iarrange], 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_Arrange

Func __GUICtrlListView_ArrayDelete(ByRef $avarray, $ielement)
    If Not IsArray($avarray) Then Return SetError(0x1, 0x0, '')
    Local $iupper = UBound($avarray)
    If $iupper = 0x1 Then
        SetError(0x2)
        Return ''
    EndIf
    Local $avnewarray[$iupper + -1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
    $avnewarray[0x0][0x0] = $avarray[0x0][0x0]
    If $ielement < 0x0 Then
        $ielement = 0x0
    EndIf
    If $ielement > ($iupper + -1) Then
        $ielement = ($iupper + -1)
    EndIf
    If $ielement > 0x0 Then
        For $icntr = 0x0 To $ielement + -1
            For $x = 0x1 To $__LISTVIEWCONSTANT_SORTINFOSIZE + -1
                $avnewarray[$icntr][$x] = $avarray[$icntr][$x]
            Next
        Next
    EndIf
    If $ielement < ($iupper + -1) Then
        For $icntr = ($ielement + 0x1) To ($iupper + -1)
            For $x = 0x1 To $__LISTVIEWCONSTANT_SORTINFOSIZE + -1
                $avnewarray[$icntr + -1][$x] = $avarray[$icntr][$x]
            Next
        Next
    EndIf
    $avarray = $avnewarray
    SetError(0x0)
    Return 0x1
EndFunc    ; -> __GUICtrlListView_ArrayDelete

Func _GUICtrlListView_BeginUpdate($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, False) = 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, False, 0x0) = 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_BeginUpdate

Func _GUICtrlListView_CancelEditLabel($hwnd)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $LVM_CANCELEDITLABEL)
    Else
        GUICtrlSendMsg($hwnd, $LVM_CANCELEDITLABEL, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_CancelEditLabel

Func _GUICtrlListView_ClickItem($hwnd, $iindex, $sbutton = "left", $bmove = False, $iclicks = 0x1, $ispeed = 0x1)
    _GUICtrlListView_EnsureVisible($hwnd, $iindex, False)
    Local $trect = _GUICtrlListView_GetItemRectEx($hwnd, $iindex, $LVIR_LABEL)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tpoint = _WinAPI_PointFromRect($trect, True)
    $tpoint = _WinAPI_ClientToScreen($hwnd, $tpoint)
    Local $ix, $iy
    _WinAPI_GetXYFromPoint($tpoint, $ix, $iy)
    Local $ixplus = DllStructGetData($trect, "Left") < 0x0  ? DllStructGetData($trect, "Left") * + -1  : 0x0
    Local $imode = Opt("MouseCoordMode", 0x1)
    If Not $bmove Then
        Local $apos = MouseGetPos()
        _WinAPI_ShowCursor(False)
        MouseClick($sbutton, $ix + $ixplus, $iy, $iclicks, $ispeed)
        MouseMove($apos[0x0], $apos[0x1], 0x0)
        _WinAPI_ShowCursor(True)
    Else
        MouseClick($sbutton, $ix + $ixplus, $iy, $iclicks, $ispeed)
    EndIf
    Opt("MouseCoordMode", $imode)
EndFunc    ; -> _GUICtrlListView_ClickItem

Func _GUICtrlListView_CopyItems($hwnd_source, $hwnd_destination, $bdelflag = False)
    Local $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd_source) Then
        $imsg = $LVM_GETITEMW
    Else
        $imsg = $LVM_GETITEMA
    EndIf
    Local $titem = $__g_tlistviewitem
    Local $a_indices, $iindex
    Local $icols = _GUICtrlListView_GetColumnCount($hwnd_source)
    Local $iitems = _GUICtrlListView_GetItemCount($hwnd_source)
    _GUICtrlListView_BeginUpdate($hwnd_source)
    _GUICtrlListView_BeginUpdate($hwnd_destination)
    If BitAND(_GUICtrlListView_GetExtendedListViewStyle($hwnd_source), $LVS_EX_CHECKBOXES) == $LVS_EX_CHECKBOXES Then
        For $i = 0x0 To $iitems + -1
            If (_GUICtrlListView_GetItemChecked($hwnd_source, $i)) Then
                If IsArray($a_indices) Then
                    ReDim $a_indices[UBound($a_indices) + 0x1]
                Else
                    Local $a_indices[0x2]
                EndIf
                $a_indices[0x0] = $a_indices[0x0] + 0x1
                $a_indices[UBound($a_indices) + -1] = $i
            EndIf
        Next
        If (IsArray($a_indices)) Then
            For $i = 0x1 To $a_indices[0x0]
                DllStructSetData($titem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
                DllStructSetData($titem, "Item", $a_indices[$i])
                DllStructSetData($titem, "SubItem", 0x0)
                DllStructSetData($titem, "StateMask", + -1)
                __guictrl_sendmsg($hwnd_source, $imsg, 0x0, $titem, 0x0, True, + -1)
                $iindex = _GUICtrlListView_AddItem($hwnd_destination, _GUICtrlListView_GetItemText($hwnd_source, $a_indices[$i], 0x0), DllStructGetData($titem, "Image"))
                _GUICtrlListView_SetItemChecked($hwnd_destination, $iindex)
                For $x = 0x1 To $icols + -1
                    DllStructSetData($titem, "Item", $a_indices[$i])
                    DllStructSetData($titem, "SubItem", $x)
                    __guictrl_sendmsg($hwnd_source, $imsg, 0x0, $titem, 0x0, True, + -1)
                    _GUICtrlListView_AddSubItem($hwnd_destination, $iindex, _GUICtrlListView_GetItemText($hwnd_source, $a_indices[$i], $x), $x, DllStructGetData($titem, "Image"))
                Next
            Next
            If $bdelflag Then
                For $i = $a_indices[0x0] To 0x1 Step + -1
                    _GUICtrlListView_DeleteItem($hwnd_source, $a_indices[$i])
                Next
            EndIf
        EndIf
    EndIf
    If (_GUICtrlListView_GetSelectedCount($hwnd_source)) Then
        $a_indices = _GUICtrlListView_GetSelectedIndices($hwnd_source, 0x1)
        For $i = 0x1 To $a_indices[0x0]
            DllStructSetData($titem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
            DllStructSetData($titem, "Item", $a_indices[$i])
            DllStructSetData($titem, "SubItem", 0x0)
            DllStructSetData($titem, "StateMask", + -1)
            __guictrl_sendmsg($hwnd_source, $imsg, 0x0, $titem, 0x0, True, + -1)
            $iindex = _GUICtrlListView_AddItem($hwnd_destination, _GUICtrlListView_GetItemText($hwnd_source, $a_indices[$i], 0x0), DllStructGetData($titem, "Image"))
            For $x = 0x1 To $icols + -1
                DllStructSetData($titem, "Item", $a_indices[$i])
                DllStructSetData($titem, "SubItem", $x)
                __guictrl_sendmsg($hwnd_source, $imsg, 0x0, $titem, 0x0, True, + -1)
                _GUICtrlListView_AddSubItem($hwnd_destination, $iindex, _GUICtrlListView_GetItemText($hwnd_source, $a_indices[$i], $x), $x, DllStructGetData($titem, "Image"))
            Next
        Next
        _GUICtrlListView_SetItemSelected($hwnd_source, + -1, False)
        If $bdelflag Then
            For $i = $a_indices[0x0] To 0x1 Step + -1
                _GUICtrlListView_DeleteItem($hwnd_source, $a_indices[$i])
            Next
        EndIf
    EndIf
    _GUICtrlListView_EndUpdate($hwnd_source)
    _GUICtrlListView_EndUpdate($hwnd_destination)
EndFunc    ; -> _GUICtrlListView_CopyItems

Func _GUICtrlListView_Create($hwnd, $sheadertext, $ix, $iy, $iwidth = 0x96, $iheight = 0x96, $istyle = 0xd, $iexstyle = 0x0, $bcoinit = False)
    If Not IsHWnd($hwnd) Then Return SetError(0x1, 0x0, 0x0)
    If Not IsString($sheadertext) Then Return SetError(0x2, 0x0, 0x0)
    If $iwidth = + -1 Then $iwidth = 0x96
    If $iheight = + -1 Then $iheight = 0x96
    If $istyle = + -1 Then $istyle = $LVS_DEFAULT
    If $iexstyle = + -1 Then $iexstyle = 0x0
    Local Const $S_OK = 0x0
    Local Const $S_FALSE = 0x1
    Local Const $RPC_E_CHANGED_MODE = -2147417850
    Local Const $E_INVALIDARG = -2147024809
    Local Const $E_OUTOFMEMORY = -2147024882
    Local Const $E_UNEXPECTED = -2147418113
    Local $sseparatorchar = Opt("GUIDataSeparatorChar")
    Local Const $COINIT_APARTMENTTHREADED = 0x2
    Local $istr_len = StringLen($sheadertext)
    If $istr_len Then $sheadertext = StringSplit($sheadertext, $sseparatorchar)
    $istyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $istyle)
    If $bcoinit Then
        Local $acall = DllCall("ole32.dll", "long", "CoInitializeEx", "ptr", 0x0, "dword", $COINIT_APARTMENTTHREADED)
        If @error Then Return SetError(@error, @extended, 0x0)
        Switch $acall[0x0]
        Case $S_OK
        Case $S_FALSE
        Case $RPC_E_CHANGED_MODE
        Case $E_INVALIDARG
        Case $E_OUTOFMEMORY
        Case $E_UNEXPECTED
        EndSwitch
    EndIf
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hlist = _WinAPI_CreateWindowEx($iexstyle, $__LISTVIEWCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    _SendMessage($hlist, $__LISTVIEWCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__LISTVIEWCONSTANT_DEFAULT_GUI_FONT), True)
    If $istr_len Then
        For $x = 0x1 To $sheadertext[0x0]
            _GUICtrlListView_InsertColumn($hlist, $x + -1, $sheadertext[$x], 0x4b)
        Next
    EndIf
    Return $hlist
EndFunc    ; -> _GUICtrlListView_Create

Func _GUICtrlListView_CreateDragImage($hwnd, $iindex)
    Local $adrag[0x3]
    Local $tpoint = DllStructCreate($TAGPOINT)
    $adrag[0x0] = Ptr(__guictrl_sendmsg($hwnd, $LVM_CREATEDRAGIMAGE, $iindex, $tpoint, 0x0, True, + -1))
    $adrag[0x1] = DllStructGetData($tpoint, "X")
    $adrag[0x2] = DllStructGetData($tpoint, "Y")
    Return $adrag
EndFunc    ; -> _GUICtrlListView_CreateDragImage

Func _GUICtrlListView_CreateSolidBitMap($hwnd, $icolor, $iwidth, $iheight)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _WinAPI_CreateSolidBitmap($hwnd, $icolor, $iwidth, $iheight)
EndFunc    ; -> _GUICtrlListView_CreateSolidBitMap

Func _GUICtrlListView_DeleteAllItems($hwnd)
    If _GUICtrlListView_GetItemCount($hwnd) = 0x0 Then Return True
    Local $vcid = 0x0
    If IsHWnd($hwnd) Then
        $vcid = _WinAPI_GetDlgCtrlID($hwnd)
    Else
        $vcid = $hwnd
        $hwnd = GUICtrlGetHandle($hwnd)
    EndIf
    If $vcid < $_UDF_STARTID Then
        Local $iparam = 0x0
        For $iindex = _GUICtrlListView_GetItemCount($hwnd) + -1 To 0x0 Step + -1
            $iparam = _GUICtrlListView_GetItemParam($hwnd, $iindex)
            If GUICtrlGetState($iparam) > 0x0 And GUICtrlGetHandle($iparam) = 0x0 Then
                GUICtrlDelete($iparam)
            EndIf
        Next
        If _GUICtrlListView_GetItemCount($hwnd) = 0x0 Then Return True
    EndIf
    Return _SendMessage($hwnd, $LVM_DELETEALLITEMS) <> 0x0
EndFunc    ; -> _GUICtrlListView_DeleteAllItems

Func _GUICtrlListView_DeleteColumn($hwnd, $icol)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_DELETECOLUMN, $icol) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_DELETECOLUMN, $icol, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_DeleteColumn

Func _GUICtrlListView_DeleteItem($hwnd, $iindex)
    Local $vcid = 0x0
    If IsHWnd($hwnd) Then
        $vcid = _WinAPI_GetDlgCtrlID($hwnd)
    Else
        $vcid = $hwnd
        $hwnd = GUICtrlGetHandle($hwnd)
    EndIf
    If $vcid < $_UDF_STARTID Then
        Local $iparam = _GUICtrlListView_GetItemParam($hwnd, $iindex)
        If GUICtrlGetState($iparam) > 0x0 And GUICtrlGetHandle($iparam) = 0x0 Then
            If GUICtrlDelete($iparam) Then
                Return True
            EndIf
        EndIf
    EndIf
    Return _SendMessage($hwnd, $LVM_DELETEITEM, $iindex) <> 0x0
EndFunc    ; -> _GUICtrlListView_DeleteItem

Func _GUICtrlListView_DeleteItemsSelected($hwnd)
    Local $iitemcount = _GUICtrlListView_GetItemCount($hwnd)
    If _GUICtrlListView_GetSelectedCount($hwnd) = $iitemcount Then
        Return _GUICtrlListView_DeleteAllItems($hwnd)
    Else
        Local $aselected = _GUICtrlListView_GetSelectedIndices($hwnd, True)
        If Not IsArray($aselected) Then Return SetError($LV_ERR, $LV_ERR, 0x0)
        _GUICtrlListView_SetItemSelected($hwnd, + -1, False)
        Local $vcid = 0x0, $inative_delete, $iudf_delete
        If IsHWnd($hwnd) Then
            $vcid = _WinAPI_GetDlgCtrlID($hwnd)
        Else
            $vcid = $hwnd
            $hwnd = GUICtrlGetHandle($hwnd)
        EndIf
        For $iindex = $aselected[0x0] To 0x1 Step + -1
            If $vcid < $_UDF_STARTID Then
                Local $iparam = _GUICtrlListView_GetItemParam($hwnd, $aselected[$iindex])
                If GUICtrlGetState($iparam) > 0x0 And GUICtrlGetHandle($iparam) = 0x0 Then
                    $inative_delete = GUICtrlDelete($iparam)
                    If $inative_delete Then ContinueLoop
                EndIf
            EndIf
            $iudf_delete = _SendMessage($hwnd, $LVM_DELETEITEM, $aselected[$iindex])
            If $inative_delete + $iudf_delete = 0x0 Then
                ExitLoop
            EndIf
        Next
        Return Not $iindex
    EndIf
EndFunc    ; -> _GUICtrlListView_DeleteItemsSelected

Func _GUICtrlListView_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__LISTVIEWCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlListView_Destroy

Func __GUICtrlListView_Draw($hwnd, $iindex, $hdc, $ix, $iy, $istyle = 0x0)
    Local $IFLAGS = 0x0
    If BitAND($istyle, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $__LISTVIEWCONSTANT_ILD_TRANSPARENT)
    If BitAND($istyle, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $__LISTVIEWCONSTANT_ILD_BLEND25)
    If BitAND($istyle, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $__LISTVIEWCONSTANT_ILD_BLEND50)
    If BitAND($istyle, 0x8) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $__LISTVIEWCONSTANT_ILD_MASK)
    Local $acall = DllCall("comctl32.dll", "bool", "ImageList_Draw", "handle", $hwnd, "int", $iindex, "handle", $hdc, "int", $ix, "int", $iy, "uint", $IFLAGS)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> __GUICtrlListView_Draw

Func _GUICtrlListView_DrawDragImage(ByRef $hwnd, ByRef $adrag)
    Local $hdc = _WinAPI_GetWindowDC($hwnd)
    Local $tpoint = _WinAPI_GetMousePos(True, $hwnd)
    _WinAPI_InvalidateRect($hwnd)
    __GUICtrlListView_Draw($adrag[0x0], 0x0, $hdc, DllStructGetData($tpoint, "X"), DllStructGetData($tpoint, "Y"))
    _WinAPI_ReleaseDC($hwnd, $hdc)
EndFunc    ; -> _GUICtrlListView_DrawDragImage

Func _GUICtrlListView_EditLabel($hwnd, $iindex)
    Local $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $imsg = $LVM_EDITLABELW
    Else
        $imsg = $LVM_EDITLABEL
    EndIf
    Local $acall
    If IsHWnd($hwnd) Then
        $acall = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = 0x0 Then Return 0x0
        Return _SendMessage($hwnd, $imsg, $iindex, 0x0, 0x0, "wparam", "lparam", "hwnd")
    Else
        $acall = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", GUICtrlGetHandle($hwnd))
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = 0x0 Then Return 0x0
        Return Ptr(GUICtrlSendMsg($hwnd, $imsg, $iindex, 0x0))
    EndIf
EndFunc    ; -> _GUICtrlListView_EditLabel

Func _GUICtrlListView_EnableGroupView($hwnd, $benable = True)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_ENABLEGROUPVIEW, $benable)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_ENABLEGROUPVIEW, $benable, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_EnableGroupView

Func _GUICtrlListView_EndUpdate($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, True) = 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, True, 0x0) = 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_EndUpdate

Func _GUICtrlListView_EnsureVisible($hwnd, $iindex, $bpartialok = False)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_ENSUREVISIBLE, $iindex, $bpartialok)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_ENSUREVISIBLE, $iindex, $bpartialok)
    EndIf
EndFunc    ; -> _GUICtrlListView_EnsureVisible

Func _GUICtrlListView_FindInText($hwnd, $stext, $istart = + -1, $bwrapok = True, $breverse = False)
    Local $icount = _GUICtrlListView_GetItemCount($hwnd)
    Local $icolumns = _GUICtrlListView_GetColumnCount($hwnd)
    If $icolumns = 0x0 Then $icolumns = 0x1
    If $breverse And $istart = + -1 Then Return + -1
    Local $slist
    If $breverse Then
        For $ii = $istart + -1 To 0x0 Step + -1
            For $ij = 0x0 To $icolumns + -1
                $slist = _GUICtrlListView_GetItemText($hwnd, $ii, $ij)
                If StringInStr($slist, $stext) Then Return $ii
            Next
        Next
    Else
        For $ii = $istart + 0x1 To $icount + -1
            For $ij = 0x0 To $icolumns + -1
                $slist = _GUICtrlListView_GetItemText($hwnd, $ii, $ij)
                If StringInStr($slist, $stext) Then Return $ii
            Next
        Next
    EndIf
    If (($istart = + -1) Or Not $bwrapok) And Not $breverse Then Return + -1
    If $breverse And $bwrapok Then
        For $ii = $icount + -1 To $istart + 0x1 Step + -1
            For $ij = 0x0 To $icolumns + -1
                $slist = _GUICtrlListView_GetItemText($hwnd, $ii, $ij)
                If StringInStr($slist, $stext) Then Return $ii
            Next
        Next
    Else
        For $ii = 0x0 To $istart + -1
            For $ij = 0x0 To $icolumns + -1
                $slist = _GUICtrlListView_GetItemText($hwnd, $ii, $ij)
                If StringInStr($slist, $stext) Then Return $ii
            Next
        Next
    EndIf
    Return + -1
EndFunc    ; -> _GUICtrlListView_FindInText

Func _GUICtrlListView_FindItem($hwnd, $istart, ByRef $tfindinfo, $stext = '')
    Local $ibuffer = StringLen($stext) + 0x1
    Local $tbuffer = DllStructCreate("char Text[" & $ibuffer & "]")
    DllStructSetData($tbuffer, 0x1, $stext)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_FINDITEM, $istart, $tfindinfo, $tbuffer, False, 0x2, False, + -1)
    Return $iret
EndFunc    ; -> _GUICtrlListView_FindItem

Func _GUICtrlListView_FindNearest($hwnd, $ix, $iy, $idir = 0x0, $istart = + -1, $bwrapok = True)
    Local $adir[0x8] = [$__LISTVIEWCONSTANT_VK_LEFT, $__LISTVIEWCONSTANT_VK_RIGHT, $__LISTVIEWCONSTANT_VK_UP, $__LISTVIEWCONSTANT_VK_DOWN, $__LISTVIEWCONSTANT_VK_HOME, $__LISTVIEWCONSTANT_VK_END, $__LISTVIEWCONSTANT_VK_PRIOR, $__LISTVIEWCONSTANT_VK_NEXT]
    Local $tfindinfo = DllStructCreate($TAGLVFINDINFO)
    Local $IFLAGS = $LVFI_NEARESTXY
    If $bwrapok Then $IFLAGS = BitOR($IFLAGS, $LVFI_WRAP)
    DllStructSetData($tfindinfo, "Flags", $IFLAGS)
    DllStructSetData($tfindinfo, "X", $ix)
    DllStructSetData($tfindinfo, "Y", $iy)
    DllStructSetData($tfindinfo, "Direction", $adir[$idir])
    Return _GUICtrlListView_FindItem($hwnd, $istart, $tfindinfo)
EndFunc    ; -> _GUICtrlListView_FindNearest

Func _GUICtrlListView_FindParam($hwnd, $iparam, $istart = + -1)
    Local $tfindinfo = DllStructCreate($TAGLVFINDINFO)
    DllStructSetData($tfindinfo, "Flags", $LVFI_PARAM)
    DllStructSetData($tfindinfo, "Param", $iparam)
    Return _GUICtrlListView_FindItem($hwnd, $istart, $tfindinfo)
EndFunc    ; -> _GUICtrlListView_FindParam

Func _GUICtrlListView_FindText($hwnd, $stext, $istart = + -1, $bpartialok = True, $bwrapok = True)
    Local $tfindinfo = DllStructCreate($TAGLVFINDINFO)
    Local $IFLAGS = $LVFI_STRING
    If $bpartialok Then $IFLAGS = BitOR($IFLAGS, $LVFI_PARTIAL)
    If $bwrapok Then $IFLAGS = BitOR($IFLAGS, $LVFI_WRAP)
    DllStructSetData($tfindinfo, "Flags", $IFLAGS)
    Return _GUICtrlListView_FindItem($hwnd, $istart, $tfindinfo, $stext)
EndFunc    ; -> _GUICtrlListView_FindText

Func _GUICtrlListView_GetBkColor($hwnd)
    Local $i_color
    If IsHWnd($hwnd) Then
        $i_color = _SendMessage($hwnd, $LVM_GETBKCOLOR)
    Else
        $i_color = GUICtrlSendMsg($hwnd, $LVM_GETBKCOLOR, 0x0, 0x0)
    EndIf
    Return __GUICtrlListView_ReverseColorOrder($i_color)
EndFunc    ; -> _GUICtrlListView_GetBkColor

Func _GUICtrlListView_GetBkImage($hwnd)
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_GETBKIMAGEW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_GETBKIMAGEA
    EndIf
    Local $timage = DllStructCreate($TAGLVBKIMAGE)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $timage, $tbuffer, True, 0x3, True)
    Local $aimage[0x4]
    Switch BitAND(DllStructGetData($timage, "Flags"), $LVBKIF_SOURCE_MASK)
    Case $LVBKIF_SOURCE_HBITMAP
        $aimage[0x0] = 0x1
    Case $LVBKIF_SOURCE_URL
        $aimage[0x0] = 0x2
    EndSwitch
    $aimage[0x1] = DllStructGetData($tbuffer, 0x1)
    $aimage[0x2] = DllStructGetData($timage, "XOffPercent")
    $aimage[0x3] = DllStructGetData($timage, "YOffPercent")
    Return SetError($iret <> 0x0, 0x0, $aimage)
EndFunc    ; -> _GUICtrlListView_GetBkImage

Func _GUICtrlListView_GetCallbackMask($hwnd)
    Local $IFLAGS = 0x0
    Local $imask = _SendMessage($hwnd, $LVM_GETCALLBACKMASK)
    If BitAND($imask, $LVIS_CUT) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x1)
    If BitAND($imask, $LVIS_DROPHILITED) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x2)
    If BitAND($imask, $LVIS_FOCUSED) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x4)
    If BitAND($imask, $LVIS_SELECTED) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x8)
    If BitAND($imask, $LVIS_OVERLAYMASK) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x10)
    If BitAND($imask, $LVIS_STATEIMAGEMASK) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, 0x20)
    Return $IFLAGS
EndFunc    ; -> _GUICtrlListView_GetCallbackMask

Func _GUICtrlListView_GetColumn($hwnd, $iindex)
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_GETCOLUMNW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_GETCOLUMNA
    EndIf
    Local $tcolumn = DllStructCreate($TAGLVCOLUMN)
    DllStructSetData($tcolumn, "Mask", $LVCF_ALLDATA)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $tcolumn, $tbuffer, True, 0x4, True)
    Local $acolumn[0x9]
    Switch BitAND(DllStructGetData($tcolumn, "Fmt"), $LVCFMT_JUSTIFYMASK)
    Case $LVCFMT_RIGHT
        $acolumn[0x0] = 0x1
    Case $LVCFMT_CENTER
        $acolumn[0x0] = 0x2
    Case Else
        $acolumn[0x0] = 0x0
    EndSwitch
    $acolumn[0x1] = BitAND(DllStructGetData($tcolumn, "Fmt"), $LVCFMT_IMAGE) <> 0x0
    $acolumn[0x2] = BitAND(DllStructGetData($tcolumn, "Fmt"), $LVCFMT_BITMAP_ON_RIGHT) <> 0x0
    $acolumn[0x3] = BitAND(DllStructGetData($tcolumn, "Fmt"), $LVCFMT_COL_HAS_IMAGES) <> 0x0
    $acolumn[0x4] = DllStructGetData($tcolumn, "CX")
    $acolumn[0x5] = DllStructGetData($tbuffer, 0x1)
    $acolumn[0x6] = DllStructGetData($tcolumn, "SubItem")
    $acolumn[0x7] = DllStructGetData($tcolumn, "Image")
    $acolumn[0x8] = DllStructGetData($tcolumn, "Order")
    Return SetError($iret = 0x0, 0x0, $acolumn)
EndFunc    ; -> _GUICtrlListView_GetColumn

Func _GUICtrlListView_GetColumnCount($hwnd)
    Return _SendMessage(_GUICtrlListView_GetHeader($hwnd), 0x1200)
EndFunc    ; -> _GUICtrlListView_GetColumnCount

Func _GUICtrlListView_GetColumnOrder($hwnd)
    Local $a_cols = _GUICtrlListView_GetColumnOrderArray($hwnd), $s_cols = ''
    Local $sseparatorchar = Opt("GUIDataSeparatorChar")
    For $i = 0x1 To $a_cols[0x0]
        $s_cols &= $a_cols[$i] & $sseparatorchar
    Next
    $s_cols = StringTrimRight($s_cols, 0x1)
    Return $s_cols
EndFunc    ; -> _GUICtrlListView_GetColumnOrder

Func _GUICtrlListView_GetColumnOrderArray($hwnd)
    Local $icolumns = _GUICtrlListView_GetColumnCount($hwnd)
    Local $tcolumns = DllStructCreate("int[" & $icolumns & "]")
    __guictrl_sendmsg($hwnd, $LVM_GETCOLUMNORDERARRAY, $icolumns, $tcolumns, 0x0, True, + -1)
    Local $abuffer[$icolumns + 0x1]
    $abuffer[0x0] = $icolumns
    For $ii = 0x1 To $icolumns
        $abuffer[$ii] = DllStructGetData($tcolumns, 0x1, $ii)
    Next
    Return $abuffer
EndFunc    ; -> _GUICtrlListView_GetColumnOrderArray

Func _GUICtrlListView_GetColumnWidth($hwnd, $icol)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETCOLUMNWIDTH, $icol)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETCOLUMNWIDTH, $icol, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetColumnWidth

Func _GUICtrlListView_GetCounterPage($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETCOUNTPERPAGE)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETCOUNTPERPAGE, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetCounterPage

Func _GUICtrlListView_GetEditControl($hwnd)
    If IsHWnd($hwnd) Then
        Return HWnd(_SendMessage($hwnd, $LVM_GETEDITCONTROL))
    Else
        Return HWnd(GUICtrlSendMsg($hwnd, $LVM_GETEDITCONTROL, 0x0, 0x0))
    EndIf
EndFunc    ; -> _GUICtrlListView_GetEditControl

Func _GUICtrlListView_GetEmptyText($hwnd)
    Local $ttext = DllStructCreate("wchar[4096]")
    Local $itext = DllStructGetSize($ttext)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_GETEMPTYTEXT, $itext, $ttext, 0x0, True, + -1)
    Return $iret  ? DllStructGetData($ttext, 0x1) : ''
EndFunc    ; -> _GUICtrlListView_GetEmptyText

Func _GUICtrlListView_GetExtendedListViewStyle($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETEXTENDEDLISTVIEWSTYLE)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETEXTENDEDLISTVIEWSTYLE, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetExtendedListViewStyle

Func _GUICtrlListView_GetFocusedGroup($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETFOCUSEDGROUP)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETFOCUSEDGROUP, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetFocusedGroup

Func _GUICtrlListView_GetGroupCount($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETGROUPCOUNT)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETGROUPCOUNT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetGroupCount

Func _GUICtrlListView_GetGroupInfo($hwnd, $igroupid)
    Local $tgroup = __GUICtrlListView_GetGroupInfoEx($hwnd, $igroupid, BitOR($LVGF_HEADER, $LVGF_ALIGN))
    Local $ierr = @error
    Local $agroup[0x2]
    $agroup[0x0] = _WinAPI_GetString(DllStructGetData($tgroup, "Header"))
    Select
    Case BitAND(DllStructGetData($tgroup, "Align"), $LVGA_HEADER_CENTER) <> 0x0
        $agroup[0x1] = 0x1
    Case BitAND(DllStructGetData($tgroup, "Align"), $LVGA_HEADER_RIGHT) <> 0x0
        $agroup[0x1] = 0x2
    Case Else
        $agroup[0x1] = 0x0
    EndSelect
    Return SetError($ierr, 0x0, $agroup)
EndFunc    ; -> _GUICtrlListView_GetGroupInfo

Func __GUICtrlListView_GetGroupInfoEx($hwnd, $igroupid, $imask)
    Local $tgroup = DllStructCreate($TAGLVGROUP)
    Local $igroup = DllStructGetSize($tgroup)
    DllStructSetData($tgroup, "Size", $igroup)
    DllStructSetData($tgroup, "Mask", $imask)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_GETGROUPINFO, $igroupid, $tgroup, 0x0, True, + -1)
    Return SetError($iret <> $igroupid, 0x0, $tgroup)
EndFunc    ; -> __GUICtrlListView_GetGroupInfoEx

Func _GUICtrlListView_GetGroupInfoByIndex($hwnd, $iindex)
    Local $tgroup = DllStructCreate($TAGLVGROUP)
    Local $igroup = DllStructGetSize($tgroup)
    DllStructSetData($tgroup, "Size", $igroup)
    DllStructSetData($tgroup, "Mask", BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_GROUPID))
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_GETGROUPINFOBYINDEX, $iindex, $tgroup, 0x0, True, + -1)
    Local $agroup[0x3]
    $agroup[0x0] = _WinAPI_GetString(DllStructGetData($tgroup, "Header"))
    Select
    Case BitAND(DllStructGetData($tgroup, "Align"), $LVGA_HEADER_CENTER) <> 0x0
        $agroup[0x1] = 0x1
    Case BitAND(DllStructGetData($tgroup, "Align"), $LVGA_HEADER_RIGHT) <> 0x0
        $agroup[0x1] = 0x2
    Case Else
        $agroup[0x1] = 0x0
    EndSelect
    $agroup[0x2] = DllStructGetData($tgroup, "GroupID")
    Return SetError($iret = 0x0, 0x0, $agroup)
EndFunc    ; -> _GUICtrlListView_GetGroupInfoByIndex

Func _GUICtrlListView_GetGroupRect($hwnd, $igroupid, $iget = $LVGGR_GROUP)
    Local $trect = DllStructCreate($TAGRECT)
    DllStructSetData($trect, "Top", $iget)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_GETGROUPRECT, $igroupid, $trect, 0x0, True, + -1)
    Local $arect[0x4]
    For $x = 0x0 To 0x3
        $arect[$x] = DllStructGetData($trect, $x + 0x1)
    Next
    Return SetError($iret = 0x0, 0x0, $arect)
EndFunc    ; -> _GUICtrlListView_GetGroupRect

Func _GUICtrlListView_GetGroupState($hwnd, $igroupid, $imask)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETGROUPSTATE, $igroupid, $imask)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETGROUPSTATE, $igroupid, $imask)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetGroupState

Func _GUICtrlListView_GetGroupViewEnabled($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_ISGROUPVIEWENABLED) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_ISGROUPVIEWENABLED, 0x0, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_GetGroupViewEnabled

Func _GUICtrlListView_GetHeader($hwnd)
    If IsHWnd($hwnd) Then
        Return HWnd(_SendMessage($hwnd, $LVM_GETHEADER))
    Else
        Return HWnd(GUICtrlSendMsg($hwnd, $LVM_GETHEADER, 0x0, 0x0))
    EndIf
EndFunc    ; -> _GUICtrlListView_GetHeader

Func _GUICtrlListView_GetHotCursor($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETHOTCURSOR, 0x0, 0x0, 0x0, "wparam", "lparam", "handle")
    Else
        Return Ptr(GUICtrlSendMsg($hwnd, $LVM_GETHOTCURSOR, 0x0, 0x0))
    EndIf
EndFunc    ; -> _GUICtrlListView_GetHotCursor

Func _GUICtrlListView_GetHotItem($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETHOTITEM)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETHOTITEM, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetHotItem

Func _GUICtrlListView_GetHoverTime($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETHOVERTIME)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETHOVERTIME, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetHoverTime

Func _GUICtrlListView_GetImageList($hwnd, $iimagelist)
    Local $aimagelist[0x3] = [$LVSIL_NORMAL, $LVSIL_SMALL, $LVSIL_STATE]
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETIMAGELIST, $aimagelist[$iimagelist], 0x0, 0x0, "wparam", "lparam", "handle")
    Else
        Return Ptr(GUICtrlSendMsg($hwnd, $LVM_GETIMAGELIST, $aimagelist[$iimagelist], 0x0))
    EndIf
EndFunc    ; -> _GUICtrlListView_GetImageList

Func _GUICtrlListView_GetInsertMark($hwnd)
    Local $tmark = DllStructCreate($TAGLVINSERTMARK)
    Local $imark = DllStructGetSize($tmark)
    DllStructSetData($tmark, "Size", $imark)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_GETINSERTMARK, 0x0, $tmark, 0x0, True, + -1)
    Local $amark[0x2]
    $amark[0x0] = DllStructGetData($tmark, "Flags") = $LVIM_AFTER
    $amark[0x1] = DllStructGetData($tmark, "Item")
    Return SetError($iret = 0x0, 0x0, $amark)
EndFunc    ; -> _GUICtrlListView_GetInsertMark

Func _GUICtrlListView_GetInsertMarkColor($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETINSERTMARKCOLOR, $LVSIL_STATE)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETINSERTMARKCOLOR, $LVSIL_STATE, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetInsertMarkColor

Func _GUICtrlListView_GetInsertMarkRect($hwnd)
    Local $trect = DllStructCreate($TAGRECT)
    Local $arect[0x5]
    $arect[0x0] = __guictrl_sendmsg($hwnd, $LVM_GETINSERTMARKRECT, 0x0, $trect, 0x0, True, + -1)
    $arect[0x1] = DllStructGetData($trect, "Left")
    $arect[0x2] = DllStructGetData($trect, "Top")
    $arect[0x3] = DllStructGetData($trect, "Right")
    $arect[0x4] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlListView_GetInsertMarkRect

Func _GUICtrlListView_GetISearchString($hwnd)
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_GETISEARCHSTRINGW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_GETISEARCHSTRINGA
    EndIf
    Local $ibuffer
    If IsHWnd($hwnd) Then
        $ibuffer = _SendMessage($hwnd, $imsg) + 0x1
    Else
        $ibuffer = GUICtrlSendMsg($hwnd, $imsg, 0x0, 0x0) + 0x1
    EndIf
    If $ibuffer = 0x1 Then Return ''
    __guictrl_sendmsg($hwnd, $imsg, 0x0, $tbuffer, 0x0, True, + -1)
    Return DllStructGetData($tbuffer, 0x1)
EndFunc    ; -> _GUICtrlListView_GetISearchString

Func _GUICtrlListView_GetItem($hwnd, $iindex, $isubitem = 0x0)
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", $isubitem)
    DllStructSetData($titem, "StateMask", + -1)
    _GUICtrlListView_GetItemEx($hwnd, $titem)
    Local $istate = DllStructGetData($titem, "State")
    Local $aitem[0x8]
    If BitAND($istate, $LVIS_CUT) <> 0x0 Then $aitem[0x0] = BitOR($aitem[0x0], 0x1)
    If BitAND($istate, $LVIS_DROPHILITED) <> 0x0 Then $aitem[0x0] = BitOR($aitem[0x0], 0x2)
    If BitAND($istate, $LVIS_FOCUSED) <> 0x0 Then $aitem[0x0] = BitOR($aitem[0x0], 0x4)
    If BitAND($istate, $LVIS_SELECTED) <> 0x0 Then $aitem[0x0] = BitOR($aitem[0x0], 0x8)
    $aitem[0x1] = __GUICtrlListView_OverlayImageMaskToIndex($istate)
    $aitem[0x2] = __GUICtrlListView_StateImageMaskToIndex($istate)
    $aitem[0x3] = _GUICtrlListView_GetItemText($hwnd, $iindex, $isubitem)
    $aitem[0x4] = DllStructGetData($titem, "Image")
    $aitem[0x5] = DllStructGetData($titem, "Param")
    $aitem[0x6] = DllStructGetData($titem, "Indent")
    $aitem[0x7] = DllStructGetData($titem, "GroupID")
    Return $aitem
EndFunc    ; -> _GUICtrlListView_GetItem

Func _GUICtrlListView_GetItemChecked($hwnd, $iindex)
    Local $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $imsg = $LVM_GETITEMW
    Else
        $imsg = $LVM_GETITEMA
    EndIf
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_STATE)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", 0x0)
    DllStructSetData($titem, "StateMask", 0xffff)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, 0x0, True, + -1)
    If Not $iret Then Return SetError($LV_ERR, $LV_ERR, False)
    Return BitAND(DllStructGetData($titem, "State"), 0x2000) <> 0x0
EndFunc    ; -> _GUICtrlListView_GetItemChecked

Func _GUICtrlListView_GetItemCount($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETITEMCOUNT)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETITEMCOUNT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetItemCount

Func _GUICtrlListView_GetItemCut($hwnd, $iindex)
    Return _GUICtrlListView_GetItemState($hwnd, $iindex, $LVIS_CUT) <> 0x0
EndFunc    ; -> _GUICtrlListView_GetItemCut

Func _GUICtrlListView_GetItemDropHilited($hwnd, $iindex)
    Return _GUICtrlListView_GetItemState($hwnd, $iindex, $LVIS_DROPHILITED) <> 0x0
EndFunc    ; -> _GUICtrlListView_GetItemDropHilited

Func _GUICtrlListView_GetItemEx($hwnd, ByRef $titem)
    Local $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $imsg = $LVM_GETITEMW
    Else
        $imsg = $LVM_GETITEMA
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, 0x0, True, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_GetItemEx

Func _GUICtrlListView_GetItemFocused($hwnd, $iindex)
    Return _GUICtrlListView_GetItemState($hwnd, $iindex, $LVIS_FOCUSED) <> 0x0
EndFunc    ; -> _GUICtrlListView_GetItemFocused

Func _GUICtrlListView_GetItemGroupID($hwnd, $iindex)
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_GROUPID)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", 0x0)
    _GUICtrlListView_GetItemEx($hwnd, $titem)
    Return DllStructGetData($titem, "GroupID")
EndFunc    ; -> _GUICtrlListView_GetItemGroupID

Func _GUICtrlListView_GetItemImage($hwnd, $iindex, $isubitem = 0x0)
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_IMAGE)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", $isubitem)
    _GUICtrlListView_GetItemEx($hwnd, $titem)
    Return DllStructGetData($titem, "Image")
EndFunc    ; -> _GUICtrlListView_GetItemImage

Func _GUICtrlListView_GetItemIndent($hwnd, $iindex)
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_INDENT)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", 0x0)
    _GUICtrlListView_GetItemEx($hwnd, $titem)
    Return DllStructGetData($titem, "Indent")
EndFunc    ; -> _GUICtrlListView_GetItemIndent

Func __GUICtrlListView_GetItemOverlayImage($hwnd, $iindex)
    Return BitShift(_GUICtrlListView_GetItemState($hwnd, $iindex, $LVIS_OVERLAYMASK), 0x8)
EndFunc    ; -> __GUICtrlListView_GetItemOverlayImage

Func _GUICtrlListView_GetItemParam($hwnd, $iindex)
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_PARAM)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", 0x0)
    _GUICtrlListView_GetItemEx($hwnd, $titem)
    Return DllStructGetData($titem, "Param")
EndFunc    ; -> _GUICtrlListView_GetItemParam

Func _GUICtrlListView_GetItemPosition($hwnd, $iindex)
    Local $tpoint = DllStructCreate($TAGPOINT)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_GETITEMPOSITION, $iindex, $tpoint, 0x0, True, + -1)
    Local $APOINT[0x2]
    If Not $iret Then Return $APOINT
    $APOINT[0x0] = DllStructGetData($tpoint, "X")
    $APOINT[0x1] = DllStructGetData($tpoint, "Y")
    Return $APOINT
EndFunc    ; -> _GUICtrlListView_GetItemPosition

Func _GUICtrlListView_GetItemPositionX($hwnd, $iindex)
    Local $APOINT = _GUICtrlListView_GetItemPosition($hwnd, $iindex)
    Return $APOINT[0x0]
EndFunc    ; -> _GUICtrlListView_GetItemPositionX

Func _GUICtrlListView_GetItemPositionY($hwnd, $iindex)
    Local $APOINT = _GUICtrlListView_GetItemPosition($hwnd, $iindex)
    Return $APOINT[0x1]
EndFunc    ; -> _GUICtrlListView_GetItemPositionY

Func _GUICtrlListView_GetItemRect($hwnd, $iindex, $ipart = 0x3)
    Local $trect = _GUICtrlListView_GetItemRectEx($hwnd, $iindex, $ipart)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlListView_GetItemRect

Func _GUICtrlListView_GetItemRectEx($hwnd, $iindex, $ipart = 0x3)
    Local $trect = DllStructCreate($TAGRECT)
    DllStructSetData($trect, "Left", $ipart)
    __guictrl_sendmsg($hwnd, $LVM_GETITEMRECT, $iindex, $trect, 0x0, True, + -1)
    Return $trect
EndFunc    ; -> _GUICtrlListView_GetItemRectEx

Func _GUICtrlListView_GetItemSelected($hwnd, $iindex)
    Return _GUICtrlListView_GetItemState($hwnd, $iindex, $LVIS_SELECTED) <> 0x0
EndFunc    ; -> _GUICtrlListView_GetItemSelected

Func _GUICtrlListView_GetItemSpacing($hwnd, $bsmall = False)
    Local $ispace
    If IsHWnd($hwnd) Then
        $ispace = _SendMessage($hwnd, $LVM_GETITEMSPACING, $bsmall)
    Else
        $ispace = GUICtrlSendMsg($hwnd, $LVM_GETITEMSPACING, $bsmall, 0x0)
    EndIf
    Local $aspace[0x2]
    $aspace[0x0] = BitAND($ispace, 0xffff)
    $aspace[0x1] = BitShift($ispace, 0x10)
    Return $aspace
EndFunc    ; -> _GUICtrlListView_GetItemSpacing

Func _GUICtrlListView_GetItemSpacingX($hwnd, $bsmall = False)
    If IsHWnd($hwnd) Then
        Return BitAND(_SendMessage($hwnd, $LVM_GETITEMSPACING, $bsmall, 0x0), 0xffff)
    Else
        Return BitAND(GUICtrlSendMsg($hwnd, $LVM_GETITEMSPACING, $bsmall, 0x0), 0xffff)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetItemSpacingX

Func _GUICtrlListView_GetItemSpacingY($hwnd, $bsmall = False)
    If IsHWnd($hwnd) Then
        Return BitShift(_SendMessage($hwnd, $LVM_GETITEMSPACING, $bsmall, 0x0), 0x10)
    Else
        Return BitShift(GUICtrlSendMsg($hwnd, $LVM_GETITEMSPACING, $bsmall, 0x0), 0x10)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetItemSpacingY

Func _GUICtrlListView_GetItemState($hwnd, $iindex, $imask)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETITEMSTATE, $iindex, $imask)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETITEMSTATE, $iindex, $imask)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetItemState

Func _GUICtrlListView_GetItemStateImage($hwnd, $iindex)
    Return BitShift(_GUICtrlListView_GetItemState($hwnd, $iindex, $LVIS_STATEIMAGEMASK), 0xc)
EndFunc    ; -> _GUICtrlListView_GetItemStateImage

Func _GUICtrlListView_GetItemText($hwnd, $iindex, $isubitem = 0x0)
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_GETITEMTEXTW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_GETITEMTEXTA
    EndIf
    Local $titem = $__g_tlistviewitem
    DllStructSetData($tbuffer, 0x1, '')
    DllStructSetData($titem, "Mask", $LVIF_TEXT)
    DllStructSetData($titem, "SubItem", $isubitem)
    __guictrl_sendmsg($hwnd, $imsg, $iindex, $titem, $tbuffer, False, 0x6, True)
    Return DllStructGetData($tbuffer, 0x1)
EndFunc    ; -> _GUICtrlListView_GetItemText

Func _GUICtrlListView_GetItemTextArray($hwnd, $iitem = + -1)
    Local $sitems = _GUICtrlListView_GetItemTextString($hwnd, $iitem)
    If $sitems = '' Then
        Local $aitems[0x1] = [0x0]
        Return SetError($LV_ERR, $LV_ERR, $aitems)
    EndIf
    Return StringSplit($sitems, Opt("GUIDataSeparatorChar"))
EndFunc    ; -> _GUICtrlListView_GetItemTextArray

Func _GUICtrlListView_GetItemTextString($hwnd, $iitem = + -1)
    Local $srow = '', $sseparatorchar = Opt("GUIDataSeparatorChar"), $iselected
    If $iitem = + -1 Then
        $iselected = _GUICtrlListView_GetNextItem($hwnd)
    Else
        $iselected = $iitem
    EndIf
    If $iselected < 0x0 Or $iselected > _GUICtrlListView_GetItemCount($hwnd) + -1 Then Return SetError(0x1, 0x0, 0x0)
    For $x = 0x0 To _GUICtrlListView_GetColumnCount($hwnd) + -1
        $srow &= _GUICtrlListView_GetItemText($hwnd, $iselected, $x) & $sseparatorchar
    Next
    Return StringTrimRight($srow, 0x1)
EndFunc    ; -> _GUICtrlListView_GetItemTextString

Func _GUICtrlListView_GetNextItem($hwnd, $istart = + -1, $isearch = 0x0, $istate = 0x8)
    Local $asearch[0x5] = [$LVNI_ALL, $LVNI_ABOVE, $LVNI_BELOW, $LVNI_TOLEFT, $LVNI_TORIGHT]
    Local $IFLAGS = $asearch[$isearch]
    If BitAND($istate, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $LVNI_CUT)
    If BitAND($istate, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $LVNI_DROPHILITED)
    If BitAND($istate, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $LVNI_FOCUSED)
    If BitAND($istate, 0x8) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $LVNI_SELECTED)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETNEXTITEM, $istart, $IFLAGS)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETNEXTITEM, $istart, $IFLAGS)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetNextItem

Func _GUICtrlListView_GetNumberOfWorkAreas($hwnd)
    Local $tdata = DllStructCreate("int Data")
    __guictrl_sendmsg($hwnd, $LVM_GETNUMBEROFWORKAREAS, 0x0, $tdata, 0x0, True, + -1)
    Return DllStructGetData($tdata, "Data")
EndFunc    ; -> _GUICtrlListView_GetNumberOfWorkAreas

Func _GUICtrlListView_GetOrigin($hwnd)
    Local $tpoint = DllStructCreate($TAGPOINT)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_GETORIGIN, 0x0, $tpoint, 0x0, True, + -1)
    Local $aorigin[0x2]
    $aorigin[0x0] = DllStructGetData($tpoint, "X")
    $aorigin[0x1] = DllStructGetData($tpoint, "Y")
    Return SetError(@error, $iret = 0x1, $aorigin)
EndFunc    ; -> _GUICtrlListView_GetOrigin

Func _GUICtrlListView_GetOriginX($hwnd)
    Local $aorigin = _GUICtrlListView_GetOrigin($hwnd)
    Return $aorigin[0x0]
EndFunc    ; -> _GUICtrlListView_GetOriginX

Func _GUICtrlListView_GetOriginY($hwnd)
    Local $aorigin = _GUICtrlListView_GetOrigin($hwnd)
    Return $aorigin[0x1]
EndFunc    ; -> _GUICtrlListView_GetOriginY

Func _GUICtrlListView_GetOutlineColor($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETOUTLINECOLOR)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETOUTLINECOLOR, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetOutlineColor

Func _GUICtrlListView_GetSelectedColumn($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETSELECTEDCOLUMN)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETSELECTEDCOLUMN, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetSelectedColumn

Func _GUICtrlListView_GetSelectedCount($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETSELECTEDCOUNT)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETSELECTEDCOUNT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetSelectedCount

Func __GUICtrlListView_GetCheckedIndices($hwnd)
    Local $icount = _GUICtrlListView_GetItemCount($hwnd)
    Local $aselected[$icount + 0x1] = [0x0]
    For $i = 0x0 To $icount + -1
        If _GUICtrlListView_GetItemChecked($hwnd, $i) Then
            $aselected[0x0]+= 0x1
            $aselected[$aselected[0x0]] = $i
        EndIf
    Next
    ReDim $aselected[$aselected[0x0] + 0x1]
    Return $aselected
EndFunc    ; -> __GUICtrlListView_GetCheckedIndices

Func _GUICtrlListView_GetSelectedIndices($hwnd, $barray = False)
    Local $sindices, $aindices[0x1] = [0x0]
    Local $iselectedcount = _GUICtrlListView_GetSelectedCount($hwnd)
    If $iselectedcount Then
        Local $iselected, $istart = + -1
        For $i = 0x1 To $iselectedcount
            If IsHWnd($hwnd) Then
                $iselected = _SendMessage($hwnd, $LVM_GETNEXTITEM, $istart, $LVNI_SELECTED)
            Else
                $iselected = GUICtrlSendMsg($hwnd, $LVM_GETNEXTITEM, $istart, $LVNI_SELECTED)
            EndIf
            If (Not $barray) Then
                If StringLen($sindices) Then
                    $sindices &= "|" & $iselected
                Else
                    $sindices = $iselected
                EndIf
            Else
                ReDim $aindices[UBound($aindices) + 0x1]
                $aindices[0x0] = UBound($aindices) + -1
                $aindices[UBound($aindices) + -1] = $iselected
            EndIf
            $istart = $iselected
        Next
    EndIf
    If (Not $barray) Then
        Return String($sindices)
    Else
        Return $aindices
    EndIf
EndFunc    ; -> _GUICtrlListView_GetSelectedIndices

Func _GUICtrlListView_GetSelectionMark($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETSELECTIONMARK)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETSELECTIONMARK, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetSelectionMark

Func _GUICtrlListView_GetStringWidth($hwnd, $sstring)
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_GETSTRINGWIDTHW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_GETSTRINGWIDTHA
    EndIf
    DllStructSetData($tbuffer, 0x1, $sstring)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $tbuffer, 0x0, True, + -1)
    Return $iret
EndFunc    ; -> _GUICtrlListView_GetStringWidth

Func _GUICtrlListView_GetSubItemRect($hwnd, $iindex, $isubitem, $ipart = 0x0)
    Local $apart[0x2] = [$LVIR_BOUNDS, $LVIR_ICON]
    Local $trect = DllStructCreate($TAGRECT)
    DllStructSetData($trect, "Top", $isubitem)
    DllStructSetData($trect, "Left", $apart[$ipart])
    __guictrl_sendmsg($hwnd, $LVM_GETSUBITEMRECT, $iindex, $trect, 0x0, True, + -1)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlListView_GetSubItemRect

Func _GUICtrlListView_GetTextBkColor($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETTEXTBKCOLOR)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETTEXTBKCOLOR, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetTextBkColor

Func _GUICtrlListView_GetTextColor($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETTEXTCOLOR)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETTEXTCOLOR, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetTextColor

Func _GUICtrlListView_GetToolTips($hwnd)
    If IsHWnd($hwnd) Then
        Return HWnd(_SendMessage($hwnd, $LVM_GETTOOLTIPS))
    Else
        Return HWnd(GUICtrlSendMsg($hwnd, $LVM_GETTOOLTIPS, 0x0, 0x0))
    EndIf
EndFunc    ; -> _GUICtrlListView_GetToolTips

Func _GUICtrlListView_GetTopIndex($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETTOPINDEX)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETTOPINDEX, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_GetTopIndex

Func _GUICtrlListView_GetUnicodeFormat($hwnd)
    If Not IsDllStruct($__g_tlistviewbuffer) Then
        $__g_tlistviewbuffer = DllStructCreate("wchar Text[4096]")
        $__g_tlistviewbufferansi = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_tlistviewbuffer))
    EndIf
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_GETUNICODEFORMAT) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_GETUNICODEFORMAT, 0x0, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_GetUnicodeFormat

Func _GUICtrlListView_GetView($hwnd)
    Local $iview
    If IsHWnd($hwnd) Then
        $iview = _SendMessage($hwnd, $LVM_GETVIEW)
    Else
        $iview = GUICtrlSendMsg($hwnd, $LVM_GETVIEW, 0x0, 0x0)
    EndIf
    Switch $iview
    Case $LV_VIEW_ICON
        Return Int($LV_VIEW_ICON)
    Case $LV_VIEW_DETAILS
        Return Int($LV_VIEW_DETAILS)
    Case $LV_VIEW_LIST
        Return Int($LV_VIEW_LIST)
    Case $LV_VIEW_SMALLICON
        Return Int($LV_VIEW_SMALLICON)
    Case $LV_VIEW_TILE
        Return Int($LV_VIEW_TILE)
    Case Else
        Return + -1
    EndSwitch
EndFunc    ; -> _GUICtrlListView_GetView

Func _GUICtrlListView_GetViewDetails($hwnd)
    Return _GUICtrlListView_GetView($hwnd) = $LV_VIEW_DETAILS
EndFunc    ; -> _GUICtrlListView_GetViewDetails

Func _GUICtrlListView_GetViewLarge($hwnd)
    Return _GUICtrlListView_GetView($hwnd) = $LV_VIEW_ICON
EndFunc    ; -> _GUICtrlListView_GetViewLarge

Func _GUICtrlListView_GetViewList($hwnd)
    Return _GUICtrlListView_GetView($hwnd) = $LV_VIEW_LIST
EndFunc    ; -> _GUICtrlListView_GetViewList

Func _GUICtrlListView_GetViewSmall($hwnd)
    Return _GUICtrlListView_GetView($hwnd) = $LV_VIEW_SMALLICON
EndFunc    ; -> _GUICtrlListView_GetViewSmall

Func _GUICtrlListView_GetViewTile($hwnd)
    Return _GUICtrlListView_GetView($hwnd) = $LV_VIEW_TILE
EndFunc    ; -> _GUICtrlListView_GetViewTile

Func _GUICtrlListView_GetViewRect($hwnd)
    Local $arect[0x4] = [0x0, 0x0, 0x0, 0x0]
    Local $iview = _GUICtrlListView_GetView($hwnd)
    If ($iview < 0x0) And ($iview > 0x4) Then Return $arect
    Local $trect = DllStructCreate($TAGRECT)
    __guictrl_sendmsg($hwnd, $LVM_GETVIEWRECT, 0x0, $trect, 0x0, True, + -1)
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlListView_GetViewRect

Func _GUICtrlListView_HideColumn($hwnd, $icol)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETCOLUMNWIDTH, $icol) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETCOLUMNWIDTH, $icol, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_HideColumn

Func _GUICtrlListView_HitTest($hwnd, $ix = + -1, $iy = + -1)
    Local $imode = Opt("MouseCoordMode", 0x1)
    Local $apos = MouseGetPos()
    Opt("MouseCoordMode", $imode)
    Local $tpoint = DllStructCreate($TAGPOINT)
    DllStructSetData($tpoint, "X", $apos[0x0])
    DllStructSetData($tpoint, "Y", $apos[0x1])
    Local $acall = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hwnd, "struct*", $tpoint)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = 0x0 Then Return 0x0
    If $ix = + -1 Then $ix = DllStructGetData($tpoint, "X")
    If $iy = + -1 Then $iy = DllStructGetData($tpoint, "Y")
    Local $ttest = DllStructCreate($TAGLVHITTESTINFO)
    DllStructSetData($ttest, "X", $ix)
    DllStructSetData($ttest, "Y", $iy)
    Local $atest[0xa]
    $atest[0x0] = __guictrl_sendmsg($hwnd, $LVM_HITTEST, 0x0, $ttest, 0x0, True, + -1)
    Local $IFLAGS = DllStructGetData($ttest, "Flags")
    $atest[0x1] = BitAND($IFLAGS, $LVHT_NOWHERE) <> 0x0
    $atest[0x2] = BitAND($IFLAGS, $LVHT_ONITEMICON) <> 0x0
    $atest[0x3] = BitAND($IFLAGS, $LVHT_ONITEMLABEL) <> 0x0
    $atest[0x4] = BitAND($IFLAGS, $LVHT_ONITEMSTATEICON) <> 0x0
    $atest[0x5] = BitAND($IFLAGS, $LVHT_ONITEM) <> 0x0
    $atest[0x6] = BitAND($IFLAGS, $LVHT_ABOVE) <> 0x0
    $atest[0x7] = BitAND($IFLAGS, $LVHT_BELOW) <> 0x0
    $atest[0x8] = BitAND($IFLAGS, $LVHT_TOLEFT) <> 0x0
    $atest[0x9] = BitAND($IFLAGS, $LVHT_TORIGHT) <> 0x0
    Return $atest
EndFunc    ; -> _GUICtrlListView_HitTest

Func __GUICtrlListView_IndexToOverlayImageMask($iindex)
    Return BitShift($iindex, + -8)
EndFunc    ; -> __GUICtrlListView_IndexToOverlayImageMask

Func __GUICtrlListView_IndexToStateImageMask($iindex)
    Return BitShift($iindex, + -12)
EndFunc    ; -> __GUICtrlListView_IndexToStateImageMask

Func _GUICtrlListView_InsertColumn($hwnd, $iindex, $stext, $iwidth = 0x32, $ialign = + -1, $iimage = + -1, $bonright = False)
    Local $aalign[0x3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_INSERTCOLUMNW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_INSERTCOLUMNA
    EndIf
    Local $tcolumn = DllStructCreate($TAGLVCOLUMN)
    Local $imask = BitOR($LVCF_FMT, $LVCF_WIDTH, $LVCF_TEXT)
    If $ialign < 0x0 Or $ialign > 0x2 Then $ialign = 0x0
    Local $ifmt = $aalign[$ialign]
    If $iimage <> + -1 Then
        $imask = BitOR($imask, $LVCF_IMAGE)
        $ifmt = BitOR($ifmt, $LVCFMT_COL_HAS_IMAGES, $LVCFMT_IMAGE)
    EndIf
    If $bonright Then $ifmt = BitOR($ifmt, $LVCFMT_BITMAP_ON_RIGHT)
    DllStructSetData($tbuffer, 0x1, $stext)
    DllStructSetData($tcolumn, "Mask", $imask)
    DllStructSetData($tcolumn, "Fmt", $ifmt)
    DllStructSetData($tcolumn, "CX", $iwidth)
    DllStructSetData($tcolumn, "Image", $iimage)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $tcolumn, $tbuffer, False, 0x4)
    If $ialign > 0x0 Then _GUICtrlListView_SetColumn($hwnd, $iret, $stext, $iwidth, $ialign, $iimage, $bonright)
    Return $iret
EndFunc    ; -> _GUICtrlListView_InsertColumn

Func _GUICtrlListView_InsertGroup($hwnd, $iindex, $igroupid, $SHEADER, $ialign = 0x0)
    Local $aalign[0x3] = [$LVGA_HEADER_LEFT, $LVGA_HEADER_CENTER, $LVGA_HEADER_RIGHT]
    If $ialign < 0x0 Or $ialign > 0x2 Then $ialign = 0x0
    Local $theader = _WinAPI_MultiByteToWideChar($SHEADER)
    Local $tgroup = DllStructCreate($TAGLVGROUP)
    Local $imask = BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_GROUPID)
    DllStructSetData($tgroup, "Size", DllStructGetSize($tgroup))
    DllStructSetData($tgroup, "Mask", $imask)
    DllStructSetData($tgroup, "GroupID", $igroupid)
    DllStructSetData($tgroup, "Align", $aalign[$ialign])
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_INSERTGROUP, $iindex, $tgroup, $theader, False, 0x3)
    Return $iret
EndFunc    ; -> _GUICtrlListView_InsertGroup

Func _GUICtrlListView_InsertItem($hwnd, $stext, $iindex = + -1, $iimage = + -1, $iparam = 0x0)
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_INSERTITEMW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_INSERTITEMA
    EndIf
    Local $titem = $__g_tlistviewitem
    If $iindex = + -1 Then $iindex = 0x3b9ac9ff
    DllStructSetData($tbuffer, 0x1, $stext)
    Local $imask = BitOR($LVIF_TEXT, $LVIF_PARAM)
    If $iimage >= 0x0 Then $imask = BitOR($imask, $LVIF_IMAGE)
    DllStructSetData($titem, "Mask", $imask)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", 0x0)
    DllStructSetData($titem, "Image", $iimage)
    DllStructSetData($titem, "Param", $iparam)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, $tbuffer, False, 0x6)
    Return $iret
EndFunc    ; -> _GUICtrlListView_InsertItem

Func _GUICtrlListView_InsertMarkHitTest($hwnd, $ix = + -1, $iy = + -1)
    Local $imode = Opt("MouseCoordMode", 0x1)
    Local $apos = MouseGetPos()
    Opt("MouseCoordMode", $imode)
    Local $tpoint = DllStructCreate($TAGPOINT)
    DllStructSetData($tpoint, "X", $apos[0x0])
    DllStructSetData($tpoint, "Y", $apos[0x1])
    Local $acall = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hwnd, "struct*", $tpoint)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = 0x0 Then Return 0x0
    If $ix = + -1 Then $ix = DllStructGetData($tpoint, "X")
    If $iy = + -1 Then $iy = DllStructGetData($tpoint, "Y")
    Local $tmark = DllStructCreate($TAGLVINSERTMARK)
    DllStructSetData($tpoint, "X", $ix)
    DllStructSetData($tpoint, "Y", $iy)
    DllStructSetData($tmark, "Size", DllStructGetSize($tmark))
    __guictrl_sendmsg($hwnd, $LVM_INSERTMARKHITTEST, DllStructGetPtr($tpoint), $tmark, $tpoint, True, + -1, False, 0x0)
    Local $atest[0x2]
    $atest[0x0] = DllStructGetData($tmark, "Flags") = $LVIM_AFTER
    $atest[0x1] = DllStructGetData($tmark, "Item")
    Return $atest
EndFunc    ; -> _GUICtrlListView_InsertMarkHitTest

Func _GUICtrlListView_IsItemVisible($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_ISITEMVISIBLE, $iindex) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_ISITEMVISIBLE, $iindex, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_IsItemVisible

Func _GUICtrlListView_JustifyColumn($hwnd, $iindex, $ialign = + -1)
    Local $aalign[0x3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
    Local $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $imsg = $LVM_SETCOLUMNW
    Else
        $imsg = $LVM_SETCOLUMNA
    EndIf
    Local $tcolumn = DllStructCreate($TAGLVCOLUMN)
    If $ialign < 0x0 Or $ialign > 0x2 Then $ialign = 0x0
    Local $imask = $LVCF_FMT
    Local $ifmt = $aalign[$ialign]
    DllStructSetData($tcolumn, "Mask", $imask)
    DllStructSetData($tcolumn, "Fmt", $ifmt)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $tcolumn, 0x0, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_JustifyColumn

Func _GUICtrlListView_MapIDToIndex($hwnd, $iid)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_MAPIDTOINDEX, $iid)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_MAPIDTOINDEX, $iid, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_MapIDToIndex

Func _GUICtrlListView_MapIndexToID($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_MAPINDEXTOID, $iindex)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_MAPINDEXTOID, $iindex, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_MapIndexToID

Func _GUICtrlListView_MoveGroup($hwnd, $igroupid, $iindex = + -1)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_MOVEGROUP, $igroupid, $iindex)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_MOVEGROUP, $igroupid, $iindex)
    EndIf
EndFunc    ; -> _GUICtrlListView_MoveGroup

Func __GUICtrlListView_OverlayImageMaskToIndex($imask)
    Return BitShift(BitAND($LVIS_OVERLAYMASK, $imask), 0x8)
EndFunc    ; -> __GUICtrlListView_OverlayImageMaskToIndex

Func _GUICtrlListView_RedrawItems($hwnd, $ifirst, $ilast)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_REDRAWITEMS, $ifirst, $ilast) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_REDRAWITEMS, $ifirst, $ilast) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_RedrawItems

Func _GUICtrlListView_RegisterSortCallBack($hwnd, $vcomparetype = 0x1, $barrows = True, $sprivatecallback = "__GUICtrlListView_Sort")
    #Au3Stripper_Ignore_Funcs=$sPrivateCallBack
    If IsBool($vcomparetype) Then $vcomparetype = ($vcomparetype) ? 0x1  : 0x0
    Local $hheader = _GUICtrlListView_GetHeader($hwnd)
    ReDim $__g_alistviewsortinfo[UBound($__g_alistviewsortinfo) + 0x1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
    $__g_alistviewsortinfo[0x0][0x0] = UBound($__g_alistviewsortinfo) + -1
    Local $iindex = $__g_alistviewsortinfo[0x0][0x0]
    $__g_alistviewsortinfo[$iindex][0x0] = _GUICtrlListView_GetUnicodeFormat($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    $__g_alistviewsortinfo[$iindex][0x1] = $hwnd
    $__g_alistviewsortinfo[$iindex][0x2] = DllCallbackRegister($sprivatecallback, "int", "int;int;hwnd")
    $__g_alistviewsortinfo[$iindex][0x3] = + -1
    $__g_alistviewsortinfo[$iindex][0x4] = + -1
    $__g_alistviewsortinfo[$iindex][0x5] = 0x1
    $__g_alistviewsortinfo[$iindex][0x6] = + -1
    $__g_alistviewsortinfo[$iindex][0x7] = 0x0
    $__g_alistviewsortinfo[$iindex][0x8] = $vcomparetype
    $__g_alistviewsortinfo[$iindex][0x9] = $barrows
    $__g_alistviewsortinfo[$iindex][0xa] = $hheader
    Return $__g_alistviewsortinfo[$iindex][0x2] <> 0x0
EndFunc    ; -> _GUICtrlListView_RegisterSortCallBack

Func _GUICtrlListView_RemoveAllGroups($hwnd)
    _GUICtrlListView_BeginUpdate($hwnd)
    Local $igroupid
    For $x = _GUICtrlListView_GetGroupCount($hwnd) + -1 To 0x0 Step + -1
        $igroupid = _GUICtrlListView_GetGroupInfoByIndex($hwnd, $x)[0x2]
        _GUICtrlListView_RemoveGroup($hwnd, $igroupid)
    Next
    _GUICtrlListView_EndUpdate($hwnd)
EndFunc    ; -> _GUICtrlListView_RemoveAllGroups

Func _GUICtrlListView_RemoveGroup($hwnd, $igroupid)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_REMOVEGROUP, $igroupid)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_REMOVEGROUP, $igroupid, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_RemoveGroup

Func __GUICtrlListView_ReverseColorOrder($icolor)
    Local $sh = Hex(String($icolor), 0x6)
    Return "0x" & StringMid($sh, 0x5, 0x2) & StringMid($sh, 0x3, 0x2) & StringMid($sh, 0x1, 0x2)
EndFunc    ; -> __GUICtrlListView_ReverseColorOrder

Func _GUICtrlListView_Scroll($hwnd, $idx, $idy)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SCROLL, $idx, $idy) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SCROLL, $idx, $idy) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_Scroll

Func _GUICtrlListView_SetBkColor($hwnd, $icolor)
    Local $iret
    If IsHWnd($hwnd) Then
        $iret = _SendMessage($hwnd, $LVM_SETBKCOLOR, 0x0, $icolor)
    Else
        $iret = GUICtrlSendMsg($hwnd, $LVM_SETBKCOLOR, 0x0, $icolor)
    EndIf
    _WinAPI_InvalidateRect($hwnd)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetBkColor

Func _guictrllistview_setbkhbitmap($hwnd, $hbitmap, $istyle = 0x0, $ixoffset = 0x0, $iyoffset = 0x0, $bdeletebitmap = False)
    Local $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $imsg = $LVM_SETBKIMAGEW
    Else
        $imsg = $LVM_SETBKIMAGEA
    EndIf
    Local $IFLAGS = BitOR($LVBKIF_STYLE_TILE, $LVBKIF_FLAG_TILEOFFSET)
    If $ixoffset = Default Then $ixoffset = 0x0
    If $iyoffset = Default Then $iyoffset = 0x0
    If IsPtr($hbitmap) Then
        If (Not $istyle) Or ($istyle = Default) Then
            $IFLAGS = $LVBKIF_STYLE_NORMAL
        Else
            $ixoffset *= + -1
            $iyoffset *= + -1
        EndIf
        $IFLAGS = BitOR($IFLAGS, $LVBKIF_SOURCE_HBITMAP)
    Else
        $IFLAGS = $LVBKIF_SOURCE_NONE
    EndIf
    Local $tlvbkimage = DllStructCreate($TAGLVBKIMAGE)
    Local $plvbkimage = DllStructGetPtr($tlvbkimage)
    DllStructSetData($tlvbkimage, "Flags", $IFLAGS)
    DllStructSetData($tlvbkimage, "hBmp", $hbitmap)
    DllStructSetData($tlvbkimage, "XOffPercent", $ixoffset)
    DllStructSetData($tlvbkimage, "YOffPercent", $iyoffset)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $plvbkimage)
    If $bdeletebitmap And $iret Then DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hbitmap)
    If $IFLAGS = $LVBKIF_SOURCE_NONE Then Return True
    Return $iret <> 0x0
EndFunc    ; -> _guictrllistview_setbkhbitmap

Func _GUICtrlListView_SetBkImage($hwnd, $surl = '', $istyle = 0x0, $ixoffset = 0x0, $iyoffset = 0x0)
    Local $astyle[0x2] = [$LVBKIF_STYLE_NORMAL, $LVBKIF_STYLE_TILE]
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_SETBKIMAGEW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_SETBKIMAGEA
    EndIf
    Local $timage = DllStructCreate($TAGLVBKIMAGE)
    Local $IFLAGS = 0x0
    If $surl <> '' Then $IFLAGS = $LVBKIF_SOURCE_URL
    $IFLAGS = BitOR($IFLAGS, $astyle[$istyle])
    DllStructSetData($tbuffer, 0x1, $surl)
    DllStructSetData($timage, "Flags", $IFLAGS)
    DllStructSetData($timage, "XOffPercent", $ixoffset)
    DllStructSetData($timage, "YOffPercent", $iyoffset)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $timage, $tbuffer, False, 0x3, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetBkImage

Func _GUICtrlListView_SetCallBackMask($hwnd, $imask)
    Local $IFLAGS = 0x0
    If BitAND($imask, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $LVIS_CUT)
    If BitAND($imask, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $LVIS_DROPHILITED)
    If BitAND($imask, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $LVIS_FOCUSED)
    If BitAND($imask, 0x8) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $LVIS_SELECTED)
    If BitAND($imask, 0x10) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $LVIS_OVERLAYMASK)
    If BitAND($imask, 0x20) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $LVIS_STATEIMAGEMASK)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETCALLBACKMASK, $IFLAGS) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETCALLBACKMASK, $IFLAGS, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_SetCallBackMask

Func _GUICtrlListView_SetColumn($hwnd, $iindex, $stext, $iwidth = + -1, $ialign = + -1, $iimage = + -1, $bonright = False)
    Local $aalign[0x3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_SETCOLUMNW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_SETCOLUMNA
    EndIf
    Local $tcolumn = DllStructCreate($TAGLVCOLUMN)
    Local $imask = $LVCF_TEXT
    If $ialign < 0x0 Or $ialign > 0x2 Then $ialign = 0x0
    $imask = BitOR($imask, $LVCF_FMT)
    Local $ifmt = $aalign[$ialign]
    If $iwidth <> + -1 Then $imask = BitOR($imask, $LVCF_WIDTH)
    If $iimage <> + -1 Then
        $imask = BitOR($imask, $LVCF_IMAGE)
        $ifmt = BitOR($ifmt, $LVCFMT_COL_HAS_IMAGES, $LVCFMT_IMAGE)
    Else
        $iimage = 0x0
    EndIf
    If $bonright Then $ifmt = BitOR($ifmt, $LVCFMT_BITMAP_ON_RIGHT)
    DllStructSetData($tbuffer, 0x1, $stext)
    DllStructSetData($tcolumn, "Mask", $imask)
    DllStructSetData($tcolumn, "Fmt", $ifmt)
    DllStructSetData($tcolumn, "CX", $iwidth)
    DllStructSetData($tcolumn, "Image", $iimage)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $tcolumn, $tbuffer, False, 0x4)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetColumn

Func _GUICtrlListView_SetColumnOrder($hwnd, $sorder)
    Local $sseparatorchar = Opt("GUIDataSeparatorChar")
    Return _GUICtrlListView_SetColumnOrderArray($hwnd, StringSplit($sorder, $sseparatorchar))
EndFunc    ; -> _GUICtrlListView_SetColumnOrder

Func _GUICtrlListView_SetColumnOrderArray($hwnd, $aorder)
    Local $torders = DllStructCreate("int[" & $aorder[0x0] & "]")
    For $ii = 0x1 To $aorder[0x0]
        DllStructSetData($torders, 0x1, $aorder[$ii], $ii)
    Next
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_SETCOLUMNORDERARRAY, $aorder[0x0], $torders, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetColumnOrderArray

Func _GUICtrlListView_SetColumnWidth($hwnd, $icol, $iwidth)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETCOLUMNWIDTH, $icol, $iwidth)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETCOLUMNWIDTH, $icol, $iwidth)
    EndIf
EndFunc    ; -> _GUICtrlListView_SetColumnWidth

Func _GUICtrlListView_SetExtendedListViewStyle($hwnd, $iexstyle, $iexmask = 0x0)
    Local $iret
    If IsHWnd($hwnd) Then
        $iret = _SendMessage($hwnd, $LVM_SETEXTENDEDLISTVIEWSTYLE, $iexmask, $iexstyle)
    Else
        $iret = GUICtrlSendMsg($hwnd, $LVM_SETEXTENDEDLISTVIEWSTYLE, $iexmask, $iexstyle)
    EndIf
    _WinAPI_InvalidateRect($hwnd)
    Return $iret
EndFunc    ; -> _GUICtrlListView_SetExtendedListViewStyle

Func _GUICtrlListView_SetGroupInfo($hwnd, $igroupid, $SHEADER, $ialign = 0x0, $istate = $LVGS_NORMAL)
    Local $tgroup = 0x0
    If BitAND($istate, $LVGS_SELECTED) Then
        $tgroup = __GUICtrlListView_GetGroupInfoEx($hwnd, $igroupid, BitOR($LVGF_GROUPID, $LVGF_ITEMS))
        If @error Or DllStructGetData($tgroup, "cItems") = 0x0 Then Return False
    EndIf
    Local $aalign[0x3] = [$LVGA_HEADER_LEFT, $LVGA_HEADER_CENTER, $LVGA_HEADER_RIGHT]
    If $ialign < 0x0 Or $ialign > 0x2 Then $ialign = 0x0
    Local $theader = _WinAPI_MultiByteToWideChar($SHEADER)
    $tgroup = DllStructCreate($TAGLVGROUP)
    Local $imask = BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_STATE)
    DllStructSetData($tgroup, "Size", DllStructGetSize($tgroup))
    DllStructSetData($tgroup, "Mask", $imask)
    DllStructSetData($tgroup, "Align", $aalign[$ialign])
    DllStructSetData($tgroup, "State", $istate)
    DllStructSetData($tgroup, "StateMask", $istate)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_SETGROUPINFO, $igroupid, $tgroup, $theader, False, 0x3)
    DllStructSetData($tgroup, "Mask", $LVGF_GROUPID)
    DllStructSetData($tgroup, "GroupID", $igroupid)
    __guictrl_sendmsg($hwnd, $LVM_SETGROUPINFO, 0x0, $tgroup, 0x0, False, + -1)
    _WinAPI_InvalidateRect($hwnd)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetGroupInfo

Func _GUICtrlListView_SetHotCursor($hwnd, $hcursor)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETHOTCURSOR, 0x0, $hcursor, 0x0, "wparam", "handle", "handle")
    Else
        Return Ptr(GUICtrlSendMsg($hwnd, $LVM_SETHOTCURSOR, 0x0, $hcursor))
    EndIf
EndFunc    ; -> _GUICtrlListView_SetHotCursor

Func _GUICtrlListView_SetHotItem($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETHOTITEM, $iindex)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETHOTITEM, $iindex, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_SetHotItem

Func _GUICtrlListView_SetHoverTime($hwnd, $itime)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETHOVERTIME, 0x0, $itime)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETHOVERTIME, 0x0, $itime)
    EndIf
EndFunc    ; -> _GUICtrlListView_SetHoverTime

Func _GUICtrlListView_SetIconSpacing($hwnd, $icx, $icy)
    Local $iret, $apadding[0x2]
    If IsHWnd($hwnd) Then
        $iret = _SendMessage($hwnd, $LVM_SETICONSPACING, 0x0, _WinAPI_MakeLong($icx, $icy))
    Else
        $iret = GUICtrlSendMsg($hwnd, $LVM_SETICONSPACING, 0x0, _WinAPI_MakeLong($icx, $icy))
    EndIf
    _WinAPI_InvalidateRect($hwnd)
    $apadding[0x0] = BitAND($iret, 0xffff)
    $apadding[0x1] = BitShift($iret, 0x10)
    Return $apadding
EndFunc    ; -> _GUICtrlListView_SetIconSpacing

Func _GUICtrlListView_SetImageList($hwnd, $hhandle, $itype = 0x0)
    $itype = Int($itype)
    If $itype < 0x0 Or $itype > 0x2 Then
        $itype = 0x0
    EndIf
    Local $atype[0x3] = [$LVSIL_NORMAL, $LVSIL_SMALL, $LVSIL_STATE]
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETIMAGELIST, $atype[$itype], $hhandle, 0x0, "wparam", "handle", "handle")
    Else
        Return Ptr(GUICtrlSendMsg($hwnd, $LVM_SETIMAGELIST, $atype[$itype], $hhandle))
    EndIf
EndFunc    ; -> _GUICtrlListView_SetImageList

Func _GUICtrlListView_SetInfoTip($hwnd, $iindex, $stext, $isubitem = 0x0)
    Local $tbuffer = _WinAPI_MultiByteToWideChar($stext)
    Local $tinfo = DllStructCreate($TAGLVSETINFOTIP)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "Item", $iindex)
    DllStructSetData($tinfo, "SubItem", $isubitem)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_SETINFOTIP, 0x0, $tinfo, $tbuffer, False, 0x3, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetInfoTip

Func _GUICtrlListView_SetInsertMark($hwnd, $iindex, $bafter = False)
    Local $tmark = DllStructCreate($TAGLVINSERTMARK)
    DllStructSetData($tmark, "Size", DllStructGetSize($tmark))
    If $bafter Then DllStructSetData($tmark, "Flags", $LVIM_AFTER)
    DllStructSetData($tmark, "Item", $iindex)
    DllStructSetData($tmark, "Reserved", 0x0)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_SETINSERTMARK, 0x0, $tmark, 0x0, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetInsertMark

Func _GUICtrlListView_SetInsertMarkColor($hwnd, $icolor)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETINSERTMARKCOLOR, 0x0, $icolor)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETINSERTMARKCOLOR, 0x0, $icolor)
    EndIf
EndFunc    ; -> _GUICtrlListView_SetInsertMarkColor

Func _GUICtrlListView_SetItem($hwnd, $stext, $iindex = 0x0, $isubitem = 0x0, $iimage = + -1, $iparam = + -1, $iindent = + -1)
    Local $pbuffer, $ibuffer
    If $stext <> + -1 Then
        Local $tbuffer
        If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
            $tbuffer = $__g_tlistviewbuffer
        Else
            $tbuffer = $__g_tlistviewbufferansi
        EndIf
        $pbuffer = DllStructGetPtr($tbuffer)
        $ibuffer = DllStructGetSize($tbuffer)
        DllStructSetData($tbuffer, "Text", $stext)
    Else
        $pbuffer = + -1
        $ibuffer = 0x0
    EndIf
    Local $titem = $__g_tlistviewitem
    Local $imask = $LVIF_TEXT
    If $iimage <> + -1 Then $imask = BitOR($imask, $LVIF_IMAGE)
    If $iparam <> + -1 Then $imask = BitOR($imask, $LVIF_PARAM)
    If $iindent <> + -1 Then $imask = BitOR($imask, $LVIF_INDENT)
    DllStructSetData($titem, "Mask", $imask)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", $isubitem)
    DllStructSetData($titem, "Text", $pbuffer)
    DllStructSetData($titem, "TextMax", $ibuffer)
    DllStructSetData($titem, "Image", $iimage)
    DllStructSetData($titem, "Param", $iparam)
    DllStructSetData($titem, "Indent", $iindent)
    Return _GUICtrlListView_SetItemEx($hwnd, $titem)
EndFunc    ; -> _GUICtrlListView_SetItem

Func _GUICtrlListView_SetItemChecked($hwnd, $iindex, $bcheck = True)
    Local $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $imsg = $LVM_SETITEMW
    Else
        $imsg = $LVM_SETITEMA
    EndIf
    Local $titem = $__g_tlistviewitem
    If ($bcheck) Then
        DllStructSetData($titem, "State", 0x2000)
    Else
        DllStructSetData($titem, "State", 0x1000)
    EndIf
    DllStructSetData($titem, "StateMask", 0xf000)
    DllStructSetData($titem, "Mask", $LVIF_STATE)
    DllStructSetData($titem, "SubItem", 0x0)
    Local $iindexmax = $iindex
    If $iindex = + -1 Then
        $iindex = 0x0
        $iindexmax = _GUICtrlListView_GetItemCount($hwnd) + -1
    EndIf
    Local $iret
    For $x = $iindex To $iindexmax
        DllStructSetData($titem, "Item", $x)
        $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, 0x0, False, + -1)
        If $iret = 0x0 Then ExitLoop
    Next
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetItemChecked

Func _GUICtrlListView_SetItemCount($hwnd, $iitems)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETITEMCOUNT, $iitems, BitOR($LVSICF_NOINVALIDATEALL, $LVSICF_NOSCROLL)) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETITEMCOUNT, $iitems, BitOR($LVSICF_NOINVALIDATEALL, $LVSICF_NOSCROLL)) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_SetItemCount

Func _GUICtrlListView_SetItemCut($hwnd, $iindex, $benabled = True)
    Local $istate = 0x0
    If $benabled Then $istate = $LVIS_CUT
    Return _GUICtrlListView_SetItemState($hwnd, $iindex, $istate, $LVIS_CUT)
EndFunc    ; -> _GUICtrlListView_SetItemCut

Func _GUICtrlListView_SetItemDropHilited($hwnd, $iindex, $benabled = True)
    Local $istate = 0x0
    If $benabled Then $istate = $LVIS_DROPHILITED
    Return _GUICtrlListView_SetItemState($hwnd, $iindex, $istate, $LVIS_DROPHILITED)
EndFunc    ; -> _GUICtrlListView_SetItemDropHilited

Func _GUICtrlListView_SetItemEx($hwnd, ByRef $titem, $inested = 0x0)
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_SETITEMW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_SETITEMA
    EndIf
    Local $ibuffer = 0x0
    If $inested Then
        $tbuffer = 0x0
        DllStructSetData($titem, "Text", 0x0)
    Else
        If DllStructGetData($titem, "Text") <> + -1 Then
            $ibuffer = DllStructGetSize($tbuffer)
        Else
        EndIf
    EndIf
    DllStructSetData($titem, "TextMax", $ibuffer)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, $tbuffer, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetItemEx

Func _GUICtrlListView_SetItemFocused($hwnd, $iindex, $benabled = True)
    Local $istate = 0x0
    If $benabled Then $istate = $LVIS_FOCUSED
    Return _GUICtrlListView_SetItemState($hwnd, $iindex, $istate, $LVIS_FOCUSED)
EndFunc    ; -> _GUICtrlListView_SetItemFocused

Func _GUICtrlListView_SetItemGroupID($hwnd, $iindex, $igroupid)
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_GROUPID)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", 0x0)
    DllStructSetData($titem, "GroupID", $igroupid)
    Return _GUICtrlListView_SetItemEx($hwnd, $titem, 0x1)
EndFunc    ; -> _GUICtrlListView_SetItemGroupID

Func _GUICtrlListView_SetItemImage($hwnd, $iindex, $iimage, $isubitem = 0x0)
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_IMAGE)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", $isubitem)
    DllStructSetData($titem, "Image", $iimage)
    Return _GUICtrlListView_SetItemEx($hwnd, $titem, 0x1)
EndFunc    ; -> _GUICtrlListView_SetItemImage

Func _GUICtrlListView_SetItemIndent($hwnd, $iindex, $iindent)
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_INDENT)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", 0x0)
    DllStructSetData($titem, "Indent", $iindent)
    Local $iret = _GUICtrlListView_SetItemEx($hwnd, $titem, 0x1)
    _WinAPI_InvalidateRect($hwnd)
    Return $iret
EndFunc    ; -> _GUICtrlListView_SetItemIndent

Func __GUICtrlListView_SetItemOverlayImage($hwnd, $iindex, $iimage)
    Return _GUICtrlListView_SetItemState($hwnd, $iindex, __GUICtrlListView_IndexToOverlayImageMask($iimage), $LVIS_OVERLAYMASK)
EndFunc    ; -> __GUICtrlListView_SetItemOverlayImage

Func _GUICtrlListView_SetItemParam($hwnd, $iindex, $iparam)
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_PARAM)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", 0x0)
    DllStructSetData($titem, "Param", $iparam)
    Return _GUICtrlListView_SetItemEx($hwnd, $titem, 0x1)
EndFunc    ; -> _GUICtrlListView_SetItemParam

Func _GUICtrlListView_SetItemPosition($hwnd, $iindex, $icx, $icy)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETITEMPOSITION, $iindex, _WinAPI_MakeLong($icx, $icy)) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETITEMPOSITION, $iindex, _WinAPI_MakeLong($icx, $icy)) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_SetItemPosition

Func _GUICtrlListView_SetItemPosition32($hwnd, $iindex, $icx, $icy)
    Local $tpoint = DllStructCreate($TAGPOINT)
    DllStructSetData($tpoint, "X", $icx)
    DllStructSetData($tpoint, "Y", $icy)
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_SETITEMPOSITION32, $iindex, $tpoint, 0x0, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetItemPosition32

Func _GUICtrlListView_SetItemSelected($hwnd, $iindex, $bselected = True, $bfocused = False)
    Local $titem = $__g_tlistviewitem
    Local $iselected = 0x0, $ifocused = 0x0
    If ($bselected = True) Then $iselected = $LVIS_SELECTED
    If ($bfocused = True And $iindex <> + -1) Then $ifocused = $LVIS_FOCUSED
    DllStructSetData($titem, "Mask", $LVIF_STATE)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", 0x0)
    DllStructSetData($titem, "State", BitOR($iselected, $ifocused))
    DllStructSetData($titem, "StateMask", BitOR($LVIS_SELECTED, $ifocused))
    Local $iret = __guictrl_sendmsg($hwnd, $LVM_SETITEMSTATE, $iindex, $titem, 0x0, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetItemSelected

Func _GUICtrlListView_SetItemState($hwnd, $iindex, $istate, $istatemask)
    Local $titem = $__g_tlistviewitem
    DllStructSetData($titem, "Mask", $LVIF_STATE)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", 0x0)
    DllStructSetData($titem, "State", $istate)
    DllStructSetData($titem, "StateMask", $istatemask)
    Return _GUICtrlListView_SetItemEx($hwnd, $titem, 0x1) <> 0x0
EndFunc    ; -> _GUICtrlListView_SetItemState

Func _GUICtrlListView_SetItemStateImage($hwnd, $iindex, $iimage)
    Return _GUICtrlListView_SetItemState($hwnd, $iindex, BitShift($iimage, + -12), $LVIS_STATEIMAGEMASK)
EndFunc    ; -> _GUICtrlListView_SetItemStateImage

Func _GUICtrlListView_SetItemText($hwnd, $iindex, $stext, $isubitem = 0x0)
    Local $iret
    If $isubitem = + -1 Then
        Local $sseparatorchar = Opt("GUIDataSeparatorChar")
        Local $i_cols = _GUICtrlListView_GetColumnCount($hwnd)
        Local $a_text = StringSplit($stext, $sseparatorchar)
        If $i_cols > $a_text[0x0] Then $i_cols = $a_text[0x0]
        For $i = 0x1 To $i_cols
            $iret = _GUICtrlListView_SetItemText($hwnd, $iindex, $a_text[$i], $i + -1)
            If Not $iret Then ExitLoop
        Next
        Return $iret
    EndIf
    Local $tbuffer, $imsg
    If _GUICtrlListView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_SETITEMW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_SETITEMA
    EndIf
    Local $titem = $__g_tlistviewitem
    DllStructSetData($tbuffer, 0x1, $stext)
    DllStructSetData($titem, "Mask", $LVIF_TEXT)
    DllStructSetData($titem, "Item", $iindex)
    DllStructSetData($titem, "SubItem", $isubitem)
    $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, $tbuffer, False, 0x6, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetItemText

Func _GUICtrlListView_SetOutlineColor($hwnd, $icolor)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETOUTLINECOLOR, 0x0, $icolor)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETOUTLINECOLOR, 0x0, $icolor)
    EndIf
EndFunc    ; -> _GUICtrlListView_SetOutlineColor

Func _GUICtrlListView_SetSelectedColumn($hwnd, $icol)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $LVM_SETSELECTEDCOLUMN, $icol)
    Else
        GUICtrlSendMsg($hwnd, $LVM_SETSELECTEDCOLUMN, $icol, 0x0)
    EndIf
    _WinAPI_InvalidateRect($hwnd)
EndFunc    ; -> _GUICtrlListView_SetSelectedColumn

Func _GUICtrlListView_SetSelectionMark($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETSELECTIONMARK, 0x0, $iindex)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETSELECTIONMARK, 0x0, $iindex)
    EndIf
EndFunc    ; -> _GUICtrlListView_SetSelectionMark

Func _GUICtrlListView_SetTextBkColor($hwnd, $icolor)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETTEXTBKCOLOR, 0x0, $icolor) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETTEXTBKCOLOR, 0x0, $icolor) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlListView_SetTextBkColor

Func _GUICtrlListView_SetTextColor($hwnd, $icolor)
    Local $iret
    If IsHWnd($hwnd) Then
        $iret = _SendMessage($hwnd, $LVM_SETTEXTCOLOR, 0x0, $icolor)
    Else
        $iret = GUICtrlSendMsg($hwnd, $LVM_SETTEXTCOLOR, 0x0, $icolor)
    EndIf
    _WinAPI_InvalidateRect($hwnd)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SetTextColor

Func _GUICtrlListView_SetToolTips($hwnd, $htooltip)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETTOOLTIPS, 0x0, $htooltip, 0x0, "wparam", "hwnd", "hwnd")
    Else
        Return HWnd(GUICtrlSendMsg($hwnd, $LVM_SETTOOLTIPS, 0x0, $htooltip))
    EndIf
EndFunc    ; -> _GUICtrlListView_SetToolTips

Func _GUICtrlListView_SetUnicodeFormat($hwnd, $bunicode)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETUNICODEFORMAT, $bunicode)
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETUNICODEFORMAT, $bunicode, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlListView_SetUnicodeFormat

Func _GUICtrlListView_SetView($hwnd, $iview)
    Local $aview[0x5] = [$LV_VIEW_ICON, $LV_VIEW_DETAILS, $LV_VIEW_LIST, $LV_VIEW_SMALLICON, $LV_VIEW_TILE]
    If ($iview < 0x0) Or ($iview > 0x4) Then Return False
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $LVM_SETVIEW, $aview[$iview]) <> + -1
    Else
        Return GUICtrlSendMsg($hwnd, $LVM_SETVIEW, $aview[$iview], 0x0) <> + -1
    EndIf
EndFunc    ; -> _GUICtrlListView_SetView

Func _GUICtrlListView_SetWorkAreas($hwnd, $ileft, $itop, $iright, $ibottom)
    Local $trect = DllStructCreate($TAGRECT)
    DllStructSetData($trect, "Left", $ileft)
    DllStructSetData($trect, "Top", $itop)
    DllStructSetData($trect, "Right", $iright)
    DllStructSetData($trect, "Bottom", $ibottom)
    __guictrl_sendmsg($hwnd, $LVM_SETWORKAREAS, 0x1, $trect, 0x0, False, + -1)
EndFunc    ; -> _GUICtrlListView_SetWorkAreas

Func _GUICtrlListView_SimpleSort($hwnd, ByRef $vsortsense, $icol, $btogglesense = True)
    Local $iitemcount = _GUICtrlListView_GetItemCount($hwnd)
    If $iitemcount Then
        Local $idescending = 0x0
        If UBound($vsortsense) Then
            $idescending = $vsortsense[$icol]
        Else
            $idescending = $vsortsense
        EndIf
        Local $vseparatorchar = Opt("GUIDataSeparatorChar")
        Local $icolumncount = _GUICtrlListView_GetColumnCount($hwnd)
        Local Enum $IINDEXVALUE = $icolumncount, $IITEMPARAM
        Local $alistviewitems[$iitemcount][$icolumncount + 0x2]
        Local $sselecteditems = _GUICtrlListView_GetSelectedIndices($hwnd)
        Local $aselecteditems[0x1] = [0x0]
        If Not $sselecteditems = '' Then $aselecteditems = StringSplit($sselecteditems, $vseparatorchar)
        Local $acheckeditems = __GUICtrlListView_GetCheckedIndices($hwnd)
        Local $sitemtext, $ifocused = + -1
        For $i = 0x0 To $iitemcount + -1
            If $ifocused = + -1 Then
                If _GUICtrlListView_GetItemFocused($hwnd, $i) Then $ifocused = $i
            EndIf
            _GUICtrlListView_SetItemSelected($hwnd, $i, False)
            _GUICtrlListView_SetItemChecked($hwnd, $i, False)
            For $j = 0x0 To $icolumncount + -1
                $sitemtext = StringStripWS(_GUICtrlListView_GetItemText($hwnd, $i, $j), $STR_STRIPTRAILING)
                If (StringIsFloat($sitemtext) Or StringIsInt($sitemtext)) Then
                    $alistviewitems[$i][$j] = Number($sitemtext)
                Else
                    $alistviewitems[$i][$j] = $sitemtext
                EndIf
            Next
            $alistviewitems[$i][$IINDEXVALUE] = $i
            $alistviewitems[$i][$IITEMPARAM] = _GUICtrlListView_GetItemParam($hwnd, $i)
        Next
        _ArraySort($alistviewitems, $idescending, 0x0, 0x0, $icol)
        For $i = 0x0 To $iitemcount + -1
            For $j = 0x0 To $icolumncount + -1
                _GUICtrlListView_SetItemText($hwnd, $i, $alistviewitems[$i][$j], $j)
            Next
            _GUICtrlListView_SetItemParam($hwnd, $i, $alistviewitems[$i][$IITEMPARAM])
            For $j = 0x1 To $aselecteditems[0x0]
                If $alistviewitems[$i][$IINDEXVALUE] = $aselecteditems[$j] Then
                    If $alistviewitems[$i][$IINDEXVALUE] = $ifocused Then
                        _GUICtrlListView_SetItemSelected($hwnd, $i, True, True)
                    Else
                        _GUICtrlListView_SetItemSelected($hwnd, $i, True)
                    EndIf
                    ExitLoop
                EndIf
            Next
            For $j = 0x1 To $acheckeditems[0x0]
                If $alistviewitems[$i][$IINDEXVALUE] = $acheckeditems[$j] Then
                    _GUICtrlListView_SetItemChecked($hwnd, $i, True)
                    ExitLoop
                EndIf
            Next
        Next
        If $btogglesense Then
            If UBound($vsortsense) Then
                $vsortsense[$icol] = Not $idescending
            Else
                $vsortsense = Not $idescending
            EndIf
        EndIf
    EndIf
EndFunc    ; -> _GUICtrlListView_SimpleSort

#Au3Stripper_Ignore_Funcs=__GUICtrlListView_Sort
Func __GUICtrlListView_Sort($nitem1, $nitem2, $hwnd)
    Local $iindex, $sval1, $sval2, $nresult
    Local $tbuffer, $imsg
    If $__g_alistviewsortinfo[$iindex][0x0] Then
        $tbuffer = $__g_tlistviewbuffer
        $imsg = $LVM_GETITEMTEXTW
    Else
        $tbuffer = $__g_tlistviewbufferansi
        $imsg = $LVM_GETITEMTEXTA
    EndIf
    Local $titem = $__g_tlistviewitem
    For $x = 0x1 To $__g_alistviewsortinfo[0x0][0x0]
        If $hwnd = $__g_alistviewsortinfo[$x][0x1] Then
            $iindex = $x
            ExitLoop
        EndIf
    Next
    If $__g_alistviewsortinfo[$iindex][0x3] = $__g_alistviewsortinfo[$iindex][0x4] Then
        If Not $__g_alistviewsortinfo[$iindex][0x7] Then
            $__g_alistviewsortinfo[$iindex][0x5]*= + -1
            $__g_alistviewsortinfo[$iindex][0x7] = 0x1
        EndIf
    Else
        $__g_alistviewsortinfo[$iindex][0x7] = 0x1
    EndIf
    $__g_alistviewsortinfo[$iindex][0x6] = $__g_alistviewsortinfo[$iindex][0x3]
    DllStructSetData($titem, "Mask", $LVIF_TEXT)
    DllStructSetData($titem, "SubItem", $__g_alistviewsortinfo[$iindex][0x3])
    __guictrl_sendmsg($hwnd, $imsg, $nitem1, $titem, $tbuffer, False, 0x6, True)
    $sval1 = DllStructGetData($tbuffer, 0x1)
    __guictrl_sendmsg($hwnd, $imsg, $nitem2, $titem, $tbuffer, False, 0x6, True)
    $sval2 = DllStructGetData($tbuffer, 0x1)
    If $__g_alistviewsortinfo[$iindex][0x8] = 0x1 Then
        If (StringIsFloat($sval1) Or StringIsInt($sval1)) Then $sval1 = Number($sval1)
        If (StringIsFloat($sval2) Or StringIsInt($sval2)) Then $sval2 = Number($sval2)
    EndIf
    If $__g_alistviewsortinfo[$iindex][0x8] < 0x2 Then
        $nresult = 0x0
        If $sval1 < $sval2 Then
            $nresult = + -1
        ElseIf $sval1 > $sval2 Then
            $nresult = 0x1
        EndIf
    Else
        $nresult = DllCall("shlwapi.dll", "int", "StrCmpLogicalW", "wstr", $sval1, "wstr", $sval2)[0x0]
    EndIf
    $nresult = $nresult * $__g_alistviewsortinfo[$iindex][0x5]
    Return $nresult
EndFunc    ; -> __GUICtrlListView_Sort

Func _GUICtrlListView_SortItems($hwnd, $icol)
    Local $iret, $iindex, $pfunction, $hheader, $iformat
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    For $x = 0x1 To $__g_alistviewsortinfo[0x0][0x0]
        If $hwnd = $__g_alistviewsortinfo[$x][0x1] Then
            $iindex = $x
            ExitLoop
        EndIf
    Next
    $pfunction = DllCallbackGetPtr($__g_alistviewsortinfo[$iindex][0x2])
    $__g_alistviewsortinfo[$iindex][0x3] = $icol
    $__g_alistviewsortinfo[$iindex][0x7] = 0x0
    $__g_alistviewsortinfo[$iindex][0x4] = $__g_alistviewsortinfo[$iindex][0x6]
    $iret = _SendMessage($hwnd, $LVM_SORTITEMSEX, $hwnd, $pfunction, 0x0, "hwnd", "ptr")
    If $iret <> 0x0 Then
        If $__g_alistviewsortinfo[$iindex][0x9] Then
            $hheader = $__g_alistviewsortinfo[$iindex][0xa]
            For $x = 0x0 To _GUICtrlHeader_GetItemCount($hheader) + -1
                $iformat = _GUICtrlHeader_GetItemFormat($hheader, $x)
                If BitAND($iformat, $HDF_SORTDOWN) Then
                    _GUICtrlHeader_SetItemFormat($hheader, $x, BitXOR($iformat, $HDF_SORTDOWN))
                ElseIf BitAND($iformat, $HDF_SORTUP) Then
                    _GUICtrlHeader_SetItemFormat($hheader, $x, BitXOR($iformat, $HDF_SORTUP))
                EndIf
            Next
            $iformat = _GUICtrlHeader_GetItemFormat($hheader, $icol)
            If $__g_alistviewsortinfo[$iindex][0x5] = 0x1 Then
                _GUICtrlHeader_SetItemFormat($hheader, $icol, BitOR($iformat, $HDF_SORTUP))
            Else
                _GUICtrlHeader_SetItemFormat($hheader, $icol, BitOR($iformat, $HDF_SORTDOWN))
            EndIf
        EndIf
    EndIf
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlListView_SortItems

Func __GUICtrlListView_StateImageMaskToIndex($imask)
    Return BitShift(BitAND($imask, $LVIS_STATEIMAGEMASK), 0xc)
EndFunc    ; -> __GUICtrlListView_StateImageMaskToIndex

Func _GUICtrlListView_SubItemHitTest($hwnd, $ix = + -1, $iy = + -1)
    If $ix = + -1 Then $ix = _WinAPI_GetMousePosX(True, $hwnd)
    If $iy = + -1 Then $iy = _WinAPI_GetMousePosY(True, $hwnd)
    Local $ttest = DllStructCreate($TAGLVHITTESTINFO)
    DllStructSetData($ttest, "X", $ix)
    DllStructSetData($ttest, "Y", $iy)
    __guictrl_sendmsg($hwnd, $LVM_SUBITEMHITTEST, 0x0, $ttest, 0x0, True, + -1)
    Local $IFLAGS = DllStructGetData($ttest, "Flags")
    Local $atest[0xb]
    $atest[0x0] = DllStructGetData($ttest, "Item")
    $atest[0x1] = DllStructGetData($ttest, "SubItem")
    $atest[0x2] = BitAND($IFLAGS, $LVHT_NOWHERE) <> 0x0
    $atest[0x3] = BitAND($IFLAGS, $LVHT_ONITEMICON) <> 0x0
    $atest[0x4] = BitAND($IFLAGS, $LVHT_ONITEMLABEL) <> 0x0
    $atest[0x5] = BitAND($IFLAGS, $LVHT_ONITEMSTATEICON) <> 0x0
    $atest[0x6] = BitAND($IFLAGS, $LVHT_ONITEM) <> 0x0
    $atest[0x7] = BitAND($IFLAGS, $LVHT_ABOVE) <> 0x0
    $atest[0x8] = BitAND($IFLAGS, $LVHT_BELOW) <> 0x0
    $atest[0x9] = BitAND($IFLAGS, $LVHT_TOLEFT) <> 0x0
    $atest[0xa] = BitAND($IFLAGS, $LVHT_TORIGHT) <> 0x0
    Return $atest
EndFunc    ; -> _GUICtrlListView_SubItemHitTest

Func _GUICtrlListView_UnRegisterSortCallBack($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    For $x = 0x1 To $__g_alistviewsortinfo[0x0][0x0]
        If $hwnd = $__g_alistviewsortinfo[$x][0x1] Then
            DllCallbackFree($__g_alistviewsortinfo[$x][0x2])
            __GUICtrlListView_ArrayDelete($__g_alistviewsortinfo, $x)
            $__g_alistviewsortinfo[0x0][0x0]-= 0x1
            ExitLoop
        EndIf
    Next
EndFunc    ; -> _GUICtrlListView_UnRegisterSortCallBack

Global Const $__MENUCONSTANT_OBJID_CLIENT = -4
Global Const $TAGMENUBARINFO = "dword Size;" & $TAGRECT & ";handle hMenu;handle hWndMenu;bool Focused"
Global Const $TAGMDINEXTMENU = "handle hMenuIn;handle hMenuNext;hwnd hWndNext"
Global Const $TAGMENUGETOBJECTINFO = "dword Flags;uint Pos;handle hMenu;ptr RIID;ptr Obj"
Global Const $TAGTPMPARAMS = "uint Size;" & $TAGRECT
Func _GUICtrlMenu_AddMenuItem($hmenu, $stext, $icmdid = 0x0, $hsubmenu = 0x0)
    Local $iindex = _GUICtrlMenu_GetItemCount($hmenu)
    Local $tmenu = DllStructCreate($TAGMENUITEMINFO)
    DllStructSetData($tmenu, "Size", DllStructGetSize($tmenu))
    DllStructSetData($tmenu, "ID", $icmdid)
    DllStructSetData($tmenu, "SubMenu", $hsubmenu)
    If $stext = '' Then
        DllStructSetData($tmenu, "Mask", $MIIM_FTYPE)
        DllStructSetData($tmenu, "Type", $MFT_SEPARATOR)
    Else
        DllStructSetData($tmenu, "Mask", BitOR($MIIM_ID, $MIIM_STRING, $MIIM_SUBMENU))
        DllStructSetData($tmenu, "Type", $MFT_STRING)
        Local $ttext = DllStructCreate("wchar Text[" & StringLen($stext) + 0x1 & "]")
        DllStructSetData($ttext, "Text", $stext)
        DllStructSetData($tmenu, "TypeData", DllStructGetPtr($ttext))
    EndIf
    Local $acall = DllCall("user32.dll", "bool", "InsertMenuItemW", "handle", $hmenu, "uint", $iindex, "bool", True, "struct*", $tmenu)
    If @error Then Return SetError(@error, @extended, + -1)
    Return SetExtended($acall[0x0], $iindex)
EndFunc    ; -> _GUICtrlMenu_AddMenuItem

Func _GUICtrlMenu_AppendMenu($hmenu, $IFLAGS, $inewitem, $vnewitem)
    Local $stype = "wstr"
    If BitAND($IFLAGS, $MF_BITMAP) Then $stype = "handle"
    If BitAND($IFLAGS, $MF_OWNERDRAW) Then $stype = "ulong_ptr"
    Local $acall = DllCall("user32.dll", "bool", "AppendMenuW", "handle", $hmenu, "uint", $IFLAGS, "uint_ptr", $inewitem, $stype, $vnewitem)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
    _GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hmenu))
    Return True
EndFunc    ; -> _GUICtrlMenu_AppendMenu

Func _GUICtrlMenu_CalculatePopupWindowPosition($ix, $iy, $iwidth, $iheight, $IFLAGS = 0x0, $texclude = 0x0)
    Local $tanchor = DllStructCreate($TAGPOINT)
    DllStructSetData($tanchor, 0x1, $ix)
    DllStructSetData($tanchor, 0x2, $iy)
    Local $tsize = DllStructCreate($TAGSIZE)
    DllStructSetData($tsize, 0x1, $iwidth)
    DllStructSetData($tsize, 0x2, $iheight)
    Local $tpos = DllStructCreate($TAGRECT)
    Local $acall = DllCall("user32.dll", "bool", "CalculatePopupWindowPosition", "struct*", $tanchor, "struct*", $tsize, "uint", $IFLAGS, "struct*", $texclude, "struct*", $tpos)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Return $tpos
EndFunc    ; -> _GUICtrlMenu_CalculatePopupWindowPosition

Func _GUICtrlMenu_CheckMenuItem($hmenu, $iitem, $bcheck = True, $bbypos = True)
    Local $ibypos = 0x0
    If $bcheck Then $ibypos = BitOR($ibypos, $MF_CHECKED)
    If $bbypos Then $ibypos = BitOR($ibypos, $MF_BYPOSITION)
    Local $acall = DllCall("user32.dll", "dword", "CheckMenuItem", "handle", $hmenu, "uint", $iitem, "uint", $ibypos)
    If @error Then Return SetError(@error, @extended, + -1)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_CheckMenuItem

Func _GUICtrlMenu_CheckRadioItem($hmenu, $ifirst, $ilast, $icheck, $bbypos = True)
    Local $ibypos = 0x0
    If $bbypos Then $ibypos = $MF_BYPOSITION
    Local $acall = DllCall("user32.dll", "bool", "CheckMenuRadioItem", "handle", $hmenu, "uint", $ifirst, "uint", $ilast, "uint", $icheck, "uint", $ibypos)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_CheckRadioItem

Func _GUICtrlMenu_CreateMenu($istyle = $MNS_CHECKORBMP)
    Local $acall = DllCall("user32.dll", "handle", "CreateMenu")
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    _GUICtrlMenu_SetMenuStyle($acall[0x0], $istyle)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_CreateMenu

Func _GUICtrlMenu_CreatePopup($istyle = $MNS_CHECKORBMP)
    Local $acall = DllCall("user32.dll", "handle", "CreatePopupMenu")
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    _GUICtrlMenu_SetMenuStyle($acall[0x0], $istyle)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_CreatePopup

Func _GUICtrlMenu_DeleteMenu($hmenu, $iitem, $bbypos = True)
    Local $ibypos = 0x0
    If $bbypos Then $ibypos = $MF_BYPOSITION
    Local $acall = DllCall("user32.dll", "bool", "DeleteMenu", "handle", $hmenu, "uint", $iitem, "uint", $ibypos)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
    _GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hmenu))
    Return True
EndFunc    ; -> _GUICtrlMenu_DeleteMenu

Func _GUICtrlMenu_DestroyMenu($hmenu)
    Local $acall = DllCall("user32.dll", "bool", "DestroyMenu", "handle", $hmenu)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_DestroyMenu

Func _GUICtrlMenu_DrawMenuBar($hwnd)
    Local $acall = DllCall("user32.dll", "bool", "DrawMenuBar", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_DrawMenuBar

Func _GUICtrlMenu_EnableMenuItem($hmenu, $iitem, $istate = 0x0, $bbypos = True)
    Local $ibypos = $istate
    If $bbypos Then $ibypos = BitOR($ibypos, $MF_BYPOSITION)
    Local $acall = DllCall("user32.dll", "bool", "EnableMenuItem", "handle", $hmenu, "uint", $iitem, "uint", $ibypos)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
    _GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hmenu))
    Return True
EndFunc    ; -> _GUICtrlMenu_EnableMenuItem

Func _GUICtrlMenu_EndMenu()
    Local $acall = DllCall("user32.dll", "bool", "EndMenu")
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_EndMenu

Func _GUICtrlMenu_FindItem($hmenu, $stext, $binstr = False, $istart = 0x0)
    Local $smenu
    For $ii = $istart To _GUICtrlMenu_GetItemCount($hmenu)
        $smenu = StringReplace(_GUICtrlMenu_GetItemText($hmenu, $ii), "&", '')
        Switch $binstr
        Case False
            If $smenu = $stext Then Return $ii
        Case True
            If StringInStr($smenu, $stext) Then Return $ii
        EndSwitch
    Next
    Return + -1
EndFunc    ; -> _GUICtrlMenu_FindItem

Func _GUICtrlMenu_FindParent($hmenu)
    Local $hlist = _WinAPI_EnumWindowsTop()
    For $ii = 0x1 To $hlist[0x0][0x0]
        If _GUICtrlMenu_GetMenu($hlist[$ii][0x0]) = $hmenu Then Return $hlist[$ii][0x0]
    Next
EndFunc    ; -> _GUICtrlMenu_FindParent

Func _GUICtrlMenu_GetItemBmp($hmenu, $iitem, $bbypos = True)
    Local $tinfo = _GUICtrlMenu_GetItemInfo($hmenu, $iitem, $bbypos)
    Return DllStructGetData($tinfo, "BmpItem")
EndFunc    ; -> _GUICtrlMenu_GetItemBmp

Func _GUICtrlMenu_GetItemBmpChecked($hmenu, $iitem, $bbypos = True)
    Local $tinfo = _GUICtrlMenu_GetItemInfo($hmenu, $iitem, $bbypos)
    Return DllStructGetData($tinfo, "BmpChecked")
EndFunc    ; -> _GUICtrlMenu_GetItemBmpChecked

Func _GUICtrlMenu_GetItemBmpUnchecked($hmenu, $iitem, $bbypos = True)
    Local $tinfo = _GUICtrlMenu_GetItemInfo($hmenu, $iitem, $bbypos)
    Return DllStructGetData($tinfo, "BmpUnchecked")
EndFunc    ; -> _GUICtrlMenu_GetItemBmpUnchecked

Func _GUICtrlMenu_GetItemChecked($hmenu, $iitem, $bbypos = True)
    Return BitAND(_GUICtrlMenu_GetItemStateEx($hmenu, $iitem, $bbypos), $MF_CHECKED) <> 0x0
EndFunc    ; -> _GUICtrlMenu_GetItemChecked

Func _GUICtrlMenu_GetItemCount($hmenu)
    Local $acall = DllCall("user32.dll", "int", "GetMenuItemCount", "handle", $hmenu)
    If @error Then Return SetError(@error, @extended, + -1)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_GetItemCount

Func _GUICtrlMenu_GetItemData($hmenu, $iitem, $bbypos = True)
    Local $tinfo = _GUICtrlMenu_GetItemInfo($hmenu, $iitem, $bbypos)
    Return DllStructGetData($tinfo, "ItemData")
EndFunc    ; -> _GUICtrlMenu_GetItemData

Func _GUICtrlMenu_GetItemDefault($hmenu, $iitem, $bbypos = True)
    Return BitAND(_GUICtrlMenu_GetItemStateEx($hmenu, $iitem, $bbypos), $MF_DEFAULT) <> 0x0
EndFunc    ; -> _GUICtrlMenu_GetItemDefault

Func _GUICtrlMenu_GetItemDisabled($hmenu, $iitem, $bbypos = True)
    Return BitAND(_GUICtrlMenu_GetItemStateEx($hmenu, $iitem, $bbypos), $MF_DISABLED) <> 0x0
EndFunc    ; -> _GUICtrlMenu_GetItemDisabled

Func _GUICtrlMenu_GetItemEnabled($hmenu, $iitem, $bbypos = True)
    Return BitAND(_GUICtrlMenu_GetItemStateEx($hmenu, $iitem, $bbypos), $MF_DISABLED) = 0x0
EndFunc    ; -> _GUICtrlMenu_GetItemEnabled

Func _GUICtrlMenu_GetItemGrayed($hmenu, $iitem, $bbypos = True)
    Return BitAND(_GUICtrlMenu_GetItemStateEx($hmenu, $iitem, $bbypos), $MF_GRAYED) <> 0x0
EndFunc    ; -> _GUICtrlMenu_GetItemGrayed

Func _GUICtrlMenu_GetItemHighlighted($hmenu, $iitem, $bbypos = True)
    Return BitAND(_GUICtrlMenu_GetItemStateEx($hmenu, $iitem, $bbypos), $MF_HILITE) <> 0x0
EndFunc    ; -> _GUICtrlMenu_GetItemHighlighted

Func _GUICtrlMenu_GetItemID($hmenu, $iitem, $bbypos = True)
    Local $tinfo = _GUICtrlMenu_GetItemInfo($hmenu, $iitem, $bbypos)
    Return DllStructGetData($tinfo, "ID")
EndFunc    ; -> _GUICtrlMenu_GetItemID

Func _GUICtrlMenu_GetItemInfo($hmenu, $iitem, $bbypos = True)
    Local $tinfo = DllStructCreate($TAGMENUITEMINFO)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "Mask", $MIIM_DATAMASK)
    Local $acall = DllCall("user32.dll", "bool", "GetMenuItemInfo", "handle", $hmenu, "uint", $iitem, "bool", $bbypos, "struct*", $tinfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $tinfo)
EndFunc    ; -> _GUICtrlMenu_GetItemInfo

Func _GUICtrlMenu_GetItemRect($hwnd, $hmenu, $iitem)
    Local $trect = _GUICtrlMenu_GetItemRectEx($hwnd, $hmenu, $iitem)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlMenu_GetItemRect

Func _GUICtrlMenu_GetItemRectEx($hwnd, $hmenu, $iitem)
    Local $trect = DllStructCreate($TAGRECT)
    Local $acall = DllCall("user32.dll", "bool", "GetMenuItemRect", "hwnd", $hwnd, "handle", $hmenu, "uint", $iitem, "struct*", $trect)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $trect)
EndFunc    ; -> _GUICtrlMenu_GetItemRectEx

Func _GUICtrlMenu_GetItemState($hmenu, $iitem, $bbypos = True)
    Local $iret = 0x0
    Local $istate = _GUICtrlMenu_GetItemStateEx($hmenu, $iitem, $bbypos)
    If BitAND($istate, $MFS_CHECKED) <> 0x0 Then $iret = BitOR($iret, 0x1)
    If BitAND($istate, $MFS_DEFAULT) <> 0x0 Then $iret = BitOR($iret, 0x2)
    If BitAND($istate, $MFS_DISABLED) <> 0x0 Then $iret = BitOR($iret, 0x4)
    If BitAND($istate, $MFS_GRAYED) <> 0x0 Then $iret = BitOR($iret, 0x8)
    If BitAND($istate, $MFS_HILITE) <> 0x0 Then $iret = BitOR($iret, 0x10)
    Return $iret
EndFunc    ; -> _GUICtrlMenu_GetItemState

Func _GUICtrlMenu_GetItemStateEx($hmenu, $iitem, $bbypos = True)
    Local $tinfo = _GUICtrlMenu_GetItemInfo($hmenu, $iitem, $bbypos)
    Return DllStructGetData($tinfo, "State")
EndFunc    ; -> _GUICtrlMenu_GetItemStateEx

Func _GUICtrlMenu_GetItemSubMenu($hmenu, $iitem)
    Local $acall = DllCall("user32.dll", "handle", "GetSubMenu", "handle", $hmenu, "int", $iitem)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_GetItemSubMenu

Func _GUICtrlMenu_GetItemText($hmenu, $iitem, $bbypos = True)
    Local $ibypos = 0x0
    If $bbypos Then $ibypos = $MF_BYPOSITION
    Local $acall = DllCall("user32.dll", "int", "GetMenuStringW", "handle", $hmenu, "uint", $iitem, "wstr", '', "int", 0x1000, "uint", $ibypos)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $acall[0x3])
EndFunc    ; -> _GUICtrlMenu_GetItemText

Func _GUICtrlMenu_GetItemType($hmenu, $iitem, $bbypos = True)
    Local $tinfo = _GUICtrlMenu_GetItemInfo($hmenu, $iitem, $bbypos)
    Return DllStructGetData($tinfo, "Type")
EndFunc    ; -> _GUICtrlMenu_GetItemType

Func _GUICtrlMenu_GetMenu($hwnd)
    Local $acall = DllCall("user32.dll", "handle", "GetMenu", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_GetMenu

Func _GUICtrlMenu_GetMenuBackground($hmenu)
    Local $tinfo = _GUICtrlMenu_GetMenuInfo($hmenu)
    Return DllStructGetData($tinfo, "hBack")
EndFunc    ; -> _GUICtrlMenu_GetMenuBackground

Func _GUICtrlMenu_GetMenuBarInfo($hwnd, $iitem = 0x0, $iobject = 0x1)
    Local $aobject[0x3] = [$__MENUCONSTANT_OBJID_CLIENT, $OBJID_MENU, $OBJID_SYSMENU]
    Local $tinfo = DllStructCreate($TAGMENUBARINFO)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    Local $acall = DllCall("user32.dll", "bool", "GetMenuBarInfo", "hwnd", $hwnd, "long", $aobject[$iobject], "long", $iitem, "struct*", $tinfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $ainfo[0x8]
    $ainfo[0x0] = DllStructGetData($tinfo, "Left")
    $ainfo[0x1] = DllStructGetData($tinfo, "Top")
    $ainfo[0x2] = DllStructGetData($tinfo, "Right")
    $ainfo[0x3] = DllStructGetData($tinfo, "Bottom")
    $ainfo[0x4] = DllStructGetData($tinfo, "hMenu")
    $ainfo[0x5] = DllStructGetData($tinfo, "hWndMenu")
    $ainfo[0x6] = BitAND(DllStructGetData($tinfo, "Focused"), 0x1) <> 0x0
    $ainfo[0x7] = BitAND(DllStructGetData($tinfo, "Focused"), 0x2) <> 0x0
    Return SetExtended($acall[0x0], $ainfo)
EndFunc    ; -> _GUICtrlMenu_GetMenuBarInfo

Func _GUICtrlMenu_GetMenuContextHelpID($hmenu)
    Local $tinfo = _GUICtrlMenu_GetMenuInfo($hmenu)
    Return DllStructGetData($tinfo, "ContextHelpID")
EndFunc    ; -> _GUICtrlMenu_GetMenuContextHelpID

Func _GUICtrlMenu_GetMenuData($hmenu)
    Local $tinfo = _GUICtrlMenu_GetMenuInfo($hmenu)
    Return DllStructGetData($tinfo, "MenuData")
EndFunc    ; -> _GUICtrlMenu_GetMenuData

Func _GUICtrlMenu_GetMenuDefaultItem($hmenu, $bbypos = True, $IFLAGS = 0x0)
    Local $acall = DllCall("user32.dll", "INT", "GetMenuDefaultItem", "handle", $hmenu, "uint", $bbypos, "uint", $IFLAGS)
    If @error Then Return SetError(@error, @extended, + -1)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_GetMenuDefaultItem

Func _GUICtrlMenu_GetMenuHeight($hmenu)
    Local $tinfo = _GUICtrlMenu_GetMenuInfo($hmenu)
    Return DllStructGetData($tinfo, "YMax")
EndFunc    ; -> _GUICtrlMenu_GetMenuHeight

Func _GUICtrlMenu_GetMenuInfo($hmenu)
    Local $tinfo = DllStructCreate($TAGMENUINFO)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "Mask", BitOR($MIM_BACKGROUND, $MIM_HELPID, $MIM_MAXHEIGHT, $MIM_MENUDATA, $MIM_STYLE))
    Local $acall = DllCall("user32.dll", "bool", "GetMenuInfo", "handle", $hmenu, "struct*", $tinfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $tinfo)
EndFunc    ; -> _GUICtrlMenu_GetMenuInfo

Func _GUICtrlMenu_GetMenuStyle($hmenu)
    Local $tinfo = _GUICtrlMenu_GetMenuInfo($hmenu)
    Return DllStructGetData($tinfo, "Style")
EndFunc    ; -> _GUICtrlMenu_GetMenuStyle

Func _GUICtrlMenu_GetSystemMenu($hwnd, $brevert = False)
    Local $acall = DllCall("user32.dll", "hwnd", "GetSystemMenu", "hwnd", $hwnd, "int", $brevert)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_GetSystemMenu

Func _GUICtrlMenu_InsertMenuItem($hmenu, $iindex, $stext, $icmdid = 0x0, $hsubmenu = 0x0)
    Local $tmenu = DllStructCreate($TAGMENUITEMINFO)
    DllStructSetData($tmenu, "Size", DllStructGetSize($tmenu))
    DllStructSetData($tmenu, "ID", $icmdid)
    DllStructSetData($tmenu, "SubMenu", $hsubmenu)
    If $stext = '' Then
        DllStructSetData($tmenu, "Mask", $MIIM_FTYPE)
        DllStructSetData($tmenu, "Type", $MFT_SEPARATOR)
    Else
        DllStructSetData($tmenu, "Mask", BitOR($MIIM_ID, $MIIM_STRING, $MIIM_SUBMENU))
        DllStructSetData($tmenu, "Type", $MFT_STRING)
        Local $ttext = DllStructCreate("wchar Text[" & StringLen($stext) + 0x1 & "]")
        DllStructSetData($ttext, "Text", $stext)
        DllStructSetData($tmenu, "TypeData", DllStructGetPtr($ttext))
    EndIf
    Local $acall = DllCall("user32.dll", "bool", "InsertMenuItemW", "handle", $hmenu, "uint", $iindex, "bool", True, "struct*", $tmenu)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_InsertMenuItem

Func _GUICtrlMenu_InsertMenuItemEx($hmenu, $iindex, ByRef $tmenu, $bbypos = True)
    Local $acall = DllCall("user32.dll", "bool", "InsertMenuItemW", "handle", $hmenu, "uint", $iindex, "bool", $bbypos, "struct*", $tmenu)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_InsertMenuItemEx

Func _GUICtrlMenu_IsMenu($hmenu)
    Local $acall = DllCall("user32.dll", "bool", "IsMenu", "handle", $hmenu)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_IsMenu

Func _GUICtrlMenu_LoadMenu($hinst, $smenuname)
    Local $acall = DllCall("user32.dll", "handle", "LoadMenuW", "handle", $hinst, "wstr", $smenuname)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_LoadMenu

Func _GUICtrlMenu_MapAccelerator($hmenu, $saccelkey)
    Local $stext
    Local $icount = _GUICtrlMenu_GetItemCount($hmenu)
    For $ii = 0x0 To $icount + -1
        $stext = _GUICtrlMenu_GetItemText($hmenu, $ii)
        If StringInStr($stext, "&" & $saccelkey) > 0x0 Then Return $ii
    Next
    Return + -1
EndFunc    ; -> _GUICtrlMenu_MapAccelerator

Func _GUICtrlMenu_MenuItemFromPoint($hwnd, $hmenu, $ix = + -1, $iy = + -1)
    If $ix = + -1 Then $ix = _WinAPI_GetMousePosX()
    If $iy = + -1 Then $iy = _WinAPI_GetMousePosY()
    Local $acall = DllCall("user32.dll", "int", "MenuItemFromPoint", "hwnd", $hwnd, "handle", $hmenu, "int", $ix, "int", $iy)
    If @error Then Return SetError(@error, @extended, + -1)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_MenuItemFromPoint

Func _GUICtrlMenu_RemoveMenu($hmenu, $iitem, $bbypos = True)
    Local $ibypos = 0x0
    If $bbypos Then $ibypos = $MF_BYPOSITION
    Local $acall = DllCall("user32.dll", "bool", "RemoveMenu", "handle", $hmenu, "uint", $iitem, "uint", $ibypos)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
    _GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hmenu))
    Return True
EndFunc    ; -> _GUICtrlMenu_RemoveMenu

Func _GUICtrlMenu_SetItemBitmaps($hmenu, $iitem, $hchecked, $hunchecked, $bbypos = True)
    Local $ibypos = 0x0
    If $bbypos Then $ibypos = $MF_BYPOSITION
    Local $acall = DllCall("user32.dll", "bool", "SetMenuItemBitmaps", "handle", $hmenu, "uint", $iitem, "uint", $ibypos, "handle", $hunchecked, "handle", $hchecked)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_SetItemBitmaps

Func _GUICtrlMenu_SetItemBmp($hmenu, $iitem, $hbitmap, $bbypos = True)
    Local $tinfo = DllStructCreate($TAGMENUITEMINFO)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "Mask", $MIIM_BITMAP)
    DllStructSetData($tinfo, "BmpItem", $hbitmap)
    Return _GUICtrlMenu_SetItemInfo($hmenu, $iitem, $tinfo, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemBmp

Func _GUICtrlMenu_SetItemBmpChecked($hmenu, $iitem, $hbitmap, $bbypos = True)
    Local $tinfo = _GUICtrlMenu_GetItemInfo($hmenu, $iitem, $bbypos)
    DllStructSetData($tinfo, "Mask", $MIIM_CHECKMARKS)
    DllStructSetData($tinfo, "BmpChecked", $hbitmap)
    Return _GUICtrlMenu_SetItemInfo($hmenu, $iitem, $tinfo, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemBmpChecked

Func _GUICtrlMenu_SetItemBmpUnchecked($hmenu, $iitem, $hbitmap, $bbypos = True)
    Local $tinfo = _GUICtrlMenu_GetItemInfo($hmenu, $iitem, $bbypos)
    DllStructSetData($tinfo, "Mask", $MIIM_CHECKMARKS)
    DllStructSetData($tinfo, "BmpUnchecked", $hbitmap)
    Return _GUICtrlMenu_SetItemInfo($hmenu, $iitem, $tinfo, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemBmpUnchecked

Func _GUICtrlMenu_SetItemChecked($hmenu, $iitem, $bstate = True, $bbypos = True)
    Return _GUICtrlMenu_SetItemState($hmenu, $iitem, $MFS_CHECKED, $bstate, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemChecked

Func _GUICtrlMenu_SetItemData($hmenu, $iitem, $idata, $bbypos = True)
    Local $tinfo = DllStructCreate($TAGMENUITEMINFO)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "Mask", $MIIM_DATA)
    DllStructSetData($tinfo, "ItemData", $idata)
    Return _GUICtrlMenu_SetItemInfo($hmenu, $iitem, $tinfo, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemData

Func _GUICtrlMenu_SetItemDefault($hmenu, $iitem, $bstate = True, $bbypos = True)
    Return _GUICtrlMenu_SetItemState($hmenu, $iitem, $MFS_DEFAULT, $bstate, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemDefault

Func _GUICtrlMenu_SetItemDisabled($hmenu, $iitem, $bstate = True, $bbypos = True)
    Return _GUICtrlMenu_SetItemState($hmenu, $iitem, BitOR($MFS_DISABLED, $MFS_GRAYED), $bstate, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemDisabled

Func _GUICtrlMenu_SetItemEnabled($hmenu, $iitem, $bstate = True, $bbypos = True)
    Return _GUICtrlMenu_SetItemState($hmenu, $iitem, BitOR($MFS_DISABLED, $MFS_GRAYED), Not $bstate, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemEnabled

Func _GUICtrlMenu_SetItemGrayed($hmenu, $iitem, $bstate = True, $bbypos = True)
    Return _GUICtrlMenu_SetItemState($hmenu, $iitem, $MFS_GRAYED, $bstate, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemGrayed

Func _GUICtrlMenu_SetItemHighlighted($hmenu, $iitem, $bstate = True, $bbypos = True)
    Return _GUICtrlMenu_SetItemState($hmenu, $iitem, $MFS_HILITE, $bstate, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemHighlighted

Func _GUICtrlMenu_SetItemID($hmenu, $iitem, $iid, $bbypos = True)
    Local $tinfo = DllStructCreate($TAGMENUITEMINFO)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "Mask", $MIIM_ID)
    DllStructSetData($tinfo, "ID", $iid)
    Return _GUICtrlMenu_SetItemInfo($hmenu, $iitem, $tinfo, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemID

Func _GUICtrlMenu_SetItemInfo($hmenu, $iitem, ByRef $tinfo, $bbypos = True)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    Local $acall = DllCall("user32.dll", "bool", "SetMenuItemInfoW", "handle", $hmenu, "uint", $iitem, "bool", $bbypos, "struct*", $tinfo)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_SetItemInfo

Func _GUICtrlMenu_SetItemState($hmenu, $iitem, $istate, $bstate = True, $bbypos = True)
    Local $IFLAG = _GUICtrlMenu_GetItemStateEx($hmenu, $iitem, $bbypos)
    If $bstate Then
        $istate = BitOR($IFLAG, $istate)
    Else
        $istate = BitAND($IFLAG, BitNOT($istate))
    EndIf
    Local $tinfo = DllStructCreate($TAGMENUITEMINFO)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "Mask", $MIIM_STATE)
    DllStructSetData($tinfo, "State", $istate)
    Return _GUICtrlMenu_SetItemInfo($hmenu, $iitem, $tinfo, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemState

Func _GUICtrlMenu_SetItemSubMenu($hmenu, $iitem, $hsubmenu, $bbypos = True)
    Local $tinfo = DllStructCreate($TAGMENUITEMINFO)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "Mask", $MIIM_SUBMENU)
    DllStructSetData($tinfo, "SubMenu", $hsubmenu)
    Return _GUICtrlMenu_SetItemInfo($hmenu, $iitem, $tinfo, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemSubMenu

Func _GUICtrlMenu_SetItemText($hmenu, $iitem, $stext, $bbypos = True)
    Local $tbuffer = DllStructCreate("wchar Text[" & StringLen($stext) + 0x1 & "]")
    DllStructSetData($tbuffer, "Text", $stext)
    Local $tinfo = DllStructCreate($TAGMENUITEMINFO)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "Mask", $MIIM_STRING)
    DllStructSetData($tinfo, "TypeData", DllStructGetPtr($tbuffer))
    Return _GUICtrlMenu_SetItemInfo($hmenu, $iitem, $tinfo, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemText

Func _GUICtrlMenu_SetItemType($hmenu, $iitem, $itype, $bbypos = True)
    Local $tinfo = DllStructCreate($TAGMENUITEMINFO)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "Mask", $MIIM_FTYPE)
    DllStructSetData($tinfo, "Type", $itype)
    Return _GUICtrlMenu_SetItemInfo($hmenu, $iitem, $tinfo, $bbypos)
EndFunc    ; -> _GUICtrlMenu_SetItemType

Func _GUICtrlMenu_SetMenu($hwnd, $hmenu)
    Local $acall = DllCall("user32.dll", "bool", "SetMenu", "hwnd", $hwnd, "handle", $hmenu)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_SetMenu

Func _GUICtrlMenu_SetMenuBackground($hmenu, $hbrush)
    Local $tinfo = DllStructCreate($TAGMENUINFO)
    DllStructSetData($tinfo, "Mask", $MIM_BACKGROUND)
    DllStructSetData($tinfo, "hBack", $hbrush)
    Return _GUICtrlMenu_SetMenuInfo($hmenu, $tinfo)
EndFunc    ; -> _GUICtrlMenu_SetMenuBackground

Func _GUICtrlMenu_SetMenuContextHelpID($hmenu, $ihelpid)
    Local $tinfo = DllStructCreate($TAGMENUINFO)
    DllStructSetData($tinfo, "Mask", $MIM_HELPID)
    DllStructSetData($tinfo, "ContextHelpID", $ihelpid)
    Return _GUICtrlMenu_SetMenuInfo($hmenu, $tinfo)
EndFunc    ; -> _GUICtrlMenu_SetMenuContextHelpID

Func _GUICtrlMenu_SetMenuData($hmenu, $idata)
    Local $tinfo = DllStructCreate($TAGMENUINFO)
    DllStructSetData($tinfo, "Mask", $MIM_MENUDATA)
    DllStructSetData($tinfo, "MenuData", $idata)
    Return _GUICtrlMenu_SetMenuInfo($hmenu, $tinfo)
EndFunc    ; -> _GUICtrlMenu_SetMenuData

Func _GUICtrlMenu_SetMenuDefaultItem($hmenu, $iitem, $bbypos = True)
    Local $acall = DllCall("user32.dll", "bool", "SetMenuDefaultItem", "handle", $hmenu, "uint", $iitem, "uint", $bbypos)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_SetMenuDefaultItem

Func _GUICtrlMenu_SetMenuHeight($hmenu, $iheight)
    Local $tinfo = DllStructCreate($TAGMENUINFO)
    DllStructSetData($tinfo, "Mask", $MIM_MAXHEIGHT)
    DllStructSetData($tinfo, "YMax", $iheight)
    Return _GUICtrlMenu_SetMenuInfo($hmenu, $tinfo)
EndFunc    ; -> _GUICtrlMenu_SetMenuHeight

Func _GUICtrlMenu_SetMenuInfo($hmenu, ByRef $tinfo)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    Local $acall = DllCall("user32.dll", "bool", "SetMenuInfo", "handle", $hmenu, "struct*", $tinfo)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_SetMenuInfo

Func _GUICtrlMenu_SetMenuStyle($hmenu, $istyle)
    Local $tinfo = DllStructCreate($TAGMENUINFO)
    DllStructSetData($tinfo, "Mask", $MIM_STYLE)
    DllStructSetData($tinfo, "Style", $istyle)
    Return _GUICtrlMenu_SetMenuInfo($hmenu, $tinfo)
EndFunc    ; -> _GUICtrlMenu_SetMenuStyle

Func _GUICtrlMenu_TrackPopupMenu($hmenu, $hwnd, $ix = + -1, $iy = + -1, $ialignx = 0x1, $ialigny = 0x1, $inotify = 0x0, $ibuttons = 0x0)
    If $ix = + -1 Then $ix = _WinAPI_GetMousePosX()
    If $iy = + -1 Then $iy = _WinAPI_GetMousePosY()
    Local $IFLAGS = 0x0
    Switch $ialignx
    Case 0x1
        $IFLAGS = BitOR($IFLAGS, $TPM_LEFTALIGN)
    Case 0x2
        $IFLAGS = BitOR($IFLAGS, $TPM_RIGHTALIGN)
    Case Else
        $IFLAGS = BitOR($IFLAGS, $TPM_CENTERALIGN)
    EndSwitch
    Switch $ialigny
    Case 0x1
        $IFLAGS = BitOR($IFLAGS, $TPM_TOPALIGN)
    Case 0x2
        $IFLAGS = BitOR($IFLAGS, $TPM_VCENTERALIGN)
    Case Else
        $IFLAGS = BitOR($IFLAGS, $TPM_BOTTOMALIGN)
    EndSwitch
    If BitAND($inotify, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $TPM_NONOTIFY)
    If BitAND($inotify, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $TPM_RETURNCMD)
    Switch $ibuttons
    Case 0x1
        $IFLAGS = BitOR($IFLAGS, $TPM_RIGHTBUTTON)
    Case Else
        $IFLAGS = BitOR($IFLAGS, $TPM_LEFTBUTTON)
    EndSwitch
    Local $acall = DllCall("user32.dll", "bool", "TrackPopupMenu", "handle", $hmenu, "uint", $IFLAGS, "int", $ix, "int", $iy, "int", 0x0, "hwnd", $hwnd, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> _GUICtrlMenu_TrackPopupMenu

Global Const $__MONTHCALCONSTANT_CLASSNAME = "SysMonthCal32"
Global Const $__MONTHCALCONSTANT_SWP_NOZORDER = 0x4
Func _GUICtrlMonthCal_Create($hwnd, $ix, $iy, $istyle = 0x0, $iexstyle = 0x0)
    If Not IsHWnd($hwnd) Then
        Return SetError(0x1, 0x0, 0x0)
    EndIf
    Local $hmoncal, $nctrlid
    If $istyle = + -1 Then $istyle = 0x0
    If $iexstyle = + -1 Then $iexstyle = 0x0
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
    $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    $hmoncal = _WinAPI_CreateWindowEx($iexstyle, $__MONTHCALCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, 0x0, 0x0, $hwnd, $nctrlid)
    __GUICtrlMonthCal_Resize($hmoncal, $ix, $iy)
    Return $hmoncal
EndFunc    ; -> _GUICtrlMonthCal_Create

Func _GUICtrlMonthCal_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__MONTHCALCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlMonthCal_Destroy

Func _GUICtrlMonthCal_GetCalendarBorder($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_GETCALENDARBORDER)
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_GETCALENDARBORDER, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_GetCalendarBorder

Func _GUICtrlMonthCal_GetCalendarCount($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_GETCALENDARCOUNT)
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_GETCALENDARCOUNT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_GetCalendarCount

Func _GUICtrlMonthCal_GetColor($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_GETCOLOR, $iindex)
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_GETCOLOR, $iindex, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_GetColor

Func _GUICtrlMonthCal_GetColorArray($hwnd, $icolor)
    Local $iret, $a_result[0x4]
    $a_result[0x0] = 0x3
    If IsHWnd($hwnd) Then
        $iret = _SendMessage($hwnd, $MCM_GETCOLOR, $icolor)
    Else
        $iret = GUICtrlSendMsg($hwnd, $MCM_GETCOLOR, $icolor, 0x0)
    EndIf
    If $iret = + -1 Then Return SetError(0x1, $iret, 0x0)
    $a_result[0x1] = Int($iret)
    $a_result[0x2] = "0x" & Hex(String($iret), 0x6)
    $a_result[0x3] = Hex(String($iret), 0x6)
    $a_result[0x3] = "0x" & StringMid($a_result[0x3], 0x5, 0x2) & StringMid($a_result[0x3], 0x3, 0x2) & StringMid($a_result[0x3], 0x1, 0x2)
    Return $a_result
EndFunc    ; -> _GUICtrlMonthCal_GetColorArray

Func _GUICtrlMonthCal_GetCurSel($hwnd)
    Local $tbuffer = DllStructCreate($TAGSYSTEMTIME)
    __guictrl_sendmsg($hwnd, $MCM_GETCURSEL, 0x0, $tbuffer, 0x0, True)
    Return $tbuffer
EndFunc    ; -> _GUICtrlMonthCal_GetCurSel

Func _GUICtrlMonthCal_GetCurSelStr($hwnd, $sformat = "%02d/%02d/%04d")
    Local $tbuffer = _GUICtrlMonthCal_GetCurSel($hwnd)
    Return StringFormat($sformat, DllStructGetData($tbuffer, "Month"), DllStructGetData($tbuffer, "Day"), DllStructGetData($tbuffer, "Year"))
EndFunc    ; -> _GUICtrlMonthCal_GetCurSelStr

Func _GUICtrlMonthCal_GetFirstDOW($hwnd)
    If IsHWnd($hwnd) Then
        Return _WinAPI_LoWord(_SendMessage($hwnd, $MCM_GETFIRSTDAYOFWEEK))
    Else
        Return _WinAPI_LoWord(GUICtrlSendMsg($hwnd, $MCM_GETFIRSTDAYOFWEEK, 0x0, 0x0))
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_GetFirstDOW

Func _GUICtrlMonthCal_GetFirstDOWStr($hwnd)
    Local $adays[0x7] = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    Return $adays[_GUICtrlMonthCal_GetFirstDOW($hwnd)]
EndFunc    ; -> _GUICtrlMonthCal_GetFirstDOWStr

Func _GUICtrlMonthCal_GetMaxSelCount($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_GETMAXSELCOUNT)
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_GETMAXSELCOUNT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_GetMaxSelCount

Func _GUICtrlMonthCal_GetMaxTodayWidth($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_GETMAXTODAYWIDTH)
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_GETMAXTODAYWIDTH, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_GetMaxTodayWidth

Func _GUICtrlMonthCal_GetMinReqHeight($hwnd)
    Local $trect = _GUICtrlMonthCal_GetMinReqRect($hwnd)
    Return DllStructGetData($trect, "Bottom")
EndFunc    ; -> _GUICtrlMonthCal_GetMinReqHeight

Func _GUICtrlMonthCal_GetMinReqRect($hwnd)
    Local $trect = DllStructCreate($TAGRECT)
    __guictrl_sendmsg($hwnd, $MCM_GETMINREQRECT, 0x0, $trect, True)
    Return $trect
EndFunc    ; -> _GUICtrlMonthCal_GetMinReqRect

Func _GUICtrlMonthCal_GetMinReqRectArray($hwnd)
    Local $i_ret
    Local $trect = DllStructCreate($TAGRECT)
    If @error Then Return SetError(+ -1, + -1, + -1)
    If IsHWnd($hwnd) Then
        $i_ret = _SendMessage($hwnd, $MCM_GETMINREQRECT, 0x0, $trect, 0x0, "wparam", "struct*")
    Else
        $i_ret = GUICtrlSendMsg($hwnd, $MCM_GETMINREQRECT, 0x0, DllStructGetPtr($trect))
    EndIf
    If (Not $i_ret) Then Return SetError(+ -2, + -1, + -1)
    Return StringSplit(DllStructGetData($trect, "Left") & "," & DllStructGetData($trect, "Top") & "," & DllStructGetData($trect, "Right") & "," & DllStructGetData($trect, "Bottom"), ",")
EndFunc    ; -> _GUICtrlMonthCal_GetMinReqRectArray

Func _GUICtrlMonthCal_GetMinReqWidth($hwnd)
    Local $trect = _GUICtrlMonthCal_GetMinReqRect($hwnd)
    Return DllStructGetData($trect, "Right")
EndFunc    ; -> _GUICtrlMonthCal_GetMinReqWidth

Func _GUICtrlMonthCal_GetMonthDelta($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_GETMONTHDELTA)
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_GETMONTHDELTA, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_GetMonthDelta

Func _GUICtrlMonthCal_GetMonthRange($hwnd, $bpartial = False)
    Local $tbuffer = DllStructCreate($TAGMCMONTHRANGE)
    Local $irange = __guictrl_sendmsg($hwnd, $MCM_GETMONTHRANGE, $bpartial, $tbuffer, 0x0, True)
    DllStructSetData($tbuffer, "Span", $irange)
    Return $tbuffer
EndFunc    ; -> _GUICtrlMonthCal_GetMonthRange

Func _GUICtrlMonthCal_GetMonthRangeMax($hwnd, $bpartial = False)
    Local $tbuffer = _GUICtrlMonthCal_GetMonthRange($hwnd, $bpartial)
    Local $trange = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($trange, "Year", DllStructGetData($tbuffer, "MaxYear"))
    DllStructSetData($trange, "Month", DllStructGetData($tbuffer, "MaxMonth"))
    DllStructSetData($trange, "DOW", DllStructGetData($tbuffer, "MaxDOW"))
    DllStructSetData($trange, "Day", DllStructGetData($tbuffer, "MaxDay"))
    Return $trange
EndFunc    ; -> _GUICtrlMonthCal_GetMonthRangeMax

Func _GUICtrlMonthCal_GetMonthRangeMaxStr($hwnd, $sformat = "%02d/%02d/%04d")
    Local $tbuffer = _GUICtrlMonthCal_GetMonthRangeMax($hwnd)
    Return StringFormat($sformat, DllStructGetData($tbuffer, "Month"), DllStructGetData($tbuffer, "Day"), DllStructGetData($tbuffer, "Year"))
EndFunc    ; -> _GUICtrlMonthCal_GetMonthRangeMaxStr

Func _GUICtrlMonthCal_GetMonthRangeMin($hwnd, $bpartial = False)
    Local $tbuffer = _GUICtrlMonthCal_GetMonthRange($hwnd, $bpartial)
    Local $trange = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($trange, "Year", DllStructGetData($tbuffer, "MinYear"))
    DllStructSetData($trange, "Month", DllStructGetData($tbuffer, "MinMonth"))
    DllStructSetData($trange, "DOW", DllStructGetData($tbuffer, "MinDOW"))
    DllStructSetData($trange, "Day", DllStructGetData($tbuffer, "MinDay"))
    Return $trange
EndFunc    ; -> _GUICtrlMonthCal_GetMonthRangeMin

Func _GUICtrlMonthCal_GetMonthRangeMinStr($hwnd, $sformat = "%02d/%02d/%04d")
    Local $tbuffer = _GUICtrlMonthCal_GetMonthRangeMin($hwnd)
    Return StringFormat($sformat, DllStructGetData($tbuffer, "Month"), DllStructGetData($tbuffer, "Day"), DllStructGetData($tbuffer, "Year"))
EndFunc    ; -> _GUICtrlMonthCal_GetMonthRangeMinStr

Func _GUICtrlMonthCal_GetMonthRangeSpan($hwnd, $bpartial = False)
    Local $tbuffer = _GUICtrlMonthCal_GetMonthRange($hwnd, $bpartial)
    Return DllStructGetData($tbuffer, "Span")
EndFunc    ; -> _GUICtrlMonthCal_GetMonthRangeSpan

Func _GUICtrlMonthCal_GetRange($hwnd)
    Local $tbuffer = DllStructCreate($TAGMCRANGE)
    Local $iret = __guictrl_sendmsg($hwnd, $MCM_GETRANGE, 0x0, $tbuffer, 0x0, True)
    DllStructSetData($tbuffer, "MinSet", BitAND($iret, $GDTR_MIN) <> 0x0)
    DllStructSetData($tbuffer, "MaxSet", BitAND($iret, $GDTR_MAX) <> 0x0)
    Return $tbuffer
EndFunc    ; -> _GUICtrlMonthCal_GetRange

Func _GUICtrlMonthCal_GetRangeMax($hwnd)
    Local $tbuffer = _GUICtrlMonthCal_GetRange($hwnd)
    Local $trange = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($trange, "Year", DllStructGetData($tbuffer, "MaxYear"))
    DllStructSetData($trange, "Month", DllStructGetData($tbuffer, "MaxMonth"))
    DllStructSetData($trange, "DOW", DllStructGetData($tbuffer, "MaxDOW"))
    DllStructSetData($trange, "Day", DllStructGetData($tbuffer, "MaxDay"))
    Return $trange
EndFunc    ; -> _GUICtrlMonthCal_GetRangeMax

Func _GUICtrlMonthCal_GetRangeMaxStr($hwnd, $sformat = "%02d/%02d/%04d")
    Local $tbuffer = _GUICtrlMonthCal_GetRangeMax($hwnd)
    Return StringFormat($sformat, DllStructGetData($tbuffer, "Month"), DllStructGetData($tbuffer, "Day"), DllStructGetData($tbuffer, "Year"))
EndFunc    ; -> _GUICtrlMonthCal_GetRangeMaxStr

Func _GUICtrlMonthCal_GetRangeMin($hwnd)
    Local $tbuffer = _GUICtrlMonthCal_GetRange($hwnd)
    Local $trange = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($trange, "Year", DllStructGetData($tbuffer, "MinYear"))
    DllStructSetData($trange, "Month", DllStructGetData($tbuffer, "MinMonth"))
    DllStructSetData($trange, "DOW", DllStructGetData($tbuffer, "MinDOW"))
    DllStructSetData($trange, "Day", DllStructGetData($tbuffer, "MinDay"))
    Return $trange
EndFunc    ; -> _GUICtrlMonthCal_GetRangeMin

Func _GUICtrlMonthCal_GetRangeMinStr($hwnd, $sformat = "%02d/%02d/%04d")
    Local $tbuffer = _GUICtrlMonthCal_GetRangeMin($hwnd)
    Return StringFormat($sformat, DllStructGetData($tbuffer, "Month"), DllStructGetData($tbuffer, "Day"), DllStructGetData($tbuffer, "Year"))
EndFunc    ; -> _GUICtrlMonthCal_GetRangeMinStr

Func _GUICtrlMonthCal_GetSelRange($hwnd)
    Local $tbuffer = DllStructCreate($TAGMCSELRANGE)
    Local $iret = __guictrl_sendmsg($hwnd, $MCM_GETSELRANGE, 0x0, $tbuffer, 0x0, True)
    Return SetError($iret = 0x0, 0x0, $tbuffer)
EndFunc    ; -> _GUICtrlMonthCal_GetSelRange

Func _GUICtrlMonthCal_GetSelRangeMax($hwnd)
    Local $tbuffer = _GUICtrlMonthCal_GetSelRange($hwnd)
    Local $trange = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($trange, "Year", DllStructGetData($tbuffer, "MaxYear"))
    DllStructSetData($trange, "Month", DllStructGetData($tbuffer, "MaxMonth"))
    DllStructSetData($trange, "DOW", DllStructGetData($tbuffer, "MaxDOW"))
    DllStructSetData($trange, "Day", DllStructGetData($tbuffer, "MaxDay"))
    Return $trange
EndFunc    ; -> _GUICtrlMonthCal_GetSelRangeMax

Func _GUICtrlMonthCal_GetSelRangeMaxStr($hwnd, $sformat = "%02d/%02d/%04d")
    Local $tbuffer = _GUICtrlMonthCal_GetSelRangeMax($hwnd)
    Return StringFormat($sformat, DllStructGetData($tbuffer, "Month"), DllStructGetData($tbuffer, "Day"), DllStructGetData($tbuffer, "Year"))
EndFunc    ; -> _GUICtrlMonthCal_GetSelRangeMaxStr

Func _GUICtrlMonthCal_GetSelRangeMin($hwnd)
    Local $tbuffer = _GUICtrlMonthCal_GetSelRange($hwnd)
    Local $trange = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($trange, "Year", DllStructGetData($tbuffer, "MinYear"))
    DllStructSetData($trange, "Month", DllStructGetData($tbuffer, "MinMonth"))
    DllStructSetData($trange, "DOW", DllStructGetData($tbuffer, "MinDOW"))
    DllStructSetData($trange, "Day", DllStructGetData($tbuffer, "MinDay"))
    Return $trange
EndFunc    ; -> _GUICtrlMonthCal_GetSelRangeMin

Func _GUICtrlMonthCal_GetSelRangeMinStr($hwnd, $sformat = "%02d/%02d/%04d")
    Local $tbuffer = _GUICtrlMonthCal_GetSelRangeMin($hwnd)
    Return StringFormat($sformat, DllStructGetData($tbuffer, "Month"), DllStructGetData($tbuffer, "Day"), DllStructGetData($tbuffer, "Year"))
EndFunc    ; -> _GUICtrlMonthCal_GetSelRangeMinStr

Func _GUICtrlMonthCal_GetToday($hwnd)
    Local $tbuffer = DllStructCreate($TAGSYSTEMTIME)
    Local $iret = __guictrl_sendmsg($hwnd, $MCM_GETTODAY, 0x0, $tbuffer, 0x0, True)
    Return SetError($iret = 0x0, 0x0, $tbuffer)
EndFunc    ; -> _GUICtrlMonthCal_GetToday

Func _GUICtrlMonthCal_GetTodayStr($hwnd, $sformat = "%02d/%02d/%04d")
    Local $tbuffer = _GUICtrlMonthCal_GetToday($hwnd)
    Return StringFormat($sformat, DllStructGetData($tbuffer, "Month"), DllStructGetData($tbuffer, "Day"), DllStructGetData($tbuffer, "Year"))
EndFunc    ; -> _GUICtrlMonthCal_GetTodayStr

Func _GUICtrlMonthCal_GetUnicodeFormat($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_GETUNICODEFORMAT) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_GETUNICODEFORMAT, 0x0, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_GetUnicodeFormat

Func _GUICtrlMonthCal_HitTest($hwnd, $ix, $iy)
    Local $ttest = DllStructCreate($TAGMCHITTESTINFO)
    Local $itest = DllStructGetSize($ttest)
    DllStructSetData($ttest, "Size", $itest)
    DllStructSetData($ttest, "X", $ix)
    DllStructSetData($ttest, "Y", $iy)
    __guictrl_sendmsg($hwnd, $MCM_HITTEST, 0x0, $ttest, 0x0, True)
    Return $ttest
EndFunc    ; -> _GUICtrlMonthCal_HitTest

Func __GUICtrlMonthCal_Resize($hwnd, $ix = + -1, $iy = + -1)
    Local $in = _GUICtrlMonthCal_GetMaxTodayWidth($hwnd)
    Local $ih = _GUICtrlMonthCal_GetMinReqHeight($hwnd)
    Local $iw = _GUICtrlMonthCal_GetMinReqWidth($hwnd)
    If $in > $iw Then $iw = $in
    If ($ix = + -1) Or ($iy = + -1) Then
        Local $trect = _WinAPI_GetWindowRect($hwnd)
        If $ix = + -1 Then $ix = DllStructGetData($trect, "Left")
        If $iy = + -1 Then $iy = DllStructGetData($trect, "Top")
    EndIf
    _WinAPI_SetWindowPos($hwnd, 0x0, $ix, $iy, $iw, $ih, $__MONTHCALCONSTANT_SWP_NOZORDER)
EndFunc    ; -> __GUICtrlMonthCal_Resize

Func _GUICtrlMonthCal_SetCalendarBorder($hwnd, $ibordersize = 0x4, $bsetborder = True)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $MCM_SETCALENDARBORDER, $bsetborder, $ibordersize)
    Else
        GUICtrlSendMsg($hwnd, $MCM_SETCALENDARBORDER, $bsetborder, $ibordersize)
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_SetCalendarBorder

Func _GUICtrlMonthCal_SetColor($hwnd, $iindex, $icolor)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_SETCOLOR, $iindex, $icolor)
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_SETCOLOR, $iindex, $icolor)
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_SetColor

Func _GUICtrlMonthCal_SetCurSel($hwnd, $iyear, $imonth, $iday)
    Local $tbuffer = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($tbuffer, "Month", $imonth)
    DllStructSetData($tbuffer, "Day", $iday)
    DllStructSetData($tbuffer, "Year", $iyear)
    Local $iret = __guictrl_sendmsg($hwnd, $MCM_SETCURSEL, 0x0, $tbuffer)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlMonthCal_SetCurSel

Func _GUICtrlMonthCal_SetDayState($hwnd, $amasks)
    Local $imasks = _GUICtrlMonthCal_GetMonthRangeSpan($hwnd, True)
    Local $tbuffer = DllStructCreate("int;int;int")
    For $ii = 0x0 To $imasks + -1
        DllStructSetData($tbuffer, $ii + 0x1, $amasks[$ii])
    Next
    Local $iret = __guictrl_sendmsg($hwnd, $MCM_SETDAYSTATE, $imasks, $tbuffer)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlMonthCal_SetDayState

Func _GUICtrlMonthCal_SetFirstDOW($hwnd, $sday)
    Local $i_day
    If $sday >= 0x0 Or $sday <= 0x6 Then
        $i_day = $sday
    ElseIf StringInStr("MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY", $sday) Then
        Switch StringUpper($sday)
        Case "MONDAY"
            $i_day = 0x0
        Case "TUESDAY"
            $i_day = 0x1
        Case "WEDNESDAY"
            $i_day = 0x2
        Case "THURSDAY"
            $i_day = 0x3
        Case "FRIDAY"
            $i_day = 0x4
        Case "SATURDAY"
            $i_day = 0x5
        Case "SUNDAY"
            $i_day = 0x6
        EndSwitch
    Else
        Return SetError(+ -1, + -1, + -1)
    EndIf
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_SETFIRSTDAYOFWEEK, 0x0, $i_day)
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_SETFIRSTDAYOFWEEK, 0x0, $i_day)
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_SetFirstDOW

Func _GUICtrlMonthCal_SetMaxSelCount($hwnd, $imaxsel)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_SETMAXSELCOUNT, $imaxsel) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_SETMAXSELCOUNT, $imaxsel, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_SetMaxSelCount

Func _GUICtrlMonthCal_SetMonthDelta($hwnd, $idelta)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_SETMONTHDELTA, $idelta)
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_SETMONTHDELTA, $idelta, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_SetMonthDelta

Func _GUICtrlMonthCal_SetRange($hwnd, $iminyear, $iminmonth, $iminday, $imaxyear, $imaxmonth, $imaxday)
    Local $trange = DllStructCreate($TAGMCRANGE)
    Local $IFLAGS = BitOR($GDTR_MIN, $GDTR_MAX)
    DllStructSetData($trange, "MinYear", $iminyear)
    DllStructSetData($trange, "MinMonth", $iminmonth)
    DllStructSetData($trange, "MinDay", $iminday)
    DllStructSetData($trange, "MaxYear", $imaxyear)
    DllStructSetData($trange, "MaxMonth", $imaxmonth)
    DllStructSetData($trange, "MaxDay", $imaxday)
    Local $iret = __guictrl_sendmsg($hwnd, $MCM_SETRANGE, $IFLAGS, $trange)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlMonthCal_SetRange

Func _GUICtrlMonthCal_SetSelRange($hwnd, $iminyear, $iminmonth, $iminday, $imaxyear, $imaxmonth, $imaxday)
    Local $tbuffer = DllStructCreate($TAGMCRANGE)
    DllStructSetData($tbuffer, "MinYear", $iminyear)
    DllStructSetData($tbuffer, "MinMonth", $iminmonth)
    DllStructSetData($tbuffer, "MinDay", $iminday)
    DllStructSetData($tbuffer, "MaxYear", $imaxyear)
    DllStructSetData($tbuffer, "MaxMonth", $imaxmonth)
    DllStructSetData($tbuffer, "MaxDay", $imaxday)
    Local $iret = __guictrl_sendmsg($hwnd, $MCM_SETSELRANGE, 0x0, $tbuffer)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlMonthCal_SetSelRange

Func _GUICtrlMonthCal_SetToday($hwnd, $iyear, $imonth, $iday)
    Local $tbuffer = DllStructCreate($TAGSYSTEMTIME)
    DllStructSetData($tbuffer, "Month", $imonth)
    DllStructSetData($tbuffer, "Day", $iday)
    DllStructSetData($tbuffer, "Year", $iyear)
    __guictrl_sendmsg($hwnd, $MCM_SETTODAY, 0x0, $tbuffer)
EndFunc    ; -> _GUICtrlMonthCal_SetToday

Func _GUICtrlMonthCal_SetUnicodeFormat($hwnd, $bunicode = False)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $MCM_SETUNICODEFORMAT, $bunicode) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $MCM_SETUNICODEFORMAT, $bunicode, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlMonthCal_SetUnicodeFormat

Global Const $__REBARCONSTANT_WM_USER = 0x400
Global Const $RB_BEGINDRAG = ($__REBARCONSTANT_WM_USER + 0x18)
Global Const $RB_DELETEBAND = ($__REBARCONSTANT_WM_USER + 0x2)
Global Const $RB_DRAGMOVE = ($__REBARCONSTANT_WM_USER + 0x1a)
Global Const $RB_ENDDRAG = ($__REBARCONSTANT_WM_USER + 0x19)
Global Const $RB_GETBANDBORDERS = ($__REBARCONSTANT_WM_USER + 0x22)
Global Const $RB_GETBANDCOUNT = ($__REBARCONSTANT_WM_USER + 0xc)
Global Const $RB_GETBANDINFO = ($__REBARCONSTANT_WM_USER + 0x5)
Global Const $RB_GETBANDINFOA = ($__REBARCONSTANT_WM_USER + 0x1d)
Global Const $RB_GETBANDINFOW = ($__REBARCONSTANT_WM_USER + 0x1c)
Global Const $RB_GETBANDMARGINS = ($__REBARCONSTANT_WM_USER + 0x28)
Global Const $RB_GETBARHEIGHT = ($__REBARCONSTANT_WM_USER + 0x1b)
Global Const $RB_GETBARINFO = ($__REBARCONSTANT_WM_USER + 0x3)
Global Const $RB_GETBKCOLOR = ($__REBARCONSTANT_WM_USER + 0x14)
Global Const $RB_GETCOLORSCHEME = 0x2000 + 0x3
Global Const $RB_GETDROPTARGET = (0x2000 + 0x4)
Global Const $RB_GETPALETTE = ($__REBARCONSTANT_WM_USER + 0x26)
Global Const $RB_GETRECT = ($__REBARCONSTANT_WM_USER + 0x9)
Global Const $RB_GETROWCOUNT = ($__REBARCONSTANT_WM_USER + 0xd)
Global Const $RB_GETROWHEIGHT = ($__REBARCONSTANT_WM_USER + 0xe)
Global Const $RB_GETTEXTCOLOR = ($__REBARCONSTANT_WM_USER + 0x16)
Global Const $RB_GETTOOLTIPS = ($__REBARCONSTANT_WM_USER + 0x11)
Global Const $RB_GETUNICODEFORMAT = 0x2000 + 0x6
Global Const $RB_HITTEST = ($__REBARCONSTANT_WM_USER + 0x8)
Global Const $RB_IDTOINDEX = ($__REBARCONSTANT_WM_USER + 0x10)
Global Const $RB_INSERTBANDA = ($__REBARCONSTANT_WM_USER + 0x1)
Global Const $RB_INSERTBANDW = ($__REBARCONSTANT_WM_USER + 0xa)
Global Const $RB_MAXIMIZEBAND = ($__REBARCONSTANT_WM_USER + 0x1f)
Global Const $RB_MINIMIZEBAND = ($__REBARCONSTANT_WM_USER + 0x1e)
Global Const $RB_MOVEBAND = ($__REBARCONSTANT_WM_USER + 0x27)
Global Const $RB_PUSHCHEVRON = ($__REBARCONSTANT_WM_USER + 0x2b)
Global Const $RB_SETBANDINFOA = ($__REBARCONSTANT_WM_USER + 0x6)
Global Const $RB_SETBANDINFOW = ($__REBARCONSTANT_WM_USER + 0xb)
Global Const $RB_SETBARINFO = ($__REBARCONSTANT_WM_USER + 0x4)
Global Const $RB_SETBKCOLOR = ($__REBARCONSTANT_WM_USER + 0x13)
Global Const $RB_SETCOLORSCHEME = 0x2000 + 0x2
Global Const $RB_SETPALETTE = ($__REBARCONSTANT_WM_USER + 0x25)
Global Const $RB_SETPARENT = ($__REBARCONSTANT_WM_USER + 0x7)
Global Const $RB_SETTEXTCOLOR = ($__REBARCONSTANT_WM_USER + 0x15)
Global Const $RB_SETTOOLTIPS = ($__REBARCONSTANT_WM_USER + 0x12)
Global Const $RB_SETUNICODEFORMAT = 0x2000 + 0x5
Global Const $RB_SETWINDOWTHEME = 0x2000 + 0xb
Global Const $RB_SHOWBAND = ($__REBARCONSTANT_WM_USER + 0x23)
Global Const $RB_SIZETORECT = ($__REBARCONSTANT_WM_USER + 0x17)
Global Const $RBN_FIRST = (+ -831)
Global Const $RBN_AUTOBREAK = ($RBN_FIRST + -22)
Global Const $RBN_AUTOSIZE = ($RBN_FIRST + -3)
Global Const $RBN_BEGINDRAG = ($RBN_FIRST + -4)
Global Const $RBN_CHEVRONPUSHED = ($RBN_FIRST + -10)
Global Const $RBN_CHILDSIZE = ($RBN_FIRST + -8)
Global Const $RBN_DELETEDBAND = ($RBN_FIRST + -7)
Global Const $RBN_DELETINGBAND = ($RBN_FIRST + -6)
Global Const $RBN_ENDDRAG = ($RBN_FIRST + -5)
Global Const $RBN_GETOBJECT = ($RBN_FIRST + -1)
Global Const $RBN_HEIGHTCHANGE = ($RBN_FIRST + 0x0)
Global Const $RBN_LAYOUTCHANGED = ($RBN_FIRST + -2)
Global Const $RBN_MINMAX = ($RBN_FIRST + -21)
Global Const $RBS_AUTOSIZE = 0x2000
Global Const $RBS_BANDBORDERS = 0x400
Global Const $RBS_DBLCLKTOGGLE = 0x8000
Global Const $RBS_FIXEDORDER = 0x800
Global Const $RBS_REGISTERDROP = 0x1000
Global Const $RBS_TOOLTIPS = 0x100
Global Const $RBS_VARHEIGHT = 0x200
Global Const $RBS_VERTICALGRIPPER = 0x4000
Global Const $RBBIM_STYLE = 0x1
Global Const $RBBIM_COLORS = 0x2
Global Const $RBBIM_TEXT = 0x4
Global Const $RBBIM_IMAGE = 0x8
Global Const $RBBIM_CHILD = 0x10
Global Const $RBBIM_CHILDSIZE = 0x20
Global Const $RBBIM_SIZE = 0x40
Global Const $RBBIM_BACKGROUND = 0x80
Global Const $RBBIM_ID = 0x100
Global Const $RBBIM_IDEALSIZE = 0x200
Global Const $RBBIM_LPARAM = 0x400
Global Const $RBBIM_HEADERSIZE = 0x800
Global Const $RBIM_IMAGELIST = 0x1
Global Const $RBBS_BREAK = 0x1
Global Const $RBBS_CHILDEDGE = 0x4
Global Const $RBBS_FIXEDBMP = 0x20
Global Const $RBBS_FIXEDSIZE = 0x2
Global Const $RBBS_GRIPPERALWAYS = 0x80
Global Const $RBBS_HIDDEN = 0x8
Global Const $RBBS_HIDETITLE = 0x400
Global Const $RBBS_NOGRIPPER = 0x100
Global Const $RBBS_NOVERT = 0x10
Global Const $RBBS_TOPALIGN = 0x800
Global Const $RBBS_USECHEVRON = 0x200
Global Const $RBBS_VARIABLEHEIGHT = 0x40
Global Const $RBHT_CAPTION = 0x2
Global Const $RBHT_CHEVRON = 0x8
Global Const $RBHT_CLIENT = 0x3
Global Const $RBHT_GRABBER = 0x4
Global Const $RBHT_NOWHERE = 0x1
Global Const $RBNM_ID = 0x1
Global Const $RBNM_LPARAM = 0x4
Global Const $RBNM_STYLE = 0x2
Global $__g_trebarbuffer, $__g_trebarbufferansi
Global Const $__REBARCONSTANT_CLASSNAME = "ReBarWindow32"
Global Const $__REBARCONSTANT_TB_GETBUTTONSIZE = $__REBARCONSTANT_WM_USER + 0x3a
Global Const $__REBARCONSTANT_TB_BUTTONCOUNT = $__REBARCONSTANT_WM_USER + 0x18
Global Const $__REBARCONSTANT_WS_CLIPCHILDREN = 0x2000000
Global Const $__REBARCONSTANT_WS_CLIPSIBLINGS = 0x4000000
Global Const $__REBARCONSTANT_CCS_TOP = 0x1
Global Const $TAGREBARINFO = "uint cbSize;uint fMask;handle himl"
Global Const $TAGRBHITTESTINFO = $TAGPOINT & ";uint flags;int iBand"
Func _GUICtrlRebar_AddBand($hwndrebar, $hwndchild, $iminwidth = 0x64, $idefaultwidth = 0x64, $stext = '', $iindex = + -1, $istyle = + -1)
    If Not IsHWnd($hwndchild) Then $hwndchild = GUICtrlGetHandle($hwndchild)
    Local $tbuffer, $imsg
    If _GUICtrlRebar_GetUnicodeFormat($hwndrebar) Then
        $tbuffer = $__g_trebarbuffer
        $imsg = $RB_INSERTBANDW
    Else
        $tbuffer = $__g_trebarbufferansi
        $imsg = $RB_INSERTBANDA
    EndIf
    Local $tinfo = DllStructCreate($TAGREBARBANDINFO)
    If $idefaultwidth < $iminwidth Then $idefaultwidth = $iminwidth
    If $istyle <> + -1 Then
        $istyle = BitOR($istyle, $RBBS_CHILDEDGE, $RBBS_GRIPPERALWAYS)
    Else
        $istyle = BitOR($RBBS_CHILDEDGE, $RBBS_GRIPPERALWAYS)
    EndIf
    DllStructSetData($tinfo, "cbSize", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "fMask", BitOR($RBBIM_STYLE, $RBBIM_TEXT, $RBBIM_CHILD, $RBBIM_CHILDSIZE, $RBBIM_SIZE, $RBBIM_ID))
    DllStructSetData($tinfo, "fStyle", $istyle)
    Local $trect = _WinAPI_GetWindowRect($hwndchild)
    Local $ibottom = DllStructGetData($trect, "Bottom")
    Local $itop = DllStructGetData($trect, "Top")
    DllStructSetData($tbuffer, "Text", $stext)
    DllStructSetData($tinfo, "hwndChild", $hwndchild)
    DllStructSetData($tinfo, "cxMinChild", $iminwidth)
    DllStructSetData($tinfo, "cyMinChild", $ibottom - $itop)
    DllStructSetData($tinfo, "cx", $idefaultwidth)
    DllStructSetData($tinfo, "wID", _GUICtrlRebar_GetBandCount($hwndrebar))
    Local $iret = __guictrl_sendmsg($hwndrebar, $imsg, $iindex, $tinfo, $tbuffer, False, 0x6) <> 0x0
    Return $iret
EndFunc    ; -> _GUICtrlRebar_AddBand

Func _GUICtrlRebar_AddToolBarBand($hwndrebar, $hwndtoolbar, $stext = '', $iindex = + -1, $istyle = + -1)
    Local $tbuffer, $imsg
    If _GUICtrlRebar_GetUnicodeFormat($hwndrebar) Then
        $tbuffer = $__g_trebarbuffer
        $imsg = $RB_INSERTBANDW
    Else
        $tbuffer = $__g_trebarbufferansi
        $imsg = $RB_INSERTBANDA
    EndIf
    Local $tinfo = DllStructCreate($TAGREBARBANDINFO)
    If $istyle <> + -1 Then
        $istyle = BitOR($istyle, $RBBS_CHILDEDGE, $RBBS_GRIPPERALWAYS)
    Else
        $istyle = BitOR($RBBS_CHILDEDGE, $RBBS_GRIPPERALWAYS)
    EndIf
    DllStructSetData($tinfo, "cbSize", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "fMask", BitOR($RBBIM_STYLE, $RBBIM_TEXT, $RBBIM_CHILD, $RBBIM_CHILDSIZE, $RBBIM_SIZE, $RBBIM_ID))
    DllStructSetData($tinfo, "fStyle", $istyle)
    Local $ibtnsize = _SendMessage($hwndtoolbar, $__REBARCONSTANT_TB_GETBUTTONSIZE)
    Local $inumbuttons = _SendMessage($hwndtoolbar, $__REBARCONSTANT_TB_BUTTONCOUNT)
    Local $idefaultwidth = $inumbuttons * _WinAPI_LoWord($ibtnsize)
    DllStructSetData($tbuffer, "Text", $stext)
    DllStructSetData($tinfo, "hwndChild", $hwndtoolbar)
    DllStructSetData($tinfo, "cyChild", _WinAPI_HiWord($ibtnsize))
    DllStructSetData($tinfo, "cxMinChild", $idefaultwidth)
    DllStructSetData($tinfo, "cyMinChild", _WinAPI_HiWord($ibtnsize))
    DllStructSetData($tinfo, "cx", $idefaultwidth)
    DllStructSetData($tinfo, "wID", _GUICtrlRebar_GetBandCount($hwndrebar))
    Local $iret = __guictrl_sendmsg($hwndrebar, $imsg, $iindex, $tinfo, $tbuffer, False, 0x6) <> 0x0
    Return $iret
EndFunc    ; -> _GUICtrlRebar_AddToolBarBand

Func _GUICtrlRebar_BeginDrag($hwnd, $iindex, $ipos = + -1)
    _SendMessage($hwnd, $RB_BEGINDRAG, $iindex, $ipos, 0x0, "wparam", "dword")
EndFunc    ; -> _GUICtrlRebar_BeginDrag

Func _GUICtrlRebar_Create($hwnd, $istyles = 0x513)
    Local Const $ICC_BAR_CLASSES = 0x4
    Local Const $ICC_COOL_CLASSES = 0x400
    Local $istyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $__REBARCONSTANT_WS_CLIPCHILDREN, $__REBARCONSTANT_WS_CLIPSIBLINGS)
    If $istyles <> BitOR($__REBARCONSTANT_CCS_TOP, $RBS_VARHEIGHT) Then
        $istyle = BitOR($istyle, $istyles)
    Else
        $istyle = BitOR($istyle, $__REBARCONSTANT_CCS_TOP, $RBS_VARHEIGHT)
    EndIf
    Local $ticce = DllStructCreate("dword;dword")
    DllStructSetData($ticce, 0x1, DllStructGetSize($ticce))
    DllStructSetData($ticce, 0x2, BitOR($ICC_BAR_CLASSES, $ICC_COOL_CLASSES))
    Local $acall = DllCall("comctl32.dll", "int", "InitCommonControlsEx", "struct*", $ticce)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = 0x0 Then Return SetError(+ -2, 0x0, 0x0)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hrebar = _WinAPI_CreateWindowEx(0x0, $__REBARCONSTANT_CLASSNAME, '', $istyle, 0x0, 0x0, 0x0, 0x0, $hwnd, $nctrlid)
    If @error Then Return SetError(+ -1, + -1, 0x0)
    Return $hrebar
EndFunc    ; -> _GUICtrlRebar_Create

Func _GUICtrlRebar_DeleteBand($hwnd, $iindex)
    Return _SendMessage($hwnd, $RB_DELETEBAND, $iindex) <> 0x0
EndFunc    ; -> _GUICtrlRebar_DeleteBand

Func _GUICtrlRebar_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__REBARCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
        Local $irebarcount = _GUICtrlRebar_GetBandCount($hwnd)
        For $iindex = $irebarcount + -1 To 0x0 Step + -1
            _GUICtrlRebar_DeleteBand($hwnd, $iindex)
        Next
        Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
        Local $hparent = _WinAPI_GetParent($hwnd)
        $idestroyed = _WinAPI_DestroyWindow($hwnd)
        Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
        If Not $iret Then
        EndIf
    Else
        Return SetError(0x1, 0x1, False)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlRebar_Destroy

Func _GUICtrlRebar_DragMove($hwnd, $ipos = + -1)
    _SendMessage($hwnd, $RB_DRAGMOVE, 0x0, $ipos, 0x0, "wparam", "dword")
EndFunc    ; -> _GUICtrlRebar_DragMove

Func _GUICtrlRebar_EndDrag($hwnd)
    _SendMessage($hwnd, $RB_ENDDRAG)
EndFunc    ; -> _GUICtrlRebar_EndDrag

Func _GUICtrlRebar_GetBandBackColor($hwnd, $iindex)
    Local $tinfo = __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $RBBIM_COLORS)
    If @error Then Return SetError(@error, @error, 0x0)
    Return DllStructGetData($tinfo, "clrBack")
EndFunc    ; -> _GUICtrlRebar_GetBandBackColor

Func _GUICtrlRebar_GetBandBorders($hwnd, $iindex)
    Local $trect = _GUICtrlRebar_GetBandBordersEx($hwnd, $iindex)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlRebar_GetBandBorders

Func _GUICtrlRebar_GetBandBordersEx($hwnd, $iindex)
    Local $trect = DllStructCreate($TAGRECT)
    _SendMessage($hwnd, $RB_GETBANDBORDERS, $iindex, $trect, 0x0, "uint", "struct*")
    Return $trect
EndFunc    ; -> _GUICtrlRebar_GetBandBordersEx

Func _GUICtrlRebar_GetBandChildHandle($hwnd, $iindex)
    Local $tinfo = __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $RBBIM_CHILD)
    If @error Then Return SetError(@error, @error, 0x0)
    Return DllStructGetData($tinfo, "hwndChild")
EndFunc    ; -> _GUICtrlRebar_GetBandChildHandle

Func _GUICtrlRebar_GetBandChildSize($hwnd, $iindex)
    Local $asizes[0x5]
    Local $tinfo = __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $RBBIM_CHILDSIZE)
    If @error Then Return SetError(@error, @error, $asizes)
    $asizes[0x0] = DllStructGetData($tinfo, "cxMinChild")
    $asizes[0x1] = DllStructGetData($tinfo, "cyMinChild")
    $asizes[0x2] = DllStructGetData($tinfo, "cyChild")
    $asizes[0x3] = DllStructGetData($tinfo, "cyMaxChild")
    $asizes[0x4] = DllStructGetData($tinfo, "cyIntegral")
    Return $asizes
EndFunc    ; -> _GUICtrlRebar_GetBandChildSize

Func _GUICtrlRebar_GetBandCount($hwnd)
    Return _SendMessage($hwnd, $RB_GETBANDCOUNT)
EndFunc    ; -> _GUICtrlRebar_GetBandCount

Func _GUICtrlRebar_GetBandForeColor($hwnd, $iindex)
    Local $tinfo = __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $RBBIM_COLORS)
    If @error Then Return SetError(@error, @error, 0x0)
    Return DllStructGetData($tinfo, "clrFore")
EndFunc    ; -> _GUICtrlRebar_GetBandForeColor

Func _GUICtrlRebar_GetBandHeaderSize($hwnd, $iindex)
    Local $tinfo = __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $RBBIM_HEADERSIZE)
    If @error Then Return SetError(@error, @error, 0x0)
    Return DllStructGetData($tinfo, "cxHeader")
EndFunc    ; -> _GUICtrlRebar_GetBandHeaderSize

Func _GUICtrlRebar_GetBandID($hwnd, $iindex)
    Local $tinfo = __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $RBBIM_ID)
    If @error Then Return SetError(@error, @error, 0x0)
    Return DllStructGetData($tinfo, "wID")
EndFunc    ; -> _GUICtrlRebar_GetBandID

Func _GUICtrlRebar_GetBandIdealSize($hwnd, $iindex)
    Local $tinfo = __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $RBBIM_IDEALSIZE)
    If @error Then Return SetError(@error, @error, 0x0)
    Return DllStructGetData($tinfo, "cxIdeal")
EndFunc    ; -> _GUICtrlRebar_GetBandIdealSize

Func __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $imask)
    Local $tinfo = DllStructCreate($TAGREBARBANDINFO)
    DllStructSetData($tinfo, "cbSize", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "fMask", $imask)
    Local $iret = _SendMessage($hwnd, $RB_GETBANDINFOW, $iindex, $tinfo, 0x0, "wparam", "struct*")
    Return SetError($iret = 0x0, 0x0, $tinfo)
EndFunc    ; -> __GUICtrlRebar_GetBandInfo

Func _GUICtrlRebar_GetBandLParam($hwnd, $iindex)
    Local $tinfo = __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $RBBIM_LPARAM)
    If @error Then Return SetError(@error, @error, 0x0)
    Return DllStructGetData($tinfo, "lParam")
EndFunc    ; -> _GUICtrlRebar_GetBandLParam

Func _GUICtrlRebar_GetBandLength($hwnd, $iindex)
    Local $tinfo = __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $RBBIM_SIZE)
    If @error Then Return SetError(@error, @error, 0x0)
    Return DllStructGetData($tinfo, "cx")
EndFunc    ; -> _GUICtrlRebar_GetBandLength

Func _GUICtrlRebar_GetBandMargins($hwnd)
    Local $tmargins = _GUICtrlRebar_GetBandMarginsEx($hwnd)
    Local $amargins[0x4]
    $amargins[0x0] = DllStructGetData($tmargins, "cxLeftWidth")
    $amargins[0x1] = DllStructGetData($tmargins, "cxRightWidth")
    $amargins[0x2] = DllStructGetData($tmargins, "cyTopHeight")
    $amargins[0x3] = DllStructGetData($tmargins, "cyBottomHeight")
    Return $amargins
EndFunc    ; -> _GUICtrlRebar_GetBandMargins

Func _GUICtrlRebar_GetBandMarginsEx($hwnd)
    Local $tmargins = DllStructCreate($TAGMARGINS)
    _SendMessage($hwnd, $RB_GETBANDMARGINS, 0x0, $tmargins, 0x0, "wparam", "struct*")
    Return $tmargins
EndFunc    ; -> _GUICtrlRebar_GetBandMarginsEx

Func _GUICtrlRebar_GetBandStyle($hwnd, $iindex)
    Local $tinfo = __GUICtrlRebar_GetBandInfo($hwnd, $iindex, $RBBIM_STYLE)
    If @error Then Return SetError(@error, @error, 0x0)
    Return DllStructGetData($tinfo, "fStyle")
EndFunc    ; -> _GUICtrlRebar_GetBandStyle

Func _GUICtrlRebar_GetBandStyleBreak($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_BREAK) = $RBBS_BREAK
EndFunc    ; -> _GUICtrlRebar_GetBandStyleBreak

Func _GUICtrlRebar_GetBandStyleChildEdge($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_CHILDEDGE) = $RBBS_CHILDEDGE
EndFunc    ; -> _GUICtrlRebar_GetBandStyleChildEdge

Func _GUICtrlRebar_GetBandStyleFixedBMP($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_FIXEDBMP) = $RBBS_FIXEDBMP
EndFunc    ; -> _GUICtrlRebar_GetBandStyleFixedBMP

Func _GUICtrlRebar_GetBandStyleFixedSize($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_FIXEDSIZE) = $RBBS_FIXEDSIZE
EndFunc    ; -> _GUICtrlRebar_GetBandStyleFixedSize

Func _GUICtrlRebar_GetBandStyleGripperAlways($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_GRIPPERALWAYS) = $RBBS_GRIPPERALWAYS
EndFunc    ; -> _GUICtrlRebar_GetBandStyleGripperAlways

Func _GUICtrlRebar_GetBandStyleHidden($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_HIDDEN) = $RBBS_HIDDEN
EndFunc    ; -> _GUICtrlRebar_GetBandStyleHidden

Func _GUICtrlRebar_GetBandStyleHideTitle($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_HIDETITLE) = $RBBS_HIDETITLE
EndFunc    ; -> _GUICtrlRebar_GetBandStyleHideTitle

Func _GUICtrlRebar_GetBandStyleNoGripper($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_NOGRIPPER) = $RBBS_NOGRIPPER
EndFunc    ; -> _GUICtrlRebar_GetBandStyleNoGripper

Func _GUICtrlRebar_GetBandStyleNoVert($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_NOVERT) = $RBBS_NOVERT
EndFunc    ; -> _GUICtrlRebar_GetBandStyleNoVert

Func _GUICtrlRebar_GetBandStyleTopAlign($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_TOPALIGN) = $RBBS_TOPALIGN
EndFunc    ; -> _GUICtrlRebar_GetBandStyleTopAlign

Func _GUICtrlRebar_GetBandStyleUseChevron($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_USECHEVRON) = $RBBS_USECHEVRON
EndFunc    ; -> _GUICtrlRebar_GetBandStyleUseChevron

Func _GUICtrlRebar_GetBandStyleVariableHeight($hwnd, $iindex)
    Return BitAND(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_VARIABLEHEIGHT) = $RBBS_VARIABLEHEIGHT
EndFunc    ; -> _GUICtrlRebar_GetBandStyleVariableHeight

Func _GUICtrlRebar_GetBandRect($hwnd, $iindex)
    Local $trect = _GUICtrlRebar_GetBandRectEx($hwnd, $iindex)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlRebar_GetBandRect

Func _GUICtrlRebar_GetBandRectEx($hwnd, $iindex)
    Local $trect = DllStructCreate($TAGRECT)
    _SendMessage($hwnd, $RB_GETRECT, $iindex, $trect, 0x0, "uint", "struct*")
    Return $trect
EndFunc    ; -> _GUICtrlRebar_GetBandRectEx

Func _GUICtrlRebar_GetBandText($hwnd, $iindex)
    Local $tbuffer, $imsg
    If _GUICtrlRebar_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_trebarbuffer
        $imsg = $RB_GETBANDINFOW
    Else
        $tbuffer = $__g_trebarbufferansi
        $imsg = $RB_GETBANDINFOA
    EndIf
    Local $tinfo = DllStructCreate($TAGREBARBANDINFO)
    DllStructSetData($tinfo, "cbSize", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "fMask", $RBBIM_TEXT)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $tinfo, $tbuffer, False, 0x6, True)
    Return SetError($iret = 0x0, 0x0, DllStructGetData($tbuffer, "Text"))
EndFunc    ; -> _GUICtrlRebar_GetBandText

Func _GUICtrlRebar_GetBarHeight($hwnd)
    Return _SendMessage($hwnd, $RB_GETBARHEIGHT)
EndFunc    ; -> _GUICtrlRebar_GetBarHeight

Func _GUICtrlRebar_GetBarInfo($hwnd)
    Local $tinfo = DllStructCreate($TAGREBARINFO)
    DllStructSetData($tinfo, "cbSize", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "fMask", $RBIM_IMAGELIST)
    Local $iret = _SendMessage($hwnd, $RB_GETBARINFO, 0x0, $tinfo, 0x0, "wparam", "struct*")
    Return SetError($iret = 0x0, 0x0, DllStructGetData($tinfo, "himl"))
EndFunc    ; -> _GUICtrlRebar_GetBarInfo

Func _GUICtrlRebar_GetBKColor($hwnd)
    Return _SendMessage($hwnd, $RB_GETBKCOLOR)
EndFunc    ; -> _GUICtrlRebar_GetBKColor

Func _GUICtrlRebar_GetColorScheme($hwnd)
    Local $acolors[0x2]
    Local $tcolorscheme = __GUICtrlRebar_GetColorSchemeEx($hwnd)
    If @error Then Return SetError(@error, @error, $acolors)
    $acolors[0x0] = DllStructGetData($tcolorscheme, "BtnHighlight")
    $acolors[0x1] = DllStructGetData($tcolorscheme, "BtnShadow")
    Return $acolors
EndFunc    ; -> _GUICtrlRebar_GetColorScheme

Func __GUICtrlRebar_GetColorSchemeEx($hwnd)
    Local $tcolorscheme = DllStructCreate($TAGCOLORSCHEME)
    DllStructSetData($tcolorscheme, "Size", DllStructGetSize($tcolorscheme))
    Local $iret = _SendMessage($hwnd, $RB_GETCOLORSCHEME, 0x0, $tcolorscheme, 0x0, "wparam", "struct*")
    Return SetError($iret = 0x0, 0x0, $tcolorscheme)
EndFunc    ; -> __GUICtrlRebar_GetColorSchemeEx

Func _GUICtrlRebar_GetRowCount($hwnd)
    Return _SendMessage($hwnd, $RB_GETROWCOUNT)
EndFunc    ; -> _GUICtrlRebar_GetRowCount

Func _GUICtrlRebar_GetRowHeight($hwnd, $iindex)
    Return _SendMessage($hwnd, $RB_GETROWHEIGHT, $iindex)
EndFunc    ; -> _GUICtrlRebar_GetRowHeight

Func _GUICtrlRebar_GetTextColor($hwnd)
    Return _SendMessage($hwnd, $RB_GETTEXTCOLOR)
EndFunc    ; -> _GUICtrlRebar_GetTextColor

Func _GUICtrlRebar_GetToolTips($hwnd)
    Return _SendMessage($hwnd, $RB_GETTOOLTIPS, 0x0, 0x0, 0x0, "wparam", "lparam", "hwnd")
EndFunc    ; -> _GUICtrlRebar_GetToolTips

Func _GUICtrlRebar_GetUnicodeFormat($hwnd)
    If Not IsDllStruct($__g_trebarbuffer) Then
        $__g_trebarbuffer = DllStructCreate("wchar Text[4096]")
        $__g_trebarbufferansi = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_trebarbuffer))
    EndIf
    Return _SendMessage($hwnd, $RB_GETUNICODEFORMAT) <> 0x0
EndFunc    ; -> _GUICtrlRebar_GetUnicodeFormat

Func _GUICtrlRebar_HitTest($hwnd, $ix = + -1, $iy = + -1)
    Local $imode = Opt("MouseCoordMode", 0x1)
    Local $apos = MouseGetPos()
    Opt("MouseCoordMode", $imode)
    Local $tpoint = DllStructCreate($TAGPOINT)
    DllStructSetData($tpoint, "X", $apos[0x0])
    DllStructSetData($tpoint, "Y", $apos[0x1])
    DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hwnd, "struct*", $tpoint)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $ix = + -1 Then $ix = DllStructGetData($tpoint, "X")
    If $iy = + -1 Then $iy = DllStructGetData($tpoint, "Y")
    Local $ttest = DllStructCreate($TAGRBHITTESTINFO)
    DllStructSetData($ttest, "X", $ix)
    DllStructSetData($ttest, "Y", $iy)
    Local $atest[0x6]
    $atest[0x0] = _SendMessage($hwnd, $RB_HITTEST, 0x0, $ttest, 0x0, "wparam", "struct*")
    Local $IFLAGS = DllStructGetData($ttest, "flags")
    $atest[0x1] = BitAND($IFLAGS, $RBHT_NOWHERE) <> 0x0
    $atest[0x2] = BitAND($IFLAGS, $RBHT_CLIENT) <> 0x0
    $atest[0x3] = BitAND($IFLAGS, $RBHT_CAPTION) <> 0x0
    $atest[0x4] = BitAND($IFLAGS, $RBHT_CHEVRON) <> 0x0
    $atest[0x5] = BitAND($IFLAGS, $RBHT_GRABBER) <> 0x0
    Return $atest
EndFunc    ; -> _GUICtrlRebar_HitTest

Func _GUICtrlRebar_IDToIndex($hwnd, $iid)
    Return _SendMessage($hwnd, $RB_IDTOINDEX, $iid)
EndFunc    ; -> _GUICtrlRebar_IDToIndex

Func _GUICtrlRebar_MaximizeBand($hwnd, $iindex, $bideal = True)
    _SendMessage($hwnd, $RB_MAXIMIZEBAND, $iindex, $bideal)
EndFunc    ; -> _GUICtrlRebar_MaximizeBand

Func _GUICtrlRebar_MinimizeBand($hwnd, $iindex)
    _SendMessage($hwnd, $RB_MINIMIZEBAND, $iindex)
EndFunc    ; -> _GUICtrlRebar_MinimizeBand

Func _GUICtrlRebar_MoveBand($hwnd, $iindexfrom, $iindexto)
    If $iindexto > _GUICtrlRebar_GetBandCount($hwnd) + -1 Then Return False
    Return _SendMessage($hwnd, $RB_MOVEBAND, $iindexfrom, $iindexto) <> 0x0
EndFunc    ; -> _GUICtrlRebar_MoveBand

Func _GUICtrlRebar_SetBandBackColor($hwnd, $iindex, $icolor)
    Local $tinfo = DllStructCreate($TAGREBARBANDINFO)
    Local $isize = DllStructGetSize($tinfo)
    DllStructSetData($tinfo, "cbSize", $isize)
    DllStructSetData($tinfo, "fMask", $RBBIM_COLORS)
    DllStructSetData($tinfo, "clrBack", $icolor)
    DllStructGetData($tinfo, "clrFore", _GUICtrlRebar_GetBandForeColor($hwnd, $iindex))
    Local $imsg
    If _GUICtrlRebar_GetUnicodeFormat($hwnd) Then
        $imsg = $RB_SETBANDINFOW
    Else
        $imsg = $RB_SETBANDINFOA
    EndIf
    Local $iret = _SendMessage($hwnd, $imsg, $iindex, $tinfo, 0x0, "wparam", "struct*") <> 0x0
    Return $iret
EndFunc    ; -> _GUICtrlRebar_SetBandBackColor

Func _GUICtrlRebar_SetBandForeColor($hwnd, $iindex, $icolor)
    Local $tinfo = DllStructCreate($TAGREBARBANDINFO)
    DllStructSetData($tinfo, "cbSize", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "fMask", $RBBIM_COLORS)
    DllStructSetData($tinfo, "clrFore", $icolor)
    DllStructSetData($tinfo, "clrBack", _GUICtrlRebar_GetBandBackColor($hwnd, $iindex))
    Local $imsg
    If _GUICtrlRebar_GetUnicodeFormat($hwnd) Then
        $imsg = $RB_SETBANDINFOW
    Else
        $imsg = $RB_SETBANDINFOA
    EndIf
    Local $iret = _SendMessage($hwnd, $imsg, $iindex, $tinfo, 0x0, "wparam", "struct*") <> 0x0
    Return $iret
EndFunc    ; -> _GUICtrlRebar_SetBandForeColor

Func _GUICtrlRebar_SetBandHeaderSize($hwnd, $iindex, $inewsize)
    Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_HEADERSIZE, "cxHeader", $inewsize)
EndFunc    ; -> _GUICtrlRebar_SetBandHeaderSize

Func _GUICtrlRebar_SetBandID($hwnd, $iindex, $iid)
    Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_ID, "wID", $iid)
EndFunc    ; -> _GUICtrlRebar_SetBandID

Func _GUICtrlRebar_SetBandIdealSize($hwnd, $iindex, $inewsize)
    Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_IDEALSIZE, "cxIdeal", $inewsize)
EndFunc    ; -> _GUICtrlRebar_SetBandIdealSize

Func __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $imask, $sname, $idata)
    Local $tinfo = DllStructCreate($TAGREBARBANDINFO)
    DllStructSetData($tinfo, "cbSize", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "fMask", $imask)
    DllStructSetData($tinfo, $sname, $idata)
    Local $imsg
    If _GUICtrlRebar_GetUnicodeFormat($hwnd) Then
        $imsg = $RB_SETBANDINFOW
    Else
        $imsg = $RB_SETBANDINFOA
    EndIf
    Local $iret = _SendMessage($hwnd, $imsg, $iindex, $tinfo, 0x0, "wparam", "struct*") <> 0x0
    Return $iret
EndFunc    ; -> __GUICtrlRebar_SetBandInfo

Func _GUICtrlRebar_SetBandLength($hwnd, $iindex, $ilength)
    Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_SIZE, "cx", $ilength)
EndFunc    ; -> _GUICtrlRebar_SetBandLength

Func _GUICtrlRebar_SetBandLParam($hwnd, $iindex, $lparam)
    Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_LPARAM, "lParam", $lparam)
EndFunc    ; -> _GUICtrlRebar_SetBandLParam

Func _GUICtrlRebar_SetBandStyle($hwnd, $iindex, $istyle)
    Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", $istyle)
EndFunc    ; -> _GUICtrlRebar_SetBandStyle

Func _GUICtrlRebar_SetBandStyleBreak($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_BREAK))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_BREAK))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleBreak

Func _GUICtrlRebar_SetBandStyleChildEdge($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_CHILDEDGE))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_CHILDEDGE))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleChildEdge

Func _GUICtrlRebar_SetBandStyleFixedBMP($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_FIXEDBMP))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_FIXEDBMP))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleFixedBMP

Func _GUICtrlRebar_SetBandStyleFixedSize($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_FIXEDSIZE))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_FIXEDSIZE))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleFixedSize

Func _GUICtrlRebar_SetBandStyleGripperAlways($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_GRIPPERALWAYS))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_GRIPPERALWAYS))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleGripperAlways

Func _GUICtrlRebar_SetBandStyleHidden($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_HIDDEN))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_HIDDEN))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleHidden

Func _GUICtrlRebar_SetBandStyleHideTitle($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_HIDETITLE))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_HIDETITLE))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleHideTitle

Func _GUICtrlRebar_SetBandStyleNoGripper($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_NOGRIPPER))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_NOGRIPPER))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleNoGripper

Func _GUICtrlRebar_SetBandStyleNoVert($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_NOVERT))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_NOVERT))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleNoVert

Func _GUICtrlRebar_SetBandStyleTopAlign($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_TOPALIGN))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_TOPALIGN))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleTopAlign

Func _GUICtrlRebar_SetBandStyleUseChevron($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_USECHEVRON))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_USECHEVRON))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleUseChevron

Func _GUICtrlRebar_SetBandStyleVariableHeight($hwnd, $iindex, $benabled = True)
    If $benabled Then
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_VARIABLEHEIGHT))
    Else
        Return __GUICtrlRebar_SetBandInfo($hwnd, $iindex, $RBBIM_STYLE, "fStyle", BitXOR(_GUICtrlRebar_GetBandStyle($hwnd, $iindex), $RBBS_VARIABLEHEIGHT))
    EndIf
EndFunc    ; -> _GUICtrlRebar_SetBandStyleVariableHeight

Func _GUICtrlRebar_SetBandText($hwnd, $iindex, $stext)
    Local $tbuffer, $imsg
    If _GUICtrlRebar_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_trebarbuffer
        $imsg = $RB_SETBANDINFOW
    Else
        $tbuffer = $__g_trebarbufferansi
        $imsg = $RB_SETBANDINFOA
    EndIf
    Local $tinfo = DllStructCreate($TAGREBARBANDINFO)
    DllStructSetData($tbuffer, "Text", $stext)
    DllStructSetData($tinfo, "cbSize", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "fMask", $RBBIM_TEXT)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $tinfo, $tbuffer, False, 0x6)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlRebar_SetBandText

Func _GUICtrlRebar_SetBKColor($hwnd, $icolor)
    Return _SendMessage($hwnd, $RB_SETBKCOLOR, 0x0, $icolor)
EndFunc    ; -> _GUICtrlRebar_SetBKColor

Func _GUICtrlRebar_SetBarInfo($hwnd, $himl)
    Local $tinfo = DllStructCreate($TAGREBARINFO)
    DllStructSetData($tinfo, "cbSize", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "fMask", $RBIM_IMAGELIST)
    DllStructSetData($tinfo, "himl", $himl)
    Return _SendMessage($hwnd, $RB_SETBARINFO, 0x0, $tinfo, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlRebar_SetBarInfo

Func _GUICtrlRebar_SetColorScheme($hwnd, $ibtnhighlight, $ibtnshadow)
    Local $tinfo = DllStructCreate($TAGCOLORSCHEME)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    DllStructSetData($tinfo, "BtnHighlight", $ibtnhighlight)
    DllStructSetData($tinfo, "BtnShadow", $ibtnshadow)
    _SendMessage($hwnd, $RB_SETCOLORSCHEME, 0x0, $tinfo, 0x0, "wparam", "struct*")
EndFunc    ; -> _GUICtrlRebar_SetColorScheme

Func _GUICtrlRebar_SetTextColor($hwnd, $icolor)
    Return _SendMessage($hwnd, $RB_SETTEXTCOLOR, 0x0, $icolor)
EndFunc    ; -> _GUICtrlRebar_SetTextColor

Func _GUICtrlRebar_SetToolTips($hwnd, $htooltip)
    _SendMessage($hwnd, $RB_SETTOOLTIPS, $htooltip, 0x0, 0x0, "hwnd")
EndFunc    ; -> _GUICtrlRebar_SetToolTips

Func _GUICtrlRebar_SetUnicodeFormat($hwnd, $bunicode = True)
    Return _SendMessage($hwnd, $RB_SETUNICODEFORMAT, $bunicode)
EndFunc    ; -> _GUICtrlRebar_SetUnicodeFormat

Func _GUICtrlRebar_ShowBand($hwnd, $iindex, $bshow = True)
    Return _SendMessage($hwnd, $RB_SHOWBAND, $iindex, $bshow) <> 0x0
EndFunc    ; -> _GUICtrlRebar_ShowBand

Global $__g_srtfclassname, $__g_srtfversion, $__g_irtftwipspespaceunit = 0x5a0
Global $__g_sgre_cf_rtf, $__g_sgre_cf_retextobj
Global $__g_pgrc_streamfromfilecallback = DllCallbackRegister("__GCR_StreamFromFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pgrc_streamfromvarcallback = DllCallbackRegister("__GCR_StreamFromVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pgrc_streamtofilecallback = DllCallbackRegister("__GCR_StreamToFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pgrc_streamtovarcallback = DllCallbackRegister("__GCR_StreamToVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pgrc_sstreamvar
Global $__g_tobj_richcomobject = DllStructCreate("ptr pIntf; dword  Refcount")
Global $__g_tcall_richcom, $__g_pobj_richcom
Global $__g_hlib_richcom_ole32 = DllOpen("OLE32.DLL")
Global $__g_prichcom_object_queryinterface = DllCallbackRegister("__RichCom_Object_QueryInterface", "long", "ptr;dword;dword")
Global $__g_prichcom_object_addref = DllCallbackRegister("__RichCom_Object_AddRef", "long", "ptr")
Global $__g_prichcom_object_release = DllCallbackRegister("__RichCom_Object_Release", "long", "ptr")
Global $__g_prichcom_object_getnewstorage = DllCallbackRegister("__RichCom_Object_GetNewStorage", "long", "ptr;ptr")
Global $__g_prichcom_object_getinplacecontext = DllCallbackRegister("__RichCom_Object_GetInPlaceContext", "long", "ptr;dword;dword;dword")
Global $__g_prichcom_object_showcontainerui = DllCallbackRegister("__RichCom_Object_ShowContainerUI", "long", "ptr;long")
Global $__g_prichcom_object_queryinsertobject = DllCallbackRegister("__RichCom_Object_QueryInsertObject", "long", "ptr;dword;ptr;long")
Global $__g_prichcom_object_deleteobject = DllCallbackRegister("__RichCom_Object_DeleteObject", "long", "ptr;ptr")
Global $__g_prichcom_object_queryacceptdata = DllCallbackRegister("__RichCom_Object_QueryAcceptData", "long", "ptr;ptr;dword;dword;dword;ptr")
Global $__g_prichcom_object_contextsensitivehelp = DllCallbackRegister("__RichCom_Object_ContextSensitiveHelp", "long", "ptr;long")
Global $__g_prichcom_object_getclipboarddata = DllCallbackRegister("__RichCom_Object_GetClipboardData", "long", "ptr;ptr;dword;ptr")
Global $__g_prichcom_object_getdragdropeffect = DllCallbackRegister("__RichCom_Object_GetDragDropEffect", "long", "ptr;dword;dword;dword")
Global $__g_prichcom_object_getcontextmenu = DllCallbackRegister("__RichCom_Object_GetContextMenu", "long", "ptr;short;ptr;ptr;ptr")
Global Const $__RICHEDITCONSTANT_SB_LINEDOWN = 0x1
Global Const $__RICHEDITCONSTANT_SB_LINEUP = 0x0
Global Const $__RICHEDITCONSTANT_SB_PAGEDOWN = 0x3
Global Const $__RICHEDITCONSTANT_SB_PAGEUP = 0x2
Global Const $__RICHEDITCONSTANT_WM_COPY = 0x301
Global Const $__RICHEDITCONSTANT_WM_SETFONT = 0x30
Global Const $__RICHEDITCONSTANT_WM_CUT = 0x300
Global Const $__RICHEDITCONSTANT_WM_PASTE = 0x302
Global Const $__RICHEDITCONSTANT_WM_SETREDRAW = 0xb
Global Const $__RICHEDITCONSTANT_COLOR_WINDOWTEXT = 0x8
Global Const $_GCR_S_OK = 0x0
Global Const $_GCR_E_NOTIMPL = -2147467263
Global Const $_GCR_E_INVALIDARG = -2147024809
Global Const $TAGEDITSTREAM = "struct;align 4;dword_ptr dwCookie;dword dwError;ptr pfnCallback;endstruct"
Global Const $TAGBIDIOPTIONS = "uint cbSize;word wMask;word wEffects"
Global Const $TAGCHARFORMAT = "struct;uint cbSize;dword dwMask;dword dwEffects;long yHeight;long yOffset;INT crCharColor;" & "byte bCharSet;byte bPitchAndFamily;wchar szFaceName[32];endstruct"
Global Const $TAGCHARFORMAT2 = $TAGCHARFORMAT & ";word wWeight;short sSpacing;INT crBackColor;dword lcid;dword dwReserved;" & "short sStyle;word wKerning;byte bUnderlineType;byte bAnimation;byte bRevAuthor;byte bReserved1"
Global Const $TAGCHARRANGE = "struct;long cpMin;long cpMax;endstruct"
Global Const $TAGFINDTEXT = $TAGCHARRANGE & ";ptr lpstrText"
Global Const $TAGFINDTEXTEX = $TAGCHARRANGE & ";ptr lpstrText;long cpMinRang;long cpMaxRange"
Global Const $TAGGETTEXTEX = "struct;align 4;dword cb;dword flags;uint codepage;ptr lpDefaultChar;ptr lpbUsedDefChar;endstruct"
Global Const $TAGGETTEXTLENGTHEX = "dword flags;uint codepage"
Global Const $TAGPARAFORMAT = "uint cbSize;dword dwMask;word wNumbering;word wEffects;long dxStartIndent;" & "long dxRightIndent;long dxOffset;word wAlignment;short cTabCount;long rgxTabs[32]"
Global Const $TAGPARAFORMAT2 = $TAGPARAFORMAT & ";long dySpaceBefore;long dySpaceAfter;long dyLineSpacing;short sStyle;byte bLineSpacingRule;" & "byte bOutlineLevel;word wShadingWeight;word wShadingStyle;word wNumberingStart;word wNumberingStyle;" & "word wNumberingTab;word wBorderSpace;word wBorderWidth;word wBorders"
Global Const $TAGSETTEXTEX = "dword flags;uint codepage"
Global Const $TAGTEXTRANGE = $TAGCHARRANGE & ";ptr lpstrText"
Global Const $TAGMSGFILTER = "struct;" & $tagnmhdr & ";align 4;uint msg;wparam wParam;lparam lParam;endstruct"
Global Const $TAGENLINK = "struct;" & $tagnmhdr & ";align 4;uint msg;wparam wParam;lparam lParam;" & $TAGCHARRANGE & ";endstruct"
Func _GUICtrlRichEdit_AppendText($hwnd, $stext)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $ilength = _GUICtrlRichEdit_GetTextLength($hwnd)
    _GUICtrlRichEdit_SetSel($hwnd, $ilength, $ilength)
    Local $tsettext = DllStructCreate($TAGSETTEXTEX)
    DllStructSetData($tsettext, 0x1, $ST_SELECTION)
    Local $iret
    If StringLeft($stext, 0x5) <> "{\\rtf" And StringLeft($stext, 0x5) <> "{urtf" Then
        DllStructSetData($tsettext, 0x2, $CP_UNICODE)
        $iret = _SendMessage($hwnd, $EM_SETTEXTEX, $tsettext, $stext, 0x0, "struct*", "wstr")
    Else
        DllStructSetData($tsettext, 0x2, $CP_ACP)
        $iret = _SendMessage($hwnd, $EM_SETTEXTEX, $tsettext, $stext, 0x0, "struct*", "STR")
    EndIf
    If Not $iret Then Return SetError(0x2bc, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_AppendText

Func _GUICtrlRichEdit_AutoDetectURL($hwnd, $bstate)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not IsBool($bstate) Then Return SetError(0x66, 0x0, False)
    If _SendMessage($hwnd, $EM_AUTOURLDETECT, $bstate) Then Return SetError(0x2bc, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_AutoDetectURL

Func _GUICtrlRichEdit_CanPaste($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $iret = _SendMessage($hwnd, $EM_CANPASTE, 0x0, 0x0)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_CanPaste

Func _GUICtrlRichEdit_CanPasteSpecial($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Return _SendMessage($hwnd, $EM_CANPASTE, $__g_sgre_cf_rtf, 0x0) <> 0x0 And _SendMessage($hwnd, $EM_CANPASTE, $__g_sgre_cf_retextobj, 0x0) <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_CanPasteSpecial

Func _GUICtrlRichEdit_CanRedo($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Return _SendMessage($hwnd, $EM_CANREDO, 0x0, 0x0) <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_CanRedo

Func _GUICtrlRichEdit_CanUndo($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Return _SendMessage($hwnd, $EM_CANUNDO, 0x0, 0x0) <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_CanUndo

Func _GUICtrlRichEdit_ChangeFontSize($hwnd, $iincrement)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not __GCR_IsNumeric($iincrement) Then SetError(0x66, 0x0, False)
    If Not _GUICtrlRichEdit_IsTextSelected($hwnd) Then Return SetError(+ -1, 0x0, False)
    Return _SendMessage($hwnd, $EM_SETFONTSIZE, $iincrement, 0x0) <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_ChangeFontSize

Func _GUICtrlRichEdit_Copy($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    _SendMessage($hwnd, $__RICHEDITCONSTANT_WM_COPY, 0x0, 0x0)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_Copy

Func _GUICtrlRichEdit_Create($hwnd, $stext, $ileft, $itop, $iwidth = 0x96, $iheight = 0x96, $istyle = + -1, $iexstyle = + -1)
    If Not IsHWnd($hwnd) Then Return SetError(0x1, 0x0, 0x0)
    If Not IsString($stext) Then Return SetError(0x2, 0x0, 0x0)
    If Not __GCR_IsNumeric($iwidth, ">0,-1") Then Return SetError(0x69, 0x0, 0x0)
    If Not __GCR_IsNumeric($iheight, ">0,-1") Then Return SetError(0x6a, 0x0, 0x0)
    If Not __GCR_IsNumeric($istyle, ">=0,-1") Then Return SetError(0x6b, 0x0, 0x0)
    If Not __GCR_IsNumeric($iexstyle, ">=0,-1") Then Return SetError(0x6c, 0x0, 0x0)
    If $iwidth = + -1 Then $iwidth = 0x96
    If $iheight = + -1 Then $iheight = 0x96
    If $istyle = + -1 Then $istyle = BitOR($ES_WANTRETURN, $ES_MULTILINE)
    If BitAND($istyle, $ES_MULTILINE) <> 0x0 Then $istyle = BitOR($istyle, $ES_WANTRETURN)
    If $iexstyle = + -1 Then $iexstyle = 0x200
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
    If BitAND($istyle, $ES_READONLY) = 0x0 Then $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_TABSTOP)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    __GCR_Init()
    Local $hrichedit = _WinAPI_CreateWindowEx($iexstyle, $__g_srtfclassname, '', $istyle, $ileft, $itop, $iwidth, $iheight, $hwnd, $nctrlid)
    If $hrichedit = 0x0 Then Return SetError(0x2bc, 0x0, False)
    __GCR_SetOLECallback($hrichedit)
    _SendMessage($hrichedit, $__RICHEDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($DEFAULT_GUI_FONT), True)
    _GUICtrlRichEdit_AppendText($hrichedit, $stext)
    Return $hrichedit
EndFunc    ; -> _GUICtrlRichEdit_Create

Func _GUICtrlRichEdit_Cut($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    _SendMessage($hwnd, $__RICHEDITCONSTANT_WM_CUT, 0x0, 0x0)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_Cut

Func _GUICtrlRichEdit_Deselect($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    _SendMessage($hwnd, $EM_SETSEL, + -1, 0x0)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_Deselect

Func _GUICtrlRichEdit_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_Destroy

Func _GUICtrlRichEdit_EmptyUndoBuffer($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    _SendMessage($hwnd, $EM_EMPTYUNDOBUFFER, 0x0, 0x0)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_EmptyUndoBuffer

Func _GUICtrlRichEdit_FindText($hwnd, $stext, $bforward = True, $bmatchcase = False, $bwholeword = False, $ibehavior = 0x0)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, + -1)
    If $stext = '' Then Return SetError(0x66, 0x0, + -1)
    If Not IsBool($bforward) Then Return SetError(0x67, 0x0, + -1)
    If Not IsBool($bmatchcase) Then Return SetError(0x68, 0x0, + -1)
    If Not IsBool($bwholeword) Then Return SetError(0x69, 0x0, + -1)
    If Not __GCR_IsNumeric($ibehavior) Then Return SetError(0x425, 0x0, + -1)
    If BitAND($ibehavior, BitNOT(BitOR($FR_MATCHALEFHAMZA, $FR_MATCHDIAC, $FR_MATCHKASHIDA))) <> 0x0 Then Return SetError(0x426, 0x0, + -1)
    Local $ilen = StringLen($stext) + 0x3
    Local $ttext = DllStructCreate("wchar[" & $ilen & "]")
    DllStructSetData($ttext, 0x1, $stext)
    Local $tfindtext = DllStructCreate($TAGFINDTEXT)
    Local $aianchoractive
    If _GUICtrlRichEdit_IsTextSelected($hwnd) Then
        $aianchoractive = _GUICtrlRichEdit_GetSelAA($hwnd)
    Else
        $aianchoractive = _GUICtrlRichEdit_GetSel($hwnd)
    EndIf
    DllStructSetData($tfindtext, 0x1, $aianchoractive[0x0])
    DllStructSetData($tfindtext, 0x2, ($bforward  ? + -1  : 0x0))
    DllStructSetData($tfindtext, 0x3, DllStructGetPtr($ttext))
    Local Const $FR_DOWN = 0x1
    Local Const $FR_WHOLEWORD = 0x2
    Local Const $FR_MATCHCASE = 0x4
    Local $wparam = 0x0
    If $bforward Then $wparam = $FR_DOWN
    If $bwholeword Then $wparam = BitOR($wparam, $FR_WHOLEWORD)
    If $bmatchcase Then $wparam = BitOR($wparam, $FR_MATCHCASE)
    $wparam = BitOR($wparam, $ibehavior)
    Return _SendMessage($hwnd, $EM_FINDTEXTW, $wparam, $tfindtext, "wparam", "ptr", "struct*")
EndFunc    ; -> _GUICtrlRichEdit_FindText

Func _GUICtrlRichEdit_FindTextInRange($hwnd, $stext, $istart = 0x0, $IEND = + -1, $bmatchcase = False, $bwholeword = False, $ibehavior = 0x0)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    If $stext = '' Then Return SetError(0x66, 0x0, 0x0)
    If Not __GCR_IsNumeric($istart, ">=0,-1") Then Return SetError(0x67, 0x0, 0x0)
    If Not __GCR_IsNumeric($IEND, ">=0,-1") Then Return SetError(0x68, 0x0, 0x0)
    If Not IsBool($bmatchcase) Then Return SetError(0x69, 0x0, 0x0)
    If Not IsBool($bwholeword) Then Return SetError(0x6a, 0x0, 0x0)
    If Not __GCR_IsNumeric($ibehavior) Then Return SetError(0x42f, 0x0, 0x0)
    If BitAND($ibehavior, BitNOT(BitOR($FR_MATCHALEFHAMZA, $FR_MATCHDIAC, $FR_MATCHKASHIDA))) <> 0x0 Then Return SetError(0x430, 0x0, 0x0)
    Local $ilen = StringLen($stext) + 0x3
    Local $ttext = DllStructCreate("wchar Text[" & $ilen & "]")
    DllStructSetData($ttext, "Text", $stext)
    Local $tfindtext = DllStructCreate($TAGFINDTEXTEX)
    DllStructSetData($tfindtext, "cpMin", $istart)
    DllStructSetData($tfindtext, "cpMax", $IEND)
    DllStructSetData($tfindtext, "lpstrText", DllStructGetPtr($ttext))
    Local Const $FR_DOWN = 0x1
    Local Const $FR_WHOLEWORD = 0x2
    Local Const $FR_MATCHCASE = 0x4
    Local $wparam = 0x0
    If $IEND >= $istart Or $IEND = + -1 Then
        $wparam = $FR_DOWN
    EndIf
    If $bwholeword Then $wparam = BitOR($wparam, $FR_WHOLEWORD)
    If $bmatchcase Then $wparam = BitOR($wparam, $FR_MATCHCASE)
    $wparam = BitOR($wparam, $ibehavior)
    _SendMessage($hwnd, $EM_FINDTEXTEXW, $wparam, $tfindtext, "iWparam", "ptr", "struct*")
    Local $aret[0x2]
    $aret[0x0] = DllStructGetData($tfindtext, "cpMinRang")
    $aret[0x1] = DllStructGetData($tfindtext, "cpMaxRange")
    Return $aret
EndFunc    ; -> _GUICtrlRichEdit_FindTextInRange

Func _GUICtrlRichEdit_GetCharAttributes($hwnd)
    Local Const $AV[0x11][0x3] = [["bo", $CFM_BOLD, $CFE_BOLD], ["di", $CFM_DISABLED, $CFE_DISABLED], ["em", $CFM_EMBOSS, $CFE_EMBOSS], ["hi", $CFM_HIDDEN, $CFE_HIDDEN], ["im", $CFM_IMPRINT, $CFE_IMPRINT], ["it", $CFM_ITALIC, $CFE_ITALIC], ["li", $CFM_LINK, $CFE_LINK], ["ou", $CFM_OUTLINE, $CFE_OUTLINE], ["pr", $CFM_PROTECTED, $CFE_PROTECTED], ["re", $CFM_REVISED, $CFE_REVISED], ["sh", $CFM_SHADOW, $CFE_SHADOW], ["sm", $CFM_SMALLCAPS, $CFE_SMALLCAPS], ["st", $CFM_STRIKEOUT, $CFE_STRIKEOUT], ["sb", $CFM_SUBSCRIPT, $CFE_SUBSCRIPT], ["sp", $CFM_SUPERSCRIPT, $CFE_SUPERSCRIPT], ["un", $CFM_UNDERLINE, $CFE_UNDERLINE], ["al", $CFM_ALLCAPS, $CFE_ALLCAPS]]
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    If Not _GUICtrlRichEdit_IsTextSelected($hwnd) Then Return SetError(+ -1, 0x0, '')
    Local $tcharformat = DllStructCreate($TAGCHARFORMAT2)
    DllStructSetData($tcharformat, 0x1, DllStructGetSize($tcharformat))
    Local $imask = _SendMessage($hwnd, $EM_GETCHARFORMAT, $SCF_SELECTION, $tcharformat, 0x0, "wparam", "struct*")
    Local $ieffects = DllStructGetData($tcharformat, 0x3)
    Local $sstatesandatts = '', $sstate, $bm, $be
    For $i = 0x0 To UBound($AV, $UBOUND_ROWS) + -1
        $bm = BitAND($imask, $AV[$i][0x1]) = $AV[$i][0x1]
        $be = BitAND($ieffects, $AV[$i][0x2]) = $AV[$i][0x2]
        If $bm Then
            If $be Then
                $sstate = "+"
            Else
                $sstate = "-"
            EndIf
        Else
            $sstate = "~"
        EndIf
        If $sstate <> "-" Then $sstatesandatts &= $AV[$i][0x0] & $sstate
    Next
    Return $sstatesandatts
EndFunc    ; -> _GUICtrlRichEdit_GetCharAttributes

Func _GUICtrlRichEdit_GetCharBkColor($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Local $tcharformat = DllStructCreate($TAGCHARFORMAT2)
    DllStructSetData($tcharformat, 0x1, DllStructGetSize($tcharformat))
    __GCR_SendGetCharFormatMessage($hwnd, $tcharformat)
    Local $ieffects = DllStructGetData($tcharformat, 0x3)
    Local $ibkcolor
    If BitAND($ieffects, $CFE_AUTOBACKCOLOR) = $CFE_AUTOBACKCOLOR Then
        $ibkcolor = _WinAPI_GetSysColor($__RICHEDITCONSTANT_COLOR_WINDOWTEXT)
    Else
        $ibkcolor = DllStructGetData($tcharformat, 0xc)
    EndIf
    Return SetExtended(BitAND($ieffects, $CFM_BACKCOLOR) <> 0x0, $ibkcolor)
EndFunc    ; -> _GUICtrlRichEdit_GetCharBkColor

Func _GUICtrlRichEdit_GetCharColor($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Local $tcharformat = DllStructCreate($TAGCHARFORMAT)
    DllStructSetData($tcharformat, 0x1, DllStructGetSize($tcharformat))
    __GCR_SendGetCharFormatMessage($hwnd, $tcharformat)
    Local $ieffects = DllStructGetData($tcharformat, 0x3)
    Local $icolor
    If BitAND($ieffects, $CFE_AUTOCOLOR) = $CFE_AUTOCOLOR Then
        $icolor = _WinAPI_GetSysColor($__RICHEDITCONSTANT_COLOR_WINDOWTEXT)
    Else
        $icolor = DllStructGetData($tcharformat, 0x6)
    EndIf
    Return SetExtended(BitAND($ieffects, $CFM_COLOR) <> 0x0, $icolor)
EndFunc    ; -> _GUICtrlRichEdit_GetCharColor

Func _GUICtrlRichEdit_GetCharPosFromXY($hwnd, $ix, $iy)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    If Not __GCR_IsNumeric($ix) Then Return SetError(0x66, 0x0, 0x0)
    If Not __GCR_IsNumeric($iy) Then Return SetError(0x67, 0x0, 0x0)
    Local $airect = _GUICtrlRichEdit_GetRECT($hwnd)
    If $ix < $airect[0x0] Or $ix > $airect[0x2] Or $iy < $airect[0x1] Or $iy > $airect[0x3] Then Return + -1
    Local $tpointl = DllStructCreate("LONG x; LONG y;")
    DllStructSetData($tpointl, 0x1, $ix)
    DllStructSetData($tpointl, 0x2, $iy)
    Local $iret = _SendMessage($hwnd, $EM_CHARFROMPOS, 0x0, $tpointl, 0x0, "wparam", "struct*")
    If Not $iret Then Return SetError(+ -1, 0x0, 0x0)
    Return $iret
EndFunc    ; -> _GUICtrlRichEdit_GetCharPosFromXY

Func _GUICtrlRichEdit_GetCharPosOfNextWord($hwnd, $icpstart)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    If Not __GCR_IsNumeric($icpstart) Then Return SetError(0x66, 0x0, 0x0)
    Return _SendMessage($hwnd, $EM_FINDWORDBREAK, $WB_MOVEWORDRIGHT, $icpstart)
EndFunc    ; -> _GUICtrlRichEdit_GetCharPosOfNextWord

Func _GUICtrlRichEdit_GetCharPosOfPreviousWord($hwnd, $icpstart)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    If Not __GCR_IsNumeric($icpstart) Then Return SetError(0x66, 0x0, 0x0)
    Return _SendMessage($hwnd, $EM_FINDWORDBREAK, $WB_MOVEWORDLEFT, $icpstart)
EndFunc    ; -> _GUICtrlRichEdit_GetCharPosOfPreviousWord

Func _GUICtrlRichEdit_GetCharWordBreakInfo($hwnd, $icp)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    If Not __GCR_IsNumeric($icp) Then Return SetError(0x66, 0x0, '')
    Local $iret = _SendMessage($hwnd, $EM_FINDWORDBREAK, $WB_CLASSIFY, $icp)
    Local $iclass = BitAND($iret, 0xf0)
    Local $sret = ''
    If BitAND($iclass, $WBF_BREAKAFTER) Then $sret &= "c"
    If BitAND($iclass, $WBF_BREAKLINE) Then $sret &= "d"
    If BitAND($iclass, $WBF_ISWHITE) Then $sret &= "w"
    $sret &= ";" & BitAND($iret, 0xf)
    Return $sret
EndFunc    ; -> _GUICtrlRichEdit_GetCharWordBreakInfo

Func _GUICtrlRichEdit_GetBkColor($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Local $ibkcolor = _SendMessage($hwnd, $EM_SETBKGNDCOLOR, False, 0x0)
    _SendMessage($hwnd, $EM_SETBKGNDCOLOR, False, $ibkcolor)
    Return $ibkcolor
EndFunc    ; -> _GUICtrlRichEdit_GetBkColor

Func _GUICtrlRichEdit_GetText($hwnd, $bcrtocrlf = False, $icodepage = 0x0, $sreplchar = '')
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    If Not IsBool($bcrtocrlf) Then Return SetError(0x66, 0x0, '')
    If Not __GCR_IsNumeric($icodepage) Then Return SetError(0x67, 0x0, '')
    Local $ilen = _GUICtrlRichEdit_GetTextLength($hwnd, False, True) + 0x1
    Local $suni = ''
    If $icodepage = $CP_UNICODE Or Not $icodepage Then $suni = "w"
    Local $ttext = DllStructCreate($suni & "char[" & $ilen & "]")
    Local $tgettextex = DllStructCreate($TAGGETTEXTEX)
    DllStructSetData($tgettextex, "cb", DllStructGetSize($ttext))
    Local $IFLAGS = 0x0
    If $bcrtocrlf Then $IFLAGS = $GT_USECRLF
    DllStructSetData($tgettextex, "flags", $IFLAGS)
    If $icodepage = 0x0 Then $icodepage = $CP_UNICODE
    DllStructSetData($tgettextex, "codepage", $icodepage)
    Local $puseddefchar = 0x0, $pdefaultchar = 0x0
    If $sreplchar <> '' Then
        Local $tdefaultchar = DllStructCreate("char")
        $pdefaultchar = DllStructGetPtr($tdefaultchar, 0x1)
        DllStructSetData($tdefaultchar, 0x1, $sreplchar)
        Local $tuseddefchar = DllStructCreate("bool")
        $puseddefchar = DllStructGetPtr($tuseddefchar, 0x1)
    EndIf
    DllStructSetData($tgettextex, "lpDefaultChar", $pdefaultchar)
    DllStructSetData($tgettextex, "lpbUsedDefChar", $puseddefchar)
    Local $iret = _SendMessage($hwnd, $EM_GETTEXTEX, $tgettextex, $ttext, 0x0, "struct*", "struct*")
    If $iret = 0x0 Then Return SetError(0x2bc, 0x0, '')
    If $sreplchar <> '' Then SetExtended(DllStructGetData($tuseddefchar, 0x1) <> 0x0)
    Return DllStructGetData($ttext, 0x1)
EndFunc    ; -> _GUICtrlRichEdit_GetText

Func _GUICtrlRichEdit_GetTextLength($hwnd, $bexact = True, $bchars = False, $iusecrlf = 0x1)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    If Not IsBool($bexact) Then Return SetError(0x66, 0x0, 0x0)
    If Not IsBool($bchars) Then Return SetError(0x67, 0x0, 0x0)
    Local $tgettextlen = DllStructCreate($TAGGETTEXTLENGTHEX)
    Local $IFLAGS = BitOR($iusecrlf * $GTL_USECRLF, ($bexact  ? $GTL_PRECISE  : $GTL_CLOSE))
    $IFLAGS = BitOR($IFLAGS, ($bchars  ? $GTL_DEFAULT  : $GTL_NUMBYTES))
    DllStructSetData($tgettextlen, 0x1, $IFLAGS)
    DllStructSetData($tgettextlen, 0x2, ($bchars  ? $CP_ACP  : $CP_UNICODE))
    Local $iret = _SendMessage($hwnd, $EM_GETTEXTLENGTHEX, $tgettextlen, 0x0, 0x0, "struct*")
    Return $iret
EndFunc    ; -> _GUICtrlRichEdit_GetTextLength

Func _GUICtrlRichEdit_GetZoom($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Local $wparam = 0x0, $lparam = 0x0
    Local $ai = _SendMessage($hwnd, $EM_GETZOOM, $wparam, $lparam, + -1, "int*", "int*")
    If Not $ai[0x0] Then Return SetError(0x2bc, 0x0, 0x0)
    Local $iret
    If $ai[0x3] = 0x0 And $ai[0x4] = 0x0 Then
        $iret = 0x64
    Else
        $iret = $ai[0x3] / $ai[0x4] * 0x64
    EndIf
    Return StringFormat("%.2f", $iret)
EndFunc    ; -> _GUICtrlRichEdit_GetZoom

Func _GUICtrlRichEdit_GetFirstCharPosOnLine($hwnd, $iline = + -1)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    If Not __GCR_IsNumeric($iline, ">0,-1") Then Return SetError(0x3fd, 0x0, 0x0)
    If $iline <> + -1 Then $iline -= 0x1
    Local $iret = _SendMessage($hwnd, $EM_LINEINDEX, $iline)
    If $iret = + -1 Then Return SetError(0x3fe, 0x0, 0x0)
    Return $iret
EndFunc    ; -> _GUICtrlRichEdit_GetFirstCharPosOnLine

Func _GUICtrlRichEdit_GetFont($hwnd)
    Local $aret[0x3] = [0x0, '', 0x0]
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Local $tcharformat = DllStructCreate($TAGCHARFORMAT)
    DllStructSetData($tcharformat, "cbSize", DllStructGetSize($tcharformat))
    __GCR_SendGetCharFormatMessage($hwnd, $tcharformat)
    If BitAND(DllStructGetData($tcharformat, "dwMask"), $CFM_FACE) = $CFM_FACE Then $aret[0x1] = DllStructGetData($tcharformat, "szFaceName")
    If BitAND(DllStructGetData($tcharformat, "dwMask"), $CFM_SIZE) = $CFM_SIZE Then $aret[0x0] = DllStructGetData($tcharformat, "yHeight") / 0x14
    If BitAND(DllStructGetData($tcharformat, "dwMask"), $CFM_CHARSET) = $CFM_CHARSET Then $aret[0x2] = DllStructGetData($tcharformat, "bCharSet")
    Return $aret
EndFunc    ; -> _GUICtrlRichEdit_GetFont

Func _GUICtrlRichEdit_GetRECT($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Local $trect = DllStructCreate($TAGRECT)
    _SendMessage($hwnd, $EM_GETRECT, 0x0, $trect, 0x0, "wparam", "struct*")
    Local $airect[0x4]
    $airect[0x0] = DllStructGetData($trect, "Left")
    $airect[0x1] = DllStructGetData($trect, "Top")
    $airect[0x2] = DllStructGetData($trect, "Right")
    $airect[0x3] = DllStructGetData($trect, "Bottom")
    Return $airect
EndFunc    ; -> _GUICtrlRichEdit_GetRECT

Func _GUICtrlRichEdit_GetLineCount($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Return _SendMessage($hwnd, $EM_GETLINECOUNT)
EndFunc    ; -> _GUICtrlRichEdit_GetLineCount

Func _GUICtrlRichEdit_GetLineLength($hwnd, $iline)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    If Not __GCR_IsNumeric($iline, ">0,-1") Then Return SetError(0x66, 0x0, 0x0)
    Local $icharpos = _GUICtrlRichEdit_GetFirstCharPosOnLine($hwnd, $iline)
    Local $iret = _SendMessage($hwnd, $EM_LINELENGTH, $icharpos)
    Return $iret
EndFunc    ; -> _GUICtrlRichEdit_GetLineLength

Func _GUICtrlRichEdit_GetLineNumberFromCharPos($hwnd, $icharpos)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    If Not __GCR_IsNumeric($icharpos, ">=0") Then Return SetError(0x66, 0x0, 0x0)
    Return _SendMessage($hwnd, $EM_EXLINEFROMCHAR, 0x0, $icharpos) + 0x1
EndFunc    ; -> _GUICtrlRichEdit_GetLineNumberFromCharPos

Func _GUICtrlRichEdit_GetNextRedo($hwnd, $bname = True)
    Local Const $AS[0x6] = ["Unknown", "Typing", "Delete", "Drag and drop", "Cut", "Paste"]
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    If Not IsBool($bname) Then Return SetError(0x66, 0x0, '')
    Local $iuid = _SendMessage($hwnd, $EM_GETREDONAME, 0x0, 0x0)
    If $bname Then
        Return $AS[$iuid]
    Else
        Return $iuid
    EndIf
EndFunc    ; -> _GUICtrlRichEdit_GetNextRedo

Func _GUICtrlRichEdit_GetNextUndo($hwnd, $bname = True)
    Local Const $AS[0x6] = ["Unknown", "Typing", "Delete", "Drag and drop", "Cut", "Paste"]
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    If Not IsBool($bname) Then Return SetError(0x66, 0x0, '')
    Local $iuid = _SendMessage($hwnd, $EM_GETUNDONAME, 0x0, 0x0)
    If $bname Then
        Return $AS[$iuid]
    Else
        Return $iuid
    EndIf
EndFunc    ; -> _GUICtrlRichEdit_GetNextUndo

Func _GUICtrlRichEdit_GetNumberOfFirstVisibleLine($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Return _SendMessage($hwnd, $EM_GETFIRSTVISIBLELINE) + 0x1
EndFunc    ; -> _GUICtrlRichEdit_GetNumberOfFirstVisibleLine

Func _GUICtrlRichEdit_GetParaAlignment($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, 0x1, DllStructGetSize($tparaformat))
    __GCR_SendGetParaFormatMessage($hwnd, $tparaformat)
    If @error Then Return SetError(@error, 0x0, '')
    Local $imask = DllStructGetData($tparaformat, 0x2)
    Local $ialignment = DllStructGetData($tparaformat, 0x8)
    Local $sret = ''
    Switch ($ialignment)
    Case $PFA_LEFT
        $sret = "l"
    Case $PFA_CENTER
        $sret = "c"
    Case $PFA_RIGHT
        $sret = "r"
    Case $PFA_JUSTIFY
        $sret = "j"
    Case $PFA_FULL_INTERWORD
        $sret = "w"
    EndSwitch
    $sret &= ";" & __GCR_GetParaScopeChar($hwnd, $imask, $PFM_ALIGNMENT)
    Return $sret
EndFunc    ; -> _GUICtrlRichEdit_GetParaAlignment

Func _GUICtrlRichEdit_GetParaAttributes($hwnd)
    Local Enum $EABBREV = 0x0, $EEFFECT, $EINVERTED
    Local Const $AV[0x9][0x3] = [["fpg", $PFE_PAGEBREAKBEFORE, False], ["hyp", $PFE_DONOTHYPHEN, True], ["kpt", $PFE_KEEP, False], ["kpn", $PFE_KEEPNEXT, False], ["pwo", $PFE_NOWIDOWCONTROL, False], ["r2l", $PFE_RTLPARA, False], ["row", $PFE_TABLE, False], ["sbs", $PFE_SIDEBYSIDE, False], ["sln", $PFE_NOLINENUMBER, False]]
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, 0x1, DllStructGetSize($tparaformat))
    __GCR_SendGetParaFormatMessage($hwnd, $tparaformat)
    If @error Then Return SetError(@error, 0x0, '')
    Local $ieffects = DllStructGetData($tparaformat, "wEffects")
    Local $sstatesandatts = '', $sstate
    For $i = 0x0 To UBound($AV, $UBOUND_ROWS) + -1
        $sstatesandatts &= $AV[$i][$EABBREV]
        If BitAND($ieffects, $AV[$i][$EEFFECT]) = $AV[$i][$EEFFECT] Then
            $sstate = ($AV[$i][$EINVERTED] ? "-"  : "+")
        Else
            $sstate = ($AV[$i][$EINVERTED] ? "+"  : "-")
        EndIf
        $sstatesandatts &= $sstate & ";"
    Next
    $sstatesandatts &= (_GUICtrlRichEdit_IsTextSelected($hwnd) ? "f"  : "c")
    Return $sstatesandatts
EndFunc    ; -> _GUICtrlRichEdit_GetParaAttributes

Func _GUICtrlRichEdit_GetParaBorder($hwnd)
    Local Const $AVLOCS[0x6][0x2] = [["l", 0x1], ["r", 0x2], ["t", 0x4], ["b", 0x8], ["i", 0x10], ["o", 0x20]]
    Local Const $AVLS[0xc] = ["none", 0.75, 1.5, 2.25, 0x3, 4.5, 0x6, ".75d", "1.5d", "2.25d", ".75g", ".75gd"]
    Local Const $SCLRS = "blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;"
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, 0x1, DllStructGetSize($tparaformat))
    __GCR_SendGetParaFormatMessage($hwnd, $tparaformat)
    If @error Then Return SetError(@error, 0x0, '')
    Local $imask = DllStructGetData($tparaformat, 0x2)
    Local $ispace = DllStructGetData($tparaformat, 0x16)
    Local $iborders = DllStructGetData($tparaformat, 0x18)
    Local $sret = ''
    For $i = 0x0 To UBound($AVLOCS, $UBOUND_ROWS) + -1
        If BitAND($iborders, $AVLOCS[$i][0x1]) Then $sret &= $AVLOCS[$i][0x0]
    Next
    $sret &= ";"
    $sret &= $AVLS[BitShift(BitAND($iborders, 0xf00), 0x8)]
    $sret &= ";"
    If BitAND($iborders, 0x40) Then
        $sret &= "aut"
    Else
        $sret &= StringMid($SCLRS, BitShift(BitAND($iborders, 0xf000), 0xc) * 0x4 + 0x1, 0x3)
    EndIf
    $sret &= ";"
    $sret &= __GCR_ConvertTwipsToSpaceUnit($ispace) & ";"
    $sret &= __GCR_GetParaScopeChar($hwnd, $imask, $PFM_BORDER)
    Return $sret
EndFunc    ; -> _GUICtrlRichEdit_GetParaBorder

Func _GUICtrlRichEdit_GetParaIndents($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, 0x1, DllStructGetSize($tparaformat))
    DllStructSetData($tparaformat, "dwMask", BitOR($PFM_STARTINDENT, $PFM_OFFSET))
    __GCR_SendGetParaFormatMessage($hwnd, $tparaformat)
    If @error Then Return SetError(@error, 0x0, '')
    Local $imask = DllStructGetData($tparaformat, "dwMask")
    Local $iidxsi = DllStructGetData($tparaformat, "dxStartIndent")
    Local $iidxofs = DllStructGetData($tparaformat, "dxOffset")
    Local $idxri = DllStructGetData($tparaformat, "dxRightIndent")
    Local $ileft = __GCR_ConvertTwipsToSpaceUnit($iidxsi + $iidxofs)
    Local $ifirstline = __GCR_ConvertTwipsToSpaceUnit(- $iidxofs)
    Local $iright = __GCR_ConvertTwipsToSpaceUnit($idxri)
    Local $iret = $ileft & ";" & $iright & ";" & $ifirstline & ";" & __GCR_GetParaScopeChar($hwnd, $imask, $PFM_STARTINDENT)
    Return $iret
EndFunc    ; -> _GUICtrlRichEdit_GetParaIndents

Func _GUICtrlRichEdit_GetParaNumbering($hwnd)
    Local Const $AVROMAN[0x7][0x2] = [[0x3e8, "m"], [0x1f4, "d"], [0x64, "c"], [0x32, "l"], [0xa, "x"], [0x5, "v"], [0x1, "i"]]
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, 0x1, DllStructGetSize($tparaformat))
    DllStructSetData($tparaformat, 0x2, BitOR($PFM_NUMBERING, $PFM_NUMBERINGSTART, $PFM_NUMBERINGSTYLE))
    __GCR_SendGetParaFormatMessage($hwnd, $tparaformat)
    If @error Then Return SetError(@error, 0x0, '')
    Local $imask = DllStructGetData($tparaformat, "dwMask")
    Local $ichar = DllStructGetData($tparaformat, "wNumbering")
    Local $istart = DllStructGetData($tparaformat, "wNumberingStart")
    Local $istyle = DllStructGetData($tparaformat, "wNumberingStyle")
    Local $itab = DllStructGetData($tparaformat, "wNumberingTab")
    Local $sret = ''
    Switch $ichar
    Case 0x0
        $sret = ''
    Case 0x1
        $sret = "."
    Case 0x2
        $sret = $istart
    Case 0x3
        $sret = Chr(Asc("a") + $istart + -1)
    Case 0x4
        $sret = Chr(Asc("a") + $istart + -1)
    Case 0x5, 0x6
        For $i = 0x0 To UBound($AVROMAN, $UBOUND_ROWS) + -2 Step 0x2
            For $j = $i To $i + 0x1
                While $istart >= $AVROMAN[$j][0x0]
                    $sret &= $AVROMAN[$j][0x1]
                    $istart -= $AVROMAN[$j][0x0]
                WEnd
                If $istart = $AVROMAN[$j][0x0] + -1 Then
                    $sret &= $AVROMAN[$i + 0x2][0x1] & $AVROMAN[$j][0x1]
                    $istart -= $AVROMAN[$j][0x0] - $AVROMAN[$i + 0x2][0x0]
                EndIf
            Next
        Next
        While $istart > 0x0
            $sret &= "i"
            $istart -= 0x1
        WEnd
        If $ichar = 0x6 Then $sret = StringUpper($sret)
    EndSwitch
    If $ichar > 0x1 Then
        Switch $istyle
        Case 0x0
            $sret &= ")"
        Case 0x100
            $sret = "(" & $sret & ")"
        Case 0x200
            $sret &= "."
        Case 0x300
        EndSwitch
    EndIf
    Local $AV = _GUICtrlRichEdit_GetFont($hwnd)
    Local $ipoints = $AV[0x0]
    Local $iqspaces = Round($itab / ($ipoints * 0x14), 0x0)
    For $i = 0x1 To $iqspaces
        $sret &= " "
    Next
    $sret &= ";"
    $sret &= (($ichar = 0x5 Or $ichar = 0x6) ? "Roman;"  : ";")
    $sret &= __GCR_ConvertTwipsToSpaceUnit($itab) & ";"
    $sret &= __GCR_GetParaScopeChar($hwnd, $imask, BitOR($PFM_NUMBERING, $PFM_NUMBERINGSTART, $PFM_NUMBERINGSTYLE))
    Return $sret
EndFunc    ; -> _GUICtrlRichEdit_GetParaNumbering

Func _GUICtrlRichEdit_GetParaShading($hwnd)
    Local Const $ASSTYLES[0xd] = ["non", "dhz", "dvt", "ddd", "dud", "dgr", "dtr", "lhz", "lrt", "ldd", "lud", "lgr", "ltr"]
    Local Const $ASCLRS[0x10] = ["blk", "blu", "cyn", "grn", "mag", "red", "yel", "whi", "dbl", "dgn", "dmg", "drd", "dyl", "dgy", "lgy"]
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, 0x1, DllStructGetSize($tparaformat))
    __GCR_SendGetParaFormatMessage($hwnd, $tparaformat)
    If @error Then Return SetError(@error, 0x0, '')
    Local $imask = DllStructGetData($tparaformat, "dwMask")
    Local $iweight = DllStructGetData($tparaformat, "wShadingWeight")
    Local $is = DllStructGetData($tparaformat, "wShadingStyle")
    Local $sret = $iweight & ";"
    Local $in = BitAND($is, 0xf)
    $sret &= $ASSTYLES[$in] & ";"
    $in = BitShift(BitAND($is, 0xf0), 0x4)
    $sret &= $ASCLRS[$in] & ";"
    $in = BitShift(BitAND($is, 0xf00), 0x8)
    $sret &= $ASCLRS[$in] & ";"
    $sret &= __GCR_GetParaScopeChar($hwnd, $imask, $PFM_SHADING)
    Return $sret
EndFunc    ; -> _GUICtrlRichEdit_GetParaShading

Func _GUICtrlRichEdit_GetParaSpacing($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, "cbSize", DllStructGetSize($tparaformat))
    __GCR_SendGetParaFormatMessage($hwnd, $tparaformat)
    If @error Then Return SetError(@error, 0x0, '')
    Local $iinter = DllStructGetData($tparaformat, "dyLineSpacing")
    Local $irule = DllStructGetData($tparaformat, "bLineSpacingRule")
    Local $sret = ''
    Switch $irule
    Case 0x0
        $sret = "1 line;"
    Case 0x1
        $sret = "1.5 lines;"
    Case 0x2
        $sret = "2 lines;"
    Case 0x3, 0x4
        $sret = __GCR_ConvertTwipsToSpaceUnit($iinter) & ";"
    Case 0x5
        $sret = StringFormat("%.2f", $iinter / 0x14) & " lines;"
    EndSwitch
    Local $imask = 0x0
    $sret &= __GCR_GetParaScopeChar($hwnd, $imask, $PFM_LINESPACING) & ";"
    Local $ibefore = DllStructGetData($tparaformat, "dySpaceBefore")
    $sret &= __GCR_ConvertTwipsToSpaceUnit($ibefore) & ";"
    $sret &= __GCR_GetParaScopeChar($hwnd, $imask, $PFM_SPACEBEFORE) & ";"
    Local $iafter = DllStructGetData($tparaformat, "dySPaceAfter")
    $sret &= __GCR_ConvertTwipsToSpaceUnit($iafter) & ";"
    $sret &= __GCR_GetParaScopeChar($hwnd, $imask, $PFM_SPACEAFTER)
    Return $sret
EndFunc    ; -> _GUICtrlRichEdit_GetParaSpacing

Func _GUICtrlRichEdit_GetParaTabStops($hwnd)
    Local Const $ASKIND[0x5] = ["l", "c", "r", "d", "b"], $ASLEADER[0x6] = [" ", ".", "-", "_", "t", "="]
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT)
    DllStructSetData($tparaformat, "cbSize", DllStructGetSize($tparaformat))
    __GCR_SendGetParaFormatMessage($hwnd, $tparaformat)
    If @error Then Return SetError(@error, 0x0, '')
    Local $imask = DllStructGetData($tparaformat, "dwMask")
    Local $iqtabs = DllStructGetData($tparaformat, "cTabCount")
    Local $sret = $iqtabs & ";"
    Local $in, $im
    For $i = 0x1 To $iqtabs
        $in = DllStructGetData($tparaformat, "rgxTabs", $i)
        $sret &= __GCR_ConvertTwipsToSpaceUnit(BitAND($in, 0xfffff))
        $im = BitAND(BitShift($in, 0x18), 0xf)
        $sret &= $ASKIND[$im]
        $im = BitAND(BitShift($in, 0x1c), 0xf)
        $sret &= $ASLEADER[$im] & ";"
    Next
    $sret &= __GCR_GetParaScopeChar($hwnd, $imask, $PFM_TABSTOPS)
    Return $sret
EndFunc    ; -> _GUICtrlRichEdit_GetParaTabStops

Func _GUICtrlRichEdit_GetPasswordChar($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Local $n = _SendMessage($hwnd, $EM_GETPASSWORDCHAR)
    Return ($n = 0x0) ? ''  : Chr($n)
EndFunc    ; -> _GUICtrlRichEdit_GetPasswordChar

Func _GUICtrlRichEdit_GetScrollPos($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Local $tpoint = DllStructCreate($TAGPOINT)
    _SendMessage($hwnd, $EM_GETSCROLLPOS, 0x0, $tpoint, 0x0, "wparam", "struct*")
    Local $aret[0x2]
    $aret[0x0] = DllStructGetData($tpoint, "x")
    $aret[0x1] = DllStructGetData($tpoint, "y")
    Return $aret
EndFunc    ; -> _GUICtrlRichEdit_GetScrollPos

Func _GUICtrlRichEdit_GetSel($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Local $tcharrange = DllStructCreate($TAGCHARRANGE)
    _SendMessage($hwnd, $EM_EXGETSEL, 0x0, $tcharrange, 0x0, "wparam", "struct*")
    Local $aret[0x2]
    $aret[0x0] = DllStructGetData($tcharrange, 0x1)
    $aret[0x1] = DllStructGetData($tcharrange, 0x2)
    Return $aret
EndFunc    ; -> _GUICtrlRichEdit_GetSel

Func _GUICtrlRichEdit_GetSelAA($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    Local $ailowhigh = _GUICtrlRichEdit_GetSel($hwnd)
    If $ailowhigh[0x0] = $ailowhigh[0x1] Then Return SetError(+ -1, 0x0, 0x0)
    _SendMessage($hwnd, $EM_SETSEL, + -1, 0x0)
    Local $ainosel = _GUICtrlRichEdit_GetSel($hwnd)
    Local $aret[0x2]
    If $ailowhigh[0x0] = $ainosel[0x0] Then
        $aret[0x0] = $ailowhigh[0x1]
        $aret[0x1] = $ailowhigh[0x0]
    Else
        $aret = $ailowhigh
    EndIf
    _SendMessage($hwnd, $EM_SETSEL, $ailowhigh[0x0], $ailowhigh[0x1])
    _WinAPI_SetFocus($hwnd)
    Return $aret
EndFunc    ; -> _GUICtrlRichEdit_GetSelAA

Func _GUICtrlRichEdit_GetSelText($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not _GUICtrlRichEdit_IsTextSelected($hwnd) Then Return SetError(+ -1, 0x0, + -1)
    Local $ailowhigh = _GUICtrlRichEdit_GetSel($hwnd)
    Local $ttext = DllStructCreate("wchar[" & $ailowhigh[0x1] - $ailowhigh[0x0] + 0x1 & "]")
    _SendMessage($hwnd, $EM_GETSELTEXT, 0x0, $ttext, 0x0, "wparam", "struct*")
    Return DllStructGetData($ttext, 0x1)
EndFunc    ; -> _GUICtrlRichEdit_GetSelText

Func _GUICtrlRichEdit_GetSpaceUnit()
    Switch $__g_irtftwipspespaceunit
    Case 0x5a0
        Return "in"
    Case 0x237
        Return "cm"
    Case 56.7
        Return "mm"
    Case 0x14
        Return "pt"
    Case 0x1
        Return "tw"
    EndSwitch
EndFunc    ; -> _GUICtrlRichEdit_GetSpaceUnit

Func _GUICtrlRichEdit_GetTextInLine($hwnd, $iline)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not __GCR_IsNumeric($iline, ">0,-1") Then Return SetError(0x3fd, 0x0, False)
    If $iline > _GUICtrlRichEdit_GetLineCount($hwnd) Then Return SetError(0x3fe, 0x0, False)
    Local $ilen = _GUICtrlRichEdit_GetLineLength($hwnd, $iline)
    If $ilen = 0x0 Then Return ''
    Local $tbuffer = DllStructCreate("short Len;wchar Text[" & $ilen + 0x2 & "]")
    DllStructSetData($tbuffer, "Len", $ilen + 0x2)
    If $iline <> + -1 Then $iline -= 0x1
    Local $iret = _SendMessage($hwnd, $EM_GETLINE, $iline, $tbuffer, 0xa, "wparam", "struct*")
    If $iret = 0x0 Then Return SetError(0x2bc, 0x0, False)
    Local $tstring = DllStructCreate("wchar Text[" & $ilen + 0x1 & "]", DllStructGetPtr($tbuffer))
    Return StringLeft(DllStructGetData($tstring, "Text"), $ilen)
EndFunc    ; -> _GUICtrlRichEdit_GetTextInLine

Func _GUICtrlRichEdit_GetTextInRange($hwnd, $istart, $IEND)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not __GCR_IsNumeric($istart, ">=0") Then Return SetError(0x66, 0x0, False)
    If Not __GCR_IsNumeric($IEND, ">=0,-1") Then Return SetError(0x407, 0x0, False)
    If Not ($IEND > $istart Or $IEND = + -1) Then Return SetError(0x408, 0x0, False)
    Local $ilen = _GUICtrlRichEdit_GetTextLength($hwnd)
    Local $ttext = DllStructCreate("wchar[" & ($ilen + 0x4) & "]")
    Local $ttextrange = DllStructCreate($TAGTEXTRANGE)
    DllStructSetData($ttextrange, 0x1, $istart)
    DllStructSetData($ttextrange, 0x2, $IEND)
    DllStructSetData($ttextrange, 0x3, DllStructGetPtr($ttext))
    _SendMessage($hwnd, $EM_GETTEXTRANGE, 0x0, $ttextrange, 0x0, "wparam", "struct*")
    Return DllStructGetData($ttext, 0x1)
EndFunc    ; -> _GUICtrlRichEdit_GetTextInRange

Func _GUICtrlRichEdit_GetVersion()
    Return $__g_srtfversion
EndFunc    ; -> _GUICtrlRichEdit_GetVersion

Func _GUICtrlRichEdit_GetXYFromCharPos($hwnd, $icharpos)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    If Not __GCR_IsNumeric($icharpos, ">=0") Then Return SetError(0x3fd, 0x0, 0x0)
    If $icharpos > _GUICtrlRichEdit_GetTextLength($hwnd) Then Return SetError(0x3fe, 0x0, 0x0)
    Local $tpoint = DllStructCreate($TAGPOINT)
    _SendMessage($hwnd, $EM_POSFROMCHAR, $tpoint, $icharpos, 0x0, "struct*", "lparam")
    Local $aret[0x2]
    $aret[0x0] = DllStructGetData($tpoint, "X")
    $aret[0x1] = DllStructGetData($tpoint, "Y")
    Return $aret
EndFunc    ; -> _GUICtrlRichEdit_GetXYFromCharPos

Func _GUICtrlRichEdit_GotoCharPos($hwnd, $icharpos)
    If $icharpos > _GUICtrlRichEdit_GetTextLength($hwnd, True, True, 0x0) Then Return SetError(0x67, 0x0, False)
    _GUICtrlRichEdit_SetSel($hwnd, $icharpos, $icharpos)
    If @error Then Return SetError(@error, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_GotoCharPos

Func _GUICtrlRichEdit_HideSelection($hwnd, $bhide = True)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not IsBool($bhide) Then Return SetError(0x66, 0x0, False)
    _SendMessage($hwnd, $EM_HIDESELECTION, $bhide, 0x0)
    _WinAPI_SetFocus($hwnd)
EndFunc    ; -> _GUICtrlRichEdit_HideSelection

Func _GUICtrlRichEdit_InsertText($hwnd, $stext)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If $stext = '' Then Return SetError(0x66, 0x0, False)
    Local $tsettext = DllStructCreate($TAGSETTEXTEX)
    DllStructSetData($tsettext, 0x1, $ST_SELECTION)
    _GUICtrlRichEdit_Deselect($hwnd)
    Local $iret
    If StringLeft($stext, 0x5) <> "{\\rtf" And StringLeft($stext, 0x5) <> "{urtf" Then
        DllStructSetData($tsettext, 0x2, $CP_UNICODE)
        $iret = _SendMessage($hwnd, $EM_SETTEXTEX, $tsettext, $stext, 0x0, "struct*", "wstr")
    Else
        DllStructSetData($tsettext, 0x2, $CP_ACP)
        $iret = _SendMessage($hwnd, $EM_SETTEXTEX, $tsettext, $stext, 0x0, "struct*", "STR")
    EndIf
    If Not $iret Then Return SetError(0x67, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_InsertText

Func _GUICtrlRichEdit_IsModified($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Return _SendMessage($hwnd, $EM_GETMODIFY) <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_IsModified

Func _GUICtrlRichEdit_IsTextSelected($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $tcharrange = DllStructCreate($TAGCHARRANGE)
    _SendMessage($hwnd, $EM_EXGETSEL, 0x0, $tcharrange, 0x0, "wparam", "struct*")
    Return DllStructGetData($tcharrange, 0x2) <> DllStructGetData($tcharrange, 0x1)
EndFunc    ; -> _GUICtrlRichEdit_IsTextSelected

Func _GUICtrlRichEdit_Paste($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    _SendMessage($hwnd, $__RICHEDITCONSTANT_WM_PASTE, 0x0, 0x0)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_Paste

Func _GUICtrlRichEdit_PasteSpecial($hwnd, $bandobjects = True)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $in = ($bandobjects  ? $__g_sgre_cf_retextobj  : $__g_sgre_cf_rtf)
    _SendMessage($hwnd, $EM_PASTESPECIAL, $in, 0x0)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_PasteSpecial

Func _GUICtrlRichEdit_PauseRedraw($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    _SendMessage($hwnd, $__RICHEDITCONSTANT_WM_SETREDRAW, False)
EndFunc    ; -> _GUICtrlRichEdit_PauseRedraw

Func _GUICtrlRichEdit_Redo($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Return _SendMessage($hwnd, $EM_REDO, 0x0, 0x0) <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_Redo

Func _GUICtrlRichEdit_ReplaceText($hwnd, $stext, $bcanundo = True)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not IsBool($bcanundo) Then Return SetError(0x67, 0x0, False)
    If Not _GUICtrlRichEdit_IsTextSelected($hwnd) Then Return SetError(+ -1, 0x0, False)
    Local $ttext = DllStructCreate("wchar Text[" & StringLen($stext) + 0x1 & "]")
    DllStructSetData($ttext, "Text", $stext)
    __guictrl_sendmsg($hwnd, $EM_REPLACESEL, $bcanundo, $ttext)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_ReplaceText

Func _GUICtrlRichEdit_ResumeRedraw($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    _SendMessage($hwnd, $__RICHEDITCONSTANT_WM_SETREDRAW, True)
    Return _WinAPI_InvalidateRect($hwnd)
EndFunc    ; -> _GUICtrlRichEdit_ResumeRedraw

Func _GUICtrlRichEdit_ScrollLineOrPage($hwnd, $saction)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, 0x0)
    If StringLen($saction) <> 0x2 Then Return SetError(0x3fd, 0x0, 0x0)
    Local $sch = StringLeft($saction, 0x1)
    If Not ($sch = "l" Or $sch = "p") Then Return SetError(0x3fe, 0x0, 0x0)
    $sch = StringRight($saction, 0x1)
    If Not ($sch = "d" Or $sch = "u") Then Return SetError(0x3ff, 0x0, 0x0)
    Local $wparam = 0x0
    Switch $saction
    Case "ld"
        $wparam = $__RICHEDITCONSTANT_SB_LINEDOWN
    Case "lu"
        $wparam = $__RICHEDITCONSTANT_SB_LINEUP
    Case "pd"
        $wparam = $__RICHEDITCONSTANT_SB_PAGEDOWN
    Case "pu"
        $wparam = $__RICHEDITCONSTANT_SB_PAGEUP
    EndSwitch
    Local $iret = _SendMessage($hwnd, $EM_SCROLL, $wparam, 0x0)
    $iret = BitAND($iret, 0xffff)
    If BitAND($iret, 0x8000) <> 0x0 Then $iret = BitOR($iret, -65536)
    Return $iret
EndFunc    ; -> _GUICtrlRichEdit_ScrollLineOrPage

Func _GUICtrlRichEdit_ScrollLines($hwnd, $iqlines)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not __GCR_IsNumeric($iqlines) Then SetError(0x66, 0x0, False)
    Local $iret = _SendMessage($hwnd, $EM_LINESCROLL, 0x0, $iqlines)
    If $iret = 0x0 Then Return SetError(0x2bc, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_ScrollLines

Func _GUICtrlRichEdit_ScrollToCaret($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    _SendMessage($hwnd, $EM_SCROLLCARET, 0x0, 0x0)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_ScrollToCaret

Func _GUICtrlRichEdit_SetCharAttributes($hwnd, $sstatesandeffects, $bword = False)
    Local Const $AV[0x11][0x3] = [["bo", $CFM_BOLD, $CFE_BOLD], ["di", $CFM_DISABLED, $CFE_DISABLED], ["em", $CFM_EMBOSS, $CFE_EMBOSS], ["hi", $CFM_HIDDEN, $CFE_HIDDEN], ["im", $CFM_IMPRINT, $CFE_IMPRINT], ["it", $CFM_ITALIC, $CFE_ITALIC], ["li", $CFM_LINK, $CFE_LINK], ["ou", $CFM_OUTLINE, $CFE_OUTLINE], ["pr", $CFM_PROTECTED, $CFE_PROTECTED], ["re", $CFM_REVISED, $CFE_REVISED], ["sh", $CFM_SHADOW, $CFE_SHADOW], ["sm", $CFM_SMALLCAPS, $CFE_SMALLCAPS], ["st", $CFM_STRIKEOUT, $CFE_STRIKEOUT], ["sb", $CFM_SUBSCRIPT, $CFE_SUBSCRIPT], ["sp", $CFM_SUPERSCRIPT, $CFE_SUPERSCRIPT], ["un", $CFM_UNDERLINE, $CFE_UNDERLINE], ["al", $CFM_ALLCAPS, $CFE_ALLCAPS]]
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not IsBool($bword) Then Return SetError(0x67, 0x0, False)
    Local $imask = 0x0, $ieffects = 0x0, $n, $s
    For $i = 0x1 To StringLen($sstatesandeffects) Step 0x3
        $s = StringMid($sstatesandeffects, $i + 0x1, 0x2)
        $n = + -1
        For $j = 0x0 To UBound($AV) + -1
            If $AV[$j][0x0] = $s Then
                $n = $j
                ExitLoop
            EndIf
        Next
        If $n = + -1 Then Return SetError(0x3ff, $s, False)
        $imask = BitOR($imask, $AV[$n][0x1])
        $s = StringMid($sstatesandeffects, $i, 0x1)
        Switch $s
        Case "+"
            $ieffects = BitOR($ieffects, $AV[$n][0x2])
        Case "-"
        Case Else
            Return SetError(0x3fe, $s, False)
        EndSwitch
    Next
    Local $tcharformat = DllStructCreate($TAGCHARFORMAT)
    DllStructSetData($tcharformat, 0x1, DllStructGetSize($tcharformat))
    DllStructSetData($tcharformat, 0x2, $imask)
    DllStructSetData($tcharformat, 0x3, $ieffects)
    Local $wparam = ($bword  ? BitOR($SCF_WORD, $SCF_SELECTION) : $SCF_SELECTION)
    Local $iret = _SendMessage($hwnd, $EM_SETCHARFORMAT, $wparam, $tcharformat, 0x0, "wparam", "struct*")
    If Not $iret Then Return SetError(0x2bc, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetCharAttributes

Func _GUICtrlRichEdit_SetCharBkColor($hwnd, $ibkcolor = Default)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $tcharformat = DllStructCreate($TAGCHARFORMAT2)
    DllStructSetData($tcharformat, 0x1, DllStructGetSize($tcharformat))
    If $ibkcolor = Default Then
        DllStructSetData($tcharformat, 0x3, $CFE_AUTOBACKCOLOR)
        $ibkcolor = 0x0
    Else
        If BitAND($ibkcolor, -16777216) Then Return SetError(0x3fe, 0x0, False)
    EndIf
    DllStructSetData($tcharformat, 0x2, $CFM_BACKCOLOR)
    DllStructSetData($tcharformat, 0xc, $ibkcolor)
    Return _SendMessage($hwnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tcharformat, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_SetCharBkColor

Func _GUICtrlRichEdit_SetCharColor($hwnd, $icolor = Default)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $tcharformat = DllStructCreate($TAGCHARFORMAT)
    DllStructSetData($tcharformat, 0x1, DllStructGetSize($tcharformat))
    If $icolor = Default Then
        DllStructSetData($tcharformat, 0x3, $CFE_AUTOCOLOR)
        $icolor = 0x0
    Else
        If BitAND($icolor, -16777216) Then Return SetError(0x3fe, 0x0, False)
    EndIf
    DllStructSetData($tcharformat, 0x2, $CFM_COLOR)
    DllStructSetData($tcharformat, 0x6, $icolor)
    Return _SendMessage($hwnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tcharformat, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_SetCharColor

Func _GUICtrlRichEdit_SetBkColor($hwnd, $ibngcolor = Default)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $bsyscolor = False
    If $ibngcolor = Default Then
        $bsyscolor = True
        $ibngcolor = 0x0
    Else
        If BitAND($ibngcolor, -16777216) Then Return SetError(0x3fe, 0x0, False)
    EndIf
    _SendMessage($hwnd, $EM_SETBKGNDCOLOR, $bsyscolor, $ibngcolor)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetBkColor

Func _GUICtrlRichEdit_SetLimitOnText($hwnd, $inewlimit)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not __GCR_IsNumeric($inewlimit, ">=0") Then Return SetError(0x66, 0x0, False)
    If $inewlimit < 0xffff Then $inewlimit = 0x0
    _SendMessage($hwnd, $EM_EXLIMITTEXT, 0x0, $inewlimit)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetLimitOnText

Func _GUICtrlRichEdit_SetTabStops($hwnd, $vtabstops, $bredraw = True)
    Local Const $ITWIPSPERDU = 18.75
    Local $ttabstops, $tagtabstops = '', $wparam
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not IsBool($bredraw) Then Return SetError(0x67, 0x0, False)
    If IsString($vtabstops) Then
        If $vtabstops = '' Then Return SetError(0x3ff, 0x0, False)
        Local $AS = StringSplit($vtabstops, ";")
        Local $inumtabstops = $AS[0x0]
        For $i = 0x1 To $inumtabstops
            If Not __GCR_IsNumeric($AS[$i], ">0") Then Return SetError(0x3fe, 0x0, False)
            $tagtabstops &= "int;"
        Next
        $tagtabstops = StringTrimRight($tagtabstops, 0x1)
        $ttabstops = DllStructCreate($tagtabstops)
        For $i = 0x1 To $inumtabstops
            DllStructSetData($ttabstops, $i, $AS[$i] * $__g_irtftwipspespaceunit / $ITWIPSPERDU)
        Next
        $wparam = $inumtabstops
    ElseIf IsNumber($vtabstops) Then
        If __GCR_IsNumeric($vtabstops, ">0") Then
            $ttabstops = DllStructCreate("int")
            DllStructSetData($ttabstops, 0x1, $vtabstops * $__g_irtftwipspespaceunit / $ITWIPSPERDU)
            $wparam = 0x1
        Else
            Return SetError(0x400, 0x9, False)
        EndIf
    Else
        Return SetError(0x3fd, 0x0, False)
    EndIf
    Local $bresult = _SendMessage($hwnd, $EM_SETTABSTOPS, $wparam, $ttabstops, 0x0, "wparam", "struct*") <> 0x0
    If $bredraw Then _WinAPI_InvalidateRect($hwnd)
    Return $bresult
EndFunc    ; -> _GUICtrlRichEdit_SetTabStops

Func _GUICtrlRichEdit_SetZoom($hwnd, $ipercent)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not __GCR_IsNumeric($ipercent, ">0") Then Return SetError(0x3fd, 0x0, False)
    Local $inumerator, $idenominator
    Select
    Case Not ($ipercent = 0x64 Or ($ipercent >= 0xc8 And $ipercent < 0x1900))
        Return SetError(0x3fe, 0x0, False)
    Case $ipercent >= 0x64
        $inumerator = 0x2710
        $idenominator = 0x2710 / ($ipercent / 0x64)
    Case Else
        $inumerator = 0x2710 * ($ipercent / 0x64)
        $idenominator = 0x2710
    EndSelect
    Return _SendMessage($hwnd, $EM_SETZOOM, $inumerator, $idenominator) <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_SetZoom

Func _GUICtrlRichEdit_SetEventMask($hwnd, $ieventmask)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not __GCR_IsNumeric($ieventmask) Then Return SetError(0x66, 0x0, False)
    _SendMessage($hwnd, $EM_SETEVENTMASK, 0x0, $ieventmask)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetEventMask

Func _GUICtrlRichEdit_SetFont($hwnd, $ipoints = Default, $sname = Default, $icharset = Default, $ilcid = Default)
    Local $idwmask = 0x0
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not ($ipoints = Default Or __GCR_IsNumeric($ipoints, ">0")) Then Return SetError(0x66, 0x0, False)
    If $sname <> Default Then
        Local $AS = StringSplit($sname, " ")
        For $i = 0x1 To UBound($AS) + -1
            If Not StringIsAlpha($AS[$i]) Then Return SetError(0x67, 0x0, False)
        Next
    EndIf
    If Not ($icharset = Default Or __GCR_IsNumeric($icharset)) Then Return SetError(0x68, 0x0, False)
    If Not ($ilcid = Default Or __GCR_IsNumeric($ilcid)) Then Return SetError(0x69, 0x0, False)
    Local $tcharformat = DllStructCreate($TAGCHARFORMAT2)
    DllStructSetData($tcharformat, 0x1, DllStructGetSize($tcharformat))
    If $ipoints <> Default Then
        $idwmask = $CFM_SIZE
        DllStructSetData($tcharformat, 0x4, Int($ipoints * 0x14))
    EndIf
    If $sname <> Default Then
        If StringLen($sname) > $LF_FACESIZE + -1 Then SetError(+ -1, 0x0, False)
        $idwmask = BitOR($idwmask, $CFM_FACE)
        DllStructSetData($tcharformat, 0x9, $sname)
    EndIf
    If $icharset <> Default Then
        $idwmask = BitOR($idwmask, $CFM_CHARSET)
        DllStructSetData($tcharformat, 0x7, $icharset)
    EndIf
    If $ilcid <> Default Then
        $idwmask = BitOR($idwmask, $CFM_LCID)
        DllStructSetData($tcharformat, 0xd, $ilcid)
    EndIf
    DllStructSetData($tcharformat, 0x2, $idwmask)
    Local $iret = _SendMessage($hwnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tcharformat, 0x0, "wparam", "struct*")
    If Not $iret Then Return SetError(@error + 0xc8, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetFont

Func _GUICtrlRichEdit_SetRECT($hwnd, $ileft = Default, $itop = Default, $iright = Default, $ibottom = Default, $bredraw = True)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not ($ileft = Default Or __GCR_IsNumeric($ileft, ">0")) Then Return SetError(0x3fd, 0x0, False)
    If Not ($itop = Default Or __GCR_IsNumeric($itop, ">0")) Then Return SetError(0x3fe, 0x0, False)
    If Not ($iright = Default Or __GCR_IsNumeric($iright, ">0")) Then Return SetError(0x3ff, 0x0, False)
    If Not ($ibottom = Default Or __GCR_IsNumeric($ibottom, ">0")) Then Return SetError(0x400, 0x0, False)
    If @NumParams = 0x1 Then
        Local $apos = ControlGetPos($hwnd, '', '')
        $ileft = 0x2
        $itop = 0x2
        $iright = $apos[0x2]
        $ibottom = $apos[0x3]
        _GUICtrlRichEdit_SetRECT($hwnd, $ileft, $itop, $iright, $ibottom)
        Return True
    Else
        Local $AS = _GUICtrlRichEdit_GetRECT($hwnd)
        If $ileft = Default Then
            $ileft = $AS[0x0]
        EndIf
        If $itop = Default Then
            $itop = $AS[0x1]
        EndIf
        If $iright = Default Then
            $iright = $AS[0x2]
        EndIf
        If $ibottom = Default Then
            $ibottom = $AS[0x3]
        EndIf
        If $ileft >= $iright Then Return SetError(0x401, 0x0, False)
        If $itop >= $ibottom Then Return SetError(0x402, 0x0, False)
        Local $trect = DllStructCreate($TAGRECT)
        DllStructSetData($trect, "Left", Number($ileft))
        DllStructSetData($trect, "Top", Number($itop))
        DllStructSetData($trect, "Right", Number($iright))
        DllStructSetData($trect, "Bottom", Number($ibottom))
        Local $imsg = ($bredraw  ? $EM_SETRECT  : $EM_SETRECTNP)
        _SendMessage($hwnd, $imsg, 0x0, $trect, 0x0, "wparam", "struct*")
    EndIf
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetRECT

Func _GUICtrlRichEdit_SetModified($hwnd, $bstate = True)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not IsBool($bstate) Then Return SetError(0x66, 0x0, False)
    _SendMessage($hwnd, $EM_SETMODIFY, $bstate)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetModified

Func _GUICtrlRichEdit_SetParaAlignment($hwnd, $salignment)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $ialignment
    Switch $salignment
    Case "l"
        $ialignment = $PFA_LEFT
    Case "c"
        $ialignment = $PFA_CENTER
    Case "r"
        $ialignment = $PFA_RIGHT
    Case "j"
        $ialignment = $PFA_JUSTIFY
    Case "w"
        $ialignment = $PFA_FULL_INTERWORD
    Case Else
        Return SetError(0x66, 0x0, False)
    EndSwitch
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, 0x1, DllStructGetSize($tparaformat))
    DllStructSetData($tparaformat, 0x2, $PFM_ALIGNMENT)
    DllStructSetData($tparaformat, 0x8, $ialignment)
    Return _SendMessage($hwnd, $EM_SETPARAFORMAT, 0x0, $tparaformat, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_SetParaAlignment

Func _GUICtrlRichEdit_SetParaAttributes($hwnd, $sstatesandatts)
    Local Enum $EABBREV = 0x0, $EMASK, $EEFFECT, $EINVERTED
    Local Const $AV[0x9][0x4] = [["fpg", $PFM_PAGEBREAKBEFORE, $PFE_PAGEBREAKBEFORE, False], ["hyp", $PFM_DONOTHYPHEN, $PFE_DONOTHYPHEN, True], ["kpt", $PFM_KEEP, $PFE_KEEP, False], ["kpn", $PFM_KEEPNEXT, $PFE_KEEPNEXT, False], ["pwo", $PFM_NOWIDOWCONTROL, $PFE_NOWIDOWCONTROL, False], ["r2l", $PFM_RTLPARA, $PFE_RTLPARA, False], ["row", $PFM_TABLE, $PFE_TABLE, False], ["sbs", $PFM_SIDEBYSIDE, $PFE_SIDEBYSIDE, False], ["sln", $PFM_NOLINENUMBER, $PFE_NOLINENUMBER, False]]
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Mod(StringLen($sstatesandatts) + 0x1, 0x5) <> 0x0 Then Return SetError(0x3ff, 0x0, False)
    Local $AS = StringSplit($sstatesandatts, ";")
    Local $imask = 0x0, $ieffects = 0x0, $s, $n
    For $i = 0x1 To UBound($AS, $UBOUND_ROWS) + -1
        $s = StringMid($AS[$i], 0x2)
        $n = + -1
        For $j = 0x0 To UBound($AV, $UBOUND_ROWS) + -1
            If $AV[$j][$EABBREV] = $s Then
                $n = $j
                ExitLoop
            EndIf
        Next
        If $n = + -1 Then Return SetError(0x3fe, $s, False)
        $imask = BitOR($imask, $AV[$n][$EMASK])
        $s = StringLeft($AS[$i], 0x1)
        Switch $s
        Case "+"
            If Not $AV[$n][$EINVERTED] Then
                $ieffects = BitOR($ieffects, $AV[$n][$EEFFECT])
            EndIf
        Case "-"
            If $AV[$n][$EINVERTED] Then
                $ieffects = BitOR($ieffects, $AV[$n][$EEFFECT])
            EndIf
        Case Else
            Return SetError(0x3fd, $s, False)
        EndSwitch
    Next
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, 0x1, DllStructGetSize($tparaformat))
    DllStructSetData($tparaformat, 0x2, $imask)
    DllStructSetData($tparaformat, 0x4, $ieffects)
    Return _SendMessage($hwnd, $EM_SETPARAFORMAT, 0x0, $tparaformat, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_SetParaAttributes

Func _GUICtrlRichEdit_SetParaBorder($hwnd, $slocation = Default, $vlinestyle = Default, $scolor = Default, $ispace = Default)
    Local $iborders
    Local Const $AVLOCS[0x6][0x2] = [["l", 0x1], ["r", 0x2], ["t", 0x4], ["b", 0x8], ["i", 0x10], ["o", 0x20]]
    Local Const $AVLS[0xc] = ["none", 0.75, 1.5, 2.25, 0x3, 4.5, 0x6, ".75d", "1.5d", "2.25d", ".75g", ".75gd"]
    Local Const $SCLRS = ";blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;aut;"
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not ($ispace = Default Or __GCR_IsNumeric($ispace, ">=0")) Then Return SetError(0x69, 0x0, False)
    If $slocation = '' Then
        $iborders = 0x0
        $ispace = 0x0
    Else
        If $slocation = Default Or $vlinestyle = Default Or $scolor = Default Or $ispace = Default Then
            Local $AS = StringSplit(_GUICtrlRichEdit_GetParaBorder($hwnd), ";")
            If $slocation = Default Then $slocation = $AS[0x1]
            If $vlinestyle = Default Then $vlinestyle = $AS[0x2]
            If $scolor = Default Then $scolor = $AS[0x3]
            If $ispace = Default Then $ispace = $AS[0x4]
        EndIf
        Local $iloc = 0x0, $n, $s
        For $i = 0x1 To StringLen($slocation)
            $s = StringMid($slocation, $i, 0x1)
            $n = + -1
            For $j = 0x0 To UBound($AVLOCS, $UBOUND_ROWS) + -1
                If $AVLOCS[$j][0x0] = $s Then
                    $n = $j
                    ExitLoop
                EndIf
            Next
            If $n = + -1 Then Return SetError(0x66, $s, False)
            $iloc = BitOR($iloc, $AVLOCS[$n][0x1])
        Next
        $n = + -1
        For $i = 0x0 To UBound($AVLS, $UBOUND_ROWS) + -1
            If $vlinestyle = $AVLS[$i] Then
                $n = $i
                ExitLoop
            EndIf
        Next
        If $n = + -1 Then Return SetError(0x67, 0x0, False)
        Local $ilinestyle = $n
        $n = StringInStr($SCLRS, ";" & $scolor & ";")
        If $n = 0x0 Then Return SetError(0x68, 0x0, False)
        Local $icolor = Int($n / 0x4)
        If $icolor = 0x10 Then
            $iloc = BitOR($iloc, 0x40)
            $icolor = 0x0
        EndIf
        $iborders = $iloc + BitShift($ilinestyle, + -8) + BitShift($icolor, + -12)
    EndIf
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, "cbSize", DllStructGetSize($tparaformat))
    DllStructSetData($tparaformat, "wBorderSpace", $ispace * $__g_irtftwipspespaceunit)
    DllStructSetData($tparaformat, "wBorders", $iborders)
    DllStructSetData($tparaformat, "dwMask", $PFM_BORDER)
    Return _SendMessage($hwnd, $EM_SETPARAFORMAT, 0x0, $tparaformat, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_SetParaBorder

Func _GUICtrlRichEdit_SetParaIndents($hwnd, $vleft = Default, $iright = Default, $ifirstline = Default)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not ($vleft = Default Or __GCR_IsNumeric($vleft)) Then Return SetError(0x3fd, 0x0, False)
    If Not ($iright = Default Or __GCR_IsNumeric($iright, ">=0")) Then Return SetError(0x67, 0x0, False)
    If Not ($ifirstline = Default Or __GCR_IsNumeric($ifirstline)) Then Return SetError(0x68, 0x0, False)
    Local $s = _GUICtrlRichEdit_GetParaIndents($hwnd)
    Local $AS = StringSplit($s, ";")
    If $vleft = Default Then $vleft = $AS[0x1]
    If $iright = Default Then $iright = $AS[0x2]
    If $ifirstline = Default Then $ifirstline = $AS[0x3]
    If $vleft < 0x0 Then Return SetError(0x3fe, 0x0, False)
    If $vleft + $ifirstline < 0x0 Then Return SetError(0xc8, 0x0, False)
    If StringInStr("+-", StringLeft($vleft, 0x1)) <> 0x0 Then $vleft = $AS[0x1] + $vleft
    Local $iidxsi = $vleft + $ifirstline
    Local $iidxofs = - $ifirstline
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT)
    DllStructSetData($tparaformat, 0x1, DllStructGetSize($tparaformat))
    DllStructSetData($tparaformat, "dxStartIndent", $iidxsi * $__g_irtftwipspespaceunit)
    DllStructSetData($tparaformat, "dxOffset", $iidxofs * $__g_irtftwipspespaceunit)
    DllStructSetData($tparaformat, "dxRightIndent", $iright * $__g_irtftwipspespaceunit)
    DllStructSetData($tparaformat, 0x2, BitOR($PFM_STARTINDENT, $PFM_OFFSET, $PFM_RIGHTINDENT))
    Local $iret = _SendMessage($hwnd, $EM_SETPARAFORMAT, 0x0, $tparaformat, 0x0, "wparam", "struct*")
    If Not $iret Then Return SetError(0x2bc, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetParaIndents

Func _GUICtrlRichEdit_SetParaNumbering($hwnd, $sstyle, $itexttonbrspace = Default, $bforceroman = False)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not ($itexttonbrspace = Default Or __GCR_IsNumeric($itexttonbrspace, ">0")) Then Return SetError(0x67, 0x0, False)
    If Not IsBool($bforceroman) Then Return SetError(0x68, 0x0, False)
    Local $ipfm, $iwnumbering, $iwnumstart, $iwnumstyle, $iqspaces
    __GCR_ParseParaNumberingStyle($sstyle, $bforceroman, $ipfm, $iwnumbering, $iwnumstart, $iwnumstyle, $iqspaces)
    If @error Then Return SetError(@error, 0x0, False)
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, 0x1, DllStructGetSize($tparaformat))
    If BitAND($ipfm, $PFM_NUMBERING) Then DllStructSetData($tparaformat, 0x3, $iwnumbering)
    If BitAND($ipfm, $PFM_NUMBERINGSTART) Then DllStructSetData($tparaformat, 0x13, $iwnumstart)
    If BitAND($ipfm, $PFM_NUMBERINGSTYLE) Then DllStructSetData($tparaformat, 0x14, $iwnumstyle)
    If BitAND($ipfm, $PFM_NUMBERINGTAB) Then
        Local $itwips
        If $itexttonbrspace = Default Then
            Local $AV = _GUICtrlRichEdit_GetFont($hwnd)
            Local $ipoints = $AV[0x0]
            $itwips = $iqspaces * $ipoints * 0x14
        Else
            $itwips = $itexttonbrspace * $__g_irtftwipspespaceunit
        EndIf
        DllStructSetData($tparaformat, 0x15, $itwips)
    EndIf
    DllStructSetData($tparaformat, 0x2, $ipfm)
    Return _SendMessage($hwnd, $EM_SETPARAFORMAT, 0x0, $tparaformat, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_SetParaNumbering

Func _GUICtrlRichEdit_SetParaShading($hwnd, $iweight = Default, $sstyle = Default, $sforecolor = Default, $sbackcolor = Default)
    Local $is = 0x0
    Local Const $SSTYLES = ";non;dhz;dvt;ddd;dud;dgr;dtr;lhz;lrt;ldd;lud;lgr;ltr;"
    Local Const $SCLRS = ";blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;"
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not ($iweight = Default Or __GCR_IsNumeric($iweight, ">=0")) Then Return SetError(0x3fd, 0x0, False)
    If $iweight <> Default Or $sstyle <> Default Or $sforecolor <> Default Or $sbackcolor <> Default Then
        Local $AS = StringSplit(_GUICtrlRichEdit_GetParaShading($hwnd), ";")
        If $iweight = Default Then $iweight = $AS[0x1]
        If $sstyle = Default Then $sstyle = $AS[0x2]
        If $sforecolor = Default Then $sforecolor = $AS[0x3]
        If $sbackcolor = Default Then $sbackcolor = $AS[0x4]
    EndIf
    If $iweight < 0x0 Or $iweight > 0x64 Then Return SetError(0x3fe, 0x0, False)
    Local $in = StringInStr($SSTYLES, ";" & $sstyle & ";")
    If $in = 0x0 Then Return SetError(0x67, 0x0, False)
    Local $istyle = Int($in / 0x4)
    Local $ifore = BitShift(BitAND($is, 0xf0), 0x4)
    $in = StringInStr($SCLRS, ";" & $sforecolor & ";")
    If $in = 0x0 Then Return SetError(0x68, 0x0, False)
    $ifore = Int($in / 0x4)
    $in = StringInStr($SCLRS, ";" & $sbackcolor & ";")
    If $in = 0x0 Then Return SetError(0x69, 0x0, False)
    Local $iback = Int($in / 0x4)
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, "cbSize", DllStructGetSize($tparaformat))
    DllStructSetData($tparaformat, "wShadingWeight", $iweight)
    $in = $istyle + BitShift($ifore, + -4) + BitShift($iback, + -8)
    DllStructSetData($tparaformat, "wShadingStyle", $in)
    DllStructSetData($tparaformat, "dwMask", $PFM_SHADING)
    Local $iret = _SendMessage($hwnd, $EM_SETPARAFORMAT, 0x0, $tparaformat, 0x0, "wparam", "struct*")
    If Not $iret Then Return SetError(0x2bc, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetParaShading

Func _GUICtrlRichEdit_SetParaSpacing($hwnd, $vinter = Default, $ibefore = Default, $iafter = Default)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not ($ibefore = Default Or __GCR_IsNumeric($ibefore, ">=0")) Then Return SetError(0x67, 0x0, False)
    If Not ($iafter = Default Or __GCR_IsNumeric($iafter, ">=0")) Then Return SetError(0x68, 0x0, False)
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, "cbSize", DllStructGetSize($tparaformat))
    Local $imask = 0x0
    If $vinter <> Default Then
        $vinter = StringStripWS($vinter, $STR_STRIPALL)
        Local $ip = StringInStr($vinter, "line", $STR_NOCASESENSEBASIC)
        If $ip <> 0x0 Then
            $vinter = StringLeft($vinter, $ip + -1)
        EndIf
        If Not __GCR_IsNumeric($vinter, ">=0") Then Return SetError(0x3fd, 0x0, False)
        Local $irule, $ilnsp = 0x0
        If $ip <> 0x0 Then
            Switch $vinter
            Case 0x1
                $irule = 0x0
            Case 1.5
                $irule = 0x1
            Case 0x2
                $irule = 0x2
            Case Else
                If $vinter < 0x1 Then Return SetError(0x3fe, 0x0, False)
                $irule = 0x5
                $ilnsp = $vinter * 0x14
            EndSwitch
        Else
            $irule = 0x4
            $ilnsp = $vinter * $__g_irtftwipspespaceunit
        EndIf
        $imask = $PFM_LINESPACING
        DllStructSetData($tparaformat, "bLineSpacingRule", $irule)
        If $ilnsp <> 0x0 Then DllStructSetData($tparaformat, 0xd, $ilnsp)
    EndIf
    If $ibefore <> Default Then
        $imask = BitOR($imask, $PFM_SPACEBEFORE)
        DllStructSetData($tparaformat, "dySpaceBefore", $ibefore * $__g_irtftwipspespaceunit)
    EndIf
    If $iafter <> Default Then
        $imask = BitOR($imask, $PFM_SPACEAFTER)
        DllStructSetData($tparaformat, "dySpaceAfter", $iafter * $__g_irtftwipspespaceunit)
    EndIf
    If $imask <> 0x0 Then
        DllStructSetData($tparaformat, "dwMask", $imask)
        Return _SendMessage($hwnd, $EM_SETPARAFORMAT, 0x0, $tparaformat, 0x0, "wparam", "struct*") <> 0x0
    Else
        Return True
    EndIf
EndFunc    ; -> _GUICtrlRichEdit_SetParaSpacing

Func _GUICtrlRichEdit_SetParaTabStops($hwnd, $stabstops)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $tparaformat = DllStructCreate($TAGPARAFORMAT2)
    DllStructSetData($tparaformat, "cbSize", DllStructGetSize($tparaformat))
    If $stabstops = '' Then
        DllStructSetData($tparaformat, "cTabCount", 0x0)
    Else
        Local $astabs = StringSplit($stabstops, ";")
        If $astabs[0x0] > $MAX_TAB_STOPS Then Return SetError(0x3fd, 0x0, False)
        Local $asatab, $i, $s, $in, $ip
        For $itab = 0x1 To $astabs[0x0]
            $asatab = StringSplit($astabs[$itab], '')
            $i = 0x1
            While $i <= $asatab[0x0] And StringInStr("01234567890.", $asatab[$i]) <> 0x0
                $i += 0x1
            WEnd
            If $i = 0x1 Then Return SetError(0x3fd, $itab, False)
            $s = StringLeft($astabs[$itab], $i + -1)
            If Not __GCR_IsNumeric($s, ">=0") Then Return SetError(0x3fd, $itab, False)
            $in = $s * $__g_irtftwipspespaceunit
            If $i <= $asatab[0x0] Then
                $ip = StringInStr("lcrdb", $asatab[$i])
                If $ip = 0x0 Then Return SetError(0x3fe, $itab, False)
                $in = BitOR($in, BitShift($ip + -1, + -24))
            EndIf
            $i += 0x1
            If $i <= $asatab[0x0] Then
                $ip = StringInStr(" .-_t=", $asatab[$i])
                If $ip = 0x0 Then Return SetError(0x3ff, $itab, False)
                $in = BitOR($in, BitShift($ip + -1, + -28))
            EndIf
            DllStructSetData($tparaformat, "rgxTabs", $in, $itab)
        Next
        DllStructSetData($tparaformat, "cTabCount", $astabs[0x0])
    EndIf
    DllStructSetData($tparaformat, "dwMask", $PFM_TABSTOPS)
    Return _SendMessage($hwnd, $EM_SETPARAFORMAT, 0x0, $tparaformat, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_SetParaTabStops

Func _GUICtrlRichEdit_SetPasswordChar($hwnd, $sdisplaychar = "*")
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not IsString($sdisplaychar) Then SetError(0x66, 0x0, False)
    If $sdisplaychar = '' Then
        _SendMessage($hwnd, $EM_SETPASSWORDCHAR)
    Else
        _SendMessage($hwnd, $EM_SETPASSWORDCHAR, Asc($sdisplaychar))
    EndIf
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetPasswordChar

Func _GUICtrlRichEdit_SetReadOnly($hwnd, $bstate = True)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not IsBool($bstate) Then Return SetError(0x66, 0x0, False)
    Local $iret = _SendMessage($hwnd, $EM_SETREADONLY, $bstate)
    If $iret = 0x0 Then Return SetError(0x2bc, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetReadOnly

Func _GUICtrlRichEdit_SetScrollPos($hwnd, $ix, $iy)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not __GCR_IsNumeric($ix, ">=0") Then Return SetError(0x66, 0x0, False)
    If Not __GCR_IsNumeric($iy, ">=0") Then Return SetError(0x67, 0x0, False)
    Local $tpoint = DllStructCreate($TAGPOINT)
    DllStructSetData($tpoint, 0x1, $ix)
    DllStructSetData($tpoint, 0x2, $iy)
    Return _SendMessage($hwnd, $EM_SETSCROLLPOS, 0x0, $tpoint, 0x0, "wparam", "struct*") <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_SetScrollPos

Func _GUICtrlRichEdit_SetSel($hwnd, $ianchor, $iactive, $bhidesel = False)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not __GCR_IsNumeric($ianchor, ">=0,-1") Then Return SetError(0x66, 0x0, False)
    If Not __GCR_IsNumeric($iactive, ">=0,-1") Then Return SetError(0x67, 0x0, False)
    If Not IsBool($bhidesel) Then Return SetError(0x68, 0x0, False)
    _SendMessage($hwnd, $EM_SETSEL, $ianchor, $iactive)
    If $bhidesel Then _SendMessage($hwnd, $EM_HIDESELECTION, $bhidesel)
    _WinAPI_SetFocus($hwnd)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetSel

Func _GUICtrlRichEdit_SetSpaceUnit($sunit)
    Switch StringLower($sunit)
    Case "in"
        $__g_irtftwipspespaceunit = 0x5a0
    Case "cm"
        $__g_irtftwipspespaceunit = 0x237
    Case "mm"
        $__g_irtftwipspespaceunit = 56.7
    Case "pt"
        $__g_irtftwipspespaceunit = 0x14
    Case "tw"
        $__g_irtftwipspespaceunit = 0x1
    Case Else
        Return SetError(0x1, 0x0, False)
    EndSwitch
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetSpaceUnit

Func _GUICtrlRichEdit_SetText($hwnd, $stext)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $tsettext = DllStructCreate($TAGSETTEXTEX)
    DllStructSetData($tsettext, 0x1, $ST_DEFAULT)
    DllStructSetData($tsettext, 0x2, $CP_ACP)
    Local $iret
    If StringLeft($stext, 0x5) <> "{\\rtf" And StringLeft($stext, 0x5) <> "{urtf" Then
        DllStructSetData($tsettext, 0x2, $CP_UNICODE)
        $iret = _SendMessage($hwnd, $EM_SETTEXTEX, $tsettext, $stext, 0x0, "struct*", "wstr")
    Else
        $iret = _SendMessage($hwnd, $EM_SETTEXTEX, $tsettext, $stext, 0x0, "struct*", "STR")
    EndIf
    If Not $iret Then Return SetError(0x2bc, 0x0, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_SetText

Func _GUICtrlRichEdit_SetUndoLimit($hwnd, $ilimit)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    If Not __GCR_IsNumeric($ilimit, ">=0") Then Return SetError(0x66, 0x0, False)
    Return _SendMessage($hwnd, $EM_SETUNDOLIMIT, $ilimit) <> 0x0 Or $ilimit = 0x0
EndFunc    ; -> _GUICtrlRichEdit_SetUndoLimit

Func _GUICtrlRichEdit_StreamFromFile($hwnd, $sfilespec, $ifileencoding = Default)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $teditstream = DllStructCreate($TAGEDITSTREAM)
    DllStructSetData($teditstream, "pfnCallback", DllCallbackGetPtr($__g_pgrc_streamfromfilecallback))
    If $ifileencoding = Default Then $ifileencoding = $FO_READ
    Local $hfile = FileOpen($sfilespec, $FO_READ + $ifileencoding)
    If $hfile = + -1 Then Return SetError(0x3fd, 0x0, False)
    Local $sbuf = FileRead($hfile, 0x5)
    FileClose($hfile)
    $hfile = FileOpen($sfilespec, $FO_READ + $ifileencoding)
    DllStructSetData($teditstream, "dwCookie", $hfile)
    Local $wparam = ($sbuf == "{\\rtf" Or $sbuf == "{urtf") ? $SF_RTF  : $SF_TEXT
    $wparam = BitOR($wparam, $SFF_SELECTION)
    If Not _GUICtrlRichEdit_IsTextSelected($hwnd) Then
        _GUICtrlRichEdit_SetText($hwnd, '')
    EndIf
    Local $iqchs = _SendMessage($hwnd, $EM_STREAMIN, $wparam, $teditstream, 0x0, "wparam", "struct*")
    FileClose($hfile)
    Local $ierror = DllStructGetData($teditstream, "dwError")
    If $ierror <> 0x0 Then Return SetError(0x2bc, $ierror, False)
    If $iqchs = 0x0 Then
        If FileGetSize($sfilespec) = 0x0 Then Return SetError(0x3fe, 0x0, False)
        Return SetError(0x2bc, $ierror, False)
    EndIf
    Return True
EndFunc    ; -> _GUICtrlRichEdit_StreamFromFile

Func _GUICtrlRichEdit_StreamFromVar($hwnd, $svar)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $teditstream = DllStructCreate($TAGEDITSTREAM)
    DllStructSetData($teditstream, "pfnCallback", DllCallbackGetPtr($__g_pgrc_streamfromvarcallback))
    $__g_pgrc_sstreamvar = $svar
    Local $s = StringLeft($svar, 0x5)
    Local $wparam = ($s == "{\\rtf" Or $s == "{urtf") ? $SF_RTF  : $SF_TEXT
    $wparam = BitOR($wparam, $SFF_SELECTION)
    If Not _GUICtrlRichEdit_IsTextSelected($hwnd) Then
        _GUICtrlRichEdit_SetText($hwnd, '')
    EndIf
    _SendMessage($hwnd, $EM_STREAMIN, $wparam, $teditstream, 0x0, "wparam", "struct*")
    Local $ierror = DllStructGetData($teditstream, "dwError")
    If $ierror <> 0x0 Then Return SetError(0x2bc, $ierror, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_StreamFromVar

Func _GUICtrlRichEdit_StreamToFile($hwnd, $sfilespec, $bincludecom = True, $iopts = 0x0, $icodepage = 0x0, $ifileencoding = Default)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Local $wparam
    If StringRight($sfilespec, 0x4) = ".rtf" Then
        $wparam = ($bincludecom  ? $SF_RTF  : $SF_RTFNOOBJS)
    Else
        $wparam = ($bincludecom  ? $SF_TEXTIZED  : $SF_TEXT)
        If BitAND($iopts, $SFF_PLAINRTF) Then Return SetError(0x411, 0x0, False)
    EndIf
    If BitAND($iopts, BitNOT(BitOR($SFF_PLAINRTF, $SF_UNICODE))) Then Return SetError(0x412, 0x0, False)
    If BitAND($iopts, $SF_UNICODE) Then
        If Not BitAND($wparam, $SF_TEXT) Then Return SetError(0x413, 0x0, False)
    EndIf
    If _GUICtrlRichEdit_IsTextSelected($hwnd) Then $wparam = BitOR($wparam, $SFF_SELECTION)
    $wparam = BitOR($wparam, $iopts)
    If $icodepage <> 0x0 Then
        $wparam = BitOR($wparam, $SF_USECODEPAGE, BitShift($icodepage, + -16))
    EndIf
    Local $teditstream = DllStructCreate($TAGEDITSTREAM)
    DllStructSetData($teditstream, "pfnCallback", DllCallbackGetPtr($__g_pgrc_streamtofilecallback))
    If $ifileencoding = Default Then $ifileencoding = $FO_READ
    Local $hfile = FileOpen($sfilespec, $FO_OVERWRITE + $ifileencoding)
    If $hfile = + -1 Then Return SetError(0x66, 0x0, False)
    DllStructSetData($teditstream, "dwCookie", $hfile)
    _SendMessage($hwnd, $EM_STREAMOUT, $wparam, $teditstream, 0x0, "wparam", "struct*")
    FileClose($hfile)
    Local $ierror = DllStructGetData($teditstream, "dwError")
    If $ierror <> 0x0 Then Return SetError(0x2bc, $ierror, False)
    Return True
EndFunc    ; -> _GUICtrlRichEdit_StreamToFile

Func _GUICtrlRichEdit_StreamToVar($hwnd, $brtf = True, $bincludecom = True, $iopts = 0x0, $icodepage = 0x0)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, '')
    Local $wparam
    If $brtf Then
        $wparam = ($bincludecom  ? $SF_RTF  : $SF_RTFNOOBJS)
    Else
        $wparam = ($bincludecom  ? $SF_TEXTIZED  : $SF_TEXT)
        If BitAND($iopts, $SFF_PLAINRTF) Then Return SetError(0x411, 0x0, '')
    EndIf
    If BitAND($iopts, BitNOT(BitOR($SFF_PLAINRTF, $SF_UNICODE))) Then Return SetError(0x412, 0x0, '')
    If BitAND($iopts, $SF_UNICODE) Then
        If Not BitAND($wparam, $SF_TEXT) Then Return SetError(0x413, 0x0, '')
    EndIf
    If _GUICtrlRichEdit_IsTextSelected($hwnd) Then $wparam = BitOR($wparam, $SFF_SELECTION)
    $wparam = BitOR($wparam, $iopts)
    If $icodepage <> 0x0 Then
        $wparam = BitOR($wparam, $SF_USECODEPAGE, BitShift($icodepage, + -16))
    EndIf
    Local $teditstream = DllStructCreate($TAGEDITSTREAM)
    DllStructSetData($teditstream, "pfnCallback", DllCallbackGetPtr($__g_pgrc_streamtovarcallback))
    $__g_pgrc_sstreamvar = ''
    _SendMessage($hwnd, $EM_STREAMOUT, $wparam, $teditstream, 0x0, "wparam", "struct*")
    Local $ierror = DllStructGetData($teditstream, "dwError")
    If $ierror <> 0x0 Then Return SetError(0x2bc, $ierror, '')
    Return $__g_pgrc_sstreamvar
EndFunc    ; -> _GUICtrlRichEdit_StreamToVar

Func _GUICtrlRichEdit_Undo($hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__g_srtfclassname) Then Return SetError(0x65, 0x0, False)
    Return _SendMessage($hwnd, $EM_UNDO, 0x0, 0x0) <> 0x0
EndFunc    ; -> _GUICtrlRichEdit_Undo

Func __GCR_Init()
    Local $ah_guictrlrtf_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "MSFTEDIT.DLL")
    If $ah_guictrlrtf_lib[0x0] <> 0x0 Then
        $__g_srtfclassname = "RichEdit50W"
        $__g_srtfversion = 4.1
    Else
        $ah_guictrlrtf_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "RICHED20.DLL")
        $__g_srtfversion = FileGetVersion(@SystemDir & "\\riched20.dll", "ProductVersion")
        Switch $__g_srtfversion
        Case 3
            $__g_srtfclassname = "RichEdit20W"
        Case 5
            $__g_srtfclassname = "RichEdit50W"
        Case 6
            $__g_srtfclassname = "RichEdit60W"
        EndSwitch
    EndIf
    $__g_sgre_cf_rtf = _ClipBoard_RegisterFormat("Rich Text Format")
    $__g_sgre_cf_retextobj = _ClipBoard_RegisterFormat("Rich Text Format with Objects")
EndFunc    ; -> __GCR_Init

Func __GCR_StreamFromFileCallback($hfile, $pbuf, $ibuflen, $pqbytes)
    Local $tqbytes = DllStructCreate("long", $pqbytes)
    DllStructSetData($tqbytes, 0x1, 0x0)
    Local $tbuf = DllStructCreate("char[" & $ibuflen & "]", $pbuf)
    Local $sbuf = FileRead($hfile, $ibuflen + -1)
    If @error Then Return 0x1
    DllStructSetData($tbuf, 0x1, $sbuf)
    DllStructSetData($tqbytes, 0x1, StringLen($sbuf))
    Return 0x0
EndFunc    ; -> __GCR_StreamFromFileCallback

Func __GCR_StreamFromVarCallback($icookie, $pbuf, $ibuflen, $pqbytes)
    #forceref $iCookie
    Local $tqbytes = DllStructCreate("long", $pqbytes)
    DllStructSetData($tqbytes, 0x1, 0x0)
    Local $tctl = DllStructCreate("char[" & $ibuflen & "]", $pbuf)
    Local $sctl = StringLeft($__g_pgrc_sstreamvar, $ibuflen + -1)
    If $sctl = '' Then Return 0x1
    DllStructSetData($tctl, 0x1, $sctl)
    Local $ilen = StringLen($sctl)
    DllStructSetData($tqbytes, 0x1, $ilen)
    $__g_pgrc_sstreamvar = StringMid($__g_pgrc_sstreamvar, $ilen + 0x1)
    Return 0x0
EndFunc    ; -> __GCR_StreamFromVarCallback

Func __GCR_StreamToFileCallback($hfile, $pbuf, $ibuflen, $pqbytes)
    Local $tqbytes = DllStructCreate("long", $pqbytes)
    DllStructSetData($tqbytes, 0x1, 0x0)
    Local $tbuf = DllStructCreate("char[" & $ibuflen & "]", $pbuf)
    Local $s = DllStructGetData($tbuf, 0x1)
    FileWrite($hfile, $s)
    DllStructSetData($tqbytes, 0x1, StringLen($s))
    Return 0x0
EndFunc    ; -> __GCR_StreamToFileCallback

Func __GCR_StreamToVarCallback($icookie, $pbuf, $ibuflen, $pqbytes)
    #forceref $iCookie
    Local $tqbytes = DllStructCreate("long", $pqbytes)
    DllStructSetData($tqbytes, 0x1, 0x0)
    Local $tbuf = DllStructCreate("char[" & $ibuflen & "]", $pbuf)
    Local $s = DllStructGetData($tbuf, 0x1)
    $__g_pgrc_sstreamvar &= $s
    DllStructSetData($tqbytes, 0x1, StringLen($s))
    Return 0x0
EndFunc    ; -> __GCR_StreamToVarCallback

Func __GCR_ConvertTwipsToSpaceUnit($nin)
    Local $sret
    Switch $__g_irtftwipspespaceunit
    Case 0x5a0, 0x237
        $sret = StringFormat("%.2f", $nin / $__g_irtftwipspespaceunit)
        If $sret = "-0.00" Then $sret = "0.00"
    Case 56.7, 0x48
        $sret = StringFormat("%.1f", $nin / $__g_irtftwipspespaceunit)
        If $sret = "-0.0" Then $sret = "0.0"
    Case Else
        $sret = $nin
    EndSwitch
    Return $sret
EndFunc    ; -> __GCR_ConvertTwipsToSpaceUnit

Func __GCR_IsNumeric($vn, $srange = '')
    If Not (IsNumber($vn) Or StringIsInt($vn) Or StringIsFloat($vn)) Then Return False
    Switch $srange
    Case ">0"
        If $vn <= 0x0 Then Return False
    Case ">=0"
        If $vn < 0x0 Then Return False
    Case ">0,-1"
        If Not ($vn > 0x0 Or $vn = + -1) Then Return False
    Case ">=0,-1"
        If Not ($vn >= 0x0 Or $vn = + -1) Then Return False
    EndSwitch
    Return True
EndFunc    ; -> __GCR_IsNumeric

Func __GCR_GetParaScopeChar($hwnd, $imask, $ipfm)
    If Not _GUICtrlRichEdit_IsTextSelected($hwnd) Then
        Return "c"
    ElseIf BitAND($imask, $ipfm) = $ipfm Then
        Return "a"
    Else
        Return "f"
    EndIf
EndFunc    ; -> __GCR_GetParaScopeChar

Func __GCR_ParseParaNumberingStyle($sin, $bforceroman, ByRef $ipfm, ByRef $iwnumbering, ByRef $iwnumstart, ByRef $iwnumstyle, ByRef $iqspaces)
    Local Const $SROMAN = "mdclxviMDCLXVI", $IRPAR = 0x0, $I2PAR = 0x100, $IPERIOD = 0x200, $INBRONLY = 0x300
    If $sin = '' Then
        $iwnumbering = 0x0
        $ipfm = $PFM_NUMBERING
    Else
        Local $s = StringStripWS($sin, $STR_STRIPTRAILING)
        $iqspaces = StringLen($sin) - StringLen($s)
        $sin = $s
        $ipfm = $PFM_NUMBERINGTAB
        If $sin = "." Then
            $iwnumbering = $PFN_BULLET
            $ipfm = BitOR($ipfm, $PFM_NUMBERING)
        ElseIf $sin = "=" Then
            $iwnumstyle = 0x400
            $ipfm = BitOR($ipfm, $PFM_NUMBERINGSTYLE)
        Else
            Switch StringRight($sin, 0x1)
            Case ")"
                If StringLeft($sin, 0x1) = "(" Then
                    $iwnumstyle = $I2PAR
                    $sin = StringTrimLeft($sin, 0x1)
                Else
                    $iwnumstyle = $IRPAR
                EndIf
            Case "."
                $iwnumstyle = $IPERIOD
            Case Else
                $iwnumstyle = $INBRONLY
            EndSwitch
            $ipfm = BitOR($ipfm, $PFM_NUMBERINGSTYLE)
            If $iwnumstyle <> 0x300 Then $sin = StringTrimRight($sin, 0x1)
            If StringIsDigit($sin) Then
                $iwnumstart = Number($sin)
                $iwnumbering = 0x2
                $ipfm = BitOR($ipfm, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
            Else
                Local $bmayberoman = True
                For $i = 0x1 To StringLen($sin)
                    If Not StringInStr($SROMAN, StringMid($sin, $i, 0x1)) Then
                        $bmayberoman = False
                        ExitLoop
                    EndIf
                Next
                Local $bisroman
                If $bmayberoman Then
                    $bisroman = $bforceroman
                Else
                    $bisroman = False
                EndIf
                Switch True
                Case $bisroman
                    $iwnumstart = __GCR_ConvertRomanToNumber($sin)
                    If $iwnumstart = + -1 Then Return SetError(0x66, 0x0, False)
                    $iwnumbering = (StringIsLower($sin) ? 0x5  : 0x6)
                    $ipfm = BitOR($ipfm, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
                Case StringIsAlpha($sin)
                    If StringIsLower($sin) Then
                        $iwnumbering = 0x3
                    Else
                        $iwnumbering = 0x4
                        $sin = StringLower($sin)
                    EndIf
                    $iwnumstart = 0x0
                    Local $in
                    For $ip = 0x1 To StringLen($sin)
                        $in = Asc(StringMid($sin, $i))
                        If $in >= Asc("a") And $in <= Asc("z") Then
                            $iwnumstart = $iwnumstart * 0x1a + ($in - Asc("a") + 0x1)
                        EndIf
                    Next
                    $ipfm = BitOR($ipfm, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
                Case Else
                    Return SetError(0x66, 0x0, False)
                EndSwitch
            EndIf
        EndIf
    EndIf
    Return True
EndFunc    ; -> __GCR_ParseParaNumberingStyle

Func __GCR_ConvertRomanToNumber($srnum)
    Local Enum $E9, $E5, $E4, $E1, $EMULT, $EHIGHER
    Local Const $AV[0x3][0x6] = [["cm", "d", "cd", "c", 0x64, "m"], ["xc", "l", "xl", "x", 0xa, "mdc"], ["ix", "v", "iv", "i", 0x1, "mdclx"]]
    $srnum = StringLower($srnum)
    Local $i = 0x1
    While StringMid($srnum, $i, 0x1) = "m"
        $i += 0x1
    WEnd
    Local $idigit, $iq1s, $iret = ($i + -1) * 0x3e8
    For $j = 0x0 To 0x2
        $idigit = 0x0
        If StringMid($srnum, $i, 0x2) = $AV[$j][$E9] Then
            $idigit = 0x9
            $i += 0x2
        ElseIf StringMid($srnum, $i, 0x1) = $AV[$j][$E5] Then
            $idigit = 0x5
            $i += 0x1
        ElseIf StringMid($srnum, $i, 0x2) = $AV[$j][$E4] Then
            $idigit = 0x4
            $i += 0x2
        ElseIf StringInStr($AV[$j][$EHIGHER], StringMid($srnum, $i, 0x1)) Then
            Return + -1
        EndIf
        If $idigit = 0x0 Or $idigit = 0x5 Then
            $iq1s = 0x0
            While StringMid($srnum, $i, 0x1) = $AV[$j][$E1]
                $iq1s += 0x1
                If $iq1s > 0x3 Then Return 0x0
                $i += 0x1
            WEnd
            $idigit += $iq1s
        EndIf
        $iret += $idigit * $AV[$j][$EMULT]
    Next
    If $i <= StringLen($srnum) Then Return + -1
    Return $iret
EndFunc    ; -> __GCR_ConvertRomanToNumber

Func __GCR_SendGetCharFormatMessage($hwnd, $tcharformat)
    Return _SendMessage($hwnd, $EM_GETCHARFORMAT, $SCF_SELECTION, $tcharformat, 0x0, "wparam", "struct*")
EndFunc    ; -> __GCR_SendGetCharFormatMessage

Func __GCR_SendGetParaFormatMessage($hwnd, $tparaformat)
    Local $bissel = _GUICtrlRichEdit_IsTextSelected($hwnd)
    Local $iinspt = 0x0
    If Not $bissel Then
        Local $AS = _GUICtrlRichEdit_GetSel($hwnd)
        $iinspt = $AS[0x0]
        Local $in = _GUICtrlRichEdit_GetFirstCharPosOnLine($hwnd)
        _GUICtrlRichEdit_SetSel($hwnd, $in, $in + 0x1, True)
    EndIf
    _SendMessage($hwnd, $EM_GETPARAFORMAT, 0x0, $tparaformat, 0x0, "wparam", "struct*")
    If @error Then Return SetError(@error, @extended, False)
    If Not $bissel Then _GUICtrlRichEdit_SetSel($hwnd, $iinspt, $iinspt)
    Return True
EndFunc    ; -> __GCR_SendGetParaFormatMessage

Func __GCR_SetOLECallback($hwnd)
    If Not IsHWnd($hwnd) Then Return SetError(0x65, 0x0, False)
    If Not $__g_pobj_richcom Then
        $__g_tcall_richcom = DllStructCreate("ptr[20]")
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_queryinterface), 0x1)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_addref), 0x2)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_release), 0x3)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_getnewstorage), 0x4)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_getinplacecontext), 0x5)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_showcontainerui), 0x6)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_queryinsertobject), 0x7)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_deleteobject), 0x8)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_queryacceptdata), 0x9)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_contextsensitivehelp), 0xa)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_getclipboarddata), 0xb)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_getdragdropeffect), 0xc)
        DllStructSetData($__g_tcall_richcom, 0x1, DllCallbackGetPtr($__g_prichcom_object_getcontextmenu), 0xd)
        DllStructSetData($__g_tobj_richcomobject, 0x1, DllStructGetPtr($__g_tcall_richcom))
        DllStructSetData($__g_tobj_richcomobject, 0x2, 0x1)
        $__g_pobj_richcom = DllStructGetPtr($__g_tobj_richcomobject)
    EndIf
    Local Const $EM_SETOLECALLBACK = 0x400 + 0x46
    If _SendMessage($hwnd, $EM_SETOLECALLBACK, 0x0, $__g_pobj_richcom) = 0x0 Then Return SetError(0x2bc, 0x0, False)
    Return True
EndFunc    ; -> __GCR_SetOLECallback

Func __RichCom_Object_QueryInterface($pobject, $irefiid, $ppvobj)
    #forceref $pObject, $iREFIID, $pPvObj
    Return $_GCR_S_OK
EndFunc    ; -> __RichCom_Object_QueryInterface

Func __RichCom_Object_AddRef($pobject)
    Local $tdata = DllStructCreate("ptr;dword", $pobject)
    DllStructSetData($tdata, 0x2, DllStructGetData($tdata, 0x2) + 0x1)
    Return DllStructGetData($tdata, 0x2)
EndFunc    ; -> __RichCom_Object_AddRef

Func __RichCom_Object_Release($pobject)
    Local $tdata = DllStructCreate("ptr;dword", $pobject)
    If DllStructGetData($tdata, 0x2) > 0x0 Then
        DllStructSetData($tdata, 0x2, DllStructGetData($tdata, 0x2) + -1)
        Return DllStructGetData($tdata, 0x2)
    EndIf
EndFunc    ; -> __RichCom_Object_Release

Func __RichCom_Object_GetInPlaceContext($pobject, $ppframe, $ppdoc, $pframeinfo)
    #forceref $pObject, $pPFrame, $pPDoc, $pFrameInfo
    Return $_GCR_E_NOTIMPL
EndFunc    ; -> __RichCom_Object_GetInPlaceContext

Func __RichCom_Object_ShowContainerUI($pobject, $bshow)
    #forceref $pObject, $bShow
    Return $_GCR_E_NOTIMPL
EndFunc    ; -> __RichCom_Object_ShowContainerUI

Func __RichCom_Object_QueryInsertObject($pobject, $pclsid, $tstg, $vcp)
    #forceref $pObject, $pClsid, $tStg, $vCp
    Return $_GCR_S_OK
EndFunc    ; -> __RichCom_Object_QueryInsertObject

Func __RichCom_Object_DeleteObject($pobject, $poleobj)
    #forceref $pObject, $pOleobj
    Return $_GCR_E_NOTIMPL
EndFunc    ; -> __RichCom_Object_DeleteObject

Func __RichCom_Object_QueryAcceptData($pobject, $pdataobj, $pcfformat, $vreco, $breally, $hmetapict)
    #forceref $pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict
    Return $_GCR_S_OK
EndFunc    ; -> __RichCom_Object_QueryAcceptData

Func __RichCom_Object_ContextSensitiveHelp($pobject, $bentermode)
    #forceref $pObject, $bEnterMode
    Return $_GCR_E_NOTIMPL
EndFunc    ; -> __RichCom_Object_ContextSensitiveHelp

Func __RichCom_Object_GetClipboardData($pobject, $pchrg, $vreco, $ppdataobj)
    #forceref $pObject, $pChrg, $vReco, $pPdataobj
    Return $_GCR_E_NOTIMPL
EndFunc    ; -> __RichCom_Object_GetClipboardData

Func __RichCom_Object_GetDragDropEffect($pobject, $bdrag, $igrfkeystate, $pieffect)
    #forceref $pObject, $bDrag, $iGrfKeyState, $piEffect
    Return $_GCR_E_NOTIMPL
EndFunc    ; -> __RichCom_Object_GetDragDropEffect

Func __RichCom_Object_GetContextMenu($pobject, $iseltype, $poleobj, $pchrg, $phmenu)
    #forceref $pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu
    Return $_GCR_E_NOTIMPL
EndFunc    ; -> __RichCom_Object_GetContextMenu

Func __RichCom_Object_GetNewStorage($pobject, $ppstg)
    #forceref $pObject
    Local $asc = DllCall($__g_hlib_richcom_ole32, "dword", "CreateILockBytesOnHGlobal", "hwnd", 0x0, "int", 0x1, "ptr*", 0x0)
    Local $plockbytes = $asc[0x3]
    $asc = $asc[0x0]
    If $asc Then Return $asc
    $asc = DllCall($__g_hlib_richcom_ole32, "dword", "StgCreateDocfileOnILockBytes", "ptr", $plockbytes, "dword", BitOR(0x10, 0x2, 0x1000), "dword", 0x0, "ptr*", 0x0)
    Local $tstg = DllStructCreate("ptr", $ppstg)
    DllStructSetData($tstg, 0x1, $asc[0x4])
    $asc = $asc[0x0]
    If $asc Then
        Local $tobj = DllStructCreate("ptr", $plockbytes)
        Local $tunknownfunctable = DllStructCreate("ptr[3]", DllStructGetData($tobj, 0x1))
        Local $preleasefunc = DllStructGetData($tunknownfunctable, 0x3)
        DllCallAddress("long", $preleasefunc, "ptr", $plockbytes)
    EndIf
    Return $asc
EndFunc    ; -> __RichCom_Object_GetNewStorage

Global Const $SIF_POS = 0x4
Global Const $SIF_PAGE = 0x2
Global Const $SIF_RANGE = 0x1
Global Const $SIF_TRACKPOS = 0x10
Global Const $SIF_ALL = BitOR($SIF_RANGE, $SIF_PAGE, $SIF_POS, $SIF_TRACKPOS)
Global Const $SB_HORZ = 0x0
Global Const $SB_VERT = 0x1
Global Const $SB_CTL = 0x2
Global Const $SB_BOTH = 0x3
Global Const $SB_LINELEFT = 0x0
Global Const $SB_LINERIGHT = 0x1
Global Const $SB_PAGELEFT = 0x2
Global Const $SB_PAGERIGHT = 0x3
Global Const $SB_THUMBPOSITION = 0x4
Global Const $SB_THUMBTRACK = 0x5
Global Const $SB_LINEDOWN = 0x1
Global Const $SB_LINEUP = 0x0
Global Const $SB_PAGEDOWN = 0x3
Global Const $SB_PAGEUP = 0x2
Global Const $SB_SCROLLCARET = 0x4
Global Const $SB_TOP = 0x6
Global Const $SB_BOTTOM = 0x7
Global Const $ESB_DISABLE_BOTH = 0x3
Global Const $ESB_DISABLE_DOWN = 0x2
Global Const $ESB_DISABLE_LEFT = 0x1
Global Const $ESB_DISABLE_LTUP = $ESB_DISABLE_LEFT
Global Const $ESB_DISABLE_RIGHT = 0x2
Global Const $ESB_DISABLE_RTDN = $ESB_DISABLE_RIGHT
Global Const $ESB_DISABLE_UP = 0x1
Global Const $ESB_ENABLE_BOTH = 0x0
Global Const $OBJID_HSCROLL = -6
Global Const $OBJID_VSCROLL = -5
Global Const $OBJID_CLIENT = -4
Global $__g_asb_windowinfo[0x1][0x8]
Func _GUIScrollBars_EnableScrollBar($hwnd, $isbflags = $SB_BOTH, $iarrows = $ESB_ENABLE_BOTH)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, False)
    Local $acall = DllCall("user32.dll", "bool", "EnableScrollBar", "hwnd", $hwnd, "uint", $isbflags, "uint", $iarrows)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUIScrollBars_EnableScrollBar

Func _GUIScrollBars_GetScrollBarInfoEx($hwnd, $iobject)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, 0x0)
    Local $tscrollbarinfo = DllStructCreate($TAGSCROLLBARINFO)
    DllStructSetData($tscrollbarinfo, "cbSize", DllStructGetSize($tscrollbarinfo))
    Local $acall = DllCall("user32.dll", "bool", "GetScrollBarInfo", "hwnd", $hwnd, "long", $iobject, "struct*", $tscrollbarinfo)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $tscrollbarinfo)
EndFunc    ; -> _GUIScrollBars_GetScrollBarInfoEx

Func _GUIScrollBars_GetScrollBarRect($hwnd, $iobject)
    Local $arect[0x4]
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, 0x0)
    Local $tscrollbarinfo = _GUIScrollBars_GetScrollBarInfoEx($hwnd, $iobject)
    If @error Then Return SetError(@error, @extended, 0x0)
    $arect[0x0] = DllStructGetData($tscrollbarinfo, "Left")
    $arect[0x1] = DllStructGetData($tscrollbarinfo, "Top")
    $arect[0x2] = DllStructGetData($tscrollbarinfo, "Right")
    $arect[0x3] = DllStructGetData($tscrollbarinfo, "Bottom")
    Return $arect
EndFunc    ; -> _GUIScrollBars_GetScrollBarRect

Func _GUIScrollBars_GetScrollBarRGState($hwnd, $iobject)
    Local $argstate[0x6]
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, 0x0)
    Local $tscrollbarinfo = _GUIScrollBars_GetScrollBarInfoEx($hwnd, $iobject)
    If @error Then Return SetError(@error, @extended, 0x0)
    For $x = 0x0 To 0x5
        $argstate[$x] = DllStructGetData($tscrollbarinfo, "rgstate", $x + 0x1)
    Next
    Return $argstate
EndFunc    ; -> _GUIScrollBars_GetScrollBarRGState

Func _GUIScrollBars_GetScrollBarXYLineButton($hwnd, $iobject)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    Local $tscrollbarinfo = _GUIScrollBars_GetScrollBarInfoEx($hwnd, $iobject)
    If @error Then Return SetError(@error, @extended, + -1)
    Return DllStructGetData($tscrollbarinfo, "dxyLineButton")
EndFunc    ; -> _GUIScrollBars_GetScrollBarXYLineButton

Func _GUIScrollBars_GetScrollBarXYThumbTop($hwnd, $iobject)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    Local $tscrollbarinfo = _GUIScrollBars_GetScrollBarInfoEx($hwnd, $iobject)
    If @error Then Return SetError(@error, @extended, + -1)
    Return DllStructGetData($tscrollbarinfo, "xyThumbTop")
EndFunc    ; -> _GUIScrollBars_GetScrollBarXYThumbTop

Func _GUIScrollBars_GetScrollBarXYThumbBottom($hwnd, $iobject)
    If Not IsHWnd($hwnd) Then Return SetError(+ -1, + -1, + -1)
    Local $tscrollbarinfo = _GUIScrollBars_GetScrollBarInfoEx($hwnd, $iobject)
    If @error Then Return SetError(+ -1, + -1, + -1)
    Return DllStructGetData($tscrollbarinfo, "xyThumbBottom")
EndFunc    ; -> _GUIScrollBars_GetScrollBarXYThumbBottom

Func _GUIScrollBars_GetScrollInfo($hwnd, $ibar, ByRef $tscrollinfo)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, False)
    Local $acall = DllCall("user32.dll", "bool", "GetScrollInfo", "hwnd", $hwnd, "int", $ibar, "struct*", $tscrollinfo)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUIScrollBars_GetScrollInfo

Func _GUIScrollBars_GetScrollInfoEx($hwnd, $ibar)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, 0x0)
    Local $tscrollinfo = DllStructCreate($TAGSCROLLINFO)
    DllStructSetData($tscrollinfo, "cbSize", DllStructGetSize($tscrollinfo))
    DllStructSetData($tscrollinfo, "fMask", $SIF_ALL)
    If Not _GUIScrollBars_GetScrollInfo($hwnd, $ibar, $tscrollinfo) Then Return SetError(@error, @extended, 0x0)
    Return $tscrollinfo
EndFunc    ; -> _GUIScrollBars_GetScrollInfoEx

Func _GUIScrollBars_GetScrollInfoPage($hwnd, $ibar)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    Local $tscrollinfo = _GUIScrollBars_GetScrollInfoEx($hwnd, $ibar)
    If @error Then Return SetError(@error, @extended, + -1)
    Return DllStructGetData($tscrollinfo, "nPage")
EndFunc    ; -> _GUIScrollBars_GetScrollInfoPage

Func _GUIScrollBars_GetScrollInfoPos($hwnd, $ibar)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    Local $tscrollinfo = _GUIScrollBars_GetScrollInfoEx($hwnd, $ibar)
    If @error Then Return SetError(@error, @extended, + -1)
    Return DllStructGetData($tscrollinfo, "nPos")
EndFunc    ; -> _GUIScrollBars_GetScrollInfoPos

Func _GUIScrollBars_GetScrollInfoMin($hwnd, $ibar)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    Local $tscrollinfo = _GUIScrollBars_GetScrollInfoEx($hwnd, $ibar)
    If @error Then Return SetError(@error, @extended, + -1)
    Return DllStructGetData($tscrollinfo, "nMin")
EndFunc    ; -> _GUIScrollBars_GetScrollInfoMin

Func _GUIScrollBars_GetScrollInfoMax($hwnd, $ibar)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    Local $tscrollinfo = _GUIScrollBars_GetScrollInfoEx($hwnd, $ibar)
    If @error Then Return SetError(@error, @extended, + -1)
    Return DllStructGetData($tscrollinfo, "nMax")
EndFunc    ; -> _GUIScrollBars_GetScrollInfoMax

Func _GUIScrollBars_GetScrollInfoTrackPos($hwnd, $ibar)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    Local $tscrollinfo = _GUIScrollBars_GetScrollInfoEx($hwnd, $ibar)
    If @error Then Return SetError(@error, @extended, + -1)
    Return DllStructGetData($tscrollinfo, "nTrackPos")
EndFunc    ; -> _GUIScrollBars_GetScrollInfoTrackPos

Func _GUIScrollBars_GetScrollPos($hwnd, $ibar)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    Local $acall = DllCall("user32.dll", "int", "GetScrollPos", "hwnd", $hwnd, "int", $ibar)
    If @error Then Return SetError(@error, @extended, + -1)
    Return $acall[0x0]
EndFunc    ; -> _GUIScrollBars_GetScrollPos

Func _GUIScrollBars_GetScrollRange($hwnd, $ibar)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    Local $acall = DllCall("user32.dll", "bool", "GetScrollRange", "hwnd", $hwnd, "int", $ibar, "int*", 0x0, "int*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    Local $amin_max[0x2]
    $amin_max[0x0] = $acall[0x3]
    $amin_max[0x1] = $acall[0x4]
    Return SetExtended($acall[0x0], $amin_max)
EndFunc    ; -> _GUIScrollBars_GetScrollRange

Func _GUIScrollBars_Init($hwnd, $imaxh = + -1, $imaxv = + -1)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, 0x0)
    If $__g_asb_windowinfo[0x0][0x0] <> 0x0 Then ReDim $__g_asb_windowinfo[UBound($__g_asb_windowinfo) + 0x1][0x8]
    Local $tscrollinfo = DllStructCreate($TAGSCROLLINFO)
    Local $trect = DllStructCreate($TAGRECT)
    Local $iindex = UBound($__g_asb_windowinfo) + -1
    Local $ierror, $iextended
    $__g_asb_windowinfo[$iindex][0x0] = $hwnd
    $__g_asb_windowinfo[$iindex][0x1] = $imaxh
    $__g_asb_windowinfo[$iindex][0x6] = $imaxh
    $__g_asb_windowinfo[$iindex][0x7] = $imaxv
    If $imaxv = + -1 Then $__g_asb_windowinfo[$iindex][0x7] = 0x1b
    Local $hdc = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
    If @error Then Return SetError(@error, @extended)
    $hdc = $hdc[0x0]
    Local $ttextmetric = DllStructCreate($TAGTEXTMETRIC)
    DllStructSetData($tscrollinfo, "cbSize", DllStructGetSize($tscrollinfo))
    DllCall("gdi32.dll", "bool", "GetTextMetricsW", "handle", $hdc, "struct*", $ttextmetric)
    If @error Then
        $ierror = @error
        $iextended = @extended
    EndIf
    DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
    If $ierror Then Return SetError($ierror, $iextended)
    Local $iupperx, $ixamount = DllStructGetData($ttextmetric, "tmAveCharWidth")
    If BitAND(DllStructGetData($ttextmetric, "tmPitchAndFamily"), 0x1) Then
        $iupperx = 0x3 * $ixamount / 0x2
    Else
        $iupperx = 0x2 * $ixamount / 0x2
    EndIf
    Local $iyamount = DllStructGetData($ttextmetric, "tmHeight") + DllStructGetData($ttextmetric, "tmExternalLeading")
    If $imaxh = + -1 Then $__g_asb_windowinfo[$iindex][0x1] = 0x30 * $ixamount + 0xc * $iupperx
    $__g_asb_windowinfo[$iindex][0x2] = $ixamount
    $__g_asb_windowinfo[$iindex][0x3] = $iyamount
    _GUIScrollBars_ShowScrollBar($hwnd, $SB_HORZ, False)
    _GUIScrollBars_ShowScrollBar($hwnd, $SB_VERT, False)
    _GUIScrollBars_ShowScrollBar($hwnd, $SB_HORZ)
    _GUIScrollBars_ShowScrollBar($hwnd, $SB_VERT)
    DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hwnd, "struct*", $trect)
    If @error Then Return SetError(@error, @extended)
    Local $iclientx = DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
    Local $iclienty = DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top")
    $__g_asb_windowinfo[$iindex][0x4] = $iclientx
    $__g_asb_windowinfo[$iindex][0x5] = $iclienty
    $tscrollinfo = DllStructCreate($TAGSCROLLINFO)
    DllStructSetData($tscrollinfo, "fMask", BitOR($SIF_RANGE, $SIF_PAGE))
    DllStructSetData($tscrollinfo, "nMin", 0x0)
    DllStructSetData($tscrollinfo, "nMax", $__g_asb_windowinfo[$iindex][0x7])
    DllStructSetData($tscrollinfo, "nPage", $iclienty / $iyamount)
    _GUIScrollBars_SetScrollInfo($hwnd, $SB_VERT, $tscrollinfo)
    DllStructSetData($tscrollinfo, "fMask", BitOR($SIF_RANGE, $SIF_PAGE))
    DllStructSetData($tscrollinfo, "nMin", 0x0)
    DllStructSetData($tscrollinfo, "nMax", 0x2 + $__g_asb_windowinfo[$iindex][0x1] / $ixamount)
    DllStructSetData($tscrollinfo, "nPage", $iclientx / $ixamount)
    _GUIScrollBars_SetScrollInfo($hwnd, $SB_HORZ, $tscrollinfo)
EndFunc    ; -> _GUIScrollBars_Init

Func _GUIScrollBars_ScrollWindow($hwnd, $ixamount, $iyamount)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, False)
    Local $acall = DllCall("user32.dll", "bool", "ScrollWindow", "hwnd", $hwnd, "int", $ixamount, "int", $iyamount, "ptr", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUIScrollBars_ScrollWindow

Func _GUIScrollBars_SetScrollInfo($hwnd, $ibar, $tscrollinfo, $bredraw = True)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    DllStructSetData($tscrollinfo, "cbSize", DllStructGetSize($tscrollinfo))
    Local $acall = DllCall("user32.dll", "int", "SetScrollInfo", "hwnd", $hwnd, "int", $ibar, "struct*", $tscrollinfo, "bool", $bredraw)
    If @error Then Return SetError(@error, @extended, + -1)
    Return $acall[0x0]
EndFunc    ; -> _GUIScrollBars_SetScrollInfo

Func _GUIScrollBars_SetScrollInfoMin($hwnd, $ibar, $imin)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, False)
    Local $arange = _GUIScrollBars_GetScrollRange($hwnd, $ibar)
    _GUIScrollBars_SetScrollRange($hwnd, $ibar, $imin, $arange[0x1])
    Local $arange_check = _GUIScrollBars_GetScrollRange($hwnd, $ibar)
    If $arange[0x1] <> $arange_check[0x1] Or $imin <> $arange_check[0x0] Then
        _GUIScrollBars_SetScrollRange($hwnd, $ibar, $arange[0x0], $arange[0x1])
        Return False
    EndIf
    Return True
EndFunc    ; -> _GUIScrollBars_SetScrollInfoMin

Func _GUIScrollBars_SetScrollInfoMax($hwnd, $ibar, $imax)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, False)
    Local $arange = _GUIScrollBars_GetScrollRange($hwnd, $ibar)
    _GUIScrollBars_SetScrollRange($hwnd, $ibar, $arange[0x0], $imax)
    Local $arange_check = _GUIScrollBars_GetScrollRange($hwnd, $ibar)
    If $arange[0x0] <> $arange_check[0x0] Or $imax <> $arange_check[0x1] Then
        _GUIScrollBars_SetScrollRange($hwnd, $ibar, $arange[0x0], $arange[0x1])
        Return False
    EndIf
    Return True
EndFunc    ; -> _GUIScrollBars_SetScrollInfoMax

Func _GUIScrollBars_SetScrollInfoPage($hwnd, $ibar, $ipage)
    If Not IsHWnd($hwnd) Then Return SetError(+ -2, + -1, + -1)
    Local $tscrollinfo = DllStructCreate($TAGSCROLLINFO)
    DllStructSetData($tscrollinfo, "fMask", $SIF_PAGE)
    DllStructSetData($tscrollinfo, "nPage", $ipage)
    Return _GUIScrollBars_SetScrollInfo($hwnd, $ibar, $tscrollinfo)
EndFunc    ; -> _GUIScrollBars_SetScrollInfoPage

Func _GUIScrollBars_SetScrollInfoPos($hwnd, $ibar, $ipos)
    Local $iindex = + -1, $iyamount, $ixamount
    For $x = 0x0 To UBound($__g_asb_windowinfo) + -1
        If $__g_asb_windowinfo[$x][0x0] = $hwnd Then
            $iindex = $x
            $ixamount = $__g_asb_windowinfo[$iindex][0x2]
            $iyamount = $__g_asb_windowinfo[$iindex][0x3]
            ExitLoop
        EndIf
    Next
    If $iindex = + -1 Then Return 0x0
    Local $tscrollinfo = _GUIScrollBars_GetScrollInfoEx($hwnd, $ibar)
    Local $iposxy = DllStructGetData($tscrollinfo, "nPos")
    DllStructSetData($tscrollinfo, "fMask", $SIF_POS)
    DllStructSetData($tscrollinfo, "nPos", $ipos)
    _GUIScrollBars_SetScrollInfo($hwnd, $ibar, $tscrollinfo)
    _GUIScrollBars_GetScrollInfo($hwnd, $ibar, $tscrollinfo)
    $ipos = DllStructGetData($tscrollinfo, "nPos")
    If $ibar = $SB_HORZ Then
        If ($ipos <> $iposxy) Then _GUIScrollBars_ScrollWindow($hwnd, $ixamount * ($iposxy - $ipos), 0x0)
    Else
        If ($ipos <> $iposxy) Then _GUIScrollBars_ScrollWindow($hwnd, 0x0, $iyamount * ($iposxy - $ipos))
    EndIf
EndFunc    ; -> _GUIScrollBars_SetScrollInfoPos

Func _GUIScrollBars_SetScrollRange($hwnd, $ibar, $iminpos, $imaxpos)
    Local $acall = DllCall("user32.dll", "bool", "SetScrollRange", "hwnd", $hwnd, "int", $ibar, "int", $iminpos, "int", $imaxpos, "bool", True)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUIScrollBars_SetScrollRange

Func _GUIScrollBars_ShowScrollBar($hwnd, $ibar, $bshow = True)
    Local $acall = DllCall("user32.dll", "bool", "ShowScrollBar", "hwnd", $hwnd, "int", $ibar, "bool", $bshow)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _GUIScrollBars_ShowScrollBar

Global $__g_hslastwnd
Global Const $__SLIDERCONSTANT_CLASSNAME = "msctls_trackbar32"
Func _GUICtrlSlider_ClearSel($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_CLEARSEL, True)
EndFunc    ; -> _GUICtrlSlider_ClearSel

Func _GUICtrlSlider_ClearTics($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_CLEARTICS, True)
EndFunc    ; -> _GUICtrlSlider_ClearTics

Func _GUICtrlSlider_Create($hwnd, $ix, $iy, $iwidth = 0x64, $iheight = 0x14, $istyle = $TBS_AUTOTICKS, $iexstyle = 0x0)
    If Not IsHWnd($hwnd) Then Return SetError(0x1, 0x0, 0x0)
    If $iwidth = + -1 Then $iwidth = 0x64
    If $iheight = + -1 Then $iheight = 0x14
    If $istyle = + -1 Then $istyle = $TBS_AUTOTICKS
    If $iexstyle = + -1 Then $iexstyle = 0x0
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $hslider = _WinAPI_CreateWindowEx($iexstyle, $__SLIDERCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    _SendMessage($hslider, $TBM_SETRANGE, True, _WinAPI_MakeLong(0x0, 0x64))
    _GUICtrlSlider_SetTicFreq($hslider, 0x5)
    Return $hslider
EndFunc    ; -> _GUICtrlSlider_Create

Func _GUICtrlSlider_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__SLIDERCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hslastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlSlider_Destroy

Func _GUICtrlSlider_GetBuddy($hwnd, $blocation)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETBUDDY, $blocation, 0x0, 0x0, "wparam", "lparam", "hwnd")
EndFunc    ; -> _GUICtrlSlider_GetBuddy

Func _GUICtrlSlider_GetChannelRect($hwnd)
    Local $trect = _GUICtrlSlider_GetChannelRectEx($hwnd)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlSlider_GetChannelRect

Func _GUICtrlSlider_GetChannelRectEx($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $trect = DllStructCreate($TAGRECT)
    _SendMessage($hwnd, $TBM_GETCHANNELRECT, 0x0, $trect, 0x0, "wparam", "struct*")
    Return $trect
EndFunc    ; -> _GUICtrlSlider_GetChannelRectEx

Func _GUICtrlSlider_GetLineSize($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETLINESIZE)
EndFunc    ; -> _GUICtrlSlider_GetLineSize

Func _GUICtrlSlider_GetLogicalTics($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $iarraysize = _GUICtrlSlider_GetNumTics($hwnd) + -2
    Local $atics[$iarraysize]
    Local $parray = _SendMessage($hwnd, $TBM_GETPTICS)
    If @error Then Return SetError(@error, @extended, $atics)
    Local $tarray = DllStructCreate("dword[" & $iarraysize & "]", $parray)
    For $x = 0x1 To $iarraysize
        $atics[$x + -1] = _GUICtrlSlider_GetTicPos($hwnd, DllStructGetData($tarray, 0x1, $x))
    Next
    Return $atics
EndFunc    ; -> _GUICtrlSlider_GetLogicalTics

Func _GUICtrlSlider_GetNumTics($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETNUMTICS)
EndFunc    ; -> _GUICtrlSlider_GetNumTics

Func _GUICtrlSlider_GetPageSize($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETPAGESIZE)
EndFunc    ; -> _GUICtrlSlider_GetPageSize

Func _GUICtrlSlider_GetPos($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETPOS)
EndFunc    ; -> _GUICtrlSlider_GetPos

Func _GUICtrlSlider_GetRange($hwnd)
    Local $aminmax[0x2]
    $aminmax[0x0] = _GUICtrlSlider_GetRangeMin($hwnd)
    $aminmax[0x1] = _GUICtrlSlider_GetRangeMax($hwnd)
    Return $aminmax
EndFunc    ; -> _GUICtrlSlider_GetRange

Func _GUICtrlSlider_GetRangeMax($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETRANGEMAX)
EndFunc    ; -> _GUICtrlSlider_GetRangeMax

Func _GUICtrlSlider_GetRangeMin($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETRANGEMIN)
EndFunc    ; -> _GUICtrlSlider_GetRangeMin

Func _GUICtrlSlider_GetSel($hwnd)
    Local $aselstartend[0x2]
    $aselstartend[0x0] = _GUICtrlSlider_GetSelStart($hwnd)
    $aselstartend[0x1] = _GUICtrlSlider_GetSelEnd($hwnd)
    Return $aselstartend
EndFunc    ; -> _GUICtrlSlider_GetSel

Func _GUICtrlSlider_GetSelEnd($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETSELEND)
EndFunc    ; -> _GUICtrlSlider_GetSelEnd

Func _GUICtrlSlider_GetSelStart($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETSELSTART)
EndFunc    ; -> _GUICtrlSlider_GetSelStart

Func _GUICtrlSlider_GetThumbLength($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETTHUMBLENGTH)
EndFunc    ; -> _GUICtrlSlider_GetThumbLength

Func _GUICtrlSlider_GetThumbRect($hwnd)
    Local $trect = _GUICtrlSlider_GetThumbRectEx($hwnd)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlSlider_GetThumbRect

Func _GUICtrlSlider_GetThumbRectEx($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $trect = DllStructCreate($TAGRECT)
    _SendMessage($hwnd, $TBM_GETTHUMBRECT, 0x0, $trect, 0x0, "wparam", "struct*")
    Return $trect
EndFunc    ; -> _GUICtrlSlider_GetThumbRectEx

Func _GUICtrlSlider_GetTic($hwnd, $itic)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETTIC, $itic)
EndFunc    ; -> _GUICtrlSlider_GetTic

Func _GUICtrlSlider_GetTicPos($hwnd, $itic)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETTICPOS, $itic)
EndFunc    ; -> _GUICtrlSlider_GetTicPos

Func _GUICtrlSlider_GetToolTips($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETTOOLTIPS, 0x0, 0x0, 0x0, "wparam", "lparam", "hwnd")
EndFunc    ; -> _GUICtrlSlider_GetToolTips

Func _GUICtrlSlider_GetUnicodeFormat($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_GETUNICODEFORMAT) <> 0x0
EndFunc    ; -> _GUICtrlSlider_GetUnicodeFormat

Func _GUICtrlSlider_SetBuddy($hwnd, $blocation, $hbuddy)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If Not IsHWnd($hbuddy) Then $hbuddy = GUICtrlGetHandle($hbuddy)
    Return _SendMessage($hwnd, $TBM_SETBUDDY, $blocation, $hbuddy, 0x0, "wparam", "hwnd", "hwnd")
EndFunc    ; -> _GUICtrlSlider_SetBuddy

Func _GUICtrlSlider_SetLineSize($hwnd, $ilinesize)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_SETLINESIZE, 0x0, $ilinesize)
EndFunc    ; -> _GUICtrlSlider_SetLineSize

Func _GUICtrlSlider_SetPageSize($hwnd, $ipagesize)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_SETPAGESIZE, 0x0, $ipagesize)
EndFunc    ; -> _GUICtrlSlider_SetPageSize

Func _GUICtrlSlider_SetPos($hwnd, $iposition)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETPOS, True, $iposition)
EndFunc    ; -> _GUICtrlSlider_SetPos

Func _GUICtrlSlider_SetRange($hwnd, $iminimum, $imaximum)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETRANGE, True, _WinAPI_MakeLong($iminimum, $imaximum))
EndFunc    ; -> _GUICtrlSlider_SetRange

Func _GUICtrlSlider_SetRangeMax($hwnd, $imaximum)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETRANGEMAX, True, $imaximum)
EndFunc    ; -> _GUICtrlSlider_SetRangeMax

Func _GUICtrlSlider_SetRangeMin($hwnd, $iminimum)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETRANGEMIN, True, $iminimum)
EndFunc    ; -> _GUICtrlSlider_SetRangeMin

Func _GUICtrlSlider_SetSel($hwnd, $iminimum, $imaximum)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETSEL, True, _WinAPI_MakeLong($iminimum, $imaximum))
EndFunc    ; -> _GUICtrlSlider_SetSel

Func _GUICtrlSlider_SetSelEnd($hwnd, $imaximum)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETSELEND, True, $imaximum)
EndFunc    ; -> _GUICtrlSlider_SetSelEnd

Func _GUICtrlSlider_SetSelStart($hwnd, $iminimum)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETSELSTART, True, $iminimum)
EndFunc    ; -> _GUICtrlSlider_SetSelStart

Func _GUICtrlSlider_SetThumbLength($hwnd, $ilength)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETTHUMBLENGTH, $ilength)
EndFunc    ; -> _GUICtrlSlider_SetThumbLength

Func _GUICtrlSlider_SetTic($hwnd, $iposition)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETTIC, 0x0, $iposition)
EndFunc    ; -> _GUICtrlSlider_SetTic

Func _GUICtrlSlider_SetTicFreq($hwnd, $ifreg)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETTICFREQ, $ifreg)
EndFunc    ; -> _GUICtrlSlider_SetTicFreq

Func _GUICtrlSlider_SetTipSide($hwnd, $ilocation)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETTIPSIDE, $ilocation)
EndFunc    ; -> _GUICtrlSlider_SetTipSide

Func _GUICtrlSlider_SetToolTips($hwnd, $hwndtt)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TBM_SETTOOLTIPS, $hwndtt, 0x0, 0x0, "hwnd")
EndFunc    ; -> _GUICtrlSlider_SetToolTips

Func _GUICtrlSlider_SetUnicodeFormat($hwnd, $bunicode)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TBM_SETUNICODEFORMAT, $bunicode) <> 0x0
EndFunc    ; -> _GUICtrlSlider_SetUnicodeFormat

Global $__g_ttabbuffer, $__g_ttabbufferansi
Global Const $__TABCONSTANT_CLASSNAME = "SysTabControl32"
Global Const $__TABCONSTANT_WS_CLIPSIBLINGS = 0x4000000
Global Const $__TABCONSTANT_WM_NOTIFY = 0x4e
Global Const $__TABCONSTANT_DEFAULT_GUI_FONT = 0x11
Global Const $TAGTCITEM = "struct; uint Mask;dword State;dword StateMask;ptr Text;int TextMax;int Image;lparam Param; endstruct"
Global Const $TAGTCHITTESTINFO = "struct;" & $TAGPOINT & ";uint Flags; endstruct"
Func __GUICtrlTab_AdjustRect($hwnd, ByRef $trect, $blarger = False)
    If IsHWnd($hwnd) Then
        __guictrl_sendmsg($hwnd, $TCM_ADJUSTRECT, $blarger, $trect, 0x0, True)
    EndIf
EndFunc    ; -> __GUICtrlTab_AdjustRect

Func _GUICtrlTab_ActivateTab($hwnd, $iindex)
    Local $nindx
    If $hwnd = + -1 Then $hwnd = GUICtrlGetHandle(+ -1)
    If IsHWnd($hwnd) Then
        $nindx = _WinAPI_GetDlgCtrlID($hwnd)
    Else
        $nindx = $hwnd
        $hwnd = GUICtrlGetHandle($hwnd)
    EndIf
    Local $hparent = _WinAPI_GetParent($hwnd)
    If @error Then Return SetError(0x1, 0x0, + -1)
    Local $tnmhdr = DllStructCreate($tagnmhdr)
    DllStructSetData($tnmhdr, 0x1, $hwnd)
    DllStructSetData($tnmhdr, 0x2, $nindx)
    DllStructSetData($tnmhdr, 0x3, $TCN_SELCHANGING)
    _SendMessage($hparent, $__TABCONSTANT_WM_NOTIFY, $nindx, $tnmhdr, 0x0, "wparam", "struct*")
    Local $iret = _GUICtrlTab_SetCurSel($hwnd, $iindex)
    DllStructSetData($tnmhdr, 0x3, $TCN_SELCHANGE)
    _SendMessage($hparent, $__TABCONSTANT_WM_NOTIFY, $nindx, $tnmhdr, 0x0, "wparam", "struct*")
    Return $iret
EndFunc    ; -> _GUICtrlTab_ActivateTab

Func _GUICtrlTab_ClickTab($hwnd, $iindex, $sbutton = "left", $bmove = False, $iclicks = 0x1, $ispeed = 0x1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $ix, $iy
    If Not $bmove Then
        Local $hwinparent = _WinAPI_GetParent($hwnd)
        Local $avtabpos = _GUICtrlTab_GetItemRect($hwnd, $iindex)
        $ix = $avtabpos[0x0] + (($avtabpos[0x2] - $avtabpos[0x0]) / 0x2)
        $iy = $avtabpos[0x1] + (($avtabpos[0x3] - $avtabpos[0x1]) / 0x2)
        ControlClick($hwinparent, '', $hwnd, $sbutton, $iclicks, $ix, $iy)
    Else
        Local $trect = _GUICtrlTab_GetItemRectEx($hwnd, $iindex)
        Local $tpoint = _WinAPI_PointFromRect($trect, True)
        $tpoint = _WinAPI_ClientToScreen($hwnd, $tpoint)
        _WinAPI_GetXYFromPoint($tpoint, $ix, $iy)
        Local $imode = Opt("MouseCoordMode", 0x1)
        MouseClick($sbutton, $ix, $iy, $iclicks, $ispeed)
        Opt("MouseCoordMode", $imode)
    EndIf
EndFunc    ; -> _GUICtrlTab_ClickTab

Func _GUICtrlTab_Create($hwnd, $ix, $iy, $iwidth = 0x96, $iheight = 0x96, $istyle = 0x40, $iexstyle = 0x0)
    If Not IsHWnd($hwnd) Then
        Return SetError(0x1, 0x0, 0x0)
    EndIf
    If $iwidth = + -1 Then $iwidth = 0x96
    If $iheight = + -1 Then $iheight = 0x96
    If $istyle = + -1 Then $istyle = $TCS_HOTTRACK
    If $iexstyle = + -1 Then $iexstyle = 0x0
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__TABCONSTANT_WS_CLIPSIBLINGS, $__UDFGUICONSTANT_WS_VISIBLE)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $htab = _WinAPI_CreateWindowEx($iexstyle, $__TABCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    _WinAPI_SetFont($htab, _WinAPI_GetStockObject($__TABCONSTANT_DEFAULT_GUI_FONT))
    Return $htab
EndFunc    ; -> _GUICtrlTab_Create

Func _GUICtrlTab_DeleteAllItems($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_DELETEALLITEMS) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_DELETEALLITEMS, 0x0, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlTab_DeleteAllItems

Func _GUICtrlTab_DeleteItem($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_DELETEITEM, $iindex) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_DELETEITEM, $iindex, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlTab_DeleteItem

Func _GUICtrlTab_DeselectAll($hwnd, $BEXCLUDE = True)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $TCM_DESELECTALL, $BEXCLUDE)
    Else
        GUICtrlSendMsg($hwnd, $TCM_DESELECTALL, $BEXCLUDE, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlTab_DeselectAll

Func _GUICtrlTab_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__TABCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlTab_Destroy

Func _GUICtrlTab_FindTab($hwnd, $stext, $binstr = False, $istart = 0x0)
    Local $stab
    For $ii = $istart To _GUICtrlTab_GetItemCount($hwnd)
        $stab = _GUICtrlTab_GetItemText($hwnd, $ii)
        Switch $binstr
        Case False
            If $stab = $stext Then Return $ii
        Case True
            If StringInStr($stab, $stext) Then Return $ii
        EndSwitch
    Next
    Return + -1
EndFunc    ; -> _GUICtrlTab_FindTab

Func _GUICtrlTab_GetCurFocus($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_GETCURFOCUS)
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_GETCURFOCUS, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlTab_GetCurFocus

Func _GUICtrlTab_GetCurSel($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_GETCURSEL)
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_GETCURSEL, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlTab_GetCurSel

Func _GUICtrlTab_GetDisplayRect($hwnd)
    Local $arect[0x4]
    Local $trect = _GUICtrlTab_GetDisplayRectEx($hwnd)
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlTab_GetDisplayRect

Func _GUICtrlTab_GetDisplayRectEx($hwnd)
    Local $trect = _WinAPI_GetClientRect($hwnd)
    __GUICtrlTab_AdjustRect($hwnd, $trect)
    Return $trect
EndFunc    ; -> _GUICtrlTab_GetDisplayRectEx

Func _GUICtrlTab_GetExtendedStyle($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_GETEXTENDEDSTYLE)
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_GETEXTENDEDSTYLE, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlTab_GetExtendedStyle

Func _GUICtrlTab_GetImageList($hwnd)
    If IsHWnd($hwnd) Then
        Return Ptr(_SendMessage($hwnd, $TCM_GETIMAGELIST))
    Else
        Return Ptr(GUICtrlSendMsg($hwnd, $TCM_GETIMAGELIST, 0x0, 0x0))
    EndIf
EndFunc    ; -> _GUICtrlTab_GetImageList

Func _GUICtrlTab_GetItem($hwnd, $iindex)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $titem = DllStructCreate($TAGTCITEM)
    DllStructSetData($titem, "Mask", $TCIF_ALLDATA)
    DllStructSetData($titem, "StateMask", BitOR($TCIS_HIGHLIGHTED, $TCIS_BUTTONPRESSED))
    Local $tbuffer, $imsg
    If _GUICtrlTab_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_ttabbuffer
        $imsg = $TCM_GETITEMW
    Else
        $tbuffer = $__g_ttabbufferansi
        $imsg = $TCM_GETITEMA
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $titem, $tbuffer, True, 0x4, True)
    Local $aitem[0x4]
    $aitem[0x0] = DllStructGetData($titem, "State")
    $aitem[0x1] = DllStructGetData($tbuffer, "Text")
    $aitem[0x2] = DllStructGetData($titem, "Image")
    $aitem[0x3] = DllStructGetData($titem, "Param")
    Return SetError($iret = 0x0, 0x0, $aitem)
EndFunc    ; -> _GUICtrlTab_GetItem

Func _GUICtrlTab_GetItemCount($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_GETITEMCOUNT)
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_GETITEMCOUNT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlTab_GetItemCount

Func _GUICtrlTab_GetItemImage($hwnd, $iindex)
    Local $aitem = _GUICtrlTab_GetItem($hwnd, $iindex)
    Return $aitem[0x2]
EndFunc    ; -> _GUICtrlTab_GetItemImage

Func _GUICtrlTab_GetItemParam($hwnd, $iindex)
    Local $aitem = _GUICtrlTab_GetItem($hwnd, $iindex)
    Return $aitem[0x3]
EndFunc    ; -> _GUICtrlTab_GetItemParam

Func _GUICtrlTab_GetItemRect($hwnd, $iindex)
    Local $arect[0x4]
    Local $trect = _GUICtrlTab_GetItemRectEx($hwnd, $iindex)
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlTab_GetItemRect

Func _GUICtrlTab_GetItemRectEx($hwnd, $iindex)
    Local $trect = DllStructCreate($TAGRECT)
    __guictrl_sendmsg($hwnd, $TCM_GETITEMRECT, $iindex, $trect, 0x0, True)
    Return $trect
EndFunc    ; -> _GUICtrlTab_GetItemRectEx

Func _GUICtrlTab_GetItemState($hwnd, $iindex)
    Local $aitem = _GUICtrlTab_GetItem($hwnd, $iindex)
    Return $aitem[0x0]
EndFunc    ; -> _GUICtrlTab_GetItemState

Func _GUICtrlTab_GetItemText($hwnd, $iindex)
    Local $aitem = _GUICtrlTab_GetItem($hwnd, $iindex)
    Return $aitem[0x1]
EndFunc    ; -> _GUICtrlTab_GetItemText

Func _GUICtrlTab_GetRowCount($hwnd)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_GETROWCOUNT)
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_GETROWCOUNT, 0x0, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlTab_GetRowCount

Func _GUICtrlTab_GetToolTips($hwnd)
    If IsHWnd($hwnd) Then
        Return HWnd(_SendMessage($hwnd, $TCM_GETTOOLTIPS))
    Else
        Return HWnd(GUICtrlSendMsg($hwnd, $TCM_GETTOOLTIPS, 0x0, 0x0))
    EndIf
EndFunc    ; -> _GUICtrlTab_GetToolTips

Func _GUICtrlTab_GetUnicodeFormat($hwnd)
    If Not IsDllStruct($__g_ttabbuffer) Then
        $__g_ttabbuffer = DllStructCreate("wchar Text[4096]")
        $__g_ttabbufferansi = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_ttabbuffer))
    EndIf
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_GETUNICODEFORMAT) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_GETUNICODEFORMAT, 0x0, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlTab_GetUnicodeFormat

Func _GUICtrlTab_HighlightItem($hwnd, $iindex, $bhighlight = True)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_HIGHLIGHTITEM, $iindex, $bhighlight) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_HIGHLIGHTITEM, $iindex, $bhighlight) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlTab_HighlightItem

Func _GUICtrlTab_HitTest($hwnd, $ix, $iy)
    Local $ahit[0x2] = [+ -1, 0x1]
    Local $thit = DllStructCreate($TAGTCHITTESTINFO)
    DllStructSetData($thit, "X", $ix)
    DllStructSetData($thit, "Y", $iy)
    Local $ahit[0x2] = [+ -1, 0x1]
    $ahit[0x0] = __guictrl_sendmsg($hwnd, $TCM_HITTEST, 0x0, $thit, 0x0, True)
    $ahit[0x1] = DllStructGetData($thit, "Flags")
    Return $ahit
EndFunc    ; -> _GUICtrlTab_HitTest

Func _GUICtrlTab_InsertItem($hwnd, $iindex, $stext, $iimage = + -1, $iparam = 0x0)
    Local $tbuffer, $imsg
    If _GUICtrlTab_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_ttabbuffer
        $imsg = $TCM_INSERTITEMW
    Else
        $tbuffer = $__g_ttabbufferansi
        $imsg = $TCM_INSERTITEMA
    EndIf
    Local $titem = DllStructCreate($TAGTCITEM)
    DllStructSetData($tbuffer, "Text", $stext)
    DllStructSetData($titem, "Mask", BitOR($TCIF_TEXT, $TCIF_IMAGE, $TCIF_PARAM))
    DllStructSetData($titem, "Image", $iimage)
    DllStructSetData($titem, "Param", $iparam)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $titem, $tbuffer, False, 0x4)
    Return $iret
EndFunc    ; -> _GUICtrlTab_InsertItem

Func _GUICtrlTab_RemoveImage($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $TCM_REMOVEIMAGE, $iindex)
        _WinAPI_InvalidateRect($hwnd)
    Else
        GUICtrlSendMsg($hwnd, $TCM_REMOVEIMAGE, $iindex, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlTab_RemoveImage

Func _GUICtrlTab_SetCurFocus($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $TCM_SETCURFOCUS, $iindex)
    Else
        GUICtrlSendMsg($hwnd, $TCM_SETCURFOCUS, $iindex, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlTab_SetCurFocus

Func _GUICtrlTab_SetCurSel($hwnd, $iindex)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_SETCURSEL, $iindex)
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_SETCURSEL, $iindex, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlTab_SetCurSel

Func _GUICtrlTab_SetExtendedStyle($hwnd, $istyle)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_SETEXTENDEDSTYLE, 0x0, $istyle)
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_SETEXTENDEDSTYLE, 0x0, $istyle)
    EndIf
EndFunc    ; -> _GUICtrlTab_SetExtendedStyle

Func _GUICtrlTab_SetImageList($hwnd, $himage)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_SETIMAGELIST, 0x0, $himage, 0x0, "wparam", "handle", "handle")
    Else
        Return Ptr(GUICtrlSendMsg($hwnd, $TCM_SETIMAGELIST, 0x0, $himage))
    EndIf
EndFunc    ; -> _GUICtrlTab_SetImageList

Func _GUICtrlTab_SetItem($hwnd, $iindex, $stext = + -1, $istate = + -1, $iimage = + -1, $iparam = + -1)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $titem = DllStructCreate($TAGTCITEM)
    Local $tbuffer, $imask = 0x0, $imsg
    If _GUICtrlTab_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_ttabbuffer
        $imsg = $TCM_SETITEMW
    Else
        $tbuffer = $__g_ttabbufferansi
        $imsg = $TCM_SETITEMA
    EndIf
    If IsString($stext) Then
        DllStructSetData($tbuffer, "Text", $stext)
        $imask = $TCIF_TEXT
    Else
        $tbuffer = 0x0
    EndIf
    If $istate <> + -1 Then
        DllStructSetData($titem, "State", $istate)
        DllStructSetData($titem, "StateMask", $istate)
        $imask = BitOR($imask, $TCIF_STATE)
    EndIf
    If $iimage <> + -1 Then
        DllStructSetData($titem, "Image", $iimage)
        $imask = BitOR($imask, $TCIF_IMAGE)
    EndIf
    If $iparam <> + -1 Then
        DllStructSetData($titem, "Param", $iparam)
        $imask = BitOR($imask, $TCIF_PARAM)
    EndIf
    DllStructSetData($titem, "Mask", $imask)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $titem, $tbuffer, False, 0x4)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlTab_SetItem

Func _GUICtrlTab_SetItemImage($hwnd, $iindex, $iimage)
    Return _GUICtrlTab_SetItem($hwnd, $iindex, + -1, + -1, $iimage)
EndFunc    ; -> _GUICtrlTab_SetItemImage

Func _GUICtrlTab_SetItemParam($hwnd, $iindex, $iparam)
    Return _GUICtrlTab_SetItem($hwnd, $iindex, + -1, + -1, + -1, $iparam)
EndFunc    ; -> _GUICtrlTab_SetItemParam

Func _GUICtrlTab_SetItemSize($hwnd, $iwidth, $iheight)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_SETITEMSIZE, 0x0, _WinAPI_MakeLong($iwidth, $iheight))
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_SETITEMSIZE, 0x0, _WinAPI_MakeLong($iwidth, $iheight))
    EndIf
EndFunc    ; -> _GUICtrlTab_SetItemSize

Func _GUICtrlTab_SetItemState($hwnd, $iindex, $istate)
    Return _GUICtrlTab_SetItem($hwnd, $iindex, + -1, $istate)
EndFunc    ; -> _GUICtrlTab_SetItemState

Func _GUICtrlTab_SetItemText($hwnd, $iindex, $stext)
    Return _GUICtrlTab_SetItem($hwnd, $iindex, $stext)
EndFunc    ; -> _GUICtrlTab_SetItemText

Func _GUICtrlTab_SetMinTabWidth($hwnd, $iminwidth)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_SETMINTABWIDTH, 0x0, $iminwidth)
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_SETMINTABWIDTH, 0x0, $iminwidth)
    EndIf
EndFunc    ; -> _GUICtrlTab_SetMinTabWidth

Func _GUICtrlTab_SetPadding($hwnd, $ihorz, $ivert)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $TCM_SETPADDING, 0x0, _WinAPI_MakeLong($ihorz, $ivert))
    Else
        GUICtrlSendMsg($hwnd, $TCM_SETPADDING, 0x0, _WinAPI_MakeLong($ihorz, $ivert))
    EndIf
EndFunc    ; -> _GUICtrlTab_SetPadding

Func _GUICtrlTab_SetToolTips($hwnd, $htooltip)
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $TCM_SETTOOLTIPS, $htooltip, 0x0, 0x0, "hwnd")
    Else
        GUICtrlSendMsg($hwnd, $TCM_SETTOOLTIPS, $htooltip, 0x0)
    EndIf
EndFunc    ; -> _GUICtrlTab_SetToolTips

Func _GUICtrlTab_SetUnicodeFormat($hwnd, $bunicode)
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TCM_SETUNICODEFORMAT, $bunicode) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $TCM_SETUNICODEFORMAT, $bunicode, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlTab_SetUnicodeFormat

Global Const $TBIF_IMAGE = 0x1
Global Const $TBIF_TEXT = 0x2
Global Const $TBIF_STATE = 0x4
Global Const $TBIF_STYLE = 0x8
Global Const $TBIF_LPARAM = 0x10
Global Const $TBIF_COMMAND = 0x20
Global Const $TBIF_SIZE = 0x40
Global Const $TBIF_BYINDEX = -2147483648
Global Const $TBMF_PAD = 0x1
Global Const $TBMF_BARPAD = 0x2
Global Const $TBMF_BUTTONSPACING = 0x4
Global Const $TBSTATE_CHECKED = 0x1
Global Const $TBSTATE_PRESSED = 0x2
Global Const $TBSTATE_ENABLED = 0x4
Global Const $TBSTATE_HIDDEN = 0x8
Global Const $TBSTATE_INDETERMINATE = 0x10
Global Const $TBSTATE_WRAP = 0x20
Global Const $TBSTATE_ELLIPSES = 0x40
Global Const $TBSTATE_MARKED = 0x80
Global Const $__TOOLBARCONSTANTS_WM_USER = 0x400
Global Const $TB_ENABLEBUTTON = $__TOOLBARCONSTANTS_WM_USER + 0x1
Global Const $TB_CHECKBUTTON = $__TOOLBARCONSTANTS_WM_USER + 0x2
Global Const $TB_PRESSBUTTON = $__TOOLBARCONSTANTS_WM_USER + 0x3
Global Const $TB_HIDEBUTTON = $__TOOLBARCONSTANTS_WM_USER + 0x4
Global Const $TB_INDETERMINATE = $__TOOLBARCONSTANTS_WM_USER + 0x5
Global Const $TB_MARKBUTTON = $__TOOLBARCONSTANTS_WM_USER + 0x6
Global Const $TB_ISBUTTONENABLED = $__TOOLBARCONSTANTS_WM_USER + 0x9
Global Const $TB_ISBUTTONCHECKED = $__TOOLBARCONSTANTS_WM_USER + 0xa
Global Const $TB_ISBUTTONPRESSED = $__TOOLBARCONSTANTS_WM_USER + 0xb
Global Const $TB_ISBUTTONHIDDEN = $__TOOLBARCONSTANTS_WM_USER + 0xc
Global Const $TB_ISBUTTONINDETERMINATE = $__TOOLBARCONSTANTS_WM_USER + 0xd
Global Const $TB_ISBUTTONHIGHLIGHTED = $__TOOLBARCONSTANTS_WM_USER + 0xe
Global Const $TB_SETSTATE = $__TOOLBARCONSTANTS_WM_USER + 0x11
Global Const $TB_GETSTATE = $__TOOLBARCONSTANTS_WM_USER + 0x12
Global Const $TB_ADDBITMAP = $__TOOLBARCONSTANTS_WM_USER + 0x13
Global Const $TB_ADDBUTTONSA = $__TOOLBARCONSTANTS_WM_USER + 0x14
Global Const $TB_INSERTBUTTONA = $__TOOLBARCONSTANTS_WM_USER + 0x15
Global Const $TB_DELETEBUTTON = $__TOOLBARCONSTANTS_WM_USER + 0x16
Global Const $TB_GETBUTTON = $__TOOLBARCONSTANTS_WM_USER + 0x17
Global Const $TB_BUTTONCOUNT = $__TOOLBARCONSTANTS_WM_USER + 0x18
Global Const $TB_COMMANDTOINDEX = $__TOOLBARCONSTANTS_WM_USER + 0x19
Global Const $TB_SAVERESTOREA = $__TOOLBARCONSTANTS_WM_USER + 0x1a
Global Const $TB_SAVERESTOREW = $__TOOLBARCONSTANTS_WM_USER + 0x4c
Global Const $TB_CUSTOMIZE = $__TOOLBARCONSTANTS_WM_USER + 0x1b
Global Const $TB_ADDSTRINGA = $__TOOLBARCONSTANTS_WM_USER + 0x1c
Global Const $TB_ADDSTRINGW = $__TOOLBARCONSTANTS_WM_USER + 0x4d
Global Const $TB_GETITEMRECT = $__TOOLBARCONSTANTS_WM_USER + 0x1d
Global Const $TB_BUTTONSTRUCTSIZE = $__TOOLBARCONSTANTS_WM_USER + 0x1e
Global Const $TB_SETBUTTONSIZE = $__TOOLBARCONSTANTS_WM_USER + 0x1f
Global Const $TB_SETBITMAPSIZE = $__TOOLBARCONSTANTS_WM_USER + 0x20
Global Const $TB_AUTOSIZE = $__TOOLBARCONSTANTS_WM_USER + 0x21
Global Const $TB_GETTOOLTIPS = $__TOOLBARCONSTANTS_WM_USER + 0x23
Global Const $TB_SETTOOLTIPS = $__TOOLBARCONSTANTS_WM_USER + 0x24
Global Const $TB_SETPARENT = $__TOOLBARCONSTANTS_WM_USER + 0x25
Global Const $TB_SETROWS = $__TOOLBARCONSTANTS_WM_USER + 0x27
Global Const $TB_GETROWS = $__TOOLBARCONSTANTS_WM_USER + 0x28
Global Const $TB_GETBITMAPFLAGS = $__TOOLBARCONSTANTS_WM_USER + 0x29
Global Const $TB_SETCMDID = $__TOOLBARCONSTANTS_WM_USER + 0x2a
Global Const $TB_CHANGEBITMAP = $__TOOLBARCONSTANTS_WM_USER + 0x2b
Global Const $TB_GETBITMAP = $__TOOLBARCONSTANTS_WM_USER + 0x2c
Global Const $TB_GETBUTTONTEXTA = $__TOOLBARCONSTANTS_WM_USER + 0x2d
Global Const $TB_GETBUTTONTEXTW = $__TOOLBARCONSTANTS_WM_USER + 0x4b
Global Const $TB_REPLACEBITMAP = $__TOOLBARCONSTANTS_WM_USER + 0x2e
Global Const $TB_SETINDENT = $__TOOLBARCONSTANTS_WM_USER + 0x2f
Global Const $TB_SETIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 0x30
Global Const $TB_GETIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 0x31
Global Const $TB_LOADIMAGES = $__TOOLBARCONSTANTS_WM_USER + 0x32
Global Const $TB_GETRECT = $__TOOLBARCONSTANTS_WM_USER + 0x33
Global Const $TB_SETHOTIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 0x34
Global Const $TB_GETHOTIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 0x35
Global Const $TB_SETDISABLEDIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 0x36
Global Const $TB_GETDISABLEDIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 0x37
Global Const $TB_SETSTYLE = $__TOOLBARCONSTANTS_WM_USER + 0x38
Global Const $TB_GETSTYLE = $__TOOLBARCONSTANTS_WM_USER + 0x39
Global Const $TB_GETBUTTONSIZE = $__TOOLBARCONSTANTS_WM_USER + 0x3a
Global Const $TB_SETBUTTONWIDTH = $__TOOLBARCONSTANTS_WM_USER + 0x3b
Global Const $TB_SETMAXTEXTROWS = $__TOOLBARCONSTANTS_WM_USER + 0x3c
Global Const $TB_GETTEXTROWS = $__TOOLBARCONSTANTS_WM_USER + 0x3d
Global Const $TB_GETOBJECT = $__TOOLBARCONSTANTS_WM_USER + 0x3e
Global Const $TB_GETBUTTONINFOW = $__TOOLBARCONSTANTS_WM_USER + 0x3f
Global Const $TB_SETBUTTONINFOW = $__TOOLBARCONSTANTS_WM_USER + 0x40
Global Const $TB_GETBUTTONINFOA = $__TOOLBARCONSTANTS_WM_USER + 0x41
Global Const $TB_SETBUTTONINFOA = $__TOOLBARCONSTANTS_WM_USER + 0x42
Global Const $TB_INSERTBUTTONW = $__TOOLBARCONSTANTS_WM_USER + 0x43
Global Const $TB_ADDBUTTONSW = $__TOOLBARCONSTANTS_WM_USER + 0x44
Global Const $TB_HITTEST = $__TOOLBARCONSTANTS_WM_USER + 0x45
Global Const $TB_SETDRAWTEXTFLAGS = $__TOOLBARCONSTANTS_WM_USER + 0x46
Global Const $TB_GETHOTITEM = $__TOOLBARCONSTANTS_WM_USER + 0x47
Global Const $TB_SETHOTITEM = $__TOOLBARCONSTANTS_WM_USER + 0x48
Global Const $TB_SETANCHORHIGHLIGHT = $__TOOLBARCONSTANTS_WM_USER + 0x49
Global Const $TB_GETANCHORHIGHLIGHT = $__TOOLBARCONSTANTS_WM_USER + 0x4a
Global Const $TB_MAPACCELERATOR = $__TOOLBARCONSTANTS_WM_USER + 0x4e
Global Const $TB_GETINSERTMARK = $__TOOLBARCONSTANTS_WM_USER + 0x4f
Global Const $TB_SETINSERTMARK = $__TOOLBARCONSTANTS_WM_USER + 0x50
Global Const $TB_INSERTMARKHITTEST = $__TOOLBARCONSTANTS_WM_USER + 0x51
Global Const $TB_MOVEBUTTON = $__TOOLBARCONSTANTS_WM_USER + 0x52
Global Const $TB_GETMAXSIZE = $__TOOLBARCONSTANTS_WM_USER + 0x53
Global Const $TB_SETEXTENDEDSTYLE = $__TOOLBARCONSTANTS_WM_USER + 0x54
Global Const $TB_GETEXTENDEDSTYLE = $__TOOLBARCONSTANTS_WM_USER + 0x55
Global Const $TB_GETPADDING = $__TOOLBARCONSTANTS_WM_USER + 0x56
Global Const $TB_SETPADDING = $__TOOLBARCONSTANTS_WM_USER + 0x57
Global Const $TB_SETINSERTMARKCOLOR = $__TOOLBARCONSTANTS_WM_USER + 0x58
Global Const $TB_GETINSERTMARKCOLOR = $__TOOLBARCONSTANTS_WM_USER + 0x59
Global Const $TB_MAPACCELERATORW = $__TOOLBARCONSTANTS_WM_USER + 0x5a
Global Const $TB_GETSTRINGW = $__TOOLBARCONSTANTS_WM_USER + 0x5b
Global Const $TB_GETSTRINGA = $__TOOLBARCONSTANTS_WM_USER + 0x5c
Global Const $TB_GETMETRICS = $__TOOLBARCONSTANTS_WM_USER + 0x65
Global Const $TB_SETMETRICS = $__TOOLBARCONSTANTS_WM_USER + 0x66
Global Const $TB_GETCOLORSCHEME = 0x2000 + 0x3
Global Const $TB_SETCOLORSCHEME = 0x2000 + 0x2
Global Const $TB_SETUNICODEFORMAT = 0x2000 + 0x5
Global Const $TB_GETUNICODEFORMAT = 0x2000 + 0x6
Global Const $TB_SETWINDOWTHEME = 0x2000 + 0xb
Global Const $TBN_FIRST = + -700
Global Const $TBN_GETBUTTONINFOA = $TBN_FIRST + 0x0
Global Const $TBN_BEGINDRAG = $TBN_FIRST + -1
Global Const $TBN_ENDDRAG = $TBN_FIRST + -2
Global Const $TBN_BEGINADJUST = $TBN_FIRST + -3
Global Const $TBN_ENDADJUST = $TBN_FIRST + -4
Global Const $TBN_RESET = $TBN_FIRST + -5
Global Const $TBN_QUERYINSERT = $TBN_FIRST + -6
Global Const $TBN_QUERYDELETE = $TBN_FIRST + -7
Global Const $TBN_TOOLBARCHANGE = $TBN_FIRST + -8
Global Const $TBN_CUSTHELP = $TBN_FIRST + -9
Global Const $TBN_DROPDOWN = $TBN_FIRST + -10
Global Const $TBN_GETOBJECT = $TBN_FIRST + -12
Global Const $TBN_HOTITEMCHANGE = $TBN_FIRST + -13
Global Const $TBN_DRAGOUT = $TBN_FIRST + -14
Global Const $TBN_DELETINGBUTTON = $TBN_FIRST + -15
Global Const $TBN_GETDISPINFOA = $TBN_FIRST + -16
Global Const $TBN_GETDISPINFOW = $TBN_FIRST + -17
Global Const $TBN_GETINFOTIPA = $TBN_FIRST + -18
Global Const $TBN_GETINFOTIPW = $TBN_FIRST + -19
Global Const $TBN_GETBUTTONINFOW = $TBN_FIRST + -20
Global Const $TBN_RESTORE = $TBN_FIRST + -21
Global Const $TBN_SAVE = $TBN_FIRST + -22
Global Const $TBN_INITCUSTOMIZE = $TBN_FIRST + -23
Global Const $HICF_ACCELERATOR = 0x4
Global Const $HICF_ARROWKEYS = 0x2
Global Const $HICF_DUPACCEL = 0x8
Global Const $HICF_ENTERING = 0x10
Global Const $HICF_LEAVING = 0x20
Global Const $HICF_LMOUSE = 0x80
Global Const $HICF_MOUSE = 0x1
Global Const $HICF_OTHER = 0x0
Global Const $HICF_RESELECT = 0x40
Global Const $HICF_TOGGLEDROPDOWN = 0x100
Global Const $BTNS_BUTTON = 0x0
Global Const $BTNS_SEP = 0x1
Global Const $BTNS_CHECK = 0x2
Global Const $BTNS_GROUP = 0x4
Global Const $BTNS_CHECKGROUP = 0x6
Global Const $BTNS_DROPDOWN = 0x8
Global Const $BTNS_AUTOSIZE = 0x10
Global Const $BTNS_NOPREFIX = 0x20
Global Const $BTNS_SHOWTEXT = 0x40
Global Const $BTNS_WHOLEDROPDOWN = 0x80
Global Const $TBSTYLE_TOOLTIPS = 0x100
Global Const $TBSTYLE_WRAPABLE = 0x200
Global Const $TBSTYLE_ALTDRAG = 0x400
Global Const $TBSTYLE_FLAT = 0x800
Global Const $TBSTYLE_LIST = 0x1000
Global Const $TBSTYLE_CUSTOMERASE = 0x2000
Global Const $TBSTYLE_REGISTERDROP = 0x4000
Global Const $TBSTYLE_TRANSPARENT = 0x8000
Global Const $TBSTYLE_EX_DRAWDDARROWS = 0x1
Global Const $TBSTYLE_EX_MIXEDBUTTONS = 0x8
Global Const $TBSTYLE_EX_HIDECLIPPEDBUTTONS = 0x10
Global Const $TBSTYLE_EX_DOUBLEBUFFER = 0x80
Global $__g_ttbbuffer, $__g_ttbbufferansi
Global Const $__TOOLBARCONSTANT_CLASSNAME = "ToolbarWindow32"
Global Const $__TOOLBARCONSTANT_WS_CLIPSIBLINGS = 0x4000000
Global Const $__TOOLBARCONSTANT_HINST_COMMCTRL = + -1
Global Const $TAGTBADDBITMAP = "handle hInst;uint_ptr ID"
Global Const $TAGTBINSERTMARK = "int Button;dword Flags"
Global Const $TAGTBMETRICS = "uint Size;dword Mask;int XPad;int YPad;int XBarPad;int YBarPad;int XSpacing;int YSpacing"
Func _GUICtrlToolbar_AddBitmap($hwnd, $ibuttons, $hinst, $iid)
    Local $tbitmap = DllStructCreate($TAGTBADDBITMAP)
    DllStructSetData($tbitmap, "hInst", $hinst)
    DllStructSetData($tbitmap, "ID", $iid)
    Local $iret = __guictrl_sendmsg($hwnd, $TB_ADDBITMAP, $ibuttons, $tbitmap)
    Return $iret
EndFunc    ; -> _GUICtrlToolbar_AddBitmap

Func _GUICtrlToolbar_AddButton($hwnd, $iid, $iimage, $istring = 0x0, $istyle = 0x0, $istate = 0x4, $iparam = 0x0)
    Local $imsg
    If _GUICtrlToolbar_GetUnicodeFormat($hwnd) Then
        $imsg = $TB_ADDBUTTONSW
    Else
        $imsg = $TB_ADDBUTTONSA
    EndIf
    Local $tbutton = DllStructCreate($TAGTBBUTTON)
    DllStructSetData($tbutton, "Bitmap", $iimage)
    DllStructSetData($tbutton, "Command", $iid)
    DllStructSetData($tbutton, "State", $istate)
    DllStructSetData($tbutton, "Style", $istyle)
    DllStructSetData($tbutton, "Param", $iparam)
    DllStructSetData($tbutton, "String", $istring)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x1, $tbutton)
    __GUICtrlToolbar_AutoSize($hwnd)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlToolbar_AddButton

Func _GUICtrlToolbar_AddButtonSep($hwnd, $iwidth = 0x6)
    _GUICtrlToolbar_AddButton($hwnd, 0x0, $iwidth, 0x0, $BTNS_SEP)
EndFunc    ; -> _GUICtrlToolbar_AddButtonSep

Func _GUICtrlToolbar_AddString($hwnd, $sstring)
    Local $tbuffer, $imsg
    If _GUICtrlToolbar_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_ttbbuffer
        $imsg = $TB_ADDSTRINGW
    Else
        $tbuffer = $__g_ttbbufferansi
        $imsg = $TB_ADDSTRINGA
    EndIf
    DllStructSetData($tbuffer, "Text", $sstring)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $tbuffer)
    Return $iret
EndFunc    ; -> _GUICtrlToolbar_AddString

Func __GUICtrlToolbar_AutoSize($hwnd)
    _SendMessage($hwnd, $TB_AUTOSIZE)
EndFunc    ; -> __GUICtrlToolbar_AutoSize

Func _GUICtrlToolbar_ButtonCount($hwnd)
    Return _SendMessage($hwnd, $TB_BUTTONCOUNT)
EndFunc    ; -> _GUICtrlToolbar_ButtonCount

Func __GUICtrlToolbar_ButtonStructSize($hwnd)
    Local $tbutton = DllStructCreate($TAGTBBUTTON)
    _SendMessage($hwnd, $TB_BUTTONSTRUCTSIZE, DllStructGetSize($tbutton), 0x0, 0x0, "wparam", "ptr")
EndFunc    ; -> __GUICtrlToolbar_ButtonStructSize

Func _GUICtrlToolbar_CheckButton($hwnd, $icommandid, $bcheck = True)
    Return _SendMessage($hwnd, $TB_CHECKBUTTON, $icommandid, $bcheck) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_CheckButton

Func _GUICtrlToolbar_ClickAccel($hwnd, $saccelkey, $sbutton = "left", $bmove = False, $iclicks = 0x1, $ispeed = 0x1)
    Local $iid = _GUICtrlToolbar_MapAccelerator($hwnd, $saccelkey)
    _GUICtrlToolbar_ClickButton($hwnd, $iid, $sbutton, $bmove, $iclicks, $ispeed)
EndFunc    ; -> _GUICtrlToolbar_ClickAccel

Func _GUICtrlToolbar_ClickButton($hwnd, $icommandid, $sbutton = "left", $bmove = False, $iclicks = 0x1, $ispeed = 0x1)
    Local $trect = _GUICtrlToolbar_GetButtonRectEx($hwnd, $icommandid)
    Local $tpoint = _WinAPI_PointFromRect($trect)
    $tpoint = _WinAPI_ClientToScreen($hwnd, $tpoint)
    Local $ix, $iy
    _WinAPI_GetXYFromPoint($tpoint, $ix, $iy)
    Local $imode = Opt("MouseCoordMode", 0x1)
    If Not $bmove Then
        Local $apos = MouseGetPos()
        _WinAPI_ShowCursor(False)
        MouseClick($sbutton, $ix, $iy, $iclicks, $ispeed)
        MouseMove($apos[0x0], $apos[0x1], 0x0)
        _WinAPI_ShowCursor(True)
    Else
        MouseClick($sbutton, $ix, $iy, $iclicks, $ispeed)
    EndIf
    Opt("MouseCoordMode", $imode)
EndFunc    ; -> _GUICtrlToolbar_ClickButton

Func _GUICtrlToolbar_ClickIndex($hwnd, $iindex, $sbutton = "left", $bmove = False, $iclicks = 0x1, $ispeed = 0x1)
    Local $icommandid = _GUICtrlToolbar_IndexToCommand($hwnd, $iindex)
    _GUICtrlToolbar_ClickButton($hwnd, $icommandid, $sbutton, $bmove, $iclicks, $ispeed)
EndFunc    ; -> _GUICtrlToolbar_ClickIndex

Func _GUICtrlToolbar_CommandToIndex($hwnd, $icommandid)
    Return _SendMessage($hwnd, $TB_COMMANDTOINDEX, $icommandid)
EndFunc    ; -> _GUICtrlToolbar_CommandToIndex

Func _GUICtrlToolbar_Create($hwnd, $istyle = 0x800, $iexstyle = 0x0)
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__TOOLBARCONSTANT_WS_CLIPSIBLINGS, $__UDFGUICONSTANT_WS_VISIBLE)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $htool = _WinAPI_CreateWindowEx($iexstyle, $__TOOLBARCONSTANT_CLASSNAME, '', $istyle, 0x0, 0x0, 0x0, 0x0, $hwnd, $nctrlid)
    __GUICtrlToolbar_ButtonStructSize($htool)
    Return $htool
EndFunc    ; -> _GUICtrlToolbar_Create

Func _GUICtrlToolbar_Customize($hwnd)
    _SendMessage($hwnd, $TB_CUSTOMIZE)
EndFunc    ; -> _GUICtrlToolbar_Customize

Func _GUICtrlToolbar_DeleteButton($hwnd, $icommandid)
    Local $iindex = _GUICtrlToolbar_CommandToIndex($hwnd, $icommandid)
    If $iindex = + -1 Then Return SetError(+ -1, 0x0, False)
    Return _SendMessage($hwnd, $TB_DELETEBUTTON, $iindex) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_DeleteButton

Func _GUICtrlToolbar_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $__TOOLBARCONSTANT_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
        Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
        Local $hparent = _WinAPI_GetParent($hwnd)
        $idestroyed = _WinAPI_DestroyWindow($hwnd)
        Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
        If Not $iret Then
        EndIf
    Else
        Return SetError(0x1, 0x1, False)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlToolbar_Destroy

Func _GUICtrlToolbar_EnableButton($hwnd, $icommandid, $benable = True)
    Return _SendMessage($hwnd, $TB_ENABLEBUTTON, $icommandid, $benable) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_EnableButton

Func _GUICtrlToolbar_FindToolbar($hwnd, $stext)
    Local $icommandid, $htoolbar
    If Not _WinAPI_IsWindow($hwnd) Then
        $hwnd = WinGetHandle($hwnd)
        If @error Then Return SetError(+ -1, + -1, 0x0)
    EndIf
    Local $awinlist = _WinAPI_EnumWindows(True, $hwnd)
    For $ii = 0x1 To $awinlist[0x0][0x0]
        If $awinlist[$ii][0x1] = $__TOOLBARCONSTANT_CLASSNAME Then
            $htoolbar = $awinlist[$ii][0x0]
            For $ij = 0x0 To _GUICtrlToolbar_ButtonCount($htoolbar) + -1
                $icommandid = _GUICtrlToolbar_IndexToCommand($htoolbar, $ij)
                If _GUICtrlToolbar_GetButtonText($htoolbar, $icommandid) = $stext Then Return $htoolbar
            Next
        EndIf
    Next
    Return SetError(+ -2, + -2, 0x0)
EndFunc    ; -> _GUICtrlToolbar_FindToolbar

Func _GUICtrlToolbar_GetAnchorHighlight($hwnd)
    Return _SendMessage($hwnd, $TB_GETANCHORHIGHLIGHT) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_GetAnchorHighlight

Func _GUICtrlToolbar_GetBitmapFlags($hwnd)
    Return _SendMessage($hwnd, $TB_GETBITMAPFLAGS)
EndFunc    ; -> _GUICtrlToolbar_GetBitmapFlags

Func _GUICtrlToolbar_GetButtonBitmap($hwnd, $icommandid)
    Return _SendMessage($hwnd, $TB_GETBITMAP, $icommandid)
EndFunc    ; -> _GUICtrlToolbar_GetButtonBitmap

Func _GUICtrlToolbar_GetButtonInfo($hwnd, $icommandid)
    Local $abutton[0x5]
    Local $tbutton = _GUICtrlToolbar_GetButtonInfoEx($hwnd, $icommandid)
    $abutton[0x0] = DllStructGetData($tbutton, "Image")
    $abutton[0x1] = DllStructGetData($tbutton, "State")
    $abutton[0x2] = DllStructGetData($tbutton, "Style")
    $abutton[0x3] = DllStructGetData($tbutton, "CX")
    $abutton[0x4] = DllStructGetData($tbutton, "Param")
    Return $abutton
EndFunc    ; -> _GUICtrlToolbar_GetButtonInfo

Func _GUICtrlToolbar_GetButtonInfoEx($hwnd, $icommandid)
    Local $imsg
    If _GUICtrlToolbar_GetUnicodeFormat($hwnd) Then
        $imsg = $TB_GETBUTTONINFOW
    Else
        $imsg = $TB_GETBUTTONINFOA
    EndIf
    Local $tbutton = DllStructCreate($TAGTBBUTTONINFO)
    Local $ibutton = DllStructGetSize($tbutton)
    Local $imask = BitOR($TBIF_IMAGE, $TBIF_STATE, $TBIF_STYLE, $TBIF_LPARAM, $TBIF_SIZE)
    DllStructSetData($tbutton, "Size", $ibutton)
    DllStructSetData($tbutton, "Mask", $imask)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $icommandid, $tbutton, 0x0, True)
    Return SetError($iret = + -1, 0x0, $tbutton)
EndFunc    ; -> _GUICtrlToolbar_GetButtonInfoEx

Func _GUICtrlToolbar_GetButtonParam($hwnd, $icommandid)
    Local $tbutton = _GUICtrlToolbar_GetButtonInfoEx($hwnd, $icommandid)
    Return DllStructGetData($tbutton, "Param")
EndFunc    ; -> _GUICtrlToolbar_GetButtonParam

Func _GUICtrlToolbar_GetButtonRect($hwnd, $icommandid)
    Local $arect[0x4]
    Local $trect = _GUICtrlToolbar_GetButtonRectEx($hwnd, $icommandid)
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlToolbar_GetButtonRect

Func _GUICtrlToolbar_GetButtonRectEx($hwnd, $icommandid)
    Local $trect = DllStructCreate($TAGRECT)
    __guictrl_sendmsg($hwnd, $TB_GETRECT, $icommandid, $trect, 0x0, True)
    Return $trect
EndFunc    ; -> _GUICtrlToolbar_GetButtonRectEx

Func _GUICtrlToolbar_GetButtonSize($hwnd)
    Local $asize[0x2]
    Local $iret = _SendMessage($hwnd, $TB_GETBUTTONSIZE)
    $asize[0x0] = _WinAPI_HiWord($iret)
    $asize[0x1] = _WinAPI_LoWord($iret)
    Return $asize
EndFunc    ; -> _GUICtrlToolbar_GetButtonSize

Func _GUICtrlToolbar_GetButtonState($hwnd, $icommandid)
    Return _SendMessage($hwnd, $TB_GETSTATE, $icommandid)
EndFunc    ; -> _GUICtrlToolbar_GetButtonState

Func _GUICtrlToolbar_GetButtonStyle($hwnd, $icommandid)
    Local $tbutton = _GUICtrlToolbar_GetButtonInfoEx($hwnd, $icommandid)
    Return DllStructGetData($tbutton, "Style")
EndFunc    ; -> _GUICtrlToolbar_GetButtonStyle

Func _GUICtrlToolbar_GetButtonText($hwnd, $icommandid)
    Local $tbuffer, $imsg
    If _GUICtrlToolbar_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_ttbbuffer
        $imsg = $TB_GETBUTTONTEXTW
    Else
        $tbuffer = $__g_ttbbufferansi
        $imsg = $TB_GETBUTTONTEXTA
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $icommandid, $tbuffer, 0x0, True)
    Return SetError($iret > 0x0, 0x0, DllStructGetData($tbuffer, "Text"))
EndFunc    ; -> _GUICtrlToolbar_GetButtonText

Func _GUICtrlToolbar_GetColorScheme($hwnd)
    Local $tcolor = DllStructCreate($TAGCOLORSCHEME)
    Local $icolor = DllStructGetSize($tcolor)
    DllStructSetData($tcolor, "Size", $icolor)
    Local $iret = __guictrl_sendmsg($hwnd, $TB_GETCOLORSCHEME, 0x0, $tcolor, 0x0, True)
    Local $acolor[0x2]
    $acolor[0x0] = DllStructGetData($tcolor, "BtnHighlight")
    $acolor[0x1] = DllStructGetData($tcolor, "BtnShadow")
    Return SetError($iret = 0x0, 0x0, $acolor)
EndFunc    ; -> _GUICtrlToolbar_GetColorScheme

Func _GUICtrlToolbar_GetDisabledImageList($hwnd)
    Return Ptr(_SendMessage($hwnd, $TB_GETDISABLEDIMAGELIST))
EndFunc    ; -> _GUICtrlToolbar_GetDisabledImageList

Func _GUICtrlToolbar_GetExtendedStyle($hwnd)
    Return _SendMessage($hwnd, $TB_GETEXTENDEDSTYLE)
EndFunc    ; -> _GUICtrlToolbar_GetExtendedStyle

Func _GUICtrlToolbar_GetHotImageList($hwnd)
    Return Ptr(_SendMessage($hwnd, $TB_GETHOTIMAGELIST))
EndFunc    ; -> _GUICtrlToolbar_GetHotImageList

Func _GUICtrlToolbar_GetHotItem($hwnd)
    Return _SendMessage($hwnd, $TB_GETHOTITEM)
EndFunc    ; -> _GUICtrlToolbar_GetHotItem

Func _GUICtrlToolbar_GetImageList($hwnd)
    Return Ptr(_SendMessage($hwnd, $TB_GETIMAGELIST))
EndFunc    ; -> _GUICtrlToolbar_GetImageList

Func _GUICtrlToolbar_GetInsertMark($hwnd)
    Local $tmark = DllStructCreate($TAGTBINSERTMARK)
    Local $iret = __guictrl_sendmsg($hwnd, $TB_GETINSERTMARK, 0x0, $tmark, 0x0, True)
    Local $amark[0x2]
    $amark[0x0] = DllStructGetData($tmark, "Button")
    $amark[0x1] = DllStructGetData($tmark, "Flags")
    Return SetError($iret <> 0x0, 0x0, $amark)
EndFunc    ; -> _GUICtrlToolbar_GetInsertMark

Func _GUICtrlToolbar_GetInsertMarkColor($hwnd)
    Return _SendMessage($hwnd, $TB_GETINSERTMARKCOLOR)
EndFunc    ; -> _GUICtrlToolbar_GetInsertMarkColor

Func _GUICtrlToolbar_GetMaxSize($hwnd)
    Local $tsize = DllStructCreate($TAGSIZE)
    Local $iret = __guictrl_sendmsg($hwnd, $TB_GETMAXSIZE, 0x0, $tsize, 0x0, True)
    Local $asize[0x2]
    $asize[0x0] = DllStructGetData($tsize, "X")
    $asize[0x1] = DllStructGetData($tsize, "Y")
    Return SetError($iret = 0x0, 0x0, $asize)
EndFunc    ; -> _GUICtrlToolbar_GetMaxSize

Func _GUICtrlToolbar_GetMetrics($hwnd)
    Local $tmetrics = DllStructCreate($TAGTBMETRICS)
    Local $imetrics = DllStructGetSize($tmetrics)
    Local $imask = BitOR($TBMF_PAD, $TBMF_BUTTONSPACING)
    DllStructSetData($tmetrics, "Size", $imetrics)
    DllStructSetData($tmetrics, "Mask", $imask)
    __guictrl_sendmsg($hwnd, $TB_GETMETRICS, 0x0, $tmetrics, 0x0, True)
    Local $ametrics[0x4]
    $ametrics[0x0] = DllStructGetData($tmetrics, "XPad")
    $ametrics[0x1] = DllStructGetData($tmetrics, "YPad")
    $ametrics[0x2] = DllStructGetData($tmetrics, "XSpacing")
    $ametrics[0x3] = DllStructGetData($tmetrics, "YSpacing")
    Return $ametrics
EndFunc    ; -> _GUICtrlToolbar_GetMetrics

Func _GUICtrlToolbar_GetPadding($hwnd)
    Local $apad[0x2]
    Local $ipad = _SendMessage($hwnd, $TB_GETPADDING)
    $apad[0x0] = _WinAPI_LoWord($ipad)
    $apad[0x1] = _WinAPI_HiWord($ipad)
    Return $apad
EndFunc    ; -> _GUICtrlToolbar_GetPadding

Func _GUICtrlToolbar_GetRows($hwnd)
    Return _SendMessage($hwnd, $TB_GETROWS)
EndFunc    ; -> _GUICtrlToolbar_GetRows

Func _GUICtrlToolbar_GetString($hwnd, $iindex)
    Local $tbuffer, $imsg
    If _GUICtrlToolbar_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_ttbbuffer
        $imsg = $TB_GETSTRINGW
    Else
        $tbuffer = $__g_ttbbufferansi
        $imsg = $TB_GETSTRINGA
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, _WinAPI_MakeLong(0x1000, $iindex), $tbuffer, 0x0, True)
    Return SetError($iret = + -1, 0x0, DllStructGetData($tbuffer, "Text"))
EndFunc    ; -> _GUICtrlToolbar_GetString

Func _GUICtrlToolbar_GetStyle($hwnd)
    Return _SendMessage($hwnd, $TB_GETSTYLE)
EndFunc    ; -> _GUICtrlToolbar_GetStyle

Func _GUICtrlToolbar_GetStyleAltDrag($hwnd)
    Return BitAND(_GUICtrlToolbar_GetStyle($hwnd), $TBSTYLE_ALTDRAG) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_GetStyleAltDrag

Func _GUICtrlToolbar_GetStyleCustomErase($hwnd)
    Return BitAND(_GUICtrlToolbar_GetStyle($hwnd), $TBSTYLE_CUSTOMERASE) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_GetStyleCustomErase

Func _GUICtrlToolbar_GetStyleFlat($hwnd)
    Return BitAND(_GUICtrlToolbar_GetStyle($hwnd), $TBSTYLE_FLAT) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_GetStyleFlat

Func _GUICtrlToolbar_GetStyleList($hwnd)
    Return BitAND(_GUICtrlToolbar_GetStyle($hwnd), $TBSTYLE_LIST) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_GetStyleList

Func _GUICtrlToolbar_GetStyleRegisterDrop($hwnd)
    Return BitAND(_GUICtrlToolbar_GetStyle($hwnd), $TBSTYLE_REGISTERDROP) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_GetStyleRegisterDrop

Func _GUICtrlToolbar_GetStyleToolTips($hwnd)
    Return BitAND(_GUICtrlToolbar_GetStyle($hwnd), $TBSTYLE_TOOLTIPS) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_GetStyleToolTips

Func _GUICtrlToolbar_GetStyleTransparent($hwnd)
    Return BitAND(_GUICtrlToolbar_GetStyle($hwnd), $TBSTYLE_TRANSPARENT) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_GetStyleTransparent

Func _GUICtrlToolbar_GetStyleWrapable($hwnd)
    Return BitAND(_GUICtrlToolbar_GetStyle($hwnd), $TBSTYLE_WRAPABLE) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_GetStyleWrapable

Func _GUICtrlToolbar_GetTextRows($hwnd)
    Return _SendMessage($hwnd, $TB_GETTEXTROWS)
EndFunc    ; -> _GUICtrlToolbar_GetTextRows

Func _GUICtrlToolbar_GetToolTips($hwnd)
    Return HWnd(_SendMessage($hwnd, $TB_GETTOOLTIPS))
EndFunc    ; -> _GUICtrlToolbar_GetToolTips

Func _GUICtrlToolbar_GetUnicodeFormat($hwnd)
    If Not IsDllStruct($__g_ttbbuffer) Then
        $__g_ttbbuffer = DllStructCreate("wchar Text[4096]")
        $__g_ttbbufferansi = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_ttbbuffer))
    EndIf
    Return _SendMessage($hwnd, $TB_GETUNICODEFORMAT) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_GetUnicodeFormat

Func _GUICtrlToolbar_HideButton($hwnd, $icommandid, $bhide = True)
    Return _SendMessage($hwnd, $TB_HIDEBUTTON, $icommandid, $bhide) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_HideButton

Func _GUICtrlToolbar_HighlightButton($hwnd, $icommandid, $bhighlight = True)
    Return _SendMessage($hwnd, $TB_MARKBUTTON, $icommandid, $bhighlight) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_HighlightButton

Func _GUICtrlToolbar_HitTest($hwnd, $ix, $iy)
    Local $tpoint = DllStructCreate($TAGPOINT)
    DllStructSetData($tpoint, "X", $ix)
    DllStructSetData($tpoint, "Y", $iy)
    Local $iret = __guictrl_sendmsg($hwnd, $TB_HITTEST, 0x0, $tpoint)
    Return $iret
EndFunc    ; -> _GUICtrlToolbar_HitTest

Func _GUICtrlToolbar_IndexToCommand($hwnd, $iindex)
    Local $tbutton = DllStructCreate($TAGTBBUTTON)
    __guictrl_sendmsg($hwnd, $TB_GETBUTTON, $iindex, $tbutton, 0x0, True)
    Return DllStructGetData($tbutton, "Command")
EndFunc    ; -> _GUICtrlToolbar_IndexToCommand

Func _GUICtrlToolbar_InsertButton($hwnd, $iindex, $iid, $iimage, $stext = '', $istyle = 0x0, $istate = 0x4, $iparam = 0x0)
    Local $tbutton = DllStructCreate($TAGTBBUTTON)
    Local $tbuffer, $imsg
    If _GUICtrlToolbar_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_ttbbuffer
        $imsg = $TB_INSERTBUTTONW
    Else
        $tbuffer = $__g_ttbbufferansi
        $imsg = $TB_INSERTBUTTONA
    EndIf
    If StringLen($stext) Then
        DllStructSetData($tbuffer, "Text", $stext)
        DllStructSetData($tbutton, "String", DllStructGetPtr($tbuffer))
    Else
        $tbuffer = 0x0
    EndIf
    DllStructSetData($tbutton, "Bitmap", $iimage)
    DllStructSetData($tbutton, "Command", $iid)
    DllStructSetData($tbutton, "State", $istate)
    DllStructSetData($tbutton, "Style", $istyle)
    DllStructSetData($tbutton, "Param", $iparam)
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, $iindex, $tbutton, $tbuffer)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlToolbar_InsertButton

Func _GUICtrlToolbar_InsertMarkHitTest($hwnd, $ix, $iy)
    Local $tpoint = DllStructCreate($TAGPOINT)
    Local $tmark = DllStructCreate($TAGTBINSERTMARK)
    DllStructSetData($tpoint, "X", $ix)
    DllStructSetData($tpoint, "Y", $iy)
    Local $iret = __guictrl_sendmsg($hwnd, $TB_INSERTMARKHITTEST, DllStructGetPtr($tpoint), $tmark, False, + -1, True)
    Local $amark[0x2]
    $amark[0x0] = DllStructGetData($tmark, "Button")
    $amark[0x1] = DllStructGetData($tmark, "Flags")
    Return SetError($iret <> 0x0, 0x0, $amark)
EndFunc    ; -> _GUICtrlToolbar_InsertMarkHitTest

Func _GUICtrlToolbar_IsButtonChecked($hwnd, $icommandid)
    Return _SendMessage($hwnd, $TB_ISBUTTONCHECKED, $icommandid) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_IsButtonChecked

Func _GUICtrlToolbar_IsButtonEnabled($hwnd, $icommandid)
    Return _SendMessage($hwnd, $TB_ISBUTTONENABLED, $icommandid) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_IsButtonEnabled

Func _GUICtrlToolbar_IsButtonHidden($hwnd, $icommandid)
    Return _SendMessage($hwnd, $TB_ISBUTTONHIDDEN, $icommandid) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_IsButtonHidden

Func _GUICtrlToolbar_IsButtonHighlighted($hwnd, $icommandid)
    Return _SendMessage($hwnd, $TB_ISBUTTONHIGHLIGHTED, $icommandid) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_IsButtonHighlighted

Func _GUICtrlToolbar_IsButtonIndeterminate($hwnd, $icommandid)
    Return _SendMessage($hwnd, $TB_ISBUTTONINDETERMINATE, $icommandid) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_IsButtonIndeterminate

Func _GUICtrlToolbar_IsButtonPressed($hwnd, $icommandid)
    Return _SendMessage($hwnd, $TB_ISBUTTONPRESSED, $icommandid) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_IsButtonPressed

Func _GUICtrlToolbar_LoadBitmap($hwnd, $sfilename)
    Local $asize = _GUICtrlToolbar_GetButtonSize($hwnd)
    Local $hbitmap = _WinAPI_LoadImage(0x0, $sfilename, 0x0, $asize[0x1], $asize[0x0], $LR_LOADFROMFILE)
    If $hbitmap = 0x0 Then Return SetError(+ -1, + -1, + -1)
    Return _GUICtrlToolbar_AddBitmap($hwnd, 0x1, 0x0, $hbitmap)
EndFunc    ; -> _GUICtrlToolbar_LoadBitmap

Func _GUICtrlToolbar_LoadImages($hwnd, $ibitmapid)
    Return _SendMessage($hwnd, $TB_LOADIMAGES, $ibitmapid, $__TOOLBARCONSTANT_HINST_COMMCTRL)
EndFunc    ; -> _GUICtrlToolbar_LoadImages

Func _GUICtrlToolbar_MapAccelerator($hwnd, $saccelkey)
    Local $tcommand = DllStructCreate("int Data")
    __guictrl_sendmsg($hwnd, $TB_MAPACCELERATORW, Asc($saccelkey), $tcommand)
    Return DllStructGetData($tcommand, "Data")
EndFunc    ; -> _GUICtrlToolbar_MapAccelerator

Func _GUICtrlToolbar_MoveButton($hwnd, $ioldpos, $inewpos)
    Return _SendMessage($hwnd, $TB_MOVEBUTTON, $ioldpos, $inewpos) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_MoveButton

Func _GUICtrlToolbar_PressButton($hwnd, $icommandid, $bpress = True)
    Return _SendMessage($hwnd, $TB_PRESSBUTTON, $icommandid, $bpress) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_PressButton

Func _GUICtrlToolbar_SetAnchorHighlight($hwnd, $banchor)
    Return _SendMessage($hwnd, $TB_SETANCHORHIGHLIGHT, $banchor)
EndFunc    ; -> _GUICtrlToolbar_SetAnchorHighlight

Func _GUICtrlToolbar_SetBitmapSize($hwnd, $iwidth, $iheight)
    Return _SendMessage($hwnd, $TB_SETBITMAPSIZE, 0x0, _WinAPI_MakeLong($iwidth, $iheight), 0x0, "wparam", "long") <> 0x0
EndFunc    ; -> _GUICtrlToolbar_SetBitmapSize

Func _GUICtrlToolbar_SetButtonBitMap($hwnd, $icommandid, $iindex)
    Return _SendMessage($hwnd, $TB_CHANGEBITMAP, $icommandid, $iindex) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_SetButtonBitMap

Func _GUICtrlToolbar_SetButtonInfo($hwnd, $icommandid, $iimage = + -3, $istate = + -1, $istyle = + -1, $iwidth = + -1, $iparam = + -1)
    Local $imask = 0x0
    Local $tbutton = DllStructCreate($TAGTBBUTTONINFO)
    If $iimage <> + -3 Then
        $imask = $TBIF_IMAGE
        DllStructSetData($tbutton, "Image", $iimage)
    EndIf
    If $istate <> + -1 Then
        $imask = BitOR($imask, $TBIF_STATE)
        DllStructSetData($tbutton, "State", $istate)
    EndIf
    If $istyle <> + -1 Then
        $imask = BitOR($imask, $TBIF_STYLE)
        DllStructSetData($tbutton, "Style", $istyle)
    EndIf
    If $iwidth <> + -1 Then
        $imask = BitOR($imask, $TBIF_SIZE)
        DllStructSetData($tbutton, "CX", $iwidth)
    EndIf
    If $iparam <> + -1 Then
        $imask = BitOR($imask, $TBIF_LPARAM)
        DllStructSetData($tbutton, "Param", $iparam)
    EndIf
    DllStructSetData($tbutton, "Mask", $imask)
    Return _GUICtrlToolbar_SetButtonInfoEx($hwnd, $icommandid, $tbutton)
EndFunc    ; -> _GUICtrlToolbar_SetButtonInfo

Func _GUICtrlToolbar_SetButtonInfoEx($hwnd, $icommandid, $tbutton)
    DllStructSetData($tbutton, "Size", DllStructGetSize($tbutton))
    Local $iret = __guictrl_sendmsg($hwnd, $TB_SETBUTTONINFOW, $icommandid, $tbutton, 0x0, True)
    Return $iret <> 0x0
EndFunc    ; -> _GUICtrlToolbar_SetButtonInfoEx

Func _GUICtrlToolbar_SetButtonParam($hwnd, $icommandid, $iparam)
    Local $tbutton = DllStructCreate($TAGTBBUTTONINFO)
    DllStructSetData($tbutton, "Mask", $TBIF_LPARAM)
    DllStructSetData($tbutton, "Param", $iparam)
    Return _GUICtrlToolbar_SetButtonInfoEx($hwnd, $icommandid, $tbutton)
EndFunc    ; -> _GUICtrlToolbar_SetButtonParam

Func _GUICtrlToolbar_SetButtonSize($hwnd, $iheight, $iwidth)
    Return _SendMessage($hwnd, $TB_SETBUTTONSIZE, 0x0, _WinAPI_MakeLong($iwidth, $iheight), 0x0, "wparam", "long") <> 0x0
EndFunc    ; -> _GUICtrlToolbar_SetButtonSize

Func _GUICtrlToolbar_SetButtonState($hwnd, $icommandid, $istate)
    Return _SendMessage($hwnd, $TB_SETSTATE, $icommandid, $istate) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_SetButtonState

Func _GUICtrlToolbar_SetButtonStyle($hwnd, $icommandid, $istyle)
    Local $tbutton = DllStructCreate($TAGTBBUTTONINFO)
    DllStructSetData($tbutton, "Mask", $TBIF_STYLE)
    DllStructSetData($tbutton, "Style", $istyle)
    Return _GUICtrlToolbar_SetButtonInfoEx($hwnd, $icommandid, $tbutton)
EndFunc    ; -> _GUICtrlToolbar_SetButtonStyle

Func _GUICtrlToolbar_SetButtonText($hwnd, $icommandid, $stext)
    Local $tbuffer = DllStructCreate("wchar Text[4096]")
    Local $tbutton = DllStructCreate($TAGTBBUTTONINFO)
    DllStructSetData($tbuffer, "Text", $stext)
    DllStructSetData($tbutton, "Mask", $TBIF_TEXT)
    DllStructSetData($tbutton, "Text", DllStructGetPtr($tbuffer))
    DllStructSetData($tbutton, "TextMax", DllStructGetSize($tbuffer))
    Return _GUICtrlToolbar_SetButtonInfoEx($hwnd, $icommandid, $tbutton)
EndFunc    ; -> _GUICtrlToolbar_SetButtonText

Func _GUICtrlToolbar_SetButtonWidth($hwnd, $imin, $imax)
    Return _SendMessage($hwnd, $TB_SETBUTTONWIDTH, 0x0, _WinAPI_MakeLong($imin, $imax), 0x0, "wparam", "long") <> 0x0
EndFunc    ; -> _GUICtrlToolbar_SetButtonWidth

Func _GUICtrlToolbar_SetCmdID($hwnd, $iindex, $icommandid)
    Return _SendMessage($hwnd, $TB_SETCMDID, $iindex, $icommandid) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_SetCmdID

Func _GUICtrlToolbar_SetColorScheme($hwnd, $ihighlight, $ishadow)
    Local $tcolor = DllStructCreate($TAGCOLORSCHEME)
    Local $icolor = DllStructGetSize($tcolor)
    DllStructSetData($tcolor, "Size", $icolor)
    DllStructSetData($tcolor, "BtnHighlight", $ihighlight)
    DllStructSetData($tcolor, "BtnShadow", $ishadow)
    __guictrl_sendmsg($hwnd, $TB_SETCOLORSCHEME, 0x0, $tcolor)
EndFunc    ; -> _GUICtrlToolbar_SetColorScheme

Func _GUICtrlToolbar_SetDisabledImageList($hwnd, $himagelist)
    Return _SendMessage($hwnd, $TB_SETDISABLEDIMAGELIST, 0x0, $himagelist, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlToolbar_SetDisabledImageList

Func _GUICtrlToolbar_SetDrawTextFlags($hwnd, $imask, $idtflags)
    Return _SendMessage($hwnd, $TB_SETDRAWTEXTFLAGS, $imask, $idtflags)
EndFunc    ; -> _GUICtrlToolbar_SetDrawTextFlags

Func _GUICtrlToolbar_SetExtendedStyle($hwnd, $istyle)
    Return _SendMessage($hwnd, $TB_SETEXTENDEDSTYLE, 0x0, $istyle)
EndFunc    ; -> _GUICtrlToolbar_SetExtendedStyle

Func _GUICtrlToolbar_SetHotImageList($hwnd, $himagelist)
    Return _SendMessage($hwnd, $TB_SETHOTIMAGELIST, 0x0, $himagelist, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlToolbar_SetHotImageList

Func _GUICtrlToolbar_SetHotItem($hwnd, $iindex)
    Return _SendMessage($hwnd, $TB_SETHOTITEM, $iindex)
EndFunc    ; -> _GUICtrlToolbar_SetHotItem

Func _GUICtrlToolbar_SetImageList($hwnd, $himagelist)
    Return _SendMessage($hwnd, $TB_SETIMAGELIST, 0x0, $himagelist, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlToolbar_SetImageList

Func _GUICtrlToolbar_SetIndent($hwnd, $iindent)
    Return _SendMessage($hwnd, $TB_SETINDENT, $iindent) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_SetIndent

Func _GUICtrlToolbar_SetIndeterminate($hwnd, $icommandid, $bstate = True)
    Return _SendMessage($hwnd, $TB_INDETERMINATE, $icommandid, $bstate) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_SetIndeterminate

Func _GUICtrlToolbar_SetInsertMark($hwnd, $ibutton, $IFLAGS = 0x0)
    Local $tmark = DllStructCreate($TAGTBINSERTMARK)
    DllStructSetData($tmark, "Button", $ibutton)
    DllStructSetData($tmark, "Flags", $IFLAGS)
    __guictrl_sendmsg($hwnd, $TB_SETINSERTMARK, 0x0, $tmark)
EndFunc    ; -> _GUICtrlToolbar_SetInsertMark

Func _GUICtrlToolbar_SetInsertMarkColor($hwnd, $icolor)
    Return _SendMessage($hwnd, $TB_SETINSERTMARKCOLOR, 0x0, $icolor)
EndFunc    ; -> _GUICtrlToolbar_SetInsertMarkColor

Func _GUICtrlToolbar_SetMaxTextRows($hwnd, $imaxrows)
    Return _SendMessage($hwnd, $TB_SETMAXTEXTROWS, $imaxrows) <> 0x0
EndFunc    ; -> _GUICtrlToolbar_SetMaxTextRows

Func _GUICtrlToolbar_SetMetrics($hwnd, $ixpad, $iypad, $ixspacing, $iyspacing)
    Local $tmetrics = DllStructCreate($TAGTBMETRICS)
    Local $imetrics = DllStructGetSize($tmetrics)
    Local $imask = BitOR($TBMF_PAD, $TBMF_BUTTONSPACING)
    DllStructSetData($tmetrics, "Size", $imetrics)
    DllStructSetData($tmetrics, "Mask", $imask)
    DllStructSetData($tmetrics, "XPad", $ixpad)
    DllStructSetData($tmetrics, "YPad", $iypad)
    DllStructSetData($tmetrics, "XSpacing", $ixspacing)
    DllStructSetData($tmetrics, "YSpacing", $iyspacing)
    __guictrl_sendmsg($hwnd, $TB_SETMETRICS, 0x0, $tmetrics)
EndFunc    ; -> _GUICtrlToolbar_SetMetrics

Func _GUICtrlToolbar_SetPadding($hwnd, $icx, $icy)
    Return _SendMessage($hwnd, $TB_SETPADDING, 0x0, _WinAPI_MakeLong($icx, $icy), 0x0, "wparam", "long")
EndFunc    ; -> _GUICtrlToolbar_SetPadding

Func _GUICtrlToolbar_SetParent($hwnd, $hparent)
    Return HWnd(_SendMessage($hwnd, $TB_SETPARENT, $hparent))
EndFunc    ; -> _GUICtrlToolbar_SetParent

Func _GUICtrlToolbar_SetRows($hwnd, $irows, $blarger = True)
    Local $trect = DllStructCreate($TAGRECT)
    __guictrl_sendmsg($hwnd, $TB_SETROWS, _WinAPI_MakeLong($irows, $blarger), $trect, 0x0, True)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlToolbar_SetRows

Func _GUICtrlToolbar_SetStyle($hwnd, $istyle)
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__TOOLBARCONSTANT_WS_CLIPSIBLINGS, $__UDFGUICONSTANT_WS_VISIBLE)
    _SendMessage($hwnd, $TB_SETSTYLE, 0x0, $istyle)
EndFunc    ; -> _GUICtrlToolbar_SetStyle

Func _GUICtrlToolbar_SetStyleAltDrag($hwnd, $bstate = True)
    Return __GUICtrlToolbar_SetStyleEx($hwnd, $TBSTYLE_ALTDRAG, $bstate)
EndFunc    ; -> _GUICtrlToolbar_SetStyleAltDrag

Func _GUICtrlToolbar_SetStyleCustomErase($hwnd, $bstate = True)
    Return __GUICtrlToolbar_SetStyleEx($hwnd, $TBSTYLE_CUSTOMERASE, $bstate)
EndFunc    ; -> _GUICtrlToolbar_SetStyleCustomErase

Func __GUICtrlToolbar_SetStyleEx($hwnd, $istyle, $bstyle)
    Local $in = _GUICtrlToolbar_GetStyle($hwnd)
    If $bstyle Then
        $in = BitOR($in, $istyle)
    Else
        $in = BitAND($in, BitNOT($istyle))
    EndIf
    Return _GUICtrlToolbar_SetStyle($hwnd, $in)
EndFunc    ; -> __GUICtrlToolbar_SetStyleEx

Func _GUICtrlToolbar_SetStyleFlat($hwnd, $bstate)
    Return __GUICtrlToolbar_SetStyleEx($hwnd, $TBSTYLE_FLAT, $bstate)
EndFunc    ; -> _GUICtrlToolbar_SetStyleFlat

Func _GUICtrlToolbar_SetStyleList($hwnd, $bstate)
    Return __GUICtrlToolbar_SetStyleEx($hwnd, $TBSTYLE_LIST, $bstate)
EndFunc    ; -> _GUICtrlToolbar_SetStyleList

Func _GUICtrlToolbar_SetStyleRegisterDrop($hwnd, $bstate)
    Return __GUICtrlToolbar_SetStyleEx($hwnd, $TBSTYLE_REGISTERDROP, $bstate)
EndFunc    ; -> _GUICtrlToolbar_SetStyleRegisterDrop

Func _GUICtrlToolbar_SetStyleToolTips($hwnd, $bstate)
    Return __GUICtrlToolbar_SetStyleEx($hwnd, $TBSTYLE_TOOLTIPS, $bstate)
EndFunc    ; -> _GUICtrlToolbar_SetStyleToolTips

Func _GUICtrlToolbar_SetStyleTransparent($hwnd, $bstate)
    Return __GUICtrlToolbar_SetStyleEx($hwnd, $TBSTYLE_TRANSPARENT, $bstate)
EndFunc    ; -> _GUICtrlToolbar_SetStyleTransparent

Func _GUICtrlToolbar_SetStyleWrapable($hwnd, $bstate)
    Return __GUICtrlToolbar_SetStyleEx($hwnd, $TBSTYLE_WRAPABLE, $bstate)
EndFunc    ; -> _GUICtrlToolbar_SetStyleWrapable

Func _GUICtrlToolbar_SetToolTips($hwnd, $htooltip)
    _SendMessage($hwnd, $TB_SETTOOLTIPS, $htooltip, 0x0, 0x0, "hwnd")
EndFunc    ; -> _GUICtrlToolbar_SetToolTips

Func _GUICtrlToolbar_SetUnicodeFormat($hwnd, $bunicode = False)
    Return _SendMessage($hwnd, $TB_SETUNICODEFORMAT, $bunicode)
EndFunc    ; -> _GUICtrlToolbar_SetUnicodeFormat

Func _GUICtrlToolbar_SetWindowTheme($hwnd, $stheme)
    Local $ttheme = _WinAPI_MultiByteToWideChar($stheme)
    __guictrl_sendmsg($hwnd, $TB_SETWINDOWTHEME, 0x0, $ttheme)
EndFunc    ; -> _GUICtrlToolbar_SetWindowTheme

Global $__g_tttbuffer = DllStructCreate("wchar Text[4096]")
Global Const $_TOOLTIPCONSTANTS_CLASSNAME = "tooltips_class32"
Global Const $_TT_GHTTDEFAULTSTYLE = BitOR($TTS_ALWAYSTIP, $TTS_NOPREFIX)
Global Const $TAGNMTTDISPINFO = $tagnmhdr & ";ptr pText;wchar aText[80];ptr Instance;uint Flags;lparam Param"
Global Const $TAGTOOLINFO = "struct; uint Size;uint Flags;hwnd hWnd;uint_ptr ID;" & $TAGRECT & ";handle hInst;ptr Text;lparam Param;ptr Reserved ; endstruct"
Global Const $TAGTTGETTITLE = "dword Size;uint Bitmap;uint TitleMax;ptr Title"
Global Const $TAGTTHITTESTINFO = "hwnd Tool;" & $TAGPOINT & ";" & $TAGTOOLINFO
Func _GUIToolTip_Activate($hwnd)
    _SendMessage($hwnd, $TTM_ACTIVATE, True)
EndFunc    ; -> _GUIToolTip_Activate

Func _GUIToolTip_AddTool($htool, $hwnd, $stext, $iid = 0x0, $ileft = 0x0, $itop = 0x0, $iright = 0x0, $ibottom = 0x0, $IFLAGS = Default, $iparam = 0x0)
    Local $tbuffer, $pbuffer
    If $IFLAGS = Default Then $IFLAGS = BitOR($TTF_SUBCLASS, $TTF_IDISHWND)
    If $stext <> + -1 Then
        $tbuffer = $__g_tttbuffer
        $pbuffer = DllStructGetPtr($tbuffer)
        DllStructSetData($tbuffer, "Text", $stext)
    Else
        $tbuffer = 0x0
        $pbuffer = + -1
    EndIf
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    DllStructSetData($ttoolinfo, "Flags", $IFLAGS)
    DllStructSetData($ttoolinfo, "hWnd", $hwnd)
    DllStructSetData($ttoolinfo, "ID", $iid)
    DllStructSetData($ttoolinfo, "Left", $ileft)
    DllStructSetData($ttoolinfo, "Top", $itop)
    DllStructSetData($ttoolinfo, "Right", $iright)
    DllStructSetData($ttoolinfo, "Bottom", $ibottom)
    DllStructSetData($ttoolinfo, "Param", $iparam)
    DllStructSetData($ttoolinfo, "Text", $pbuffer)
    Local $iret = __guictrl_sendmsg($htool, $TTM_ADDTOOLW, 0x0, $ttoolinfo, $tbuffer, False, + -1)
    Return $iret <> 0x0
EndFunc    ; -> _GUIToolTip_AddTool

Func _GUIToolTip_AdjustRect($hwnd, ByRef $trect, $blarger = True)
    __guictrl_sendmsg($hwnd, $TTM_ADJUSTRECT, $blarger, $trect, 0x0, True)
    Return $trect
EndFunc    ; -> _GUIToolTip_AdjustRect

Func _GUIToolTip_BitsToTTF($IFLAGS)
    Local $in = ''
    If BitAND($IFLAGS, $TTF_IDISHWND) <> 0x0 Then $in &= "TTF_IDISHWND,"
    If BitAND($IFLAGS, $TTF_CENTERTIP) <> 0x0 Then $in &= "TTF_CENTERTIP,"
    If BitAND($IFLAGS, $TTF_RTLREADING) <> 0x0 Then $in &= "TTF_RTLREADING,"
    If BitAND($IFLAGS, $TTF_SUBCLASS) <> 0x0 Then $in &= "TTF_SUBCLASS,"
    If BitAND($IFLAGS, $TTF_TRACK) <> 0x0 Then $in &= "TTF_TRACK,"
    If BitAND($IFLAGS, $TTF_ABSOLUTE) <> 0x0 Then $in &= "TTF_ABSOLUTE,"
    If BitAND($IFLAGS, $TTF_TRANSPARENT) <> 0x0 Then $in &= "TTF_TRANSPARENT,"
    If BitAND($IFLAGS, $TTF_PARSELINKS) <> 0x0 Then $in &= "TTF_PARSELINKS,"
    Return StringTrimRight($in, 0x1)
EndFunc    ; -> _GUIToolTip_BitsToTTF

Func _GUIToolTip_Create($hwnd, $istyle = $_TT_GHTTDEFAULTSTYLE)
    Return _WinAPI_CreateWindowEx(0x0, $_TOOLTIPCONSTANTS_CLASSNAME, '', $istyle, 0x0, 0x0, 0x0, 0x0, $hwnd)
EndFunc    ; -> _GUIToolTip_Create

Func _GUIToolTip_Deactivate($hwnd)
    _SendMessage($hwnd, $TTM_ACTIVATE, False)
EndFunc    ; -> _GUIToolTip_Deactivate

Func _GUIToolTip_DelTool($hwnd, $htool, $iid = 0x0)
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    DllStructSetData($ttoolinfo, "ID", $iid)
    DllStructSetData($ttoolinfo, "hWnd", $htool)
    __guictrl_sendmsg($hwnd, $TTM_DELTOOLW, 0x0, $ttoolinfo)
EndFunc    ; -> _GUIToolTip_DelTool

Func _GUIToolTip_Destroy(ByRef $hwnd)
    If Not _WinAPI_IsClassName($hwnd, $_TOOLTIPCONSTANTS_CLASSNAME) Then Return SetError(0x2, 0x2, False)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
        Else
            Return SetError(0x1, 0x1, False)
        EndIf
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUIToolTip_Destroy

Func _GUIToolTip_EnumTools($hwnd, $iindex)
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    Local $bresult = __guictrl_sendmsg($hwnd, $TTM_ENUMTOOLSW, $iindex, $ttoolinfo, 0x0, True)
    Return _GUIToolTip_ToolToArray($hwnd, $ttoolinfo, ($bresult = True))
EndFunc    ; -> _GUIToolTip_EnumTools

Func _GUIToolTip_GetBubbleHeight($hwnd, $htool, $iid, $IFLAGS = Default)
    If $IFLAGS = Default Then $IFLAGS = BitOR($TTF_IDISHWND, $TTF_SUBCLASS)
    Return _WinAPI_HiWord(_GUIToolTip_GetBubbleSize($hwnd, $htool, $iid, $IFLAGS))
EndFunc    ; -> _GUIToolTip_GetBubbleHeight

Func _GUIToolTip_GetBubbleSize($hwnd, $htool, $iid, $IFLAGS = Default)
    If $IFLAGS = Default Then $IFLAGS = BitOR($TTF_IDISHWND, $TTF_SUBCLASS)
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    DllStructSetData($ttoolinfo, "hWnd", $htool)
    DllStructSetData($ttoolinfo, "ID", $iid)
    DllStructSetData($ttoolinfo, "Flags", $IFLAGS)
    Local $iret = __guictrl_sendmsg($hwnd, $TTM_GETBUBBLESIZE, 0x0, $ttoolinfo)
    Return $iret
EndFunc    ; -> _GUIToolTip_GetBubbleSize

Func _GUIToolTip_GetBubbleWidth($hwnd, $htool, $iid, $IFLAGS = Default)
    If $IFLAGS = Default Then $IFLAGS = BitOR($TTF_IDISHWND, $TTF_SUBCLASS)
    Return _WinAPI_LoWord(_GUIToolTip_GetBubbleSize($hwnd, $htool, $iid, $IFLAGS))
EndFunc    ; -> _GUIToolTip_GetBubbleWidth

Func _GUIToolTip_GetCurrentTool($hwnd)
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    Local $bresult = __guictrl_sendmsg($hwnd, $TTM_GETCURRENTTOOLW, 0x0, $ttoolinfo, 0x0, True)
    Return _GUIToolTip_ToolToArray($hwnd, $ttoolinfo, $bresult = True)
EndFunc    ; -> _GUIToolTip_GetCurrentTool

Func _GUIToolTip_GetDelayTime($hwnd, $iduration)
    Return _SendMessage($hwnd, $TTM_GETDELAYTIME, $iduration)
EndFunc    ; -> _GUIToolTip_GetDelayTime

Func _GUIToolTip_GetMargin($hwnd)
    Local $amargin[0x4]
    Local $trect = _GUIToolTip_GetMarginEx($hwnd)
    $amargin[0x0] = DllStructGetData($trect, "Left")
    $amargin[0x1] = DllStructGetData($trect, "Top")
    $amargin[0x2] = DllStructGetData($trect, "Right")
    $amargin[0x3] = DllStructGetData($trect, "Bottom")
    Return $amargin
EndFunc    ; -> _GUIToolTip_GetMargin

Func _GUIToolTip_GetMarginEx($hwnd)
    Local $trect = DllStructCreate($TAGRECT)
    __guictrl_sendmsg($hwnd, $TTM_GETMARGIN, 0x0, $trect, 0x0, True)
    Return $trect
EndFunc    ; -> _GUIToolTip_GetMarginEx

Func _GUIToolTip_GetMaxTipWidth($hwnd)
    Return _SendMessage($hwnd, $TTM_GETMAXTIPWIDTH)
EndFunc    ; -> _GUIToolTip_GetMaxTipWidth

Func _GUIToolTip_GetText($hwnd, $htool, $iid)
    Local $tbuffer = $__g_tttbuffer
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    DllStructSetData($ttoolinfo, "hWnd", $htool)
    DllStructSetData($ttoolinfo, "ID", $iid)
    __guictrl_sendmsg($hwnd, $TTM_GETTEXTW, 0x0, $ttoolinfo, $tbuffer, False, 0xa, True, + -1)
    Return DllStructGetData($tbuffer, "Text")
EndFunc    ; -> _GUIToolTip_GetText

Func _GUIToolTip_GetTipBkColor($hwnd)
    Return _SendMessage($hwnd, $TTM_GETTIPBKCOLOR)
EndFunc    ; -> _GUIToolTip_GetTipBkColor

Func _GUIToolTip_GetTipTextColor($hwnd)
    Return _SendMessage($hwnd, $TTM_GETTIPTEXTCOLOR)
EndFunc    ; -> _GUIToolTip_GetTipTextColor

Func _GUIToolTip_GetTitleBitMap($hwnd)
    Local $tbuffer = $__g_tttbuffer
    Local $ttitle = DllStructCreate($TAGTTGETTITLE)
    Local $ititle = DllStructGetSize($ttitle)
    DllStructSetData($ttitle, "TitleMax", DllStructGetSize($tbuffer))
    DllStructSetData($ttitle, "Size", $ititle)
    __guictrl_sendmsg($hwnd, $TTM_GETTITLE, 0x0, $ttitle, $tbuffer, False, 0x4, True, + -1)
    Return DllStructGetData($ttitle, "Bitmap")
EndFunc    ; -> _GUIToolTip_GetTitleBitMap

Func _GUIToolTip_GetTitleText($hwnd)
    Local $tbuffer = $__g_tttbuffer
    Local $ttitle = DllStructCreate($TAGTTGETTITLE)
    Local $ititle = DllStructGetSize($ttitle)
    DllStructSetData($ttitle, "TitleMax", DllStructGetSize($tbuffer))
    DllStructSetData($ttitle, "Size", $ititle)
    __guictrl_sendmsg($hwnd, $TTM_GETTITLE, 0x0, $ttitle, $tbuffer, False, 0x4, True, + -1)
    Return DllStructGetData($tbuffer, "Text")
EndFunc    ; -> _GUIToolTip_GetTitleText

Func _GUIToolTip_GetToolCount($hwnd)
    Return _SendMessage($hwnd, $TTM_GETTOOLCOUNT)
EndFunc    ; -> _GUIToolTip_GetToolCount

Func _GUIToolTip_GetToolInfo($hwnd, $htool, $iid)
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    DllStructSetData($ttoolinfo, "hWnd", $htool)
    DllStructSetData($ttoolinfo, "ID", $iid)
    Local $bresult = _SendMessage($hwnd, $TTM_GETTOOLINFOW, 0x0, $ttoolinfo, 0x0, True)
    Return _GUIToolTip_ToolToArray($hwnd, $ttoolinfo, ($bresult = True))
EndFunc    ; -> _GUIToolTip_GetToolInfo

Func _GUIToolTip_HitTest($hwnd, $htool, $ix, $iy)
    Local $thittest = DllStructCreate($TAGTTHITTESTINFO)
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($thittest, "Tool", $htool)
    DllStructSetData($thittest, "X", $ix)
    DllStructSetData($thittest, "Y", $iy)
    DllStructSetData($thittest, "Size", $itoolinfo)
    Local $bresult = __guictrl_sendmsg($hwnd, $TTM_HITTESTW, 0x0, $thittest, 0x0, True)
    DllStructSetData($ttoolinfo, "Size", DllStructGetData($thittest, "Size"))
    DllStructSetData($ttoolinfo, "Flags", DllStructGetData($thittest, "Flags"))
    DllStructSetData($ttoolinfo, "hWnd", DllStructGetData($thittest, "hWnd"))
    DllStructSetData($ttoolinfo, "ID", DllStructGetData($thittest, "ID"))
    DllStructSetData($ttoolinfo, "Left", DllStructGetData($thittest, "Left"))
    DllStructSetData($ttoolinfo, "Top", DllStructGetData($thittest, "Top"))
    DllStructSetData($ttoolinfo, "Right", DllStructGetData($thittest, "Right"))
    DllStructSetData($ttoolinfo, "Bottom", DllStructGetData($thittest, "Bottom"))
    DllStructSetData($ttoolinfo, "hInst", DllStructGetData($thittest, "hInst"))
    DllStructSetData($ttoolinfo, "Param", DllStructGetData($thittest, "Param"))
    Return _GUIToolTip_ToolToArray($hwnd, $ttoolinfo, $bresult = True)
EndFunc    ; -> _GUIToolTip_HitTest

Func _GUIToolTip_NewToolRect($hwnd, $htool, $iid, $ileft, $itop, $iright, $ibottom)
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    DllStructSetData($ttoolinfo, "hwnd", $htool)
    DllStructSetData($ttoolinfo, "ID", $iid)
    DllStructSetData($ttoolinfo, "Left", $ileft)
    DllStructSetData($ttoolinfo, "Top", $itop)
    DllStructSetData($ttoolinfo, "Right", $iright)
    DllStructSetData($ttoolinfo, "Bottom", $ibottom)
    __guictrl_sendmsg($hwnd, $TTM_NEWTOOLRECTW, 0x0, $ttoolinfo)
EndFunc    ; -> _GUIToolTip_NewToolRect

Func _GUIToolTip_Pop($hwnd)
    _SendMessage($hwnd, $TTM_POP)
EndFunc    ; -> _GUIToolTip_Pop

Func _GUIToolTip_PopUp($hwnd)
    _SendMessage($hwnd, $TTM_POPUP)
EndFunc    ; -> _GUIToolTip_PopUp

Func _GUIToolTip_SetDelayTime($hwnd, $iduration, $itime)
    _SendMessage($hwnd, $TTM_SETDELAYTIME, $iduration, $itime)
EndFunc    ; -> _GUIToolTip_SetDelayTime

Func _GUIToolTip_SetMargin($hwnd, $ileft, $itop, $iright, $ibottom)
    Local $trect = DllStructCreate($TAGRECT)
    DllStructSetData($trect, "Left", $ileft)
    DllStructSetData($trect, "Top", $itop)
    DllStructSetData($trect, "Right", $iright)
    DllStructSetData($trect, "Bottom", $ibottom)
    __guictrl_sendmsg($hwnd, $TTM_SETMARGIN, 0x0, $trect)
EndFunc    ; -> _GUIToolTip_SetMargin

Func _GUIToolTip_SetMaxTipWidth($hwnd, $iwidth)
    Return _SendMessage($hwnd, $TTM_SETMAXTIPWIDTH, 0x0, $iwidth)
EndFunc    ; -> _GUIToolTip_SetMaxTipWidth

Func _GUIToolTip_SetTipBkColor($hwnd, $icolor)
    _SendMessage($hwnd, $TTM_SETTIPBKCOLOR, $icolor)
EndFunc    ; -> _GUIToolTip_SetTipBkColor

Func _GUIToolTip_SetTipTextColor($hwnd, $icolor)
    _SendMessage($hwnd, $TTM_SETTIPTEXTCOLOR, $icolor)
EndFunc    ; -> _GUIToolTip_SetTipTextColor

Func _GUIToolTip_SetTitle($hwnd, $STITLE, $iicon = 0x0)
    Local $tbuffer = $__g_tttbuffer
    DllStructSetData($tbuffer, "Text", $STITLE)
    Local $iret = __guictrl_sendmsg($hwnd, $TTM_SETTITLEW, $iicon, $tbuffer)
    Return $iret <> 0x0
EndFunc    ; -> _GUIToolTip_SetTitle

Func _GUIToolTip_SetToolInfo($hwnd, $stext, $iid = 0x0, $ileft = 0x0, $itop = 0x0, $iright = 0x0, $ibottom = 0x0, $IFLAGS = Default, $iparam = 0x0)
    If $IFLAGS = Default Then $IFLAGS = BitOR($TTF_SUBCLASS, $TTF_IDISHWND)
    Local $tbuffer = $__g_tttbuffer
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($tbuffer, "Text", $stext)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    DllStructSetData($ttoolinfo, "Flags", $IFLAGS)
    DllStructSetData($ttoolinfo, "hWnd", $hwnd)
    DllStructSetData($ttoolinfo, "ID", $iid)
    DllStructSetData($ttoolinfo, "Left", $ileft)
    DllStructSetData($ttoolinfo, "Top", $itop)
    DllStructSetData($ttoolinfo, "Right", $iright)
    DllStructSetData($ttoolinfo, "Bottom", $ibottom)
    DllStructSetData($ttoolinfo, "Param", $iparam)
    __guictrl_sendmsg($hwnd, $TTM_SETTOOLINFOW, 0x0, $ttoolinfo, $tbuffer, False, 0xa, False, + -1)
EndFunc    ; -> _GUIToolTip_SetToolInfo

Func _GUIToolTip_SetWindowTheme($hwnd, $sstyle)
    Local $tbuffer = _WinAPI_MultiByteToWideChar($sstyle)
    __guictrl_sendmsg($hwnd, $TTM_SETWINDOWTHEME, 0x0, $tbuffer)
EndFunc    ; -> _GUIToolTip_SetWindowTheme

Func _GUIToolTip_ToolExists($hwnd)
    Return _SendMessage($hwnd, $TTM_GETCURRENTTOOL) <> 0x0
EndFunc    ; -> _GUIToolTip_ToolExists

Func _GUIToolTip_ToolToArray($hwnd, ByRef $ttoolinfo, $ierror)
    Local $atool[0xa]
    $atool[0x0] = DllStructGetData($ttoolinfo, "Flags")
    $atool[0x1] = DllStructGetData($ttoolinfo, "hWnd")
    $atool[0x2] = DllStructGetData($ttoolinfo, "ID")
    $atool[0x3] = DllStructGetData($ttoolinfo, "Left")
    $atool[0x4] = DllStructGetData($ttoolinfo, "Top")
    $atool[0x5] = DllStructGetData($ttoolinfo, "Right")
    $atool[0x6] = DllStructGetData($ttoolinfo, "Bottom")
    $atool[0x7] = DllStructGetData($ttoolinfo, "hInst")
    $atool[0x8] = _GUIToolTip_GetText($hwnd, $atool[0x1], $atool[0x2])
    $atool[0x9] = DllStructGetData($ttoolinfo, "Param")
    Return SetError($ierror, 0x0, $atool)
EndFunc    ; -> _GUIToolTip_ToolToArray

Func _GUIToolTip_TrackActivate($hwnd, $bactivate = True, $htool = 0x0, $iid = 0x0)
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    DllStructSetData($ttoolinfo, "hWnd", $htool)
    DllStructSetData($ttoolinfo, "ID", $iid)
    __guictrl_sendmsg($hwnd, $TTM_TRACKACTIVATE, $bactivate, $ttoolinfo)
EndFunc    ; -> _GUIToolTip_TrackActivate

Func _GUIToolTip_TrackPosition($hwnd, $ix, $iy)
    _SendMessage($hwnd, $TTM_TRACKPOSITION, 0x0, _WinAPI_MakeLong($ix, $iy))
EndFunc    ; -> _GUIToolTip_TrackPosition

Func _GUIToolTip_Update($hwnd)
    _SendMessage($hwnd, $TTM_UPDATE)
EndFunc    ; -> _GUIToolTip_Update

Func _GUIToolTip_UpdateTipText($hwnd, $htool, $iid, $stext)
    Local $tbuffer = $__g_tttbuffer
    Local $ttoolinfo = DllStructCreate($TAGTOOLINFO)
    Local $itoolinfo = DllStructGetSize($ttoolinfo)
    DllStructSetData($tbuffer, "Text", $stext)
    DllStructSetData($ttoolinfo, "Size", $itoolinfo)
    DllStructSetData($ttoolinfo, "hWnd", $htool)
    DllStructSetData($ttoolinfo, "ID", $iid)
    __guictrl_sendmsg($hwnd, $TTM_UPDATETIPTEXTW, 0x0, $ttoolinfo, $tbuffer, False, 0xa, False, + -1)
EndFunc    ; -> _GUIToolTip_UpdateTipText

Global $__g_ttvbuffer, $__g_ttvbufferansi
Global $__g_ttvitemex = DllStructCreate($TAGTVITEMEX)
Global Const $__TREEVIEWCONSTANT_CLASSNAME = "SysTreeView32"
Global Const $__TREEVIEWCONSTANT_WM_SETREDRAW = 0xb
Global Const $__TREEVIEWCONSTANT_DEFAULT_GUI_FONT = 0x11
Global Const $TAGTVINSERTSTRUCT = "struct; handle Parent;handle InsertAfter;" & $TAGTVITEMEX & " ;endstruct"
Func _GUICtrlTreeView_Add($hwnd, $hsibling, $stext, $iimage = + -1, $iselimage = + -1)
    Return __GUICtrlTreeView_AddItem($hwnd, $hsibling, $stext, $TVNA_ADD, $iimage, $iselimage)
EndFunc    ; -> _GUICtrlTreeView_Add

Func _GUICtrlTreeView_AddChild($hwnd, $hparent, $stext, $iimage = + -1, $iselimage = + -1)
    Return __GUICtrlTreeView_AddItem($hwnd, $hparent, $stext, $TVNA_ADDCHILD, $iimage, $iselimage)
EndFunc    ; -> _GUICtrlTreeView_AddChild

Func _GUICtrlTreeView_AddChildFirst($hwnd, $hparent, $stext, $iimage = + -1, $iselimage = + -1)
    Return __GUICtrlTreeView_AddItem($hwnd, $hparent, $stext, $TVNA_ADDCHILDFIRST, $iimage, $iselimage)
EndFunc    ; -> _GUICtrlTreeView_AddChildFirst

Func _GUICtrlTreeView_AddFirst($hwnd, $hsibling, $stext, $iimage = + -1, $iselimage = + -1)
    Return __GUICtrlTreeView_AddItem($hwnd, $hsibling, $stext, $TVNA_ADDFIRST, $iimage, $iselimage)
EndFunc    ; -> _GUICtrlTreeView_AddFirst

Func __GUICtrlTreeView_AddItem($hwnd, $hrelative, $stext, $imethod, $iimage = + -1, $iselimage = + -1, $iparam = 0x0)
    Local $iaddmode
    Switch $imethod
    Case $TVNA_ADD, $TVNA_ADDCHILD
        $iaddmode = $TVTA_ADD
    Case $TVNA_ADDFIRST, $TVNA_ADDCHILDFIRST
        $iaddmode = $TVTA_ADDFIRST
    Case Else
        $iaddmode = $TVTA_INSERT
    EndSwitch
    Local $hitem, $hitemid = 0x0
    If $hrelative <> 0x0 Then
        Switch $imethod
        Case $TVNA_ADD, $TVNA_ADDFIRST
            $hitem = _GUICtrlTreeView_GetParentHandle($hwnd, $hrelative)
        Case $TVNA_ADDCHILD, $TVNA_ADDCHILDFIRST
            $hitem = $hrelative
        Case Else
            $hitem = _GUICtrlTreeView_GetParentHandle($hwnd, $hrelative)
            $hitemid = _GUICtrlTreeView_GetPrevSibling($hwnd, $hrelative)
            If $hitemid = 0x0 Then $iaddmode = $TVTA_ADDFIRST
        EndSwitch
    EndIf
    Local $tbuffer, $imsg
    If _GUICtrlTreeView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_ttvbuffer
        $imsg = $TVM_INSERTITEMW
    Else
        $tbuffer = $__g_ttvbufferansi
        $imsg = $TVM_INSERTITEMA
    EndIf
    Local $tinsert = DllStructCreate($TAGTVINSERTSTRUCT)
    Switch $iaddmode
    Case $TVTA_ADDFIRST
        DllStructSetData($tinsert, "InsertAfter", $TVI_FIRST)
    Case $TVTA_ADD
        DllStructSetData($tinsert, "InsertAfter", $TVI_LAST)
    Case $TVTA_INSERT
        DllStructSetData($tinsert, "InsertAfter", $hitemid)
    EndSwitch
    Local $imask = BitOR($TVIF_TEXT, $TVIF_PARAM)
    If $iimage >= 0x0 Then $imask = BitOR($imask, $TVIF_IMAGE)
    If $iselimage >= 0x0 Then $imask = BitOR($imask, $TVIF_SELECTEDIMAGE)
    DllStructSetData($tbuffer, "Text", $stext)
    DllStructSetData($tinsert, "Parent", $hitem)
    DllStructSetData($tinsert, "Mask", $imask)
    DllStructSetData($tinsert, "Image", $iimage)
    DllStructSetData($tinsert, "SelectedImage", $iselimage)
    DllStructSetData($tinsert, "Param", $iparam)
    Local $hresult = Ptr(__guictrl_sendmsg($hwnd, $imsg, 0x0, $tinsert, $tbuffer, False, 0x7))
    Return $hresult
EndFunc    ; -> __GUICtrlTreeView_AddItem

Func _GUICtrlTreeView_BeginUpdate($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $__TREEVIEWCONSTANT_WM_SETREDRAW, False) = 0x0
EndFunc    ; -> _GUICtrlTreeView_BeginUpdate

Func _GUICtrlTreeView_ClickItem($hwnd, $hitem, $sbutton = "left", $bmove = False, $iclicks = 0x1, $ispeed = 0x0)
    Local $trect = _GUICtrlTreeView_DisplayRectEx($hwnd, $hitem, True)
    If @error Then Return SetError(@error, @error, 0x0)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $tpoint = _WinAPI_PointFromRect($trect, False)
    _WinAPI_ClientToScreen($hwnd, $tpoint)
    Local $ix, $iy
    _WinAPI_GetXYFromPoint($tpoint, $ix, $iy)
    Local $imode = Opt("MouseCoordMode", 0x1)
    If Not $bmove Then
        Local $apos = MouseGetPos()
        _WinAPI_ShowCursor(False)
        MouseClick($sbutton, $ix, $iy, $iclicks, $ispeed)
        MouseMove($apos[0x0], $apos[0x1], 0x0)
        _WinAPI_ShowCursor(True)
    Else
        MouseClick($sbutton, $ix, $iy, $iclicks, $ispeed)
    EndIf
    Opt("MouseCoordMode", $imode)
    Return 0x1
EndFunc    ; -> _GUICtrlTreeView_ClickItem

Func _GUICtrlTreeView_Create($hwnd, $ix, $iy, $iwidth = 0x96, $iheight = 0x96, $istyle = 0x37, $iexstyle = 0x0)
    If Not IsHWnd($hwnd) Then
        Return SetError(0x1, 0x0, 0x0)
    EndIf
    If $iwidth = + -1 Then $iwidth = 0x96
    If $iheight = + -1 Then $iheight = 0x96
    If $istyle = + -1 Then $istyle = BitOR($TVS_SHOWSELALWAYS, $TVS_DISABLEDRAGDROP, $TVS_LINESATROOT, $TVS_HASLINES, $TVS_HASBUTTONS)
    If $iexstyle = + -1 Then $iexstyle = 0x0
    $istyle = BitOR($istyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
    Local $nctrlid = __UDF_GetNextGlobalID($hwnd)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $htree = _WinAPI_CreateWindowEx($iexstyle, $__TREEVIEWCONSTANT_CLASSNAME, '', $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
    _WinAPI_SetFont($htree, _WinAPI_GetStockObject($__TREEVIEWCONSTANT_DEFAULT_GUI_FONT))
    Return $htree
EndFunc    ; -> _GUICtrlTreeView_Create

Func _GUICtrlTreeView_CreateDragImage($hwnd, $hitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_CREATEDRAGIMAGE, 0x0, $hitem, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_CreateDragImage

Func _GUICtrlTreeView_CreateSolidBitMap($hwnd, $icolor, $iwidth, $iheight)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _WinAPI_CreateSolidBitmap($hwnd, $icolor, $iwidth, $iheight)
EndFunc    ; -> _GUICtrlTreeView_CreateSolidBitMap

Func _GUICtrlTreeView_Delete($hwnd, $hitem = Null)
    If IsHWnd($hwnd) Then
        If $hitem = Null Then
            $hitem = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0x0, 0x0, "wparam", "handle", "handle")
            If $hitem <> 0x0 Then Return _SendMessage($hwnd, $TVM_DELETEITEM, 0x0, $hitem, 0x0, "wparam", "handle", "hwnd") <> 0x0
            Return False
        Else
            If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
            If GUICtrlDelete($hitem) Then Return True
            Return _SendMessage($hwnd, $TVM_DELETEITEM, 0x0, $hitem, 0x0, "wparam", "handle", "hwnd") <> 0x0
        EndIf
    Else
        If $hitem = Null Then
            $hitem = GUICtrlSendMsg($hwnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0x0)
            If $hitem <> 0x0 Then Return GUICtrlSendMsg($hwnd, $TVM_DELETEITEM, 0x0, $hitem) <> 0x0
            Return False
        Else
            If Not IsPtr($hitem) Then
                $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
            Else
                SetExtended(0x1)
            EndIf
            Return GUICtrlSendMsg($hwnd, $TVM_DELETEITEM, 0x0, $hitem) <> 0x0
        EndIf
    EndIf
EndFunc    ; -> _GUICtrlTreeView_Delete

Func _GUICtrlTreeView_DeleteAll($hwnd)
    Local $icount = 0x0
    If IsHWnd($hwnd) Then
        _SendMessage($hwnd, $TVM_DELETEITEM, 0x0, $TVI_ROOT)
        $icount = _GUICtrlTreeView_GetCount($hwnd)
        If $icount Then Return GUICtrlSendMsg($hwnd, $TVM_DELETEITEM, 0x0, $TVI_ROOT) <> 0x0
        Return True
    Else
        GUICtrlSendMsg($hwnd, $TVM_DELETEITEM, 0x0, $TVI_ROOT)
        $icount = _GUICtrlTreeView_GetCount($hwnd)
        If $icount Then Return _SendMessage($hwnd, $TVM_DELETEITEM, 0x0, $TVI_ROOT) <> 0x0
        Return True
    EndIf
EndFunc    ; -> _GUICtrlTreeView_DeleteAll

Func _GUICtrlTreeView_DeleteChildren($hwnd, $hitem)
    Local $bresult
    If IsHWnd($hwnd) Then
        $bresult = _SendMessage($hwnd, $TVM_EXPAND, BitOR($TVE_COLLAPSE, $TVE_COLLAPSERESET), $hitem, 0x0, "wparam", "handle")
    Else
        $bresult = GUICtrlSendMsg($hwnd, $TVM_EXPAND, BitOR($TVE_COLLAPSE, $TVE_COLLAPSERESET), $hitem)
    EndIf
    If $bresult Then _GUICtrlTreeView_SetChildren($hwnd, $hitem, False)
    Return $bresult
EndFunc    ; -> _GUICtrlTreeView_DeleteChildren

Func _GUICtrlTreeView_Destroy(ByRef $hwnd)
    Local $idestroyed = 0x0
    If IsHWnd($hwnd) Then
        If _WinAPI_InProcess($hwnd, $__g_hguictrl_lastwnd) Then
            Local $nctrlid = _WinAPI_GetDlgCtrlID($hwnd)
            Local $hparent = _WinAPI_GetParent($hwnd)
            $idestroyed = _WinAPI_DestroyWindow($hwnd)
            Local $iret = __UDF_FreeGlobalID($hparent, $nctrlid)
            If Not $iret Then
            EndIf
        Else
            Return SetError(0x1, 0x0, False)
        EndIf
    Else
        $idestroyed = GUICtrlDelete($hwnd)
    EndIf
    If $idestroyed Then $hwnd = 0x0
    Return $idestroyed <> 0x0
EndFunc    ; -> _GUICtrlTreeView_Destroy

Func _GUICtrlTreeView_DisplayRect($hwnd, $hitem, $btextonly = False)
    Local $trect = _GUICtrlTreeView_DisplayRectEx($hwnd, $hitem, $btextonly)
    If @error Then Return SetError(@error, 0x0, 0x0)
    Local $arect[0x4]
    $arect[0x0] = DllStructGetData($trect, "Left")
    $arect[0x1] = DllStructGetData($trect, "Top")
    $arect[0x2] = DllStructGetData($trect, "Right")
    $arect[0x3] = DllStructGetData($trect, "Bottom")
    Return $arect
EndFunc    ; -> _GUICtrlTreeView_DisplayRect

Func _GUICtrlTreeView_DisplayRectEx($hwnd, $hitem, $btextonly = False)
    Local $trect = DllStructCreate($TAGRECT)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $tcastptr = DllStructCreate("ptr", DllStructGetPtr($trect))
    DllStructSetData($tcastptr, 0x1, $hitem)
    Local $iret = __guictrl_sendmsg($hwnd, $TVM_GETITEMRECT, $btextonly, $trect, 0x0, True)
    If Not $iret Then DllStructSetData($tcastptr, 0x1, 0x0)
    Return SetError($iret = 0x0, $iret, $trect)
EndFunc    ; -> _GUICtrlTreeView_DisplayRectEx

Func _GUICtrlTreeView_EditText($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _WinAPI_SetFocus($hwnd)
    Local $imsg
    If _GUICtrlTreeView_GetUnicodeFormat($hwnd) Then
        $imsg = $TVM_EDITLABELW
    Else
        $imsg = $TVM_EDITLABELA
    EndIf
    Return _SendMessage($hwnd, $imsg, 0x0, $hitem, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_EditText

Func _GUICtrlTreeView_EndEdit($hwnd, $bcancel = False)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_ENDEDITLABELNOW, $bcancel) <> 0x0
EndFunc    ; -> _GUICtrlTreeView_EndEdit

Func _GUICtrlTreeView_EndUpdate($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $__TREEVIEWCONSTANT_WM_SETREDRAW, True) = 0x0
EndFunc    ; -> _GUICtrlTreeView_EndUpdate

Func _GUICtrlTreeView_EnsureVisible($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_ENSUREVISIBLE, 0x0, $hitem, 0x0, "wparam", "handle") <> 0x0
EndFunc    ; -> _GUICtrlTreeView_EnsureVisible

Func _GUICtrlTreeView_Expand($hwnd, $hitem = Null, $bexpand = True)
    If $hitem = Null Then
        $hitem = $TVI_ROOT
    Else
        If Not IsHWnd($hitem) Then
            Local $hitem_tmp = GUICtrlGetHandle($hitem)
            If $hitem_tmp Then $hitem = $hitem_tmp
        EndIf
    EndIf
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If $bexpand Then
        __GUICtrlTreeView_ExpandItem($hwnd, $TVE_EXPAND, $hitem)
    Else
        __GUICtrlTreeView_ExpandItem($hwnd, $TVE_COLLAPSE, $hitem)
    EndIf
EndFunc    ; -> _GUICtrlTreeView_Expand

Func __GUICtrlTreeView_ExpandItem($hwnd, $iexpand, $hitem)
    If Not IsHWnd($hwnd) Then
        If $hitem = 0x0 Then
            $hitem = $TVI_ROOT
        Else
            $hitem = GUICtrlGetHandle($hitem)
            If $hitem = 0x0 Then Return
        EndIf
        $hwnd = GUICtrlGetHandle($hwnd)
    EndIf
    _SendMessage($hwnd, $TVM_EXPAND, $iexpand, $hitem, 0x0, "wparam", "handle")
    If $iexpand = $TVE_EXPAND And $hitem > 0x0 Then _SendMessage($hwnd, $TVM_ENSUREVISIBLE, 0x0, $hitem, 0x0, "wparam", "handle")
    $hitem = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_CHILD, $hitem, 0x0, "wparam", "handle", "handle")
    Local $hchild
    While $hitem <> 0x0
        $hchild = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_CHILD, $hitem, 0x0, "wparam", "handle", "handle")
        If $hchild <> 0x0 Then __GUICtrlTreeView_ExpandItem($hwnd, $iexpand, $hitem)
        $hitem = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_NEXT, $hitem, 0x0, "wparam", "handle", "handle")
    WEnd
EndFunc    ; -> __GUICtrlTreeView_ExpandItem

Func _GUICtrlTreeView_ExpandedOnce($hwnd, $hitem)
    Return BitAND(_GUICtrlTreeView_GetState($hwnd, $hitem), $TVIS_EXPANDEDONCE) <> 0x0
EndFunc    ; -> _GUICtrlTreeView_ExpandedOnce

Func _GUICtrlTreeView_FindItem($hwnd, $stext, $binstr = False, $hstart = 0x0)
    If $hstart = 0x0 Then $hstart = _GUICtrlTreeView_GetFirstItem($hwnd)
    While $hstart <> 0x0
        Local $sitem = _GUICtrlTreeView_GetText($hwnd, $hstart)
        Switch $binstr
        Case False
            If $sitem = $stext Then ExitLoop
        Case True
            If StringInStr($sitem, $stext) Then ExitLoop
        EndSwitch
        $hstart = _GUICtrlTreeView_GetNext($hwnd, $hstart)
    WEnd
    Return $hstart
EndFunc    ; -> _GUICtrlTreeView_FindItem

Func _GUICtrlTreeView_FindItemEx($hwnd, $streepath, $hstart = 0x0)
    Local $SDELIMITER = Opt("GUIDataSeparatorChar")
    Local $iindex = 0x1
    Local $aparts = StringSplit($streepath, $SDELIMITER)
    If $hstart = 0x0 Then $hstart = _GUICtrlTreeView_GetFirstItem($hwnd)
    While ($iindex <= $aparts[0x0]) And ($hstart <> 0x0)
        If StringStripWS(_GUICtrlTreeView_GetText($hwnd, $hstart), $STR_STRIPLEADING + $STR_STRIPTRAILING) = StringStripWS($aparts[$iindex], $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
            If $iindex = $aparts[0x0] Then ExitLoop
            $iindex += 0x1
            __GUICtrlTreeView_ExpandItem($hwnd, $TVE_EXPAND, $hstart)
            $hstart = _GUICtrlTreeView_GetFirstChild($hwnd, $hstart)
        Else
            $hstart = _GUICtrlTreeView_GetNextSibling($hwnd, $hstart)
            __GUICtrlTreeView_ExpandItem($hwnd, $TVE_COLLAPSE, $hstart)
        EndIf
    WEnd
    Return $hstart
EndFunc    ; -> _GUICtrlTreeView_FindItemEx

Func _GUICtrlTreeView_GetBkColor($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $shex = Hex(String(_SendMessage($hwnd, $TVM_GETBKCOLOR)), 0x6)
    Return "0x" & StringMid($shex, 0x5, 0x2) & StringMid($shex, 0x3, 0x2) & StringMid($shex, 0x1, 0x2)
EndFunc    ; -> _GUICtrlTreeView_GetBkColor

Func _GUICtrlTreeView_GetBold($hwnd, $hitem)
    Return BitAND(_GUICtrlTreeView_GetState($hwnd, $hitem), $TVIS_BOLD) <> 0x0
EndFunc    ; -> _GUICtrlTreeView_GetBold

Func _GUICtrlTreeView_GetChecked($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_STATE)
    DllStructSetData($titem, "hItem", $hitem)
    __GUICtrlTreeView_GetItem($hwnd, $titem)
    Return BitAND(DllStructGetData($titem, "State"), $TVIS_CHECKED) = $TVIS_CHECKED
EndFunc    ; -> _GUICtrlTreeView_GetChecked

Func _GUICtrlTreeView_GetChildCount($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $iret = 0x0
    Local $hnext = _GUICtrlTreeView_GetFirstChild($hwnd, $hitem)
    If $hnext = 0x0 Then Return + -1
    Do
        $iret += 0x1
        $hnext = _GUICtrlTreeView_GetNextSibling($hwnd, $hnext)
    Until $hnext = 0x0
    Return $iret
EndFunc    ; -> _GUICtrlTreeView_GetChildCount

Func _GUICtrlTreeView_GetChildren($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_CHILDREN)
    DllStructSetData($titem, "hItem", $hitem)
    __GUICtrlTreeView_GetItem($hwnd, $titem)
    Return DllStructGetData($titem, "Children") <> 0x0
EndFunc    ; -> _GUICtrlTreeView_GetChildren

Func _GUICtrlTreeView_GetCount($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETCOUNT)
EndFunc    ; -> _GUICtrlTreeView_GetCount

Func _GUICtrlTreeView_GetCut($hwnd, $hitem)
    Return BitAND(_GUICtrlTreeView_GetState($hwnd, $hitem), $TVIS_CUT) <> 0x0
EndFunc    ; -> _GUICtrlTreeView_GetCut

Func _GUICtrlTreeView_GetDropTarget($hwnd, $hitem)
    Return BitAND(_GUICtrlTreeView_GetState($hwnd, $hitem), $TVIS_DROPHILITED) <> 0x0
EndFunc    ; -> _GUICtrlTreeView_GetDropTarget

Func _GUICtrlTreeView_GetEditControl($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETEDITCONTROL, 0x0, 0x0, 0x0, "wparam", "lparam", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetEditControl

Func _GUICtrlTreeView_GetExpanded($hwnd, $hitem)
    Return BitAND(_GUICtrlTreeView_GetState($hwnd, $hitem), $TVIS_EXPANDED) <> 0x0
EndFunc    ; -> _GUICtrlTreeView_GetExpanded

Func _GUICtrlTreeView_GetFirstChild($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_CHILD, $hitem, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetFirstChild

Func _GUICtrlTreeView_GetFirstItem($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_ROOT, 0x0, 0x0, "wparam", "lparam", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetFirstItem

Func _GUICtrlTreeView_GetFirstVisible($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_FIRSTVISIBLE, 0x0, 0x0, "wparam", "lparam", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetFirstVisible

Func _GUICtrlTreeView_GetFocused($hwnd, $hitem)
    Return BitAND(_GUICtrlTreeView_GetState($hwnd, $hitem), $TVIS_FOCUSED) <> 0x0
EndFunc    ; -> _GUICtrlTreeView_GetFocused

Func _GUICtrlTreeView_GetHeight($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETITEMHEIGHT)
EndFunc    ; -> _GUICtrlTreeView_GetHeight

Func _GUICtrlTreeView_GetImageIndex($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_IMAGE)
    DllStructSetData($titem, "hItem", $hitem)
    __GUICtrlTreeView_GetItem($hwnd, $titem)
    Return DllStructGetData($titem, "Image")
EndFunc    ; -> _GUICtrlTreeView_GetImageIndex

Func _GUICtrlTreeView_GetImageListIconHandle($hwnd, $iindex)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $himagelist = _SendMessage($hwnd, $TVM_GETIMAGELIST, 0x0, 0x0, 0x0, "wparam", "lparam", "handle")
    Local $hicon = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $himagelist, "int", $iindex, "uint", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $hicon[0x0]
EndFunc    ; -> _GUICtrlTreeView_GetImageListIconHandle

Func _GUICtrlTreeView_GetIndent($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETINDENT)
EndFunc    ; -> _GUICtrlTreeView_GetIndent

Func _GUICtrlTreeView_GetInsertMarkColor($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETINSERTMARKCOLOR)
EndFunc    ; -> _GUICtrlTreeView_GetInsertMarkColor

Func _GUICtrlTreeView_GetISearchString($hwnd)
    Local $bunicode = _GUICtrlTreeView_GetUnicodeFormat($hwnd)
    Local $imsg
    If $bunicode Then
        $imsg = $TVM_GETISEARCHSTRINGW
    Else
        $imsg = $TVM_GETISEARCHSTRINGA
    EndIf
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If _SendMessage($hwnd, $imsg) = 0x0 Then Return ''
    Local $tbuffer
    If $bunicode Then
        $tbuffer = $__g_ttvbuffer
    Else
        $tbuffer = $__g_ttvbufferansi
    EndIf
    DllStructSetData($tbuffer, "Text", '')
    __guictrl_sendmsg($hwnd, $imsg, 0x0, $tbuffer, 0x0, True)
    Return DllStructGetData($tbuffer, "Text")
EndFunc    ; -> _GUICtrlTreeView_GetISearchString

Func __GUICtrlTreeView_GetItem($hwnd, ByRef $titem)
    Local $imsg
    If _GUICtrlTreeView_GetUnicodeFormat($hwnd) Then
        $imsg = $TVM_GETITEMW
    Else
        $imsg = $TVM_GETITEMA
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, 0x0, True)
    Return $iret <> 0x0
EndFunc    ; -> __GUICtrlTreeView_GetItem

Func _GUICtrlTreeView_GetItemByIndex($hwnd, $hitem, $iindex)
    Local $hresult = _GUICtrlTreeView_GetFirstChild($hwnd, $hitem)
    While ($hresult <> 0x0) And ($iindex > 0x0)
        $hresult = _GUICtrlTreeView_GetNextSibling($hwnd, $hresult)
        $iindex -= 0x1
    WEnd
    Return $hresult
EndFunc    ; -> _GUICtrlTreeView_GetItemByIndex

Func _GUICtrlTreeView_GetItemHandle($hwnd, $hitem = Null)
    If IsHWnd($hwnd) Then
        If $hitem = Null Then $hitem = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_ROOT, 0x0, 0x0, "wparam", "lparam", "handle")
    Else
        If $hitem = Null Then
            $hitem = Ptr(GUICtrlSendMsg($hwnd, $TVM_GETNEXTITEM, $TVGN_ROOT, 0x0))
        Else
            Local $htempitem = GUICtrlGetHandle($hitem)
            If $htempitem And Not IsPtr($hitem) Then
                $hitem = $htempitem
            Else
                SetExtended(0x1)
            EndIf
        EndIf
    EndIf
    Return $hitem
EndFunc    ; -> _GUICtrlTreeView_GetItemHandle

Func _GUICtrlTreeView_GetItemParam($hwnd, $hitem = Null)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_PARAM)
    DllStructSetData($titem, "Param", 0x0)
    Local $imsg
    If _GUICtrlTreeView_GetUnicodeFormat($hwnd) Then
        $imsg = $TVM_GETITEMW
    Else
        $imsg = $TVM_GETITEMA
    EndIf
    If IsHWnd($hwnd) Then
        If $hitem = Null Then $hitem = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0x0, 0x0, "wparam", "lparam", "handle")
        If $hitem = 0x0 Then Return 0x0
        DllStructSetData($titem, "hItem", $hitem)
        If _SendMessage($hwnd, $imsg, 0x0, $titem, 0x0, "wparam", "struct*") = 0x0 Then Return 0x0
    Else
        If $hitem = Null Then
            $hitem = Ptr(GUICtrlSendMsg($hwnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0x0))
        Else
            Local $htempitem = GUICtrlGetHandle($hitem)
            If $htempitem And Not IsPtr($hitem) Then
                $hitem = $htempitem
            Else
                SetExtended(0x1)
            EndIf
        EndIf
        If $hitem = 0x0 Then Return 0x0
        DllStructSetData($titem, "hItem", $hitem)
        If GUICtrlSendMsg($hwnd, $imsg, 0x0, DllStructGetPtr($titem)) = 0x0 Then Return 0x0
    EndIf
    Return DllStructGetData($titem, "Param")
EndFunc    ; -> _GUICtrlTreeView_GetItemParam

Func _GUICtrlTreeView_GetLastChild($hwnd, $hitem)
    Local $hresult = _GUICtrlTreeView_GetFirstChild($hwnd, $hitem)
    If $hresult <> 0x0 Then
        Local $hnext = $hresult
        Do
            $hresult = $hnext
            $hnext = _GUICtrlTreeView_GetNextSibling($hwnd, $hnext)
        Until $hnext = 0x0
    EndIf
    Return $hresult
EndFunc    ; -> _GUICtrlTreeView_GetLastChild

Func _guictrltreeview_getlastitem($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_LASTVISIBLE, 0x0, 0x0, "wparam", "lparam", "handle")
EndFunc    ; -> _guictrltreeview_getlastitem

Func _GUICtrlTreeView_GetLineColor($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $shex = Hex(String(_SendMessage($hwnd, $TVM_GETLINECOLOR)), 0x6)
    Return "0x" & StringMid($shex, 0x5, 0x2) & StringMid($shex, 0x3, 0x2) & StringMid($shex, 0x1, 0x2)
EndFunc    ; -> _GUICtrlTreeView_GetLineColor

Func _GUICtrlTreeView_GetNext($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $hresult = 0x0
    If $hitem <> 0x0 Then
        Local $hnext = _GUICtrlTreeView_GetFirstChild($hwnd, $hitem)
        If $hnext = 0x0 Then
            $hnext = _GUICtrlTreeView_GetNextSibling($hwnd, $hitem)
        EndIf
        Local $hparent = $hitem
        While ($hnext = 0x0) And ($hparent <> 0x0)
            $hparent = _GUICtrlTreeView_GetParentHandle($hwnd, $hparent)
            If $hparent = 0x0 Then
                $hnext = Ptr(0x0)
                ExitLoop
            EndIf
            $hnext = _GUICtrlTreeView_GetNextSibling($hwnd, $hparent)
        WEnd
        $hresult = $hnext
    EndIf
    Return $hresult
EndFunc    ; -> _GUICtrlTreeView_GetNext

Func _GUICtrlTreeView_GetNextChild($hwnd, $hitem)
    Return _GUICtrlTreeView_GetNextSibling($hwnd, $hitem)
EndFunc    ; -> _GUICtrlTreeView_GetNextChild

Func _GUICtrlTreeView_GetNextSibling($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_NEXT, $hitem, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetNextSibling

Func _GUICtrlTreeView_GetNextVisible($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_NEXTVISIBLE, $hitem, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetNextVisible

Func _GUICtrlTreeView_GetNormalImageList($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETIMAGELIST, $TVSIL_NORMAL, 0x0, 0x0, "wparam", "lparam", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetNormalImageList

Func _GUICtrlTreeView_GetOverlayImageIndex($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_STATE)
    DllStructSetData($titem, "hItem", $hitem)
    DllStructSetData($titem, "StateMask", $TVIS_OVERLAYMASK)
    __GUICtrlTreeView_GetItem($hwnd, $titem)
    Return DllStructGetData($titem, "Image")
EndFunc    ; -> _GUICtrlTreeView_GetOverlayImageIndex

Func _GUICtrlTreeView_GetParentHandle($hwnd, $hitem = Null)
    If $hitem = Null Then
        If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
        $hitem = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0x0, 0x0, "wparam", "handle", "handle")
        If $hitem = 0x0 Then Return 0x0
    Else
        If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
        If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    EndIf
    Local $hparent = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_PARENT, $hitem, 0x0, "wparam", "handle", "handle")
    Return $hparent
EndFunc    ; -> _GUICtrlTreeView_GetParentHandle

Func _GUICtrlTreeView_GetParentParam($hwnd, $hitem = Null)
    Local $ttvitem = $__g_ttvitemex
    DllStructSetData($ttvitem, "Mask", $TVIF_PARAM)
    DllStructSetData($ttvitem, "Param", 0x0)
    Local $hparent
    If IsHWnd($hwnd) Then
        If $hitem = Null Then $hitem = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0x0, 0x0, "wparam", "handle", "handle")
        If $hitem = 0x0 Then Return 0x0
        $hparent = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_PARENT, $hitem, 0x0, "wparam", "handle", "handle")
        DllStructSetData($ttvitem, "hItem", $hparent)
        If _SendMessage($hwnd, $TVM_GETITEMA, 0x0, $ttvitem, 0x0, "wparam", "struct*") = 0x0 Then Return 0x0
    Else
        If $hitem = Null Then
            $hitem = GUICtrlSendMsg($hwnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0x0)
        Else
            Local $htempitem = GUICtrlGetHandle($hitem)
            If $htempitem And Not IsPtr($hitem) Then
                $hitem = $htempitem
            Else
                SetExtended(0x1)
            EndIf
        EndIf
        If $hitem = 0x0 Then Return 0x0
        $hparent = GUICtrlSendMsg($hwnd, $TVM_GETNEXTITEM, $TVGN_PARENT, $hitem)
        DllStructSetData($ttvitem, "hItem", $hparent)
        If GUICtrlSendMsg($hwnd, $TVM_GETITEMA, 0x0, DllStructGetPtr($ttvitem)) = 0x0 Then Return 0x0
    EndIf
    Return DllStructGetData($ttvitem, "Param")
EndFunc    ; -> _GUICtrlTreeView_GetParentParam

Func _GUICtrlTreeView_GetPrev($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $hresult = _GUICtrlTreeView_GetPrevChild($hwnd, $hitem)
    If $hresult <> 0x0 Then
        Local $hprev = $hresult
        Do
            $hresult = $hprev
            $hprev = _GUICtrlTreeView_GetLastChild($hwnd, $hprev)
        Until $hprev = 0x0
    Else
        $hresult = _GUICtrlTreeView_GetParentHandle($hwnd, $hitem)
    EndIf
    Return $hresult
EndFunc    ; -> _GUICtrlTreeView_GetPrev

Func _GUICtrlTreeView_GetPrevChild($hwnd, $hitem)
    Return _GUICtrlTreeView_GetPrevSibling($hwnd, $hitem)
EndFunc    ; -> _GUICtrlTreeView_GetPrevChild

Func _GUICtrlTreeView_GetPrevSibling($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_PREVIOUS, $hitem, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetPrevSibling

Func _GUICtrlTreeView_GetPrevVisible($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_PREVIOUSVISIBLE, $hitem, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetPrevVisible

Func _GUICtrlTreeView_GetScrollTime($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETSCROLLTIME)
EndFunc    ; -> _GUICtrlTreeView_GetScrollTime

Func _GUICtrlTreeView_GetSelected($hwnd, $hitem)
    Return BitAND(_GUICtrlTreeView_GetState($hwnd, $hitem), $TVIS_SELECTED) <> 0x0
EndFunc    ; -> _GUICtrlTreeView_GetSelected

Func _GUICtrlTreeView_GetSelectedImageIndex($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_SELECTEDIMAGE)
    DllStructSetData($titem, "hItem", $hitem)
    __GUICtrlTreeView_GetItem($hwnd, $titem)
    Return DllStructGetData($titem, "SelectedImage")
EndFunc    ; -> _GUICtrlTreeView_GetSelectedImageIndex

Func _GUICtrlTreeView_GetSelection($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0x0, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetSelection

Func _GUICtrlTreeView_GetSiblingCount($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $hnext, $iret = 0x0
    Local $hparent = _GUICtrlTreeView_GetParentHandle($hwnd, $hitem)
    If $hparent <> 0x0 Then
        $hnext = _GUICtrlTreeView_GetFirstChild($hwnd, $hparent)
        If $hnext = 0x0 Then Return + -1
        Do
            $iret += 0x1
            $hnext = _GUICtrlTreeView_GetNextSibling($hwnd, $hnext)
        Until $hnext = 0x0
    Else
        $hnext = _GUICtrlTreeView_GetFirstItem($hwnd)
        If $hnext = 0x0 Then Return + -1
        Do
            $iret += 0x1
            $hnext = _GUICtrlTreeView_GetNextSibling($hwnd, $hnext)
        Until $hnext = 0x0
    EndIf
    Return $iret
EndFunc    ; -> _GUICtrlTreeView_GetSiblingCount

Func _GUICtrlTreeView_GetState($hwnd, $hitem = Null)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_STATE)
    DllStructSetData($titem, "hItem", $hitem)
    __guictrl_sendmsg($hwnd, $TVM_GETITEMA, 0x0, $titem)
    Return DllStructGetData($titem, "State")
EndFunc    ; -> _GUICtrlTreeView_GetState

Func _GUICtrlTreeView_GetStateImageIndex($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_STATE)
    DllStructSetData($titem, "hItem", $hitem)
    __GUICtrlTreeView_GetItem($hwnd, $titem)
    Return BitShift(BitAND(DllStructGetData($titem, "State"), $TVIS_STATEIMAGEMASK), 0xc)
EndFunc    ; -> _GUICtrlTreeView_GetStateImageIndex

Func _GUICtrlTreeView_GetStateImageList($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETIMAGELIST, $TVSIL_STATE, 0x0, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_GetStateImageList

Func _GUICtrlTreeView_GetText($hwnd, $hitem = Null)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    Local $ttext, $imsg
    Local $bunicode = _GUICtrlTreeView_GetUnicodeFormat($hwnd)
    If $bunicode Then
        $ttext = $__g_ttvbuffer
        $imsg = $TVM_GETITEMW
    Else
        $ttext = $__g_ttvbufferansi
        $imsg = $TVM_GETITEMA
    EndIf
    DllStructSetData($ttext, 0x1, '')
    DllStructSetData($titem, "Mask", $TVIF_TEXT)
    DllStructSetData($titem, "hItem", $hitem)
    __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, $ttext, False, 0x5, True)
    Return DllStructGetData($ttext, 0x1)
EndFunc    ; -> _GUICtrlTreeView_GetText

Func _GUICtrlTreeView_GetTextColor($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $shex = Hex(String(_SendMessage($hwnd, $TVM_GETTEXTCOLOR)), 0x6)
    Return "0x" & StringMid($shex, 0x5, 0x2) & StringMid($shex, 0x3, 0x2) & StringMid($shex, 0x1, 0x2)
EndFunc    ; -> _GUICtrlTreeView_GetTextColor

Func _GUICtrlTreeView_GetToolTips($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETTOOLTIPS, 0x0, 0x0, 0x0, "wparam", "lparam", "hwnd")
EndFunc    ; -> _GUICtrlTreeView_GetToolTips

Func _GUICtrlTreeView_GetTree($hwnd, $hitem = Null)
    If $hitem = Null Then
        $hitem = 0x0
    Else
        If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    EndIf
    Local $spath = ''
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    If $hitem = 0x0 Then $hitem = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_CARET, 0x0, 0x0, "wparam", "handle", "handle")
    If $hitem <> 0x0 Then
        $spath = _GUICtrlTreeView_GetText($hwnd, $hitem)
        Local $hparent, $sseparator = Opt("GUIDataSeparatorChar")
        Do
            $hparent = _SendMessage($hwnd, $TVM_GETNEXTITEM, $TVGN_PARENT, $hitem, 0x0, "wparam", "handle", "handle")
            If $hparent <> 0x0 Then $spath = _GUICtrlTreeView_GetText($hwnd, $hparent) & $sseparator & $spath
            $hitem = $hparent
        Until $hitem = 0x0
    EndIf
    Return $spath
EndFunc    ; -> _GUICtrlTreeView_GetTree

Func _GUICtrlTreeView_GetUnicodeFormat($hwnd)
    If Not IsDllStruct($__g_ttvbuffer) Then
        $__g_ttvbuffer = DllStructCreate("wchar Text[4096]")
        $__g_ttvbufferansi = DllStructCreate("char Text[4096]", DllStructGetPtr($__g_ttvbuffer))
    EndIf
    If IsHWnd($hwnd) Then
        Return _SendMessage($hwnd, $TVM_GETUNICODEFORMAT) <> 0x0
    Else
        Return GUICtrlSendMsg($hwnd, $TVM_GETUNICODEFORMAT, 0x0, 0x0) <> 0x0
    EndIf
EndFunc    ; -> _GUICtrlTreeView_GetUnicodeFormat

Func _GUICtrlTreeView_GetVisible($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $trect = DllStructCreate($TAGRECT)
    Local $tcastptr = DllStructCreate("ptr", DllStructGetPtr($trect))
    DllStructSetData($tcastptr, 0x1, $hitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $iret = __guictrl_sendmsg($hwnd, $TVM_GETITEMRECT, True, $trect, 0x0, True)
    If $iret = 0x0 Then Return False
    Local $icontrolheight = _WinAPI_GetWindowHeight($hwnd)
    If DllStructGetData($trect, "Top") >= $icontrolheight Or DllStructGetData($trect, "Bottom") <= 0x0 Then
        Return False
    Else
        Return True
    EndIf
EndFunc    ; -> _GUICtrlTreeView_GetVisible

Func _GUICtrlTreeView_GetVisibleCount($hwnd)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_GETVISIBLECOUNT)
EndFunc    ; -> _GUICtrlTreeView_GetVisibleCount

Func _GUICtrlTreeView_HitTest($hwnd, $ix, $iy)
    Local $thittest = _GUICtrlTreeView_HitTestEx($hwnd, $ix, $iy)
    Local $IFLAGS = DllStructGetData($thittest, "Flags")
    Local $iret = 0x0
    If BitAND($IFLAGS, $TVHT_NOWHERE) <> 0x0 Then $iret = BitOR($iret, 0x1)
    If BitAND($IFLAGS, $TVHT_ONITEMICON) <> 0x0 Then $iret = BitOR($iret, 0x2)
    If BitAND($IFLAGS, $TVHT_ONITEMLABEL) <> 0x0 Then $iret = BitOR($iret, 0x4)
    If BitAND($IFLAGS, $TVHT_ONITEMINDENT) <> 0x0 Then $iret = BitOR($iret, 0x8)
    If BitAND($IFLAGS, $TVHT_ONITEMBUTTON) <> 0x0 Then $iret = BitOR($iret, 0x10)
    If BitAND($IFLAGS, $TVHT_ONITEMRIGHT) <> 0x0 Then $iret = BitOR($iret, 0x20)
    If BitAND($IFLAGS, $TVHT_ONITEMSTATEICON) <> 0x0 Then $iret = BitOR($iret, 0x40)
    If BitAND($IFLAGS, $TVHT_ABOVE) <> 0x0 Then $iret = BitOR($iret, 0x80)
    If BitAND($IFLAGS, $TVHT_BELOW) <> 0x0 Then $iret = BitOR($iret, 0x100)
    If BitAND($IFLAGS, $TVHT_TORIGHT) <> 0x0 Then $iret = BitOR($iret, 0x200)
    If BitAND($IFLAGS, $TVHT_TOLEFT) <> 0x0 Then $iret = BitOR($iret, 0x400)
    Return $iret
EndFunc    ; -> _GUICtrlTreeView_HitTest

Func _GUICtrlTreeView_HitTestEx($hwnd, $ix, $iy)
    Local $thittest = DllStructCreate($TAGTVHITTESTINFO)
    DllStructSetData($thittest, "X", $ix)
    DllStructSetData($thittest, "Y", $iy)
    __guictrl_sendmsg($hwnd, $TVM_HITTEST, 0x0, $thittest, 0x0, True)
    Return $thittest
EndFunc    ; -> _GUICtrlTreeView_HitTestEx

Func _GUICtrlTreeView_HitTestItem($hwnd, $ix, $iy)
    Local $thittest = _GUICtrlTreeView_HitTestEx($hwnd, $ix, $iy)
    Return DllStructGetData($thittest, "Item")
EndFunc    ; -> _GUICtrlTreeView_HitTestItem

Func _GUICtrlTreeView_Index($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $iret = + -1
    Local $hparent = _GUICtrlTreeView_GetParentHandle($hwnd, $hitem)
    Local $hnext
    If $hparent <> 0x0 Then
        $hnext = _GUICtrlTreeView_GetFirstChild($hwnd, $hparent)
        While $hnext <> 0x0
            $iret += 0x1
            If $hnext = $hitem Then ExitLoop
            $hnext = _GUICtrlTreeView_GetNextSibling($hwnd, $hnext)
        WEnd
    Else
        $hnext = _GUICtrlTreeView_GetFirstItem($hwnd)
        While $hnext <> 0x0
            $iret += 0x1
            If $hnext = $hitem Then ExitLoop
            $hnext = _GUICtrlTreeView_GetNextSibling($hwnd, $hnext)
        WEnd
    EndIf
    If $hnext = 0x0 Then $iret = + -1
    Return $iret
EndFunc    ; -> _GUICtrlTreeView_Index

Func _GUICtrlTreeView_InsertItem($hwnd, $sitem_text, $hitem_parent = 0x0, $hitem_after = 0x0, $iimage = + -1, $iselimage = + -1)
    Local $ttvi = DllStructCreate($TAGTVINSERTSTRUCT)
    Local $ttext, $imsg
    If _GUICtrlTreeView_GetUnicodeFormat($hwnd) Then
        $ttext = $__g_ttvbuffer
        $imsg = $TVM_INSERTITEMW
    Else
        $ttext = $__g_ttvbufferansi
        $imsg = $TVM_INSERTITEMA
    EndIf
    Local $ibuffer, $pbuffer
    If $sitem_text <> + -1 Then
        $ibuffer = StringLen($sitem_text) + 0x1
        DllStructSetData($ttext, "Text", $sitem_text)
        $pbuffer = DllStructGetPtr($ttext)
    Else
        $ibuffer = 0x0
        $ttext = 0x0
        $pbuffer = + -1
    EndIf
    Local $hitem_tmp, $iextended = 0x0
    If $hitem_parent = 0x0 Then
        $hitem_parent = $TVI_ROOT
    ElseIf Not IsHWnd($hitem_parent) Then
        $hitem_tmp = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem_parent)
        If $hitem_tmp Then
            $hitem_parent = $hitem_tmp
        Else
            $iextended = 0x1
        EndIf
    EndIf
    If $hitem_after = 0x0 Then
        $hitem_after = $TVI_LAST
    ElseIf ($hitem_after <> $TVI_ROOT And $hitem_after <> $TVI_FIRST And $hitem_after <> $TVI_LAST And $hitem_after <> $TVI_SORT) Then
        If Not IsHWnd($hitem_after) Then
            $hitem_tmp = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem_after)
            If Not $hitem_tmp Then
                $hitem_after = $TVI_LAST
            Else
                $hitem_after = $hitem_tmp
            EndIf
        EndIf
    EndIf
    Local $hicon
    Local $imask = $TVIF_TEXT
    If $iimage >= 0x0 Then
        $imask = BitOR($imask, $TVIF_IMAGE)
        $imask = BitOR($imask, $TVIF_IMAGE)
        DllStructSetData($ttvi, "Image", $iimage)
    Else
        $hicon = _GUICtrlTreeView_GetImageListIconHandle($hwnd, 0x0)
        If $hicon <> 0x0 Then
            $imask = BitOR($imask, $TVIF_IMAGE)
            DllStructSetData($ttvi, "Image", 0x0)
            DllCall("user32.dll", "int", "DestroyIcon", "handle", $hicon)
        EndIf
    EndIf
    If $iselimage >= 0x0 Then
        $imask = BitOR($imask, $TVIF_SELECTEDIMAGE)
        $imask = BitOR($imask, $TVIF_SELECTEDIMAGE)
        DllStructSetData($ttvi, "SelectedImage", $iselimage)
    Else
        $hicon = _GUICtrlTreeView_GetImageListIconHandle($hwnd, 0x1)
        If $hicon <> 0x0 Then
            $imask = BitOR($imask, $TVIF_SELECTEDIMAGE)
            DllStructSetData($ttvi, "SelectedImage", 0x0)
            DllCall("user32.dll", "int", "DestroyIcon", "handle", $hicon)
        EndIf
    EndIf
    $imask = BitOR($imask, $TVIF_PARAM)
    DllStructSetData($ttvi, "Param", 0x0)
    DllStructSetData($ttvi, "Parent", $hitem_parent)
    DllStructSetData($ttvi, "InsertAfter", $hitem_after)
    DllStructSetData($ttvi, "Mask", $imask)
    DllStructSetData($ttvi, "Text", $pbuffer)
    DllStructSetData($ttvi, "TextMax", $ibuffer)
    Local $hitem = Ptr(__guictrl_sendmsg($hwnd, $imsg, 0x0, $ttvi, $ttext, False, + -1))
    SetExtended($iextended)
    Return $hitem
EndFunc    ; -> _GUICtrlTreeView_InsertItem

Func _GUICtrlTreeView_IsFirstItem($hwnd, $hitem)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Return _GUICtrlTreeView_GetFirstItem($hwnd) = $hitem
EndFunc    ; -> _GUICtrlTreeView_IsFirstItem

Func _GUICtrlTreeView_IsParent($hwnd, $hparent, $hitem)
    If Not IsHWnd($hparent) Then $hparent = _GUICtrlTreeView_GetItemHandle($hwnd, $hparent)
    Return _GUICtrlTreeView_GetParentHandle($hwnd, $hitem) = $hparent
EndFunc    ; -> _GUICtrlTreeView_IsParent

Func _GUICtrlTreeView_Level($hwnd, $hitem)
    Local $iret = 0x0
    Local $hnext = _GUICtrlTreeView_GetParentHandle($hwnd, $hitem)
    While $hnext <> 0x0
        $iret += 0x1
        $hnext = _GUICtrlTreeView_GetParentHandle($hwnd, $hnext)
    WEnd
    Return $iret
EndFunc    ; -> _GUICtrlTreeView_Level

Func _GUICtrlTreeView_MapAccIDToItem($hwnd, $iid)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_MAPACCIDTOHTREEITEM, $iid, 0x0, 0x0, "wparam", "lparam", "handle")
EndFunc    ; -> _GUICtrlTreeView_MapAccIDToItem

Func _GUICtrlTreeView_MapItemToAccID($hwnd, $htreeitem)
    If Not IsHWnd($htreeitem) Then $htreeitem = _GUICtrlTreeView_GetItemHandle($hwnd, $htreeitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_MAPHTREEITEMTOACCID, $htreeitem, 0x0, 0x0, "handle")
EndFunc    ; -> _GUICtrlTreeView_MapItemToAccID

Func __GUICtrlTreeView_ReverseColorOrder($vcolor)
    Local $shex = Hex(String($vcolor), 0x6)
    Return "0x" & StringMid($shex, 0x5, 0x2) & StringMid($shex, 0x3, 0x2) & StringMid($shex, 0x1, 0x2)
EndFunc    ; -> __GUICtrlTreeView_ReverseColorOrder

Func _GUICtrlTreeView_SelectItem($hwnd, $hitem, $IFLAG = 0x0)
    If Not IsHWnd($hitem) And $hitem <> 0x0 Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If $IFLAG = 0x0 Then $IFLAG = $TVGN_CARET
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_SELECTITEM, $IFLAG, $hitem, 0x0, "wparam", "handle") <> 0x0
EndFunc    ; -> _GUICtrlTreeView_SelectItem

Func _GUICtrlTreeView_SelectItemByIndex($hwnd, $hitem, $iindex)
    Return _GUICtrlTreeView_SelectItem($hwnd, _GUICtrlTreeView_GetItemByIndex($hwnd, $hitem, $iindex))
EndFunc    ; -> _GUICtrlTreeView_SelectItemByIndex

Func _GUICtrlTreeView_SetBkColor($hwnd, $vrgbcolor)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return __GUICtrlTreeView_ReverseColorOrder(_SendMessage($hwnd, $TVM_SETBKCOLOR, 0x0, Int(__GUICtrlTreeView_ReverseColorOrder($vrgbcolor))))
EndFunc    ; -> _GUICtrlTreeView_SetBkColor

Func _GUICtrlTreeView_SetBold($hwnd, $hitem, $bflag = True)
    Return _GUICtrlTreeView_SetState($hwnd, $hitem, $TVIS_BOLD, $bflag)
EndFunc    ; -> _GUICtrlTreeView_SetBold

Func _GUICtrlTreeView_SetChecked($hwnd, $hitem, $bcheck = True)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_STATE)
    DllStructSetData($titem, "hItem", $hitem)
    If $bcheck Then
        DllStructSetData($titem, "State", 0x2000)
    Else
        DllStructSetData($titem, "State", 0x1000)
    EndIf
    DllStructSetData($titem, "StateMask", 0xf000)
    Return __GUICtrlTreeView_SetItem($hwnd, $titem)
EndFunc    ; -> _GUICtrlTreeView_SetChecked

Func _GUICtrlTreeView_SetCheckedByIndex($hwnd, $hitem, $iindex, $bcheck = True)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $hchild = _GUICtrlTreeView_GetItemByIndex($hwnd, $hitem, $iindex)
    Return _GUICtrlTreeView_SetChecked($hwnd, $hchild, $bcheck)
EndFunc    ; -> _GUICtrlTreeView_SetCheckedByIndex

Func _GUICtrlTreeView_SetChildren($hwnd, $hitem, $bflag = True)
    Local $icount = _GUICtrlTreeView_GetChildCount($hwnd, $hitem)
    If $icount = + -1 And $bflag Then Return False
    If $icount And Not $bflag Then Return False
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", BitOR($TVIF_HANDLE, $TVIF_CHILDREN))
    DllStructSetData($titem, "hItem", $hitem)
    DllStructSetData($titem, "Children", $bflag)
    Return __GUICtrlTreeView_SetItem($hwnd, $titem)
EndFunc    ; -> _GUICtrlTreeView_SetChildren

Func _GUICtrlTreeView_SetCut($hwnd, $hitem, $bflag = True)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Return _GUICtrlTreeView_SetState($hwnd, $hitem, $TVIS_CUT, $bflag)
EndFunc    ; -> _GUICtrlTreeView_SetCut

Func _GUICtrlTreeView_SetDropTarget($hwnd, $hitem, $bflag = True)
    If $bflag Then
        Return _GUICtrlTreeView_SelectItem($hwnd, $hitem, $TVGN_DROPHILITE)
    ElseIf _GUICtrlTreeView_GetDropTarget($hwnd, $hitem) Then
        Return _GUICtrlTreeView_SelectItem($hwnd, 0x0)
    EndIf
    Return False
EndFunc    ; -> _GUICtrlTreeView_SetDropTarget

Func _GUICtrlTreeView_SetFocused($hwnd, $hitem, $bflag = True)
    Return _GUICtrlTreeView_SetState($hwnd, $hitem, $TVIS_FOCUSED, $bflag)
EndFunc    ; -> _GUICtrlTreeView_SetFocused

Func _GUICtrlTreeView_SetHeight($hwnd, $iheight)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_SETITEMHEIGHT, $iheight)
EndFunc    ; -> _GUICtrlTreeView_SetHeight

Func _GUICtrlTreeView_SetIcon($hwnd, $hitem = Null, $siconfile = '', $iiconid = 0x0, $iimagemode = 0x6)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If @error Or $siconfile = '' Then Return SetError(@error + 0xa, 0x0, False)
    Local $ttvitem = $__g_ttvitemex
    Local $ticon = DllStructCreate("handle")
    Local $acount = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $siconfile, "int", $iiconid, "handle", 0x0, "struct*", $ticon, "uint", 0x1)
    If @error Then Return SetError(@error + 0x14, @extended, False)
    If $acount[0x0] = 0x0 Then Return False
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Local $himagelist = _SendMessage($hwnd, $TVM_GETIMAGELIST, 0x0, 0x0, 0x0, "wparam", "lparam", "handle")
    If $himagelist = 0x0 Then
        $himagelist = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", 0x10, "int", 0x10, "uint", 0x21, "int", 0x0, "int", 0x1)
        If @error Then Return SetError(@error + 0x1e, @extended, False)
        $himagelist = $himagelist[0x0]
        If $himagelist = 0x0 Then Return SetError(0x2, 0x0, False)
        _SendMessage($hwnd, $TVM_SETIMAGELIST, 0x0, $himagelist, 0x0, "wparam", "handle")
    EndIf
    Local $hicon = DllStructGetData($ticon, 0x1)
    Local $VICON = DllCall("comctl32.dll", "int", "ImageList_AddIcon", "handle", $himagelist, "handle", $hicon)
    $VICON = $VICON[0x0]
    If @error Then
        Local $ierror = @error + 0x28, $iextended = @extended
        DllCall("user32.dll", "int", "DestroyIcon", "handle", $hicon)
        Return SetError($ierror, $iextended, False)
    EndIf
    DllCall("user32.dll", "int", "DestroyIcon", "handle", $hicon)
    Local $imask = BitOR($TVIF_IMAGE, $TVIF_SELECTEDIMAGE)
    If BitAND($iimagemode, 0x2) Then
        DllStructSetData($ttvitem, "Image", $VICON)
        If Not BitAND($iimagemode, 0x4) Then $imask = $TVIF_IMAGE
    EndIf
    If BitAND($iimagemode, 0x4) Then
        DllStructSetData($ttvitem, "SelectedImage", $VICON)
        If Not BitAND($iimagemode, 0x2) Then
            $imask = $TVIF_SELECTEDIMAGE
        Else
            $imask = BitOR($TVIF_IMAGE, $TVIF_SELECTEDIMAGE)
        EndIf
    EndIf
    DllStructSetData($ttvitem, "Mask", $imask)
    DllStructSetData($ttvitem, "hItem", $hitem)
    Return __GUICtrlTreeView_SetItem($hwnd, $ttvitem)
EndFunc    ; -> _GUICtrlTreeView_SetIcon

Func _GUICtrlTreeView_SetImageIndex($hwnd, $hitem, $iindex)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", BitOR($TVIF_HANDLE, $TVIF_IMAGE))
    DllStructSetData($titem, "hItem", $hitem)
    DllStructSetData($titem, "Image", $iindex)
    Return __GUICtrlTreeView_SetItem($hwnd, $titem)
EndFunc    ; -> _GUICtrlTreeView_SetImageIndex

Func _GUICtrlTreeView_SetIndent($hwnd, $iindent)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    _SendMessage($hwnd, $TVM_SETINDENT, $iindent)
EndFunc    ; -> _GUICtrlTreeView_SetIndent

Func _GUICtrlTreeView_SetInsertMark($hwnd, $hitem, $bafter = True)
    If Not IsHWnd($hitem) And $hitem <> 0x0 Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_SETINSERTMARK, $bafter, $hitem, 0x0, "wparam", "handle") <> 0x0
EndFunc    ; -> _GUICtrlTreeView_SetInsertMark

Func _GUICtrlTreeView_SetInsertMarkColor($hwnd, $icolor)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_SETINSERTMARKCOLOR, 0x0, $icolor)
EndFunc    ; -> _GUICtrlTreeView_SetInsertMarkColor

Func __GUICtrlTreeView_SetItem($hwnd, ByRef $titem)
    Local $imsg
    If _GUICtrlTreeView_GetUnicodeFormat($hwnd) Then
        $imsg = $TVM_SETITEMW
    Else
        $imsg = $TVM_SETITEMA
    EndIf
    Local $iret = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem)
    Return $iret <> 0x0
EndFunc    ; -> __GUICtrlTreeView_SetItem

Func _GUICtrlTreeView_SetItemHeight($hwnd, $hitem, $iintegral)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    _GUICtrlTreeView_BeginUpdate($hwnd)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", BitOR($TVIF_HANDLE, $TVIF_INTEGRAL))
    DllStructSetData($titem, "hItem", $hitem)
    DllStructSetData($titem, "Integral", $iintegral)
    Local $bresult = __GUICtrlTreeView_SetItem($hwnd, $titem)
    _GUICtrlTreeView_EndUpdate($hwnd)
    Return $bresult
EndFunc    ; -> _GUICtrlTreeView_SetItemHeight

Func _GUICtrlTreeView_SetItemParam($hwnd, $hitem, $iparam)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", BitOR($TVIF_HANDLE, $TVIF_PARAM))
    DllStructSetData($titem, "hItem", $hitem)
    DllStructSetData($titem, "Param", $iparam)
    Local $bresult = __GUICtrlTreeView_SetItem($hwnd, $titem)
    Return $bresult
EndFunc    ; -> _GUICtrlTreeView_SetItemParam

Func _GUICtrlTreeView_SetLineColor($hwnd, $vrgbcolor)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return __GUICtrlTreeView_ReverseColorOrder(_SendMessage($hwnd, $TVM_SETLINECOLOR, 0x0, Int(__GUICtrlTreeView_ReverseColorOrder($vrgbcolor))))
EndFunc    ; -> _GUICtrlTreeView_SetLineColor

Func _GUICtrlTreeView_SetNormalImageList($hwnd, $himagelist)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_SETIMAGELIST, $TVSIL_NORMAL, $himagelist, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_SetNormalImageList

Func _GUICtrlTreeView_SetOverlayImageIndex($hwnd, $hitem, $iindex)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", BitOR($TVIF_HANDLE, $TVIF_STATE))
    DllStructSetData($titem, "hItem", $hitem)
    DllStructSetData($titem, "State", BitShift($iindex, + -8))
    DllStructSetData($titem, "StateMask", $TVIS_OVERLAYMASK)
    Return __GUICtrlTreeView_SetItem($hwnd, $titem)
EndFunc    ; -> _GUICtrlTreeView_SetOverlayImageIndex

Func _GUICtrlTreeView_SetScrollTime($hwnd, $itime)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_SETSCROLLTIME, $itime)
EndFunc    ; -> _GUICtrlTreeView_SetScrollTime

Func _GUICtrlTreeView_SetSelected($hwnd, $hitem, $bflag = True)
    Return _GUICtrlTreeView_SetState($hwnd, $hitem, $TVIS_SELECTED, $bflag)
EndFunc    ; -> _GUICtrlTreeView_SetSelected

Func _GUICtrlTreeView_SetSelectedImageIndex($hwnd, $hitem, $iindex)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", BitOR($TVIF_HANDLE, $TVIF_SELECTEDIMAGE))
    DllStructSetData($titem, "hItem", $hitem)
    DllStructSetData($titem, "SelectedImage", $iindex)
    Return __GUICtrlTreeView_SetItem($hwnd, $titem)
EndFunc    ; -> _GUICtrlTreeView_SetSelectedImageIndex

Func _GUICtrlTreeView_SetState($hwnd, $hitem, $istate = 0x0, $bsetstate = True)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_STATE)
    DllStructSetData($titem, "hItem", $hitem)
    If $bsetstate Then
        DllStructSetData($titem, "State", $istate)
    Else
        DllStructSetData($titem, "State", BitAND($bsetstate, $istate))
    EndIf
    DllStructSetData($titem, "StateMask", $istate)
    If $bsetstate Then DllStructSetData($titem, "StateMask", BitOR($bsetstate, $istate))
    Return __GUICtrlTreeView_SetItem($hwnd, $titem)
EndFunc    ; -> _GUICtrlTreeView_SetState

Func _GUICtrlTreeView_SetStateImageIndex($hwnd, $hitem, $iindex)
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If $iindex < 0x0 Then
        Return SetError(0x1, 0x0, False)
    EndIf
    Local $titem = $__g_ttvitemex
    DllStructSetData($titem, "Mask", $TVIF_STATE)
    DllStructSetData($titem, "hItem", $hitem)
    DllStructSetData($titem, "State", BitShift($iindex, + -12))
    DllStructSetData($titem, "StateMask", $TVIS_STATEIMAGEMASK)
    Return __GUICtrlTreeView_SetItem($hwnd, $titem)
EndFunc    ; -> _GUICtrlTreeView_SetStateImageIndex

Func _GUICtrlTreeView_SetStateImageList($hwnd, $himagelist)
    _GUIImageList_AddIcon($himagelist, "shell32.dll", 0x0)
    Local $icount = _GUIImageList_GetImageCount($himagelist)
    For $x = $icount + -1 To 0x1 Step + -1
        _GUIImageList_Swap($himagelist, $x, $x + -1)
    Next
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_SETIMAGELIST, $TVSIL_STATE, $himagelist, 0x0, "wparam", "handle", "handle")
EndFunc    ; -> _GUICtrlTreeView_SetStateImageList

Func _GUICtrlTreeView_SetText($hwnd, $hitem = Null, $stext = '')
    If Not IsHWnd($hitem) Then $hitem = _GUICtrlTreeView_GetItemHandle($hwnd, $hitem)
    If @error Or $stext = '' Then Return SetError(@error + 0xa, 0x0, False)
    Local $titem = $__g_ttvitemex
    Local $tbuffer, $imsg
    If _GUICtrlTreeView_GetUnicodeFormat($hwnd) Then
        $tbuffer = $__g_ttvbuffer
        $imsg = $TVM_SETITEMW
    Else
        $tbuffer = $__g_ttvbufferansi
        $imsg = $TVM_SETITEMA
    EndIf
    DllStructSetData($tbuffer, "Text", $stext)
    DllStructSetData($titem, "Mask", BitOR($TVIF_HANDLE, $TVIF_TEXT))
    DllStructSetData($titem, "hItem", $hitem)
    Local $bresult = __guictrl_sendmsg($hwnd, $imsg, 0x0, $titem, $tbuffer, False, 0x5)
    Return $bresult <> 0x0
EndFunc    ; -> _GUICtrlTreeView_SetText

Func _GUICtrlTreeView_SetTextColor($hwnd, $vrgbcolor)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return __GUICtrlTreeView_ReverseColorOrder(_SendMessage($hwnd, $TVM_SETTEXTCOLOR, 0x0, Int(__GUICtrlTreeView_ReverseColorOrder($vrgbcolor))))
EndFunc    ; -> _GUICtrlTreeView_SetTextColor

Func _GUICtrlTreeView_SetToolTips($hwnd, $htooltip)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_SETTOOLTIPS, $htooltip, 0x0, 0x0, "wparam", "int", "hwnd")
EndFunc    ; -> _GUICtrlTreeView_SetToolTips

Func _GUICtrlTreeView_SetUnicodeFormat($hwnd, $bformat = True)
    If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
    Return _SendMessage($hwnd, $TVM_SETUNICODEFORMAT, $bformat)
EndFunc    ; -> _GUICtrlTreeView_SetUnicodeFormat

Func _GUICtrlTreeView_Sort($hwnd)
    Local $iitemcount = _GUICtrlTreeView_GetCount($hwnd)
    If $iitemcount > 0x2 Then
        Local $atreeview[$iitemcount], $i = 0x0
        Local $hhandle = _GUICtrlTreeView_GetFirstItem($hwnd)
        $atreeview[0x1] = $hhandle
        $atreeview[0x0] = 0x2
        __GUICtrlTreeView_SortGetFirstChild($hwnd, $hhandle, $atreeview)
        ReDim $atreeview[$atreeview[0x0]]
        $atreeview[0x0] = 0x0
        If Not IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
        For $i = 0x0 To UBound($atreeview) + -1
            _SendMessage($hwnd, $TVM_SORTCHILDREN, 0x0, $atreeview[$i], 0x0, "wparam", "handle")
        Next
    EndIf
EndFunc    ; -> _GUICtrlTreeView_Sort

Func __GUICtrlTreeView_SortGetFirstChild($hwnd, $hitem, ByRef $atreeview)
    Local $hchild = _GUICtrlTreeView_GetFirstChild($hwnd, $hitem)
    If $hchild <> 0x0 Then
        $atreeview[$atreeview[0x0]] = $hchild
        $atreeview[0x0]+= 0x1
        __GUICtrlTreeView_SortGetFirstChild($hwnd, $hchild, $atreeview)
    EndIf
    Local $hnext = _GUICtrlTreeView_GetNextSibling($hwnd, $hitem)
    If $hnext <> 0x0 Then __GUICtrlTreeView_SortGetFirstChild($hwnd, $hnext, $atreeview)
EndFunc    ; -> __GUICtrlTreeView_SortGetFirstChild

#Region Global Variables
    Global $__g_iieloadwaittimeout = 0x493e0
    Global $__g_bieau3debug = False
    Global $__g_bieerrornotify = True
    Global $__g_oieerrorhandler, $__g_sieusererrorhandler
#EndRegion Global Variables
#Region Global Constants
    Global Const $__GAIEAU3VERSIONINFO[0x6] = ["V", 0x3, 0x1, 0x0, "20200518", "V3.1-0"]
    Global Const $LSFW_LOCK = 0x1, $LSFW_UNLOCK = 0x2
    Global Enum $_IESTATUS_SUCCESS = 0x0, $_IESTATUS_GENERALERROR, $_IESTATUS_COMERROR, $_IESTATUS_INVALIDDATATYPE, $_IESTATUS_INVALIDOBJECTTYPE, $_IESTATUS_INVALIDVALUE, $_IESTATUS_LOADWAITTIMEOUT, $_IESTATUS_NOMATCH, $_IESTATUS_ACCESSISDENIED, $_IESTATUS_CLIENTDISCONNECTED
#EndRegion Global Constants
#Region Core functions
    Func _IECreate($surl = "about:blank", $itryattach = 0x0, $ivisible = 0x1, $iwait = 0x1, $itakefocus = 0x1)
        If Not $ivisible Then $itakefocus = 0x0
        If $itryattach And $surl <> '' Then
            Local $oresult = _IEAttach($surl, "url")
            If IsObj($oresult) Then
                If $itakefocus Then WinActivate(HWnd($oresult.hWnd))
                Return SetError($_IESTATUS_SUCCESS, 0x1, $oresult)
            EndIf
        EndIf
        Local $imustunlock = 0x0
        If Not $ivisible And __IELockSetForegroundWindow($LSFW_LOCK) Then $imustunlock = 0x1
        Local $oobject = ObjCreate("InternetExplorer.Application")
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IECreate", '', "Browser Object Creation Failed")
            If $imustunlock Then __IELockSetForegroundWindow($LSFW_UNLOCK)
            Return SetError($_IESTATUS_GENERALERROR, 0x0, 0x0)
        EndIf
        $oobject.visible = $ivisible
        If $imustunlock And Not __IELockSetForegroundWindow($LSFW_UNLOCK) Then __IEConsoleWriteError("Warning", "_IECreate", '', "Foreground Window Unlock Failed!")
        _IENavigate($oobject, $surl, $iwait)
        Local $ierror = @error
        If Not $ierror And StringLeft($surl, 0x6) = "about:" Then
            Local $odocument = $oobject.document
            _IEAction($odocument, "focus")
        EndIf
        Return SetError($ierror, 0x0, $oobject)
    EndFunc    ; -> _IECreate

    Func _IECreateEmbedded()
        Local $oobject = ObjCreate("Shell.Explorer.2")
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IECreateEmbedded", '', "WebBrowser Object Creation Failed")
            Return SetError($_IESTATUS_GENERALERROR, 0x0, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject)
    EndFunc    ; -> _IECreateEmbedded

    Func _IENavigate(ByRef $oobject, $surl, $iwait = 0x1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IENavigate", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "documentContainer") Then
            __IEConsoleWriteError("Error", "_IENavigate", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $oobject.navigate($surl)
        If @error Then
            __IEConsoleWriteError("Error", "_IENavigate", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        If $iwait Then
            _IELoadWait($oobject)
            Return SetError(@error, 0x0, + -1)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, + -1)
    EndFunc    ; -> _IENavigate

    Func _IEAttach($sstring, $smode = "title", $iinstance = 0x1)
        $smode = StringLower($smode)
        $iinstance = Int($iinstance)
        If $iinstance < 0x1 Then
            __IEConsoleWriteError("Error", "_IEAttach", "$_IESTATUS_InvalidValue", "$iInstance < 1")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x3, 0x0)
        EndIf
        If $smode = "embedded" Or $smode = "dialogbox" Then
            Local $iwintitlematchmode = Opt("WinTitleMatchMode", $OPT_MATCHANY)
            If $smode = "dialogbox" And $iinstance > 0x1 Then
                If IsHWnd($sstring) Then
                    $iinstance = 0x1
                    __IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_GeneralError", "$iInstance > 1 invalid with HWnd and DialogBox.  Setting to 1.")
                Else
                    Local $awinlist = WinList($sstring, '')
                    If $iinstance <= $awinlist[0x0][0x0] Then
                        $sstring = $awinlist[$iinstance][0x1]
                        $iinstance = 0x1
                    Else
                        __IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_NoMatch")
                        Opt("WinTitleMatchMode", $iwintitlematchmode)
                        Return SetError($_IESTATUS_NOMATCH, 0x1, 0x0)
                    EndIf
                EndIf
            EndIf
            Local $hcontrol = ControlGetHandle($sstring, '', "[CLASS:Internet Explorer_Server; INSTANCE:" & $iinstance & "]")
            Local $oresult = __IEControlGetObjFromHWND($hcontrol)
            Opt("WinTitleMatchMode", $iwintitlematchmode)
            If IsObj($oresult) Then
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oresult)
            Else
                __IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_NoMatch")
                Return SetError($_IESTATUS_NOMATCH, 0x1, 0x0)
            EndIf
        EndIf
        Local $oshell = ObjCreate("Shell.Application")
        Local $oshellwindows = $oshell.Windows()
        Local $itmp = 0x1
        Local $inotifystatus, $bisbrowser, $stmp
        Local $bstatus
        For $owindow In $oshellwindows
            $bisbrowser = True
            $bstatus = __IEInternalErrorHandlerRegister()
            If Not $bstatus Then __IEConsoleWriteError("Warning", "_IEAttach", "Cannot register internal error handler, cannot trap COM errors", "Use _IEErrorHandlerRegister() to register a user error handler")
            $inotifystatus = _IEErrorNotify()
            _IEErrorNotify(False)
            If $bisbrowser Then
                $stmp = $owindow.type
                If @error Then $bisbrowser = False
            EndIf
            If $bisbrowser Then
                $stmp = $owindow.document.title
                If @error Then $bisbrowser = False
            EndIf
            _IEErrorNotify($inotifystatus)
            __IEInternalErrorHandlerDeRegister()
            If $bisbrowser Then
                Switch $smode
                Case "title"
                    If StringInStr($owindow.document.title, $sstring) > 0x0 Then
                        If $iinstance = $itmp Then
                            Return SetError($_IESTATUS_SUCCESS, 0x0, $owindow)
                        Else
                            $itmp += 0x1
                        EndIf
                    EndIf
                Case "instance"
                    If $iinstance = $itmp Then
                        Return SetError($_IESTATUS_SUCCESS, 0x0, $owindow)
                    Else
                        $itmp += 0x1
                    EndIf
                Case "windowtitle"
                    Local $bfound = False
                    $stmp = RegRead("HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\", "Window Title")
                    If Not @error Then
                        If StringInStr($owindow.document.title & " - " & $stmp, $sstring) Then $bfound = True
                    Else
                        If StringInStr($owindow.document.title & " - Microsoft Internet Explorer", $sstring) Then $bfound = True
                        If StringInStr($owindow.document.title & " - Windows Internet Explorer", $sstring) Then $bfound = True
                    EndIf
                    If $bfound Then
                        If $iinstance = $itmp Then
                            Return SetError($_IESTATUS_SUCCESS, 0x0, $owindow)
                        Else
                            $itmp += 0x1
                        EndIf
                    EndIf
                Case "url"
                    If StringInStr($owindow.LocationURL, $sstring) > 0x0 Then
                        If $iinstance = $itmp Then
                            Return SetError($_IESTATUS_SUCCESS, 0x0, $owindow)
                        Else
                            $itmp += 0x1
                        EndIf
                    EndIf
                Case "text"
                    If StringInStr($owindow.document.body.innerText, $sstring) > 0x0 Then
                        If $iinstance = $itmp Then
                            Return SetError($_IESTATUS_SUCCESS, 0x0, $owindow)
                        Else
                            $itmp += 0x1
                        EndIf
                    EndIf
                Case "html"
                    If StringInStr($owindow.document.body.innerHTML, $sstring) > 0x0 Then
                        If $iinstance = $itmp Then
                            Return SetError($_IESTATUS_SUCCESS, 0x0, $owindow)
                        Else
                            $itmp += 0x1
                        EndIf
                    EndIf
                Case "hwnd"
                    If $iinstance > 0x1 Then
                        $iinstance = 0x1
                        __IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_GeneralError", "$iInstance > 1 invalid with HWnd.  Setting to 1.")
                    EndIf
                    If _IEPropertyGet($owindow, "hwnd") = $sstring Then
                        Return SetError($_IESTATUS_SUCCESS, 0x0, $owindow)
                    EndIf
                Case Else
                    __IEConsoleWriteError("Error", "_IEAttach", "$_IESTATUS_InvalidValue", "Invalid Mode Specified")
                    Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
                EndSwitch
            EndIf
        Next
        __IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_NoMatch")
        Return SetError($_IESTATUS_NOMATCH, 0x1, 0x0)
    EndFunc    ; -> _IEAttach

    Func _IELoadWait(ByRef $oobject, $idelay = 0x0, $itimeout = + -1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Then
            __IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_InvalidObjectType", ObjName($oobject))
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Local $otemp, $babort = False, $ierrorstatuscode = $_IESTATUS_SUCCESS
        Local $bstatus = __IEInternalErrorHandlerRegister()
        If Not $bstatus Then __IEConsoleWriteError("Warning", "_IELoadWait", "Cannot register internal error handler, cannot trap COM errors", "Use _IEErrorHandlerRegister() to register a user error handler")
        Local $inotifystatus = _IEErrorNotify()
        _IEErrorNotify(False)
        Sleep($idelay)
        Local $ierror
        Local $hieloadwaittimer = TimerInit()
        If $itimeout = + -1 Then $itimeout = $__g_iieloadwaittimeout
        Select
        Case __IEIsObjType($oobject, "browser", False)
            While Not (String($oobject.readyState) = "complete" Or $oobject.readyState = 0x4 Or $babort)
                If @error Then
                    $ierror = @error
                    If __IEComErrorUnrecoverable($ierror) Then
                        $ierrorstatuscode = __IEComErrorUnrecoverable($ierror)
                        $babort = True
                    EndIf
                ElseIf (TimerDiff($hieloadwaittimer) > $itimeout) Then
                    $ierrorstatuscode = $_IESTATUS_LOADWAITTIMEOUT
                    $babort = True
                EndIf
                Sleep(0x64)
            WEnd
            While Not (String($oobject.document.readyState) = "complete" Or $oobject.document.readyState = 0x4 Or $babort)
                If @error Then
                    $ierror = @error
                    If __IEComErrorUnrecoverable($ierror) Then
                        $ierrorstatuscode = __IEComErrorUnrecoverable($ierror)
                        $babort = True
                    EndIf
                ElseIf (TimerDiff($hieloadwaittimer) > $itimeout) Then
                    $ierrorstatuscode = $_IESTATUS_LOADWAITTIMEOUT
                    $babort = True
                EndIf
                Sleep(0x64)
            WEnd
        Case __IEIsObjType($oobject, "window", False)
            While Not (String($oobject.document.readyState) = "complete" Or $oobject.document.readyState = 0x4 Or $babort)
                If @error Then
                    $ierror = @error
                    If __IEComErrorUnrecoverable($ierror) Then
                        $ierrorstatuscode = __IEComErrorUnrecoverable($ierror)
                        $babort = True
                    EndIf
                ElseIf (TimerDiff($hieloadwaittimer) > $itimeout) Then
                    $ierrorstatuscode = $_IESTATUS_LOADWAITTIMEOUT
                    $babort = True
                EndIf
                Sleep(0x64)
            WEnd
            While Not (String($oobject.top.document.readyState) = "complete" Or $oobject.top.document.readyState = 0x4 Or $babort)
                If @error Then
                    $ierror = @error
                    If __IEComErrorUnrecoverable($ierror) Then
                        $ierrorstatuscode = __IEComErrorUnrecoverable($ierror)
                        $babort = True
                    EndIf
                ElseIf (TimerDiff($hieloadwaittimer) > $itimeout) Then
                    $ierrorstatuscode = $_IESTATUS_LOADWAITTIMEOUT
                    $babort = True
                EndIf
                Sleep(0x64)
            WEnd
        Case __IEIsObjType($oobject, "document", False)
            $otemp = $oobject.parentWindow
            While Not (String($otemp.document.readyState) = "complete" Or $otemp.document.readyState = 0x4 Or $babort)
                If @error Then
                    $ierror = @error
                    If __IEComErrorUnrecoverable($ierror) Then
                        $ierrorstatuscode = __IEComErrorUnrecoverable($ierror)
                        $babort = True
                    EndIf
                ElseIf (TimerDiff($hieloadwaittimer) > $itimeout) Then
                    $ierrorstatuscode = $_IESTATUS_LOADWAITTIMEOUT
                    $babort = True
                EndIf
                Sleep(0x64)
            WEnd
            While Not (String($otemp.top.document.readyState) = "complete" Or $otemp.top.document.readyState = 0x4 Or $babort)
                If @error Then
                    $ierror = @error
                    If __IEComErrorUnrecoverable($ierror) Then
                        $ierrorstatuscode = __IEComErrorUnrecoverable($ierror)
                        $babort = True
                    EndIf
                ElseIf (TimerDiff($hieloadwaittimer) > $itimeout) Then
                    $ierrorstatuscode = $_IESTATUS_LOADWAITTIMEOUT
                    $babort = True
                EndIf
                Sleep(0x64)
            WEnd
        Case Else
            $otemp = $oobject.document.parentWindow
            While Not (String($otemp.document.readyState) = "complete" Or $otemp.document.readyState = 0x4 Or $babort)
                If @error Then
                    $ierror = @error
                    If __IEComErrorUnrecoverable($ierror) Then
                        $ierrorstatuscode = __IEComErrorUnrecoverable($ierror)
                        $babort = True
                    EndIf
                ElseIf (TimerDiff($hieloadwaittimer) > $itimeout) Then
                    $ierrorstatuscode = $_IESTATUS_LOADWAITTIMEOUT
                    $babort = True
                EndIf
                Sleep(0x64)
            WEnd
            While Not (String($otemp.top.document.readyState) = "complete" Or $oobject.top.document.readyState = 0x4 Or $babort)
                If @error Then
                    $ierror = @error
                    If __IEComErrorUnrecoverable($ierror) Then
                        $ierrorstatuscode = __IEComErrorUnrecoverable($ierror)
                        $babort = True
                    EndIf
                ElseIf (TimerDiff($hieloadwaittimer) > $itimeout) Then
                    $ierrorstatuscode = $_IESTATUS_LOADWAITTIMEOUT
                    $babort = True
                EndIf
                Sleep(0x64)
            WEnd
        EndSelect
        _IEErrorNotify($inotifystatus)
        __IEInternalErrorHandlerDeRegister()
        Switch $ierrorstatuscode
        Case $_IESTATUS_SUCCESS
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
        Case $_IESTATUS_LOADWAITTIMEOUT
            __IEConsoleWriteError("Warning", "_IELoadWait", "$_IESTATUS_LoadWaitTimeout")
            Return SetError($_IESTATUS_LOADWAITTIMEOUT, 0x3, 0x0)
        Case $_IESTATUS_ACCESSISDENIED
            __IEConsoleWriteError("Warning", "_IELoadWait", "$_IESTATUS_AccessIsDenied", "Cannot verify readyState.  Likely casue: cross-domain scripting security restriction. (" & $ierror & ")")
            Return SetError($_IESTATUS_ACCESSISDENIED, 0x0, 0x0)
        Case $_IESTATUS_CLIENTDISCONNECTED
            __IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_ClientDisconnected", $ierror & ", Browser has been deleted prior to operation.")
            Return SetError($_IESTATUS_CLIENTDISCONNECTED, 0x0, 0x0)
        Case Else
            __IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_GeneralError", "Invalid Error Status - Notify IE.au3 developer")
            Return SetError($_IESTATUS_GENERALERROR, 0x0, 0x0)
        EndSwitch
    EndFunc    ; -> _IELoadWait

    Func _IELoadWaitTimeout($itimeout = + -1)
        If $itimeout = + -1 Then
            Return SetError($_IESTATUS_SUCCESS, 0x0, $__g_iieloadwaittimeout)
        Else
            $__g_iieloadwaittimeout = $itimeout
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
        EndIf
    EndFunc    ; -> _IELoadWaitTimeout

#EndRegion Core functions
#Region Frame Functions
    Func _IEIsFrameSet(ByRef $oobject)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEIsFrameSet", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If String($oobject.document.body.tagName) = "frameset" Then
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
        Else
            If @error Then
                __IEConsoleWriteError("Error", "_IEIsFrameSet", "$_IESTATUS_COMError", @error)
                Return SetError($_IESTATUS_COMERROR, @error, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x0)
        EndIf
    EndFunc    ; -> _IEIsFrameSet

    Func _IEFrameGetCollection(ByRef $oobject, $iindex = + -1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFrameGetCollection", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        $iindex = Number($iindex)
        Select
        Case $iindex = + -1
            Return SetError($_IESTATUS_SUCCESS, $oobject.document.parentwindow.frames.length, $oobject.document.parentwindow.frames)
        Case $iindex > + -1 And $iindex < $oobject.document.parentwindow.frames.length
            Return SetError($_IESTATUS_SUCCESS, $oobject.document.parentwindow.frames.length, $oobject.document.parentwindow.frames.item($iindex))
        Case $iindex < + -1
            __IEConsoleWriteError("Error", "_IEFrameGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
        Case Else
            __IEConsoleWriteError("Warning", "_IEFrameGetCollection", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
        EndSelect
    EndFunc    ; -> _IEFrameGetCollection

    Func _IEFrameGetObjByName(ByRef $oobject, $sname)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFrameGetObjByName", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $otemp, $oframes
        If Not __IEIsObjType($oobject, "browserdom") Then
            __IEConsoleWriteError("Error", "_IEFrameGetObjByName", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        If __IEIsObjType($oobject, "document") Then
            $otemp = $oobject.parentWindow
        Else
            $otemp = $oobject.document.parentWindow
        EndIf
        If _IEIsFrameSet($otemp) Then
            $oframes = _IETagNameGetCollection($otemp, "frame")
        Else
            $oframes = _IETagNameGetCollection($otemp, "iframe")
        EndIf
        If $oframes.length Then
            For $oframe In $oframes
                If String($oframe.name) = $sname Then Return SetError($_IESTATUS_SUCCESS, 0x0, $otemp.frames($sname))
            Next
            __IEConsoleWriteError("Warning", "_IEFrameGetObjByName", "$_IESTATUS_NoMatch", "No frames matching name")
            Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
        Else
            __IEConsoleWriteError("Warning", "_IEFrameGetObjByName", "$_IESTATUS_NoMatch", "No Frames found")
            Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
        EndIf
    EndFunc    ; -> _IEFrameGetObjByName

#EndRegion Frame Functions
#Region Link functions
    Func _IELinkClickByText(ByRef $oobject, $slinktext, $iindex = 0x0, $iwait = 0x1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IELinkClickByText", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $ifound = 0x0, $smodelinktext, $olinks = $oobject.document.links
        $iindex = Number($iindex)
        For $olink In $olinks
            $smodelinktext = String($olink.outerText)
            If $smodelinktext = $slinktext Then
                If ($ifound = $iindex) Then
                    $olink.click()
                    If @error Then
                        __IEConsoleWriteError("Error", "_IELinkClickByText", "$_IESTATUS_COMError", @error)
                        Return SetError($_IESTATUS_COMERROR, @error, 0x0)
                    EndIf
                    If $iwait Then
                        _IELoadWait($oobject)
                        Return SetError(@error, 0x0, + -1)
                    EndIf
                    Return SetError($_IESTATUS_SUCCESS, 0x0, + -1)
                EndIf
                $ifound = $ifound + 0x1
            EndIf
        Next
        __IEConsoleWriteError("Warning", "_IELinkClickByText", "$_IESTATUS_NoMatch")
        Return SetError($_IESTATUS_NOMATCH, 0x0, 0x0)
    EndFunc    ; -> _IELinkClickByText

    Func _IELinkClickByIndex(ByRef $oobject, $iindex, $iwait = 0x1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IELinkClickByIndex", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $olinks = $oobject.document.links, $olink
        $iindex = Number($iindex)
        If ($iindex >= 0x0) And ($iindex <= $olinks.length + -1) Then
            $olink = $olinks($iindex)
            $olink.click()
            If @error Then
                __IEConsoleWriteError("Error", "_IELinkClickByIndex", "$_IESTATUS_COMError", @error)
                Return SetError($_IESTATUS_COMERROR, @error, 0x0)
            EndIf
            If $iwait Then
                _IELoadWait($oobject)
                Return SetError(@error, 0x0, + -1)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, + -1)
        Else
            __IEConsoleWriteError("Warning", "_IELinkClickByIndex", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
        EndIf
    EndFunc    ; -> _IELinkClickByIndex

    Func _IELinkGetCollection(ByRef $oobject, $iindex = + -1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IELinkGetCollection", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        $iindex = Number($iindex)
        Select
        Case $iindex = + -1
            Return SetError($_IESTATUS_SUCCESS, $oobject.document.links.length, $oobject.document.links)
        Case $iindex > + -1 And $iindex < $oobject.document.links.length
            Return SetError($_IESTATUS_SUCCESS, $oobject.document.links.length, $oobject.document.links.item($iindex))
        Case $iindex < + -1
            __IEConsoleWriteError("Error", "_IELinkGetCollection", "$_IESTATUS_InvalidValue")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
        Case Else
            __IEConsoleWriteError("Warning", "_IELinkGetCollection", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
        EndSelect
    EndFunc    ; -> _IELinkGetCollection

#EndRegion Link functions
#Region Image functions
    Func _IEImgClick(ByRef $oobject, $slinktext, $smode = "src", $iindex = 0x0, $iwait = 0x1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEImgClick", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $smodelinktext, $ifound = 0x0, $oimgs = $oobject.document.images
        $smode = StringLower($smode)
        $iindex = Number($iindex)
        For $oimg In $oimgs
            Select
            Case $smode = "alt"
                $smodelinktext = $oimg.alt
            Case $smode = "name"
                $smodelinktext = $oimg.name
                If Not IsString($smodelinktext) Then $smodelinktext = $oimg.id
            Case $smode = "id"
                $smodelinktext = $oimg.id
            Case $smode = "src"
                $smodelinktext = $oimg.src
            Case Else
                __IEConsoleWriteError("Error", "_IEImgClick", "$_IESTATUS_InvalidValue", "Invalid mode: " & $smode)
                Return SetError($_IESTATUS_INVALIDVALUE, 0x3, 0x0)
            EndSelect
            If StringInStr($smodelinktext, $slinktext) Then
                If ($ifound = $iindex) Then
                    $oimg.click()
                    If @error Then
                        __IEConsoleWriteError("Error", "_IEImgClick", "$_IESTATUS_COMError", @error)
                        Return SetError($_IESTATUS_COMERROR, @error, 0x0)
                    EndIf
                    If $iwait Then
                        _IELoadWait($oobject)
                        Return SetError(@error, 0x0, + -1)
                    EndIf
                    Return SetError($_IESTATUS_SUCCESS, 0x0, + -1)
                EndIf
                $ifound = $ifound + 0x1
            EndIf
        Next
        __IEConsoleWriteError("Warning", "_IEImgClick", "$_IESTATUS_NoMatch")
        Return SetError($_IESTATUS_NOMATCH, 0x0, 0x0)
    EndFunc    ; -> _IEImgClick

    Func _IEImgGetCollection(ByRef $oobject, $iindex = + -1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEImgGetCollection", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $otemp = _IEDocGetObj($oobject)
        $iindex = Number($iindex)
        Select
        Case $iindex = + -1
            Return SetError($_IESTATUS_SUCCESS, $otemp.images.length, $otemp.images)
        Case $iindex > + -1 And $iindex < $otemp.images.length
            Return SetError($_IESTATUS_SUCCESS, $otemp.images.length, $otemp.images.item($iindex))
        Case $iindex < + -1
            __IEConsoleWriteError("Error", "_IEImgGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
        Case Else
            __IEConsoleWriteError("Warning", "_IEImgGetCollection", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x1, 0x0)
        EndSelect
    EndFunc    ; -> _IEImgGetCollection

#EndRegion Image functions
#Region Form functions
    Func _IEFormGetCollection(ByRef $oobject, $iindex = + -1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormGetCollection", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $otemp = _IEDocGetObj($oobject)
        $iindex = Number($iindex)
        Select
        Case $iindex = + -1
            Return SetError($_IESTATUS_SUCCESS, $otemp.forms.length, $otemp.forms)
        Case $iindex > + -1 And $iindex < $otemp.forms.length
            Return SetError($_IESTATUS_SUCCESS, $otemp.forms.length, $otemp.forms.item($iindex))
        Case $iindex < + -1
            __IEConsoleWriteError("Error", "_IEFormGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
        Case Else
            __IEConsoleWriteError("Warning", "_IEFormGetCollection", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x1, 0x0)
        EndSelect
    EndFunc    ; -> _IEFormGetCollection

    Func _IEFormGetObjByName(ByRef $oobject, $sname, $iindex = 0x0)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormGetObjByName", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $ilength = 0x0
        Local $ocol = $oobject.document.forms.item($sname)
        If IsObj($ocol) Then
            If __IEIsObjType($ocol, "elementcollection") Then
                $ilength = $ocol.length
            Else
                $ilength = 0x1
            EndIf
        EndIf
        $iindex = Number($iindex)
        If $iindex = + -1 Then
            Return SetError($_IESTATUS_SUCCESS, $ilength, $oobject.document.forms.item($sname))
        Else
            If IsObj($oobject.document.forms.item($sname, $iindex)) Then
                Return SetError($_IESTATUS_SUCCESS, $ilength, $oobject.document.forms.item($sname, $iindex))
            Else
                __IEConsoleWriteError("Warning", "_IEFormGetObjByName", "$_IESTATUS_NoMatch")
                Return SetError($_IESTATUS_NOMATCH, 0x0, 0x0)
            EndIf
        EndIf
    EndFunc    ; -> _IEFormGetObjByName

    Func _IEFormElementGetCollection(ByRef $oobject, $iindex = + -1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormElementGetCollection", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "form") Then
            __IEConsoleWriteError("Error", "_IEFormElementGetCollection", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $iindex = Number($iindex)
        Select
        Case $iindex = + -1
            Return SetError($_IESTATUS_SUCCESS, $oobject.elements.length, $oobject.elements)
        Case $iindex > + -1 And $iindex < $oobject.elements.length
            Return SetError($_IESTATUS_SUCCESS, $oobject.elements.length, $oobject.elements.item($iindex))
        Case $iindex < + -1
            __IEConsoleWriteError("Error", "_IEFormElementGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
        Case Else
            Return SetError($_IESTATUS_NOMATCH, 0x1, 0x0)
        EndSelect
    EndFunc    ; -> _IEFormElementGetCollection

    Func _IEFormElementGetObjByName(ByRef $oobject, $sname, $iindex = 0x0)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormElementGetObjByName", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "form") Then
            __IEConsoleWriteError("Error", "_IEFormElementGetObjByName", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Local $ilength = 0x0
        Local $ocol = $oobject.elements.item($sname)
        If IsObj($ocol) Then
            If __IEIsObjType($ocol, "elementcollection") Then
                $ilength = $ocol.length
            Else
                $ilength = 0x1
            EndIf
        EndIf
        $iindex = Number($iindex)
        If $iindex = + -1 Then
            Return SetError($_IESTATUS_SUCCESS, $ilength, $oobject.elements.item($sname))
        Else
            If IsObj($oobject.elements.item($sname, $iindex)) Then
                Return SetError($_IESTATUS_SUCCESS, $ilength, $oobject.elements.item($sname, $iindex))
            Else
                __IEConsoleWriteError("Warning", "_IEFormElementGetObjByName", "$_IESTATUS_NoMatch")
                Return SetError($_IESTATUS_NOMATCH, 0x0, 0x0)
            EndIf
        EndIf
    EndFunc    ; -> _IEFormElementGetObjByName

    Func _IEFormElementGetValue(ByRef $oobject)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormElementGetValue", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "forminputelement") Then
            __IEConsoleWriteError("Error", "_IEFormElementGetValue", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Local $sreturn = String($oobject.value)
        If @error Then
            __IEConsoleWriteError("Error", "_IEFormElementGetValue", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, $sreturn)
    EndFunc    ; -> _IEFormElementGetValue

    Func _IEFormElementSetValue(ByRef $oobject, $snewvalue, $ifireevent = 0x1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "forminputelement") Then
            __IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        If String($oobject.type) = "file" Then
            __IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_InvalidObjectType", "Browser security prevents SetValue of TYPE=FILE")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $oobject.value = $snewvalue
        If @error Then
            __IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        If $ifireevent Then
            $oobject.fireEvent("OnChange")
            $oobject.fireEvent("OnClick")
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
    EndFunc    ; -> _IEFormElementSetValue

    Func _IEFormElementOptionSelect(ByRef $oobject, $sstring, $iselect = 0x1, $smode = "byValue", $ifireevent = 0x1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "formselectelement") Then
            __IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Local $oitem, $oitems = $oobject.options, $inumitems = $oobject.options.length, $bismultiple = $oobject.multiple
        Switch $smode
        Case "byValue"
            For $oitem In $oitems
                If $oitem.value = $sstring Then
                    Switch $iselect
                    Case + -1
                        Return SetError($_IESTATUS_SUCCESS, 0x0, $oitem.selected)
                    Case 0x0
                        If Not $bismultiple Then
                            __IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "$iSelect=0 only valid for type=select multiple")
                            Return SetError($_IESTATUS_INVALIDVALUE, 0x3)
                        EndIf
                        If $oitem.selected Then
                            $oitem.selected = False
                            If $ifireevent Then
                                $oobject.fireEvent("onChange")
                                $oobject.fireEvent("OnClick")
                            EndIf
                        EndIf
                        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
                    Case 0x1
                        If Not $oitem.selected Then
                            $oitem.selected = True
                            If $ifireevent Then
                                $oobject.fireEvent("onChange")
                                $oobject.fireEvent("OnClick")
                            EndIf
                        EndIf
                        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
                    Case Else
                        __IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
                        Return SetError($_IESTATUS_INVALIDVALUE, 0x3, 0x0)
                    EndSwitch
                EndIf
            Next
            __IEConsoleWriteError("Warning", "_IEFormElementOptionSelect", "$_IESTATUS_NoMatch", "Value not matched")
            Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
        Case "byText"
            For $oitem In $oitems
                If String($oitem.text) = $sstring Then
                    Switch $iselect
                    Case + -1
                        Return SetError($_IESTATUS_SUCCESS, 0x0, $oitem.selected)
                    Case 0x0
                        If Not $bismultiple Then
                            __IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "$iSelect=0 only valid for type=select multiple")
                            Return SetError($_IESTATUS_INVALIDVALUE, 0x3)
                        EndIf
                        If $oitem.selected Then
                            $oitem.selected = False
                            If $ifireevent Then
                                $oobject.fireEvent("onChange")
                                $oobject.fireEvent("OnClick")
                            EndIf
                        EndIf
                        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
                    Case 0x1
                        If Not $oitem.selected Then
                            $oitem.selected = True
                            If $ifireevent Then
                                $oobject.fireEvent("onChange")
                                $oobject.fireEvent("OnClick")
                            EndIf
                        EndIf
                        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
                    Case Else
                        __IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
                        Return SetError($_IESTATUS_INVALIDVALUE, 0x3, 0x0)
                    EndSwitch
                EndIf
            Next
            __IEConsoleWriteError("Warning", "_IEFormElementOptionSelect", "$_IESTATUS_NoMatch", "Text not matched")
            Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
        Case "byIndex"
            Local $iindex = Number($sstring)
            If $iindex < 0x0 Or $iindex >= $inumitems Then
                __IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid index value, " & $iindex)
                Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
            EndIf
            $oitem = $oitems.item($iindex)
            Switch $iselect
            Case + -1
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oitems.item($iindex).selected)
            Case 0x0
                If Not $bismultiple Then
                    __IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "$iSelect=0 only valid for type=select multiple")
                    Return SetError($_IESTATUS_INVALIDVALUE, 0x3)
                EndIf
                If $oitem.selected Then
                    $oitems.item($iindex).selected = False
                    If $ifireevent Then
                        $oobject.fireEvent("onChange")
                        $oobject.fireEvent("OnClick")
                    EndIf
                EndIf
                Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
            Case 0x1
                If Not $oitem.selected Then
                    $oitems.item($iindex).selected = True
                    If $ifireevent Then
                        $oobject.fireEvent("onChange")
                        $oobject.fireEvent("OnClick")
                    EndIf
                EndIf
                Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
            Case Else
                __IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
                Return SetError($_IESTATUS_INVALIDVALUE, 0x3, 0x0)
            EndSwitch
        Case Else
            __IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid Mode")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x4, 0x0)
        EndSwitch
    EndFunc    ; -> _IEFormElementOptionSelect

    Func _IEFormElementCheckBoxSelect(ByRef $oobject, $sstring, $sname = '', $iselect = 0x1, $smode = "byValue", $ifireevent = 0x1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "form") Then
            __IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $sstring = String($sstring)
        $sname = String($sname)
        Local $oitems
        If $sname = '' Then
            $oitems = _IETagNameGetCollection($oobject, "input")
        Else
            $oitems = Execute("$oObject.elements('" & $sname & "')")
        EndIf
        If Not IsObj($oitems) Then
            __IEConsoleWriteError("Warning", "_IEFormElementCheckBoxSelect", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x3, 0x0)
        EndIf
        Local $oitem, $bfound = False
        Switch $smode
        Case "byValue"
            If __IEIsObjType($oitems, "forminputelement") Then
                $oitem = $oitems
                If String($oitem.type) = "checkbox" And String($oitem.value) = $sstring Then $bfound = True
            Else
                For $oitem In $oitems
                    If String($oitem.type) = "checkbox" And String($oitem.value) = $sstring Then
                        $bfound = True
                        ExitLoop
                    EndIf
                Next
            EndIf
        Case "byIndex"
            If __IEIsObjType($oitems, "forminputelement") Then
                $oitem = $oitems
                If String($oitem.type) = "checkbox" And Number($sstring) = 0x0 Then $bfound = True
            Else
                Local $icount = 0x0
                For $oitem In $oitems
                    If String($oitem.type) = "checkbox" And Number($sstring) = $icount Then
                        $bfound = True
                        ExitLoop
                    Else
                        If String($oitem.type) = "checkbox" Then $icount += 0x1
                    EndIf
                Next
            EndIf
        Case Else
            __IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidValue", "Invalid Mode")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x5, 0x0)
        EndSwitch
        If Not $bfound Then
            __IEConsoleWriteError("Warning", "_IEFormElementCheckBoxSelect", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
        EndIf
        Switch $iselect
        Case + -1
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oitem.checked)
        Case 0x0
            If $oitem.checked Then
                $oitem.checked = False
                If $ifireevent Then
                    $oitem.fireEvent("onChange")
                    $oitem.fireEvent("OnClick")
                EndIf
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
        Case 0x1
            If Not $oitem.checked Then
                $oitem.checked = True
                If $ifireevent Then
                    $oitem.fireEvent("onChange")
                    $oitem.fireEvent("OnClick")
                EndIf
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
        Case Else
            __IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x3, 0x0)
        EndSwitch
    EndFunc    ; -> _IEFormElementCheckBoxSelect

    Func _IEFormElementRadioSelect(ByRef $oobject, $sstring, $sname, $iselect = 0x1, $smode = "byValue", $ifireevent = 0x1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "form") Then
            __IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $sstring = String($sstring)
        $sname = String($sname)
        Local $oitems = Execute("$oObject.elements('" & $sname & "')")
        If Not IsObj($oitems) Then
            __IEConsoleWriteError("Warning", "_IEFormElementRadioSelect", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x3, 0x0)
        EndIf
        Local $oitem, $bfound = False
        Switch $smode
        Case "byValue"
            If __IEIsObjType($oitems, "forminputelement") Then
                $oitem = $oitems
                If String($oitem.type) = "radio" And String($oitem.value) = $sstring Then $bfound = True
            Else
                For $oitem In $oitems
                    If String($oitem.type) = "radio" And String($oitem.value) = $sstring Then
                        $bfound = True
                        ExitLoop
                    EndIf
                Next
            EndIf
        Case "byIndex"
            If __IEIsObjType($oitems, "forminputelement") Then
                $oitem = $oitems
                If String($oitem.type) = "radio" And Number($sstring) = 0x0 Then $bfound = True
            Else
                Local $icount = 0x0
                For $oitem In $oitems
                    If String($oitem.type) = "radio" And Number($sstring) = $icount Then
                        $bfound = True
                        ExitLoop
                    Else
                        $icount += 0x1
                    EndIf
                Next
            EndIf
        Case Else
            __IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidValue", "Invalid Mode")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x5, 0x0)
        EndSwitch
        If Not $bfound Then
            __IEConsoleWriteError("Warning", "_IEFormElementRadioSelect", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
        EndIf
        Switch $iselect
        Case + -1
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oitem.checked)
        Case 0x0
            If $oitem.checked Then
                $oitem.checked = False
                If $ifireevent Then
                    $oitem.fireEvent("onChange")
                    $oitem.fireEvent("OnClick")
                EndIf
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
        Case 0x1
            If Not $oitem.checked Then
                $oitem.checked = True
                If $ifireevent Then
                    $oitem.fireEvent("onChange")
                    $oitem.fireEvent("OnClick")
                EndIf
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
        Case Else
            __IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidValue", "$iSelect value invalid")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x4, 0x0)
        EndSwitch
    EndFunc    ; -> _IEFormElementRadioSelect

    Func _IEFormImageClick(ByRef $oobject, $slinktext, $smode = "src", $iindex = 0x0, $iwait = 0x1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormImageClick", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $smodelinktext, $ifound = 0x0
        Local $otemp = _IEDocGetObj($oobject)
        Local $oimgs = _IETagNameGetCollection($otemp, "input")
        $smode = StringLower($smode)
        $iindex = Number($iindex)
        For $oimg In $oimgs
            If String($oimg.type) = "image" Then
                Select
                Case $smode = "alt"
                    $smodelinktext = $oimg.alt
                Case $smode = "name"
                    $smodelinktext = $oimg.name
                    If Not IsString($smodelinktext) Then $smodelinktext = $oimg.id
                Case $smode = "id"
                    $smodelinktext = $oimg.id
                Case $smode = "src"
                    $smodelinktext = $oimg.src
                Case Else
                    __IEConsoleWriteError("Error", "_IEFormImageClick", "$_IESTATUS_InvalidValue", "Invalid mode: " & $smode)
                    Return SetError($_IESTATUS_INVALIDVALUE, 0x3, 0x0)
                EndSelect
                If StringInStr($smodelinktext, $slinktext) Then
                    If ($ifound = $iindex) Then
                        $oimg.click()
                        If @error Then
                            __IEConsoleWriteError("Error", "_IEFormImageClick", "$_IESTATUS_COMError", @error)
                            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
                        EndIf
                        If $iwait Then
                            _IELoadWait($oobject)
                            Return SetError(@error, 0x0, + -1)
                        EndIf
                        Return SetError($_IESTATUS_SUCCESS, 0x0, + -1)
                    EndIf
                    $ifound = $ifound + 0x1
                EndIf
            EndIf
        Next
        __IEConsoleWriteError("Warning", "_IEFormImageClick", "$_IESTATUS_NoMatch")
        Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
    EndFunc    ; -> _IEFormImageClick

    Func _IEFormSubmit(ByRef $oobject, $iwait = 0x1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormSubmit", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "form") Then
            __IEConsoleWriteError("Error", "_IEFormSubmit", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Local $owindow = $oobject.document.parentWindow
        $oobject.submit()
        If @error Then
            __IEConsoleWriteError("Error", "_IEFormSubmit", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        If $iwait Then
            _IELoadWait($owindow)
            Return SetError(@error, 0x0, + -1)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, + -1)
    EndFunc    ; -> _IEFormSubmit

    Func _IEFormReset(ByRef $oobject)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEFormReset", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "form") Then
            __IEConsoleWriteError("Error", "_IEFormReset", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $oobject.reset()
        If @error Then
            __IEConsoleWriteError("Error", "_IEFormReset", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
    EndFunc    ; -> _IEFormReset

#EndRegion Form functions
#Region Table functions
    Func _IETableGetCollection(ByRef $oobject, $iindex = + -1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IETableGetCollection", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        $iindex = Number($iindex)
        Select
        Case $iindex = + -1
            Return SetError($_IESTATUS_SUCCESS, $oobject.document.GetElementsByTagName("table").length, $oobject.document.GetElementsByTagName("table"))
        Case $iindex > + -1 And $iindex < $oobject.document.GetElementsByTagName("table").length
            Return SetError($_IESTATUS_SUCCESS, $oobject.document.GetElementsByTagName("table").length, $oobject.document.GetElementsByTagName("table").item($iindex))
        Case $iindex < + -1
            __IEConsoleWriteError("Error", "_IETableGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
        Case Else
            __IEConsoleWriteError("Warning", "_IETableGetCollection", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x1, 0x0)
        EndSelect
    EndFunc    ; -> _IETableGetCollection

    Func _IETableWriteToArray(ByRef $oobject, $btranspose = False)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IETableWriteToArray", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "table") Then
            __IEConsoleWriteError("Error", "_IETableWriteToArray", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Local $icols = 0x0, $otds, $icol
        Local $otrs = $oobject.rows
        For $otr In $otrs
            $otds = $otr.cells
            $icol = 0x0
            For $otd In $otds
                $icol = $icol + $otd.colSpan
            Next
            If $icol > $icols Then $icols = $icol
        Next
        Local $irows = $otrs.length
        Local $atablecells[$icols][$irows]
        Local $irow = 0x0
        For $otr In $otrs
            $otds = $otr.cells
            $icol = 0x0
            For $otd In $otds
                $atablecells[$icol][$irow] = String($otd.innerText)
                If @error Then
                    __IEConsoleWriteError("Error", "_IETableWriteToArray", "$_IESTATUS_COMError", @error)
                    Return SetError($_IESTATUS_COMERROR, @error, 0x0)
                EndIf
                $icol = $icol + $otd.colSpan
            Next
            $irow = $irow + 0x1
        Next
        If $btranspose Then
            Local $id1 = UBound($atablecells, $UBOUND_ROWS), $id2 = UBound($atablecells, $UBOUND_COLUMNS), $atmp[$id2][$id1]
            For $i = 0x0 To $id2 + -1
                For $j = 0x0 To $id1 + -1
                    $atmp[$i][$j] = $atablecells[$j][$i]
                Next
            Next
            $atablecells = $atmp
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, $atablecells)
    EndFunc    ; -> _IETableWriteToArray

#EndRegion Table functions
#Region Read/Write functions
    Func _IEBodyReadHTML(ByRef $oobject)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEBodyReadHTML", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.body.innerHTML)
    EndFunc    ; -> _IEBodyReadHTML

    Func _IEBodyReadText(ByRef $oobject)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEBodyReadText", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Then
            __IEConsoleWriteError("Error", "_IEBodyReadText", "$_IESTATUS_InvalidObjectType", "Expected document element")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.body.innerText)
    EndFunc    ; -> _IEBodyReadText

    Func _IEBodyWriteHTML(ByRef $oobject, $shtml)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEBodyWriteHTML", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Then
            __IEConsoleWriteError("Error", "_IEBodyWriteHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $oobject.document.body.innerHTML = $shtml
        If @error Then
            __IEConsoleWriteError("Error", "_IEBodyWriteHTML", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        Local $otemp = $oobject.document
        _IELoadWait($otemp)
        Return SetError(@error, 0x0, + -1)
    EndFunc    ; -> _IEBodyWriteHTML

    Func _IEDocReadHTML(ByRef $oobject)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEDocReadHTML", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Then
            __IEConsoleWriteError("Error", "_IEDocReadHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.documentElement.outerHTML)
    EndFunc    ; -> _IEDocReadHTML

    Func _IEDocWriteHTML(ByRef $oobject, $shtml)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEDocWriteHTML", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Then
            __IEConsoleWriteError("Error", "_IEDocWriteHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $oobject.document.Write($shtml)
        $oobject.document.close()
        Local $otemp = $oobject.document
        If @error Then
            __IEConsoleWriteError("Error", "_IEDocWriteHTML", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        _IELoadWait($otemp)
        Return SetError(@error, 0x0, + -1)
    EndFunc    ; -> _IEDocWriteHTML

    Func _IEDocInsertText(ByRef $oobject, $sstring, $swhere = "beforeend")
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Or __IEIsObjType($oobject, "documentcontainer") Or __IEIsObjType($oobject, "document") Then
            __IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_InvalidObjectType", "Expected document element")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $swhere = StringLower($swhere)
        Select
        Case $swhere = "beforebegin"
            $oobject.insertAdjacentText($swhere, $sstring)
        Case $swhere = "afterbegin"
            $oobject.insertAdjacentText($swhere, $sstring)
        Case $swhere = "beforeend"
            $oobject.insertAdjacentText($swhere, $sstring)
        Case $swhere = "afterend"
            $oobject.insertAdjacentText($swhere, $sstring)
        Case Else
            __IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_InvalidValue", "Invalid where value")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x3, 0x0)
        EndSelect
        If @error Then
            __IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
    EndFunc    ; -> _IEDocInsertText

    Func _IEDocInsertHTML(ByRef $oobject, $sstring, $swhere = "beforeend")
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Or __IEIsObjType($oobject, "documentcontainer") Or __IEIsObjType($oobject, "document") Then
            __IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $swhere = StringLower($swhere)
        Select
        Case $swhere = "beforebegin"
            $oobject.insertAdjacentHTML($swhere, $sstring)
        Case $swhere = "afterbegin"
            $oobject.insertAdjacentHTML($swhere, $sstring)
        Case $swhere = "beforeend"
            $oobject.insertAdjacentHTML($swhere, $sstring)
        Case $swhere = "afterend"
            $oobject.insertAdjacentHTML($swhere, $sstring)
        Case Else
            __IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_InvalidValue", "Invalid where value")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x3, 0x0)
        EndSelect
        If @error Then
            __IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
    EndFunc    ; -> _IEDocInsertHTML

    Func _IEHeadInsertEventScript(ByRef $oobject, $shtmlfor, $sevent, $sscript)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEHeadInsertEventScript", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $ohead = $oobject.document.all.tags("HEAD").Item(0x0)
        Local $oscript = $oobject.document.createElement("script")
        If @error Then
            __IEConsoleWriteError("Error", "_IEHeadInsertEventScript(script)", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        With $oscript
            .defer = True
            .language = "jscript"
            .type = "text/javascript"
            .htmlFor = $shtmlfor
            .event = $sevent
            .text = $sscript
        EndWith
        $ohead.appendChild($oscript)
        If @error Then
            __IEConsoleWriteError("Error", "_IEHeadInsertEventScript", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
    EndFunc    ; -> _IEHeadInsertEventScript

#EndRegion Read/Write functions
#Region Utility functions
    Func _IEDocGetObj(ByRef $oobject)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEDocGetObj", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If __IEIsObjType($oobject, "document") Then
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document)
    EndFunc    ; -> _IEDocGetObj

    Func _IETagNameGetCollection(ByRef $oobject, $stagname, $iindex = + -1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Then
            __IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Local $otemp
        If __IEIsObjType($oobject, "documentcontainer") Then
            $otemp = _IEDocGetObj($oobject)
        Else
            $otemp = $oobject
        EndIf
        $iindex = Number($iindex)
        Select
        Case $iindex = + -1
            Return SetError($_IESTATUS_SUCCESS, $otemp.GetElementsByTagName($stagname).length, $otemp.GetElementsByTagName($stagname))
        Case $iindex > + -1 And $iindex < $otemp.GetElementsByTagName($stagname).length
            Return SetError($_IESTATUS_SUCCESS, $otemp.GetElementsByTagName($stagname).length, $otemp.GetElementsByTagName($stagname).item($iindex))
        Case $iindex < + -1
            __IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x3, 0x0)
        Case Else
            __IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x0, 0x0)
        EndSelect
    EndFunc    ; -> _IETagNameGetCollection

    Func _IETagNameAllGetCollection(ByRef $oobject, $iindex = + -1)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Then
            __IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Local $otemp
        If __IEIsObjType($oobject, "documentcontainer") Then
            $otemp = _IEDocGetObj($oobject)
        Else
            $otemp = $oobject
        EndIf
        $iindex = Number($iindex)
        Select
        Case $iindex = + -1
            Return SetError($_IESTATUS_SUCCESS, $otemp.all.length, $otemp.all)
        Case $iindex > + -1 And $iindex < $otemp.all.length
            Return SetError($_IESTATUS_SUCCESS, $otemp.all.length, $otemp.all.item($iindex))
        Case $iindex < + -1
            __IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
        Case Else
            __IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_NoMatch")
            Return SetError($_IESTATUS_NOMATCH, 0x1, 0x0)
        EndSelect
    EndFunc    ; -> _IETagNameAllGetCollection

    Func _IEGetObjByName(ByRef $oobject, $sname, $iindex = 0x0)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEGetObjByName", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        $iindex = Number($iindex)
        If $iindex = + -1 Then
            Return SetError($_IESTATUS_SUCCESS, $oobject.document.GetElementsByName($sname).length, $oobject.document.GetElementsByName($sname))
        Else
            If IsObj($oobject.document.GetElementsByName($sname).item($iindex)) Then
                Return SetError($_IESTATUS_SUCCESS, $oobject.document.GetElementsByName($sname).length, $oobject.document.GetElementsByName($sname).item($iindex))
            Else
                __IEConsoleWriteError("Warning", "_IEGetObjByName", "$_IESTATUS_NoMatch", "Name: " & $sname & ", Index: " & $iindex)
                Return SetError($_IESTATUS_NOMATCH, 0x0, 0x0)
            EndIf
        EndIf
    EndFunc    ; -> _IEGetObjByName

    Func _IEGetObjById(ByRef $oobject, $sid)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEGetObjById", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Then
            __IEConsoleWriteError("Error", "_IEGetObById", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        If IsObj($oobject.document.getElementById($sid)) Then
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.getElementById($sid))
        Else
            __IEConsoleWriteError("Warning", "_IEGetObjById", "$_IESTATUS_NoMatch", $sid)
            Return SetError($_IESTATUS_NOMATCH, 0x2, 0x0)
        EndIf
    EndFunc    ; -> _IEGetObjById

    Func _IEAction(ByRef $oobject, $saction)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEAction(" & $saction & ")", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        $saction = StringLower($saction)
        Select
        Case $saction = "click"
            If __IEIsObjType($oobject, "documentContainer") Then
                __IEConsoleWriteError("Error", "_IEAction(click)", " $_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.Click()
        Case $saction = "disable"
            If __IEIsObjType($oobject, "documentContainer") Then
                __IEConsoleWriteError("Error", "_IEAction(disable)", " $_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.disabled = True
        Case $saction = "enable"
            If __IEIsObjType($oobject, "documentContainer") Then
                __IEConsoleWriteError("Error", "_IEAction(enable)", " $_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.disabled = False
        Case $saction = "focus"
            If __IEIsObjType($oobject, "documentContainer") Then
                __IEConsoleWriteError("Error", "_IEAction(focus)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.Focus()
        Case $saction = "scrollintoview"
            If __IEIsObjType($oobject, "documentContainer") Then
                __IEConsoleWriteError("Error", "_IEAction(scrollintoview)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.scrollIntoView()
        Case $saction = "copy"
            $oobject.document.execCommand("Copy")
        Case $saction = "cut"
            $oobject.document.execCommand("Cut")
        Case $saction = "paste"
            $oobject.document.execCommand("Paste")
        Case $saction = "delete"
            $oobject.document.execCommand("Delete")
        Case $saction = "saveas"
            $oobject.document.execCommand("SaveAs")
        Case $saction = "refresh"
            $oobject.document.execCommand("Refresh")
            If @error Then
                __IEConsoleWriteError("Error", "_IEAction(refresh)", "$_IESTATUS_COMError", @error)
                Return SetError($_IESTATUS_COMERROR, @error, 0x0)
            EndIf
            _IELoadWait($oobject)
        Case $saction = "selectall"
            $oobject.document.execCommand("SelectAll")
        Case $saction = "unselect"
            $oobject.document.execCommand("Unselect")
        Case $saction = "print"
            $oobject.document.parentwindow.Print()
        Case $saction = "printdefault"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEAction(printdefault)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.execWB(0x6, 0x2)
        Case $saction = "back"
            If Not __IEIsObjType($oobject, "documentContainer") Then
                __IEConsoleWriteError("Error", "_IEAction(back)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.GoBack()
        Case $saction = "blur"
            $oobject.Blur()
        Case $saction = "forward"
            If Not __IEIsObjType($oobject, "documentContainer") Then
                __IEConsoleWriteError("Error", "_IEAction(forward)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.GoForward()
        Case $saction = "home"
            If Not __IEIsObjType($oobject, "documentContainer") Then
                __IEConsoleWriteError("Error", "_IEAction(home)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.GoHome()
        Case $saction = "invisible"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEAction(invisible)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.visible = 0x0
        Case $saction = "visible"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEAction(visible)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.visible = 0x1
        Case $saction = "search"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEAction(search)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.GoSearch()
        Case $saction = "stop"
            If Not __IEIsObjType($oobject, "documentContainer") Then
                __IEConsoleWriteError("Error", "_IEAction(stop)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.Stop()
        Case $saction = "quit"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEAction(quit)", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.Quit()
            If @error Then
                __IEConsoleWriteError("Error", "_IEAction(" & $saction & ")", "$_IESTATUS_COMError", @error)
                Return SetError($_IESTATUS_COMERROR, @error, 0x0)
            EndIf
            $oobject = 0x0
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
        Case Else
            __IEConsoleWriteError("Error", "_IEAction(" & $saction & ")", "$_IESTATUS_InvalidValue", "Invalid Action")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
        EndSelect
        If @error Then
            __IEConsoleWriteError("Error", "_IEAction(" & $saction & ")", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
    EndFunc    ; -> _IEAction

    Func _IEPropertyGet(ByRef $oobject, $sproperty)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browserdom") Then
            __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        Local $otemp, $itemp
        $sproperty = StringLower($sproperty)
        Select
        Case $sproperty = "browserx"
            If __IEIsObjType($oobject, "browsercontainer") Or __IEIsObjType($oobject, "document") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $otemp = $oobject
            $itemp = 0x0
            While IsObj($otemp)
                $itemp += $otemp.offsetLeft
                $otemp = $otemp.offsetParent
            WEnd
            Return SetError($_IESTATUS_SUCCESS, 0x0, $itemp)
        Case $sproperty = "browsery"
            If __IEIsObjType($oobject, "browsercontainer") Or __IEIsObjType($oobject, "document") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $otemp = $oobject
            $itemp = 0x0
            While IsObj($otemp)
                $itemp += $otemp.offsetTop
                $otemp = $otemp.offsetParent
            WEnd
            Return SetError($_IESTATUS_SUCCESS, 0x0, $itemp)
        Case $sproperty = "screenx"
            If __IEIsObjType($oobject, "window") Or __IEIsObjType($oobject, "document") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            If __IEIsObjType($oobject, "browser") Then
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.left())
            Else
                $otemp = $oobject
                $itemp = 0x0
                While IsObj($otemp)
                    $itemp += $otemp.offsetLeft
                    $otemp = $otemp.offsetParent
                WEnd
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $itemp + $oobject.document.parentWindow.screenLeft)
        Case $sproperty = "screeny"
            If __IEIsObjType($oobject, "window") Or __IEIsObjType($oobject, "document") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            If __IEIsObjType($oobject, "browser") Then
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.top())
            Else
                $otemp = $oobject
                $itemp = 0x0
                While IsObj($otemp)
                    $itemp += $otemp.offsetTop
                    $otemp = $otemp.offsetParent
                WEnd
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $itemp + $oobject.document.parentWindow.screenTop)
        Case $sproperty = "height"
            If __IEIsObjType($oobject, "window") Or __IEIsObjType($oobject, "document") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            If __IEIsObjType($oobject, "browser") Then
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.Height())
            Else
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.offsetHeight)
            EndIf
        Case $sproperty = "width"
            If __IEIsObjType($oobject, "window") Or __IEIsObjType($oobject, "document") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            If __IEIsObjType($oobject, "browser") Then
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.Width())
            Else
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.offsetWidth)
            EndIf
        Case $sproperty = "isdisabled"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.isDisabled())
        Case $sproperty = "addressbar"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.AddressBar())
        Case $sproperty = "busy"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.Busy())
        Case $sproperty = "fullscreen"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.fullScreen())
        Case $sproperty = "hwnd"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, HWnd($oobject.HWnd()))
        Case $sproperty = "left"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.Left())
        Case $sproperty = "locationname"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.LocationName())
        Case $sproperty = "locationurl"
            If __IEIsObjType($oobject, "browser") Then
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.locationURL())
            EndIf
            If __IEIsObjType($oobject, "window") Then
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.location.href())
            EndIf
            If __IEIsObjType($oobject, "document") Then
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.parentwindow.location.href())
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentwindow.location.href())
        Case $sproperty = "menubar"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.MenuBar())
        Case $sproperty = "offline"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.OffLine())
        Case $sproperty = "readystate"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.ReadyState())
        Case $sproperty = "resizable"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.Resizable())
        Case $sproperty = "silent"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.Silent())
        Case $sproperty = "statusbar"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.StatusBar())
        Case $sproperty = "statustext"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.StatusText())
        Case $sproperty = "top"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.Top())
        Case $sproperty = "visible"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.Visible())
        Case $sproperty = "appcodename"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.appCodeName())
        Case $sproperty = "appminorversion"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.appMinorVersion())
        Case $sproperty = "appname"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.appName())
        Case $sproperty = "appversion"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.appVersion())
        Case $sproperty = "browserlanguage"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.browserLanguage())
        Case $sproperty = "cookieenabled"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.cookieEnabled())
        Case $sproperty = "cpuclass"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.cpuClass())
        Case $sproperty = "javaenabled"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.javaEnabled())
        Case $sproperty = "online"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.onLine())
        Case $sproperty = "platform"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.platform())
        Case $sproperty = "systemlanguage"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.systemLanguage())
        Case $sproperty = "useragent"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.userAgent())
        Case $sproperty = "userlanguage"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.parentWindow.top.navigator.userLanguage())
        Case $sproperty = "referrer"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.referrer)
        Case $sproperty = "theatermode"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.TheaterMode)
        Case $sproperty = "toolbar"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.ToolBar)
        Case $sproperty = "contenteditable"
            If __IEIsObjType($oobject, "browser") Or __IEIsObjType($oobject, "document") Then
                $otemp = $oobject.document.body
            Else
                $otemp = $oobject
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $otemp.isContentEditable)
        Case $sproperty = "innertext"
            If __IEIsObjType($oobject, "documentcontainer") Or __IEIsObjType($oobject, "document") Then
                $otemp = $oobject.document.body
            Else
                $otemp = $oobject
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $otemp.innerText)
        Case $sproperty = "outertext"
            If __IEIsObjType($oobject, "documentcontainer") Or __IEIsObjType($oobject, "document") Then
                $otemp = $oobject.document.body
            Else
                $otemp = $oobject
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $otemp.outerText)
        Case $sproperty = "innerhtml"
            If __IEIsObjType($oobject, "documentcontainer") Or __IEIsObjType($oobject, "document") Then
                $otemp = $oobject.document.body
            Else
                $otemp = $oobject
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $otemp.innerHTML)
        Case $sproperty = "outerhtml"
            If __IEIsObjType($oobject, "documentcontainer") Or __IEIsObjType($oobject, "document") Then
                $otemp = $oobject.document.body
            Else
                $otemp = $oobject
            EndIf
            Return SetError($_IESTATUS_SUCCESS, 0x0, $otemp.outerHTML)
        Case $sproperty = "title"
            Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.document.title)
        Case $sproperty = "uniqueid"
            If __IEIsObjType($oobject, "window") Then
                __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            Else
                Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject.uniqueID)
            EndIf
        Case Else
            __IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidValue", "Invalid Property")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
        EndSelect
    EndFunc    ; -> _IEPropertyGet

    Func _IEPropertySet(ByRef $oobject, $sproperty, $vvalue)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $otemp
        #forceref $oTemp
        $sproperty = StringLower($sproperty)
        Select
        Case $sproperty = "addressbar"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.AddressBar = $vvalue
        Case $sproperty = "height"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.Height = $vvalue
        Case $sproperty = "left"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.Left = $vvalue
        Case $sproperty = "menubar"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.MenuBar = $vvalue
        Case $sproperty = "offline"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.OffLine = $vvalue
        Case $sproperty = "resizable"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.Resizable = $vvalue
        Case $sproperty = "statusbar"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.StatusBar = $vvalue
        Case $sproperty = "statustext"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.StatusText = $vvalue
        Case $sproperty = "top"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.Top = $vvalue
        Case $sproperty = "width"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            $oobject.Width = $vvalue
        Case $sproperty = "theatermode"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            If $vvalue Then
                $oobject.TheaterMode = True
            Else
                $oobject.TheaterMode = False
            EndIf
        Case $sproperty = "toolbar"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            If $vvalue Then
                $oobject.ToolBar = True
            Else
                $oobject.ToolBar = False
            EndIf
        Case $sproperty = "contenteditable"
            If __IEIsObjType($oobject, "browser") Or __IEIsObjType($oobject, "document") Then
                $otemp = $oobject.document.body
            Else
                $otemp = $oobject
            EndIf
            If $vvalue Then
                $otemp.contentEditable = "true"
            Else
                $otemp.contentEditable = "false"
            EndIf
        Case $sproperty = "innertext"
            If __IEIsObjType($oobject, "documentcontainer") Or __IEIsObjType($oobject, "document") Then
                $otemp = $oobject.document.body
            Else
                $otemp = $oobject
            EndIf
            $otemp.innerText = $vvalue
        Case $sproperty = "outertext"
            If __IEIsObjType($oobject, "documentcontainer") Or __IEIsObjType($oobject, "document") Then
                $otemp = $oobject.document.body
            Else
                $otemp = $oobject
            EndIf
            $otemp.outerText = $vvalue
        Case $sproperty = "innerhtml"
            If __IEIsObjType($oobject, "documentcontainer") Or __IEIsObjType($oobject, "document") Then
                $otemp = $oobject.document.body
            Else
                $otemp = $oobject
            EndIf
            $otemp.innerHTML = $vvalue
        Case $sproperty = "outerhtml"
            If __IEIsObjType($oobject, "documentcontainer") Or __IEIsObjType($oobject, "document") Then
                $otemp = $oobject.document.body
            Else
                $otemp = $oobject
            EndIf
            $otemp.outerHTML = $vvalue
        Case $sproperty = "title"
            $oobject.document.title = $vvalue
        Case $sproperty = "silent"
            If Not __IEIsObjType($oobject, "browser") Then
                __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
                Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
            EndIf
            If $vvalue Then
                $oobject.silent = True
            Else
                $oobject.silent = False
            EndIf
        Case Else
            __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidValue", "Invalid Property")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x2, 0x0)
        EndSelect
        If @error Then
            __IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
    EndFunc    ; -> _IEPropertySet

    Func _IEErrorNotify($vnotify = Default)
        If $vnotify = Default Then Return $__g_bieerrornotify
        If $vnotify Then
            $__g_bieerrornotify = True
        Else
            $__g_bieerrornotify = False
        EndIf
        Return 0x1
    EndFunc    ; -> _IEErrorNotify

    Func _IEErrorHandlerRegister($sfunctionname = "__IEInternalErrorHandler")
        $__g_oieerrorhandler = ObjEvent("AutoIt.Error", $sfunctionname)
        If IsObj($__g_oieerrorhandler) Then
            $__g_sieusererrorhandler = $sfunctionname
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
        Else
            $__g_oieerrorhandler = ''
            __IEConsoleWriteError("Error", "_IEErrorHandlerRegister", "$_IEStatus_GeneralError", "Error Handler Not Registered - Check existance of error function")
            Return SetError($_IESTATUS_GENERALERROR, 0x1, 0x0)
        EndIf
    EndFunc    ; -> _IEErrorHandlerRegister

    Func _IEErrorHandlerDeRegister()
        $__g_sieusererrorhandler = ''
        $__g_oieerrorhandler = ''
        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
    EndFunc    ; -> _IEErrorHandlerDeRegister

    Func __IEInternalErrorHandlerRegister()
        Local $scurrenterrorhandler = ObjEvent("AutoIt.Error")
        If $scurrenterrorhandler <> '' And Not IsObj($__g_oieerrorhandler) Then
            Return SetError($_IESTATUS_GENERALERROR, 0x0, False)
        EndIf
        $__g_oieerrorhandler = ObjEvent("AutoIt.Error", "__IEInternalErrorHandler")
        If IsObj($__g_oieerrorhandler) Then
            Return SetError($_IESTATUS_SUCCESS, 0x0, True)
        Else
            $__g_oieerrorhandler = ''
            Return SetError($_IESTATUS_GENERALERROR, 0x0, False)
        EndIf
    EndFunc    ; -> __IEInternalErrorHandlerRegister

    Func __IEInternalErrorHandlerDeRegister()
        $__g_oieerrorhandler = ''
        If $__g_sieusererrorhandler <> '' Then
            $__g_oieerrorhandler = ObjEvent("AutoIt.Error", $__g_sieusererrorhandler)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
    EndFunc    ; -> __IEInternalErrorHandlerDeRegister

    Func __IEInternalErrorHandler($ocomerror)
        If $__g_bieerrornotify Or $__g_bieau3debug Then ConsoleWrite("--> " & __COMErrorFormating($ocomerror, "----> $IEComError") & @CRLF)
        Return SetError($_IESTATUS_COMERROR)
    EndFunc    ; -> __IEInternalErrorHandler

    Func _IEQuit(ByRef $oobject)
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "_IEQuit", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "browser") Then
            __IEConsoleWriteError("Error", "_IEQuit", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $oobject.quit()
        If @error Then
            __IEConsoleWriteError("Error", "_IEQuit", "$_IESTATUS_COMError", @error)
            Return SetError($_IESTATUS_COMERROR, @error, 0x0)
        EndIf
        $oobject = 0x0
        Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
    EndFunc    ; -> _IEQuit

#EndRegion Utility functions
#Region General
    Func _IE_Introduction($smodule = "basic")
        Local $shtml = ''
        Switch $smodule
        Case "basic"
            $shtml &= "<!DOCTYPE html>" & @CR
            $shtml &= "<html>" & @CR
            $shtml &= "<head>" & @CR
            $shtml &= "<meta content=""text/html; charset=UTF-8"" http-equiv=""content-type"">" & @CR
            $shtml &= "<title>_IE_Introduction (""basic"")</title>" & @CR
            $shtml &= "<style>body {font-family: Arial}" & @CR
            $shtml &= "td {padding:6px}</style>" & @CR
            $shtml &= "</head>" & @CR
            $shtml &= "<body>" & @CR
            $shtml &= "<table border=1 id=""table1"" style=""width:600px;border-spacing:6px;"">" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<h1>Welcome to IE.au3</h1>" & @CR
            $shtml &= "IE.au3 is a UDF (User Defined Function) library for the " & @CR
            $shtml &= "<a href=""http://www.autoitscript.com"">AutoIt</a> scripting language." & @CR
            $shtml &= "<br>  " & @CR
            $shtml &= "IE.au3 allows you to either create or attach to an Internet Explorer browser and do " & @CR
            $shtml &= "just about anything you could do with it interactively with the mouse and " & @CR
            $shtml &= "keyboard, but do it through script." & @CR
            $shtml &= "<br>" & @CR
            $shtml &= "You can navigate to pages, click links, fill and submit forms etc. You can " & @CR
            $shtml &= "also do things you cannot do interactively like change or rewrite page " & @CR
            $shtml &= "content and JavaScripts, read, parse and save page content and monitor and act " & @CR
            $shtml &= "upon browser ""events"".<br>" & @CR
            $shtml &= "IE.au3 uses the COM interface in AutoIt to interact with the Internet Explorer " & @CR
            $shtml &= "object model and the DOM (Document Object Model) supported by the browser." & @CR
            $shtml &= "<br>" & @CR
            $shtml &= "Here are some links for more information and helpful tools:<br>" & @CR
            $shtml &= "Reference Material: " & @CR
            $shtml &= "<ul>" & @CR
            $shtml &= "<li><a href=""http://msdn1.microsoft.com/"">MSDN (Microsoft Developer Network)</a></li>" & @CR
            $shtml &= "<li><a href=""http://msdn2.microsoft.com/en-us/library/aa752084.aspx"" target=""_blank"">InternetExplorer Object</a></li>" & @CR
            $shtml &= "<li><a href=""http://msdn2.microsoft.com/en-us/library/ms531073.aspx"" target=""_blank"">Document Object</a></li>" & @CR
            $shtml &= "<li><a href=""http://msdn2.microsoft.com/en-us/ie/aa740473.aspx"" target=""_blank"">Overviews and Tutorials</a></li>" & @CR
            $shtml &= "<li><a href=""http://msdn2.microsoft.com/en-us/library/ms533029.aspx"" target=""_blank"">DHTML Objects</a></li>" & @CR
            $shtml &= "<li><a href=""http://msdn2.microsoft.com/en-us/library/ms533051.aspx"" target=""_blank"">DHTML Events</a></li>" & @CR
            $shtml &= "</ul><br>" & @CR
            $shtml &= "Helpful Tools: " & @CR
            $shtml &= "<ul>" & @CR
            $shtml &= "<li><a href=""http://www.autoitscript.com/forum/index.php?showtopic=19368"" target=""_blank"">AutoIt IE Builder</a> (build IE scripts interactively)</li>" & @CR
            $shtml &= "<li><a href=""http://www.debugbar.com/"" target=""_blank"">DebugBar</a> (DOM inspector, HTTP inspector, HTML validator and more - free for personal use) Recomme" & _
                "nded</li>" & @CR
            $shtml &= "<li><a href=""http://www.microsoft.com/downloads/details.aspx?FamilyID=e59c3964-672d-4511-bb3e-2d5e1db91038&amp;displaylang=en"" target=""_blank"">IE Developer " & _
                "Toolbar</a> (comprehensive DOM analysis tool)</li>" & @CR
            $shtml &= "<li><a href=""http://slayeroffice.com/tools/modi/v2.0/modi_help.html"" target=""_blank"">MODIV2</a> (view the DOM of a web page by mousing around)</li>" & @CR
            $shtml &= "<li><a href=""http://validator.w3.org/"" target=""_blank"">HTML Validator</a> (verify HTML follows format rules)</li>" & @CR
            $shtml &= "<li><a href=""http://www.fiddlertool.com/fiddler/"" target=""_blank"">Fiddler</a> (examine HTTP traffic)</li>" & @CR
            $shtml &= "</ul>" & @CR
            $shtml &= "</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "</table>" & @CR
            $shtml &= "</body>" & @CR
            $shtml &= "</html>"
        Case Else
            __IEConsoleWriteError("Error", "_IE_Introduction", "$_IESTATUS_InvalidValue")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x1, 0x0)
        EndSwitch
        Local $oobject = _IECreate()
        _IEDocWriteHTML($oobject, $shtml)
        Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject)
    EndFunc    ; -> _IE_Introduction

    Func _IE_Example($smodule = "basic")
        Local $shtml = '', $oobject
        Switch $smodule
        Case "basic"
            $shtml &= "<!DOCTYPE html>" & @CR
            $shtml &= "<html>" & @CR
            $shtml &= "<head>" & @CR
            $shtml &= "<meta content=""text/html; charset=UTF-8"" http-equiv=""content-type"">" & @CR
            $shtml &= "<title>_IE_Example(""basic"")</title>" & @CR
            $shtml &= "<style>body {font-family: Arial}</style>" & @CR
            $shtml &= "</head>" & @CR
            $shtml &= "<body>" & @CR
            $shtml &= "<a href=""http://www.autoitscript.com""><img src=""http://www.autoitscript.com/images/logo_autoit_210x72.png"" id=""AutoItImage"" alt=""AutoIt Homepage Image"" " & _
                "style=""background: #204080;""></a>" & @CR
            $shtml &= "<p></p>" & @CR
            $shtml &= "<div id=""line1"">This is a simple HTML page with text, links and images.</div>" & @CR
            $shtml &= "<br>" & @CR
            $shtml &= "<div id=""line2""><a href=""http://www.autoitscript.com"">AutoIt</a> is a wonderful automation scripting language.</div>" & @CR
            $shtml &= "<br>" & @CR
            $shtml &= "<div id=""line3"">It is supported by a very active and supporting <a href=""http://www.autoitscript.com/forum/"">user forum</a>.</div>" & @CR
            $shtml &= "<br>" & @CR
            $shtml &= "<div id=""IEAu3Data""></div>" & @CR
            $shtml &= "</body>" & @CR
            $shtml &= "</html>"
            $oobject = _IECreate()
            _IEDocWriteHTML($oobject, $shtml)
        Case "table"
            $shtml &= "<!DOCTYPE html>" & @CR
            $shtml &= "<html>" & @CR
            $shtml &= "<head>" & @CR
            $shtml &= "<meta content=""text/html; charset=utf-8"" http-equiv=""content-type"">" & @CR
            $shtml &= "<title>_IE_Example(""table"")</title>" & @CR
            $shtml &= "<style>body {font-family: Arial}</style>" & @CR
            $shtml &= "</head>" & @CR
            $shtml &= "<body>" & @CR
            $shtml &= "$oTableOne = _IETableGetObjByName($oIE, ""tableOne"")<br>" & @CR
            $shtml &= "&lt;table border=1 id=""tableOne""&gt;<br>" & @CR
            $shtml &= "<table border=1 id=""tableOne"">" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td>AutoIt</td>" & @CR
            $shtml &= "\t\t<td>is</td>" & @CR
            $shtml &= "\t\t<td>really</td>" & @CR
            $shtml &= "\t\t<td>great</td>" & @CR
            $shtml &= "\t\t<td>with</td>" & @CR
            $shtml &= "\t\t<td>IE.au3</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td>1</td>" & @CR
            $shtml &= "\t\t<td>2</td>" & @CR
            $shtml &= "\t\t<td>3</td>" & @CR
            $shtml &= "\t\t<td>4</td>" & @CR
            $shtml &= "\t\t<td>5</td>" & @CR
            $shtml &= "\t\t<td>6</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td>the</td>" & @CR
            $shtml &= "\t\t<td>quick</td>" & @CR
            $shtml &= "\t\t<td>red</td>" & @CR
            $shtml &= "\t\t<td>fox</td>" & @CR
            $shtml &= "\t\t<td>jumped</td>" & @CR
            $shtml &= "\t\t<td>over</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td>the</td>" & @CR
            $shtml &= "\t\t<td>lazy</td>" & @CR
            $shtml &= "\t\t<td>brown</td>" & @CR
            $shtml &= "\t\t<td>dog</td>" & @CR
            $shtml &= "\t\t<td>the</td>" & @CR
            $shtml &= "\t\t<td>time</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td>has</td>" & @CR
            $shtml &= "\t\t<td>come</td>" & @CR
            $shtml &= "\t\t<td>for</td>" & @CR
            $shtml &= "\t\t<td>all</td>" & @CR
            $shtml &= "\t\t<td>good</td>" & @CR
            $shtml &= "\t\t<td>men</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td>to</td>" & @CR
            $shtml &= "\t\t<td>come</td>" & @CR
            $shtml &= "\t\t<td>to</td>" & @CR
            $shtml &= "\t\t<td>the</td>" & @CR
            $shtml &= "\t\t<td>aid</td>" & @CR
            $shtml &= "\t\t<td>of</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "</table>" & @CR
            $shtml &= "<br>" & @CR
            $shtml &= "$oTableTwo = _IETableGetObjByName($oIE, ""tableTwo"")<br>" & @CR
            $shtml &= "&lt;table border=""1"" id=""tableTwo""&gt;<br>" & @CR
            $shtml &= "<table border=1 id=""tableTwo"">" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td colspan=""4"">Table Top</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td>One</td>" & @CR
            $shtml &= "\t\t<td colspan=""3"">Two</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td>Three</td>" & @CR
            $shtml &= "\t\t<td>Four</td>" & @CR
            $shtml &= "\t\t<td colspan=""2"">Five</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td>Six</td>" & @CR
            $shtml &= "\t\t<td colspan=""3"">Seven</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "\t<tr>" & @CR
            $shtml &= "\t\t<td>Eight</td>" & @CR
            $shtml &= "\t\t<td>Nine</td>" & @CR
            $shtml &= "\t\t<td>Ten</td>" & @CR
            $shtml &= "\t\t<td>Eleven</td>" & @CR
            $shtml &= "\t</tr>" & @CR
            $shtml &= "</table>" & @CR
            $shtml &= "</body>" & @CR
            $shtml &= "</html>"
            $oobject = _IECreate()
            _IEDocWriteHTML($oobject, $shtml)
        Case "form"
            $shtml &= "<!DOCTYPE html>" & @CR
            $shtml &= "<html>" & @CR
            $shtml &= "<head>" & @CR
            $shtml &= "<meta content=""text/html; charset=UTF-8"" http-equiv=""content-type"">" & @CR
            $shtml &= "<title>_IE_Example(""form"")</title>" & @CR
            $shtml &= "<style>body {font-family: Arial}" & @CR
            $shtml &= "td {padding:6px}</style>" & @CR
            $shtml &= "</head>" & @CR
            $shtml &= "<body>" & @CR
            $shtml &= "<form name=""ExampleForm"" onSubmit=""javascript:alert('ExampleFormSubmitted');"" method=""post"">" & @CR
            $shtml &= "<table style=""border-spacing:6px 6px;"" border=1>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>ExampleForm</td>" & @CR
            $shtml &= "<td>&lt;form name=""ExampleForm"" onSubmit=""javascript:alert('ExampleFormSubmitted');"" method=""post""&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>Hidden Input Element<input type=""hidden"" name=""hiddenExample"" value=""secret value""></td>" & @CR
            $shtml &= "<td>&lt;input type=""hidden"" name=""hiddenExample"" value=""secret value""&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<input type=""text"" name=""textExample"" value=""http://"" size=""20"" maxlength=""30"">" & @CR
            $shtml &= "</td>" & @CR
            $shtml &= "<td>&lt;input type=""text"" name=""textExample"" value=""http://"" size=""20"" maxlength=""30""&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<input type=""password"" name=""passwordExample"" size=""10"">" & @CR
            $shtml &= "</td>" & @CR
            $shtml &= "<td>&lt;input type=""password"" name=""passwordExample"" size=""10""&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<input type=""file"" name=""fileExample"">" & @CR
            $shtml &= "</td>" & @CR
            $shtml &= "<td>&lt;input type=""file"" name=""fileExample""&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<input type=""image"" name=""imageExample"" alt=""AutoIt Homepage"" src=""http://www.autoitscript.com/images/logo_autoit_210x72.png"" style=""background: #20408" & _
                "0;>" & @CR
            $shtml &= "</td>" & @CR
            $shtml &= "<td>&lt;input type=""image"" name=""imageExample"" alt=""AutoIt Homepage"" src=""http://www.autoitscript.com/images/logo_autoit_210x72.png""&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<textarea name=""textareaExample"" rows=""5"" cols=""15"">Hello!</textarea>" & @CR
            $shtml &= "</td>" & @CR
            $shtml &= "<td>&lt;textarea name=""textareaExample"" rows=""5"" cols=""15""&gt;Hello!&lt;/textarea&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<input type=""checkbox"" name=""checkboxG1Example"" value=""gameBasketball"">Basketball<br>" & @CR
            $shtml &= "<input type=""checkbox"" name=""checkboxG1Example"" value=""gameFootball"">Football<br>" & @CR
            $shtml &= "<input type=""checkbox"" name=""checkboxG2Example"" value=""gameTennis"" checked>Tennis<br>" & @CR
            $shtml &= "<input type=""checkbox"" name=""checkboxG2Example"" value=""gameBaseball"">Baseball" & @CR
            $shtml &= "</td>" & @CR
            $shtml &= "<td>&lt;input type=""checkbox"" name=""checkboxG1Example"" value=""gameBasketball""&gt;Basketball&lt;br&gt;<br>" & @CR
            $shtml &= "&lt;input type=""checkbox"" name=""checkboxG1Example"" value=""gameFootball""&gt;Football&lt;br&gt;<br>" & @CR
            $shtml &= "&lt;input type=""checkbox"" name=""checkboxG2Example"" value=""gameTennis"" checked&gt;Tennis&lt;br&gt;<br>" & @CR
            $shtml &= "&lt;input type=""checkbox"" name=""checkboxG2Example"" value=""gameBaseball""&gt;Baseball</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<input type=""radio"" name=""radioExample"" value=""vehicleAirplane"">Airplane<br>" & @CR
            $shtml &= "<input type=""radio"" name=""radioExample"" value=""vehicleTrain"" checked>Train<br>" & @CR
            $shtml &= "<input type=""radio"" name=""radioExample"" value=""vehicleBoat"">Boat<br>" & @CR
            $shtml &= "<input type=""radio"" name=""radioExample"" value=""vehicleCar"">Car</td>" & @CR
            $shtml &= "<td>&lt;input type=""radio"" name=""radioExample"" value=""vehicleAirplane""&gt;Airplane&lt;br&gt;<br>" & @CR
            $shtml &= "&lt;input type=""radio"" name=""radioExample"" value=""vehicleTrain"" checked&gt;Train&lt;br&gt;<br>" & @CR
            $shtml &= "&lt;input type=""radio"" name=""radioExample"" value=""vehicleBoat""&gt;Boat&lt;br&gt;<br>" & @CR
            $shtml &= "&lt;input type=""radio"" name=""radioExample"" value=""vehicleCar""&gt;Car&lt;br&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<select name=""selectExample"">" & @CR
            $shtml &= "<option value=""homepage.html"">Homepage" & @CR
            $shtml &= "<option value=""midipage.html"">Midipage" & @CR
            $shtml &= "<option value=""freepage.html"">Freepage" & @CR
            $shtml &= "</select>" & @CR
            $shtml &= "</td>" & @CR
            $shtml &= "<td>&lt;select name=""selectExample""&gt;<br>" & @CR
            $shtml &= "&lt;option value=""homepage.html""&gt;Homepage<br>" & @CR
            $shtml &= "&lt;option value=""midipage.html""&gt;Midipage<br>" & @CR
            $shtml &= "&lt;option value=""freepage.html""&gt;Freepage<br>" & @CR
            $shtml &= "&lt;/select&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<select name=""multipleSelectExample"" size=""6"" multiple>" & @CR
            $shtml &= "<option value=""Name1"">Aaron" & @CR
            $shtml &= "<option value=""Name2"">Bruce" & @CR
            $shtml &= "<option value=""Name3"">Carlos" & @CR
            $shtml &= "<option value=""Name4"">Denis" & @CR
            $shtml &= "<option value=""Name5"">Ed" & @CR
            $shtml &= "<option value=""Name6"">Freddy" & @CR
            $shtml &= "</select>" & @CR
            $shtml &= "</td>" & @CR
            $shtml &= "<td>&lt;select name=""multipleSelectExample"" size=""6"" multiple&gt;<br>" & @CR
            $shtml &= "&lt;option value=""Name1""&gt;Aaron<br>" & @CR
            $shtml &= "&lt;option value=""Name2""&gt;Bruce<br>" & @CR
            $shtml &= "&lt;option value=""Name3""&gt;Carlos<br>" & @CR
            $shtml &= "&lt;option value=""Name4""&gt;Denis<br>" & @CR
            $shtml &= "&lt;option value=""Name5""&gt;Ed<br>" & @CR
            $shtml &= "&lt;option value=""Name6""&gt;Freddy<br>" & @CR
            $shtml &= "&lt;/select&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td>" & @CR
            $shtml &= "<input name=""submitExample"" type=""submit"" value=""Submit"">" & @CR
            $shtml &= "<input name=""resetExample"" type=""reset"" value=""Reset"">" & @CR
            $shtml &= "</td>" & @CR
            $shtml &= "<td>&lt;input name=""submitExample"" type=""submit"" value=""Submit""&gt;<br>" & @CR
            $shtml &= "&lt;input name=""resetExample"" type=""reset"" value=""Reset""&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "</table>" & @CR
            $shtml &= "<input type=""hidden"" name=""hiddenExample"" value=""secret value"">" & @CR
            $shtml &= "</form>" & @CR
            $shtml &= "</body>" & @CR
            $shtml &= "</html>"
            $oobject = _IECreate()
            _IEDocWriteHTML($oobject, $shtml)
        Case "frameset"
            $shtml &= "<!DOCTYPE html>" & @CR
            $shtml &= "<html>" & @CR
            $shtml &= "<head>" & @CR
            $shtml &= "<meta content=""text/html; charset=UTF-8"" http-equiv=""content-type"">" & @CR
            $shtml &= "<title>_IE_Example(""frameset"")</title>" & @CR
            $shtml &= "</head>" & @CR
            $shtml &= "<frameset rows=""25,200"">" & @CR
            $shtml &= "\t<frame name=Top SRC=about:blank>" & @CR
            $shtml &= "\t<frameset cols=""100,500"">" & @CR
            $shtml &= "\t\t<frame name=Menu SRC=about:blank>" & @CR
            $shtml &= "\t\t<frame name=Main SRC=about:blank>" & @CR
            $shtml &= "\t</frameset>" & @CR
            $shtml &= "</frameset>" & @CR
            $shtml &= "</html>"
            $oobject = _IECreate()
            _IEDocWriteHTML($oobject, $shtml)
            _IEAction($oobject, "refresh")
            Local $oframetop = _IEFrameGetObjByName($oobject, "Top")
            Local $oframemenu = _IEFrameGetObjByName($oobject, "Menu")
            Local $oframemain = _IEFrameGetObjByName($oobject, "Main")
            _IEBodyWriteHTML($oframetop, "$oFrameTop = _IEFrameGetObjByName($oIE, ""Top"")")
            _IEBodyWriteHTML($oframemenu, "$oFrameMenu = _IEFrameGetObjByName($oIE, ""Menu"")")
            _IEBodyWriteHTML($oframemain, "$oFrameMain = _IEFrameGetObjByName($oIE, ""Main"")")
        Case "iframe"
            $shtml &= "<!DOCTYPE html>" & @CR
            $shtml &= "<html>" & @CR
            $shtml &= "<head>" & @CR
            $shtml &= "<meta content=""text/html; charset=UTF-8"" http-equiv=""content-type"">" & @CR
            $shtml &= "<title>_IE_Example(""iframe"")</title>" & @CR
            $shtml &= "<style>td {padding:6px}</style>" & @CR
            $shtml &= "</head>" & @CR
            $shtml &= "<body>" & @CR
            $shtml &= "<table style=""border-spacing:6px"" border=1>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td><iframe name=""iFrameOne"" src=""about:blank"" title=""iFrameOne""></iframe></td>" & @CR
            $shtml &= "<td>&lt;iframe name=""iFrameOne"" src=""about:blank"" title=""iFrameOne""&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "<tr>" & @CR
            $shtml &= "<td><iframe name=""iFrameTwo"" src=""about:blank"" title=""iFrameTwo""></iframe></td>" & @CR
            $shtml &= "<td>&lt;iframe name=""iFrameTwo"" src=""about:blank"" title=""iFrameTwo""&gt;</td>" & @CR
            $shtml &= "</tr>" & @CR
            $shtml &= "</table>" & @CR
            $shtml &= "</body>" & @CR
            $shtml &= "</html>"
            $oobject = _IECreate()
            _IEDocWriteHTML($oobject, $shtml)
            _IEAction($oobject, "refresh")
            Local $oiframeone = _IEFrameGetObjByName($oobject, "iFrameOne")
            Local $oiframetwo = _IEFrameGetObjByName($oobject, "iFrameTwo")
            _IEBodyWriteHTML($oiframeone, "$oIFrameOne = _IEFrameGetObjByName($oIE, ""iFrameOne"")")
            _IEBodyWriteHTML($oiframetwo, "$oIFrameTwo = _IEFrameGetObjByName($oIE, ""iFrameTwo"")")
        Case Else
            __IEConsoleWriteError("Error", "_IE_Example", "$_IESTATUS_InvalidValue")
            Return SetError($_IESTATUS_INVALIDVALUE, 0x1, 0x0)
        EndSwitch
        Sleep(0x1f4)
        Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject)
    EndFunc    ; -> _IE_Example

    Func _IE_VersionInfo()
        __IEConsoleWriteError("Information", "_IE_VersionInfo", "version " & $__GAIEAU3VERSIONINFO[0x0] & $__GAIEAU3VERSIONINFO[0x1] & "." & $__GAIEAU3VERSIONINFO[0x2] & "-" & $__GAIEAU3VERSIONINFO[0x3], "Release date: " & $__GAIEAU3VERSIONINFO[0x4])
        Return SetError($_IESTATUS_SUCCESS, 0x0, $__GAIEAU3VERSIONINFO)
    EndFunc    ; -> _IE_VersionInfo

#EndRegion General
#Region Internal functions
    Func __IELockSetForegroundWindow($ilockcode)
        Local $acall = DllCall("user32.dll", "bool", "LockSetForegroundWindow", "uint", $ilockcode)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, _WinAPI_GetLastError(), 0x0)
        Return $acall[0x0]
    EndFunc    ; -> __IELockSetForegroundWindow

    Func __IEControlGetObjFromHWND(ByRef $hwin)
        DllCall("ole32.dll", "long", "CoInitialize", "ptr", 0x0)
        If @error Then Return SetError(0x2, @error, 0x0)
        Local Const $WM_HTML_GETOBJECT = __IERegisterWindowMessage("WM_HTML_GETOBJECT")
        Local Const $SMTO_ABORTIFHUNG = 0x2
        Local $iresult
        __IESendMessageTimeout($hwin, $WM_HTML_GETOBJECT, 0x0, 0x0, $SMTO_ABORTIFHUNG, 0x3e8, $iresult)
        Local $tuuid = DllStructCreate("int;short;short;byte[8]")
        DllStructSetData($tuuid, 0x1, 0x626fc520)
        DllStructSetData($tuuid, 0x2, 0xa41e)
        DllStructSetData($tuuid, 0x3, 0x11cf)
        DllStructSetData($tuuid, 0x4, 0xa7, 0x1)
        DllStructSetData($tuuid, 0x4, 0x31, 0x2)
        DllStructSetData($tuuid, 0x4, 0x0, 0x3)
        DllStructSetData($tuuid, 0x4, 0xa0, 0x4)
        DllStructSetData($tuuid, 0x4, 0xc9, 0x5)
        DllStructSetData($tuuid, 0x4, 0x8, 0x6)
        DllStructSetData($tuuid, 0x4, 0x26, 0x7)
        DllStructSetData($tuuid, 0x4, 0x37, 0x8)
        Local $acall = DllCall("oleacc.dll", "long", "ObjectFromLresult", "lresult", $iresult, "struct*", $tuuid, "wparam", 0x0, "idispatch*", 0x0)
        If @error Then Return SetError(0x3, @error, 0x0)
        If IsObj($acall[0x4]) Then
            Local $oie = $acall[0x4].Script()
            If ObjName($oie, $OBJ_NAME) = "HTMLWindow2" Then Return $oie
            Local $odocument = _IEDocGetObj($oie)
            If @error Then Return SetError(@error, @extended, 0x0)
            Return $odocument.parentWindow
        Else
            Return SetError(0x1, $acall[0x0], 0x0)
        EndIf
    EndFunc    ; -> __IEControlGetObjFromHWND

    Func __IERegisterWindowMessage($smsg)
        Local $acall = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $smsg)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, _WinAPI_GetLastError(), 0x0)
        Return $acall[0x0]
    EndFunc    ; -> __IERegisterWindowMessage

    Func __IESendMessageTimeout($hwnd, $imsg, $wparam, $lparam, $IFLAGS, $itimeout, ByRef $vout, $r = 0x0, $st1 = "int", $st2 = "int")
        Local $acall = DllCall("user32.dll", "lresult", "SendMessageTimeout", "hwnd", $hwnd, "uint", $imsg, $st1, $wparam, $st2, $lparam, "uint", $IFLAGS, "uint", $itimeout, "dword_ptr*", '')
        If @error Or Not $acall[0x0] Then
            $vout = 0x0
            Return SetError(@error + 0xa, _WinAPI_GetLastError(), 0x0)
        EndIf
        $vout = $acall[0x7]
        If $r >= 0x0 And $r <= 0x4 Then Return $acall[$r]
        Return $acall
    EndFunc    ; -> __IESendMessageTimeout

    Func __IEIsObjType(ByRef $oobject, $stype, $bregister = True)
        If Not IsObj($oobject) Then
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        Local $bstatus = $bregister
        If $bregister Then
            $bstatus = __IEInternalErrorHandlerRegister()
            If Not $bstatus Then __IEConsoleWriteError("Warning", "internal function __IEIsObjType", "Cannot register internal error handler, cannot trap COM errors", "Use _IEErrorHandlerRegister() to register a user error handler")
        EndIf
        Local $inotifystatus = _IEErrorNotify()
        _IEErrorNotify(False)
        Local $sname = String(ObjName($oobject)), $ierrorstatus = $_IESTATUS_INVALIDOBJECTTYPE
        Switch $stype
        Case "browserdom"
            If __IEIsObjType($oobject, "documentcontainer", False) Then
                $ierrorstatus = $_IESTATUS_SUCCESS
            ElseIf __IEIsObjType($oobject, "document", False) Then
                $ierrorstatus = $_IESTATUS_SUCCESS
            Else
                Local $otemp = $oobject.document
                If __IEIsObjType($otemp, "document", False) Then
                    $ierrorstatus = $_IESTATUS_SUCCESS
                EndIf
            EndIf
        Case "browser"
            If ($sname = "IWebBrowser2") Or ($sname = "IWebBrowser") Or ($sname = "WebBrowser") Then $ierrorstatus = $_IESTATUS_SUCCESS
        Case "window"
            If $sname = "HTMLWindow2" Then $ierrorstatus = $_IESTATUS_SUCCESS
        Case "documentContainer"
            If __IEIsObjType($oobject, "window", False) Or __IEIsObjType($oobject, "browser", False) Then $ierrorstatus = $_IESTATUS_SUCCESS
        Case "document"
            If $sname = "HTMLDocument" Then $ierrorstatus = $_IESTATUS_SUCCESS
        Case "table"
            If $sname = "HTMLTable" Then $ierrorstatus = $_IESTATUS_SUCCESS
        Case "form"
            If $sname = "HTMLFormElement" Then $ierrorstatus = $_IESTATUS_SUCCESS
        Case "forminputelement"
            If ($sname = "HTMLInputElement") Or ($sname = "HTMLSelectElement") Or ($sname = "HTMLTextAreaElement") Then $ierrorstatus = $_IESTATUS_SUCCESS
        Case "elementcollection"
            If ($sname = "HTMLElementCollection") Then $ierrorstatus = $_IESTATUS_SUCCESS
        Case "formselectelement"
            If $sname = "HTMLSelectElement" Then $ierrorstatus = $_IESTATUS_SUCCESS
        Case Else
            $ierrorstatus = $_IESTATUS_INVALIDVALUE
        EndSwitch
        _IEErrorNotify($inotifystatus)
        If $bregister Then
            __IEInternalErrorHandlerDeRegister()
        EndIf
        If $ierrorstatus = $_IESTATUS_SUCCESS Then
            Return SetError($_IESTATUS_SUCCESS, 0x0, 0x1)
        Else
            Return SetError($ierrorstatus, 0x1, 0x0)
        EndIf
    EndFunc    ; -> __IEIsObjType

    Func __IEConsoleWriteError($sseverity, $sfunc, $smessage = Default, $sstatus = Default)
        If $__g_bieerrornotify Or $__g_bieau3debug Then
            Local $sstr = "--> IE.au3 " & $__GAIEAU3VERSIONINFO[0x5] & " " & $sseverity & " from function " & $sfunc
            If Not ($smessage = Default) Then $sstr &= ", " & $smessage
            If Not ($sstatus = Default) Then $sstr &= " (" & $sstatus & ")"
            ConsoleWrite($sstr & @CRLF)
        EndIf
        Return SetError($sstatus, 0x0, 0x1)
    EndFunc    ; -> __IEConsoleWriteError

    Func __IEComErrorUnrecoverable($ierror)
        Switch $ierror
        Case + -2147352567
            Return $_IESTATUS_ACCESSISDENIED
        Case + -2147024891
            Return $_IESTATUS_ACCESSISDENIED
        Case + -2147417848
            Return $_IESTATUS_CLIENTDISCONNECTED
        Case + -2147023174
            Return $_IESTATUS_CLIENTDISCONNECTED
        Case + -2147023179
            Return $_IESTATUS_CLIENTDISCONNECTED
        Case Else
            Return $_IESTATUS_SUCCESS
        EndSwitch
    EndFunc    ; -> __IEComErrorUnrecoverable

#EndRegion Internal functions
#Region ProtoType Functions
    Func __IENavigate(ByRef $oobject, $surl, $iwait = 0x1, $ifags = 0x0, $starget = '', $spostdata = '', $sheaders = '')
        __IEConsoleWriteError("Warning", "__IENavigate", "Unsupported function called. Not fully tested.")
        If Not IsObj($oobject) Then
            __IEConsoleWriteError("Error", "__IENavigate", "$_IESTATUS_InvalidDataType")
            Return SetError($_IESTATUS_INVALIDDATATYPE, 0x1, 0x0)
        EndIf
        If Not __IEIsObjType($oobject, "documentContainer") Then
            __IEConsoleWriteError("Error", "__IENavigate", "$_IESTATUS_InvalidObjectType")
            Return SetError($_IESTATUS_INVALIDOBJECTTYPE, 0x1, 0x0)
        EndIf
        $oobject.navigate($surl, $ifags, $starget, $spostdata, $sheaders)
        If $iwait Then
            _IELoadWait($oobject)
            Return SetError(@error, 0x0, $oobject)
        EndIf
        Return SetError($_IESTATUS_SUCCESS, 0x0, $oobject)
    EndFunc    ; -> __IENavigate

    Func __IEStringToBstr($sstring, $scharset = "us-ascii")
        Local Const $ITYPEBINARY = 0x1, $ITYPETEXT = 0x2
        Local $ostream = ObjCreate("ADODB.Stream")
        $ostream.type = $ITYPETEXT
        $ostream.CharSet = $scharset
        $ostream.Open
        $ostream.WriteText($sstring)
        $ostream.Position = 0x0
        $ostream.type = $ITYPEBINARY
        $ostream.Position = 0x0
        Return $ostream.Read()
    EndFunc    ; -> __IEStringToBstr

    Func __IEBstrToString($obstr, $scharset = "us-ascii")
        Local Const $ITYPEBINARY = 0x1, $ITYPETEXT = 0x2
        Local $ostream = ObjCreate("ADODB.Stream")
        $ostream.type = $ITYPEBINARY
        $ostream.Open
        $ostream.Write($obstr)
        $ostream.Position = 0x0
        $ostream.type = $ITYPETEXT
        $ostream.CharSet = $scharset
        $ostream.Position = 0x0
        Return $ostream.ReadText()
    EndFunc    ; -> __IEBstrToString

    Func __IECreateNewIE($STITLE, $shead = '', $sbody = '')
        Local $stemp = __IETempFile('', "~IE~", ".htm")
        If @error Then
            __IEConsoleWriteError("Error", "_IECreateHTA", '', "Error creating temporary file in @TempDir or @ScriptDir")
            Return SetError($_IESTATUS_GENERALERROR, 0x1, 0x0)
        EndIf
        Local $shtml = ''
        $shtml &= "<!DOCTYPE html>" & @CR
        $shtml &= "<html>" & @CR
        $shtml &= "<head>" & @CR
        $shtml &= "<meta content=""text/html; charset=UTF-8"" http-equiv=""content-type"">" & @CR
        $shtml &= "<title>" & $stemp & "</title>" & @CR & $shead & @CR
        $shtml &= "</head>" & @CR
        $shtml &= "<body>" & @CR & $sbody & @CR
        $shtml &= "</body>" & @CR
        $shtml &= "</html>"
        Local $hfile = FileOpen($stemp, $FO_OVERWRITE)
        FileWrite($hfile, $shtml)
        FileClose($hfile)
        If @error Then
            __IEConsoleWriteError("Error", "_IECreateNewIE", '', "Error creating temporary file in @TempDir or @ScriptDir")
            Return SetError($_IESTATUS_GENERALERROR, 0x2, 0x0)
        EndIf
        Run(@ProgramFilesDir & "\\Internet Explorer\\iexplore.exe " & $stemp)
        Local $ipid
        If WinWait($stemp, '', 0x3c) Then
            $ipid = WinGetProcess($stemp)
        Else
            __IEConsoleWriteError("Error", "_IECreateNewIE", '', "Timeout waiting for new IE window creation")
            Return SetError($_IESTATUS_GENERALERROR, 0x3, 0x0)
        EndIf
        If Not FileDelete($stemp) Then
            __IEConsoleWriteError("Warning", "_IECreateNewIE", '', "Could not delete temporary file " & FileGetLongName($stemp))
        EndIf
        Local $oobject = _IEAttach($stemp)
        _IELoadWait($oobject)
        _IEPropertySet($oobject, "title", $STITLE)
        Return SetError($_IESTATUS_SUCCESS, $ipid, $oobject)
    EndFunc    ; -> __IECreateNewIE

    Func __IETempFile($sdirectoryname = @TempDir, $sfileprefix = "~", $sfileextension = ".tmp", $irandomlength = 0x7)
        Local $stempname, $itmp = 0x0
        If Not FileExists($sdirectoryname) Then $sdirectoryname = @TempDir
        If Not FileExists($sdirectoryname) Then $sdirectoryname = @ScriptDir
        If StringRight($sdirectoryname, 0x1) <> "\\" Then $sdirectoryname = $sdirectoryname & "\\"
        Do
            $stempname = ''
            While StringLen($stempname) < $irandomlength
                $stempname = $stempname & Chr(Random(0x61, 0x7a, 0x1))
            WEnd
            $stempname = $sdirectoryname & $sfileprefix & $stempname & $sfileextension
            $itmp += 0x1
            If $itmp > 0xc8 Then
                Return SetError($_IESTATUS_GENERALERROR, 0x1, 0x0)
            EndIf
        Until Not FileExists($stempname)
        Return $stempname
    EndFunc    ; -> __IETempFile

#EndRegion ProtoType Functions
Global Const $INET_LOCALCACHE = 0x0
Global Const $INET_FORCERELOAD = 0x1
Global Const $INET_IGNORESSL = 0x2
Global Const $INET_ASCIITRANSFER = 0x4
Global Const $INET_BINARYTRANSFER = 0x8
Global Const $INET_FORCEBYPASS = 0x10
Global Const $INET_DOWNLOADWAIT = 0x0
Global Const $INET_DOWNLOADBACKGROUND = 0x1
Global Const $INET_DOWNLOADREAD = 0x0
Global Const $INET_DOWNLOADSIZE = 0x1
Global Const $INET_DOWNLOADCOMPLETE = 0x2
Global Const $INET_DOWNLOADSUCCESS = 0x3
Global Const $INET_DOWNLOADERROR = 0x4
Global Const $INET_DOWNLOADEXTENDED = 0x5
Func _GetIP()
    Local Const $GETIP_TIMER = 0x493e0
    Local Static $htimer = 0x0
    Local Static $slastip = 0x0
    If TimerDiff($htimer) < $GETIP_TIMER And Not $slastip Then
        Return SetExtended(0x1, $slastip)
    EndIf
    Local $agetipurl = ["https://api.ipify.org", "http://checkip.dyndns.org", "http://www.myexternalip.com/raw", "http://bot.whatismyipaddress.com"], $aret = 0x0, $sreturn = ''
    For $i = 0x0 To UBound($agetipurl) + -1
        $sreturn = InetRead($agetipurl[$i])
        If @error Or $sreturn == '' Then ContinueLoop
        $aret = StringRegExp(BinaryToString($sreturn), "((?:\\d{1,3}\\.){3}\\d{1,3})", $STR_REGEXPARRAYGLOBALMATCH)
        If Not @error Then
            $sreturn = $aret[0x0]
            ExitLoop
        EndIf
        $sreturn = ''
    Next
    $htimer = TimerInit()
    $slastip = $sreturn
    If $sreturn == '' Then Return SetError(0x1, 0x0, + -1)
    Return $sreturn
EndFunc    ; -> _GetIP

Func _INetExplorerCapable($siestring)
    If StringLen($siestring) <= 0x0 Then Return SetError(0x1, 0x0, '')
    Local $s_iereturn
    Local $n_iechar
    For $i_iecount = 0x1 To StringLen($siestring)
        $n_iechar = "0x" & Hex(Asc(StringMid($siestring, $i_iecount, 0x1)), 0x2)
        If $n_iechar < 0x21 Or $n_iechar = 0x25 Or $n_iechar = 0x2f Or $n_iechar > 0x7f Then
            $s_iereturn = $s_iereturn & "%" & StringRight($n_iechar, 0x2)
        Else
            $s_iereturn = $s_iereturn & Chr($n_iechar)
        EndIf
    Next
    Return $s_iereturn
EndFunc    ; -> _INetExplorerCapable

Func _INetGetSource($surl, $bstring = True)
    Local $sstring = InetRead($surl, $INET_FORCERELOAD)
    Local $ierror = @error, $iextended = @extended
    If $bstring = Default Or $bstring Then $sstring = BinaryToString($sstring)
    Return SetError($ierror, $iextended, $sstring)
EndFunc    ; -> _INetGetSource

Func _INetMail($smailto, $smailsubject, $smailbody)
    Local $iprev = Opt("ExpandEnvStrings", 0x1)
    Local $svar, $sdflt = RegRead("HKCU\\Software\\Clients\\Mail", '')
    If $sdflt = "Windows Live Mail" Then
        $svar = RegRead("HKCR\\WLMail.Url.Mailto\\Shell\\open\\command", '')
    Else
        $svar = RegRead("HKCR\\mailto\\shell\\open\\command", '')
    EndIf
    Local $iret = Run(StringReplace($svar, "%1", _INetExplorerCapable("mailto:" & $smailto & "?subject=" & $smailsubject & "&body=" & $smailbody)))
    Local $ierror = @error, $iextended = @extended
    Opt("ExpandEnvStrings", $iprev)
    Return SetError($ierror, $iextended, $iret)
EndFunc    ; -> _INetMail

Func _INetSmtpMail($ssmtpserver, $sfromname, $sfromaddress, $stoaddress, $ssubject = '', $abody = '', $sehlo = '', $sfirst = " ", $btrace = 0x0)
    If $ssmtpserver = '' Or $sfromaddress = '' Or $stoaddress = '' Or $sfromname = '' Or StringLen($sfromname) > 0x100 Then Return SetError(0x1, 0x0, 0x0)
    If $sehlo = '' Then $sehlo = @ComputerName
    If TCPStartup() = 0x0 Then Return SetError(0x2, 0x0, 0x0)
    Local $s_ipaddress, $i_count
    If StringRegExp($ssmtpserver, "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$") Then
        $s_ipaddress = $ssmtpserver
    Else
        $s_ipaddress = TCPNameToIP($ssmtpserver)
    EndIf
    If $s_ipaddress = '' Then
        TCPShutdown()
        Return SetError(0x3, 0x0, 0x0)
    EndIf
    Local $vsocket = TCPConnect($s_ipaddress, 0x19)
    If $vsocket = + -1 Then
        TCPShutdown()
        Return SetError(0x4, 0x0, 0x0)
    EndIf
    Local $asend[0x6], $areplycode[0x6]
    $asend[0x0] = "HELO " & $sehlo & @CRLF
    If StringLeft($sehlo, 0x5) = "EHLO " Then $asend[0x0] = $sehlo & @CRLF
    $areplycode[0x0] = "250"
    $asend[0x1] = "MAIL FROM: <" & $sfromaddress & ">" & @CRLF
    $areplycode[0x1] = "250"
    $asend[0x2] = "RCPT TO: <" & $stoaddress & ">" & @CRLF
    $areplycode[0x2] = "250"
    $asend[0x3] = "DATA" & @CRLF
    $areplycode[0x3] = "354"
    Local $ainfo = _Date_Time_GetTimeZoneInformation()
    If @error Then
        TCPShutdown()
        Return SetError(0x5, 0x0, 0x0)
    EndIf
    Local $ibias = $ainfo[0x1]
    If $ainfo[0x0] = 0x2 Then $ibias += $ainfo[0x7]
    $ibias *= + -1
    Local $ibiash = Int($ibias / 0x3c, 0x1)
    Local $ibiasm = Mod($ibias, 0x3c)
    $ibias = StringFormat(" (%+.2d%.2d)", $ibiash, $ibiasm)
    $asend[0x4] = "From:" & $sfromname & "<" & $sfromaddress & ">" & @CRLF & "To:" & "<" & $stoaddress & ">" & @CRLF & "Subject:" & $ssubject & @CRLF & "Mime-Version: 1.0" & @CRLF & "Date: " & _DateDayOfWeek(@WDAY, 0x1) & ", " & @MDAY & " " & _DateToMonth(@MON, 0x1) & " " & @YEAR & " " & @HOUR & ":" & @MIN & ":" & @SEC & $ibias & @CRLF & "Content-Type: text/plain; charset=US-ASCII" & @CRLF & @CRLF
    $areplycode[0x4] = ''
    $asend[0x5] = @CRLF & "." & @CRLF
    $areplycode[0x5] = "250"
    If __SmtpSend($vsocket, $asend[0x0], $areplycode[0x0], $btrace, "220", $sfirst) Then Return SetError(0x32, 0x0, 0x0)
    For $i_count = 0x1 To UBound($asend) + -2
        If __SmtpSend($vsocket, $asend[$i_count], $areplycode[$i_count], $btrace) Then Return SetError(0x32 + $i_count, 0x0, 0x0)
    Next
    For $i_count = 0x0 To UBound($abody) + -1
        If StringLeft($abody[$i_count], 0x1) = "." Then $abody[$i_count] = "." & $abody[$i_count]
        If __SmtpSend($vsocket, $abody[$i_count] & @CRLF, '', $btrace) Then Return SetError(0x1f4 + $i_count, 0x0, 0x0)
    Next
    $i_count = UBound($asend) + -1
    If __SmtpSend($vsocket, $asend[$i_count], $areplycode[$i_count], $btrace) Then Return SetError(0x1388, 0x0, 0x0)
    TCPCloseSocket($vsocket)
    TCPShutdown()
    Return 0x1
EndFunc    ; -> _INetSmtpMail

Func __SmtpTrace($sstr, $itimeout = 0x0)
    Local $sw_title = "SMTP trace"
    Local $ssmtptrace = ControlGetText($sw_title, '', "Static1")
    $sstr = StringLeft(StringReplace($sstr, @CRLF, ''), 0x46)
    $ssmtptrace &= @HOUR & ":" & @MIN & ":" & @SEC & " " & $sstr & @LF
    If WinExists($sw_title) Then
        ControlSetText($sw_title, '', "Static1", $ssmtptrace)
    Else
        SplashTextOn($sw_title, $ssmtptrace, 0x190, 0x1f4, 0x1f4, 0x64, 0x4 + 0x10, '', 0x8)
    EndIf
    If $itimeout Then Sleep($itimeout * 0x3e8)
EndFunc    ; -> __SmtpTrace

Func __SmtpSend($vsocket, $ssend, $sreplycode, $btrace, $sintreply = '', $sfirst = '')
    Local $sreceive, $i, $htimer
    If $btrace Then __SmtpTrace($ssend)
    If $sintreply <> '' Then
        If $sfirst <> + -1 Then
            If TCPSend($vsocket, $sfirst) = 0x0 Then
                TCPCloseSocket($vsocket)
                TCPShutdown()
                Return 0x1
            EndIf
        EndIf
        $sreceive = ''
        $htimer = TimerInit()
        While StringLeft($sreceive, StringLen($sintreply)) <> $sintreply And TimerDiff($htimer) < 0xafc8
            $sreceive = TCPRecv($vsocket, 0x3e8)
            If $btrace And $sreceive <> '' Then __SmtpTrace("intermediate->" & $sreceive)
        WEnd
    EndIf
    If TCPSend($vsocket, $ssend) = 0x0 Then
        TCPCloseSocket($vsocket)
        TCPShutdown()
        Return 0x1
    EndIf
    $htimer = TimerInit()
    $sreceive = ''
    While $sreceive = '' And TimerDiff($htimer) < 0xafc8
        $i += 0x1
        $sreceive = TCPRecv($vsocket, 0x3e8)
        If $sreplycode = '' Then ExitLoop
    WEnd
    If $sreplycode <> '' Then
        If $btrace Then __SmtpTrace($i & " <- " & $sreceive)
        If StringLeft($sreceive, StringLen($sreplycode)) <> $sreplycode Then
            TCPCloseSocket($vsocket)
            TCPShutdown()
            If $btrace Then __SmtpTrace("<-> " & $sreplycode, 0x5)
            Return 0x2
        EndIf
    EndIf
    Return 0x0
EndFunc    ; -> __SmtpSend

Func _TCPIpToName($sip, $ioption = Default, $hdll = Default)
    Local $iinaddr_none = -1, $iaf_inet = 0x2, $sseparator = @CR
    If $ioption = Default Then $ioption = 0x0
    If $hdll = Default Then $hdll = "ws2_32.dll"
    Local $avdllcall = DllCall($hdll, "ulong", "inet_addr", "STR", $sip)
    If @error Then Return SetError(0x1, 0x0, '')
    Local $vbinip = $avdllcall[0x0]
    If $vbinip = $iinaddr_none Then Return SetError(0x2, 0x0, '')
    $avdllcall = DllCall($hdll, "ptr", "gethostbyaddr", "ptr*", $vbinip, "int", 0x4, "int", $iaf_inet)
    If @error Then Return SetError(0x3, 0x0, '')
    Local $pvhostent = $avdllcall[0x0]
    If $pvhostent = 0x0 Then
        $avdllcall = DllCall($hdll, "int", "WSAGetLastError")
        If @error Then Return SetError(0x5, 0x0, '')
        Return SetError(0x4, $avdllcall[0x0], '')
    EndIf
    Local $thostent = DllStructCreate("ptr;ptr;short;short;ptr", $pvhostent)
    Local $shostnames = __TCPIpToName_szStringRead(DllStructGetData($thostent, 0x1))
    If @error Then Return SetError(0x6, 0x0, $shostnames)
    If $ioption = 0x1 Then
        Local $taliases
        $shostnames &= $sseparator
        For $i = 0x0 To 0x3f
            $taliases = DllStructCreate("ptr", DllStructGetData($thostent, 0x2) + ($i * 0x4))
            If DllStructGetData($taliases, 0x1) = 0x0 Then ExitLoop
            $shostnames &= __TCPIpToName_szStringRead(DllStructGetData($taliases, 0x1))
            If @error Then
                SetError(0x7)
                ExitLoop
            EndIf
        Next
        Return StringSplit(StringStripWS($shostnames, $STR_STRIPTRAILING), @CR)
    Else
        Return $shostnames
    EndIf
EndFunc    ; -> _TCPIpToName

Func __TCPIpToName_szStringRead($pstr, $ilen = + -1)
    Local $tstring
    If $pstr < 0x1 Then Return ''
    If $ilen < 0x0 Then $ilen = _WinAPI_StrLen($pstr, False)
    $tstring = DllStructCreate("char[" & $ilen & "]", $pstr)
    If @error Then Return SetError(0x2, 0x0, '')
    Return SetExtended($ilen, DllStructGetData($tstring, 0x1))
EndFunc    ; -> __TCPIpToName_szStringRead

Global Const $MATH_ISNOTDIVISIBLE = 0x1
Global Const $MATH_ISDIVISIBLE = 0x2
Global Const $MATH_DEGREES = 57.2957795130823
Func _Degree($iradians)
    Return IsNumber($iradians) ? $iradians * $MATH_DEGREES  : SetError(0x1, 0x0, 0x0)
EndFunc    ; -> _Degree

Func _MathCheckDiv($inum1, $inum2 = 0x2)
    If Not (IsInt($inum1) And IsInt($inum2)) Then
        Return SetError(0x1, 0x0, + -1)
    EndIf
    Return (Mod($inum1, $inum2) = 0x0) ? $MATH_ISDIVISIBLE  : $MATH_ISNOTDIVISIBLE
EndFunc    ; -> _MathCheckDiv

Func _Max($inum1, $inum2)
    If Not IsNumber($inum1) Then Return SetError(0x1, 0x0, 0x0)
    If Not IsNumber($inum2) Then Return SetError(0x2, 0x0, 0x0)
    Return ($inum1 > $inum2) ? $inum1  : $inum2
EndFunc    ; -> _Max

Func _Min($inum1, $inum2)
    If Not IsNumber($inum1) Then Return SetError(0x1, 0x0, 0x0)
    If Not IsNumber($inum2) Then Return SetError(0x2, 0x0, 0x0)
    Return ($inum1 > $inum2) ? $inum2  : $inum1
EndFunc    ; -> _Min

Func _Radian($idegrees)
    Return Number($idegrees) ? $idegrees / $MATH_DEGREES  : SetError(0x1, 0x0, 0x0)
EndFunc    ; -> _Radian

Global Const $__MISCCONSTANT_CC_ANYCOLOR = 0x100
Global Const $__MISCCONSTANT_CC_FULLOPEN = 0x2
Global Const $__MISCCONSTANT_CC_RGBINIT = 0x1
Global Const $TAGCHOOSECOLOR = "dword Size;hwnd hWndOwnder;handle hInstance;dword rgbResult;ptr CustColors;dword Flags;lparam lCustData;" & "ptr lpfnHook;ptr lpTemplateName"
Global Const $TAGCHOOSEFONT = "dword Size;hwnd hWndOwner;handle hDC;ptr LogFont;int PointSize;dword Flags;dword rgbColors;lparam CustData;" & "ptr fnHook;ptr TemplateName;handle hInstance;ptr szStyle;word FontType;int SizeMin;int SizeMax"
Func _ChooseColor($vreturntype = 0x0, $icolorref = 0x0, $ireftype = 0x0, $hwndownder = 0x0)
    Local $tagcustcolors = "dword[16]"
    Local $tchoose = DllStructCreate($TAGCHOOSECOLOR)
    Local Static $tcc = DllStructCreate($tagcustcolors)
    Local $ireturntype, $vreturn
    If $vreturntype = + -9 Or $vreturntype = + -10 Then
        Local $a_tcc = __choosecolor_structtoarray($tcc)
        $a_tcc[0x0] = + -1
        If $vreturntype = + -10 Then $tcc = DllStructCreate($tagcustcolors)
        Return $a_tcc
    ElseIf $vreturntype > 0x9 Then
        $tcc = DllStructCreate($tagcustcolors)
        $ireturntype = $vreturntype + -10
    ElseIf IsArray($vreturntype) Then
        If UBound($vreturntype, $UBOUND_ROWS) = 0x11 And UBound($vreturntype, $UBOUND_DIMENSIONS) = 0x1 Then
            For $n = 0x1 To 0x10
                DllStructSetData($tcc, 0x1, $vreturntype[$n], $n)
            Next
            If $vreturntype[0x0] = + -9 Then
                $vreturntype[0x0] = 0x0
                Return $vreturntype
            EndIf
            If $vreturntype[0x0] > 0x9 Then $vreturntype[0x0]-= 0xa
            $ireturntype = $vreturntype[0x0]
        Else
            Return SetError(+ -5, 0x0, + -1)
        EndIf
    Else
        $ireturntype = $vreturntype
    EndIf
    If $ireturntype < 0x0 Or $ireturntype > 0x2 Then
        If IsArray($vreturntype) Then
            $vreturntype[0x0] = + -1
            Return SetError(+ -4, 0x0, $vreturntype)
        EndIf
        Return SetError(+ -4, 0x0, + -1)
    EndIf
    If $ireftype = 0x1 Then
        $icolorref = Int($icolorref)
    ElseIf $ireftype = 0x2 Then
        $icolorref = Hex(String($icolorref), 0x6)
        $icolorref = "0x" & StringMid($icolorref, 0x5, 0x2) & StringMid($icolorref, 0x3, 0x2) & StringMid($icolorref, 0x1, 0x2)
    EndIf
    DllStructSetData($tchoose, "Size", DllStructGetSize($tchoose))
    DllStructSetData($tchoose, "hWndOwnder", $hwndownder)
    DllStructSetData($tchoose, "rgbResult", $icolorref)
    DllStructSetData($tchoose, "CustColors", DllStructGetPtr($tcc))
    DllStructSetData($tchoose, "Flags", BitOR($__MISCCONSTANT_CC_ANYCOLOR, $__MISCCONSTANT_CC_FULLOPEN, $__MISCCONSTANT_CC_RGBINIT))
    Local $aresult = DllCall("comdlg32.dll", "bool", "ChooseColor", "struct*", $tchoose)
    Local $ierror = @error
    If @error Then
        Local $iextended = @extended
        If IsArray($vreturntype) Then
            $vreturntype[0x0] = + -1
            Return SetError($ierror, $iextended, $vreturntype)
        EndIf
        Return SetError($ierror, $iextended, + -1)
    EndIf
    If $aresult[0x0] = 0x0 Then
        If IsArray($vreturntype) Then
            $vreturntype[0x0] = + -1
            Return SetError(+ -3, 0x0, $vreturntype)
        EndIf
        Return SetError(+ -3, 0x0, + -1)
    EndIf
    Local $scolor_picked = DllStructGetData($tchoose, "rgbResult")
    If $ireturntype = 0x1 Then
        $vreturn = "0x" & Hex(String($scolor_picked), 0x6)
    ElseIf $ireturntype = 0x2 Then
        $scolor_picked = Hex(String($scolor_picked), 0x6)
        $vreturn = "0x" & StringMid($scolor_picked, 0x5, 0x2) & StringMid($scolor_picked, 0x3, 0x2) & StringMid($scolor_picked, 0x1, 0x2)
    Else
        $vreturn = $scolor_picked
    EndIf
    If IsArray($vreturntype) Then
        $vreturntype = __choosecolor_structtoarray($tcc)
        $vreturntype[0x0] = $vreturn
        Return $vreturntype
    EndIf
    Return $vreturn
EndFunc    ; -> _ChooseColor

Func __choosecolor_structtoarray(ByRef $tstruct)
    Local $AARRAY[0x11]
    For $n = 0x1 To 0x10
        $AARRAY[$n] = DllStructGetData($tstruct, 0x1, $n)
    Next
    Return $AARRAY
EndFunc    ; -> __choosecolor_structtoarray

Func _ChooseFont($sfontname = "Courier New", $ipointsize = 0xa, $ifontcolorref = 0x0, $ifontweight = 0x0, $bitalic = False, $bunderline = False, $bstrikethru = False, $hwndowner = 0x0)
    Local $iitalic = 0x0, $iunderline = 0x0, $istrikeout = 0x0
    $ifontcolorref = BitOR(BitShift(BitAND($ifontcolorref, 0xff), + -16), BitAND($ifontcolorref, 0xff00), BitShift(BitAND($ifontcolorref, 0xff0000), 0x10))
    Local $hdc = __MISC_GetDC(0x0)
    Local $iheight = Round(($ipointsize * __MISC_GetDeviceCaps($hdc, $LOGPIXELSX)) / 0x48, 0x0)
    __MISC_ReleaseDC(0x0, $hdc)
    Local $tchoosefont = DllStructCreate($TAGCHOOSEFONT)
    Local $tlogfont = DllStructCreate($TAGLOGFONT)
    DllStructSetData($tchoosefont, "Size", DllStructGetSize($tchoosefont))
    DllStructSetData($tchoosefont, "hWndOwner", $hwndowner)
    DllStructSetData($tchoosefont, "LogFont", DllStructGetPtr($tlogfont))
    DllStructSetData($tchoosefont, "PointSize", $ipointsize)
    DllStructSetData($tchoosefont, "Flags", BitOR($CF_SCREENFONTS, $CF_PRINTERFONTS, $CF_EFFECTS, $CF_INITTOLOGFONTSTRUCT, $CF_NOSCRIPTSEL))
    DllStructSetData($tchoosefont, "rgbColors", $ifontcolorref)
    DllStructSetData($tchoosefont, "FontType", 0x0)
    DllStructSetData($tlogfont, "Height", $iheight)
    DllStructSetData($tlogfont, "Weight", $ifontweight)
    DllStructSetData($tlogfont, "Italic", $bitalic)
    DllStructSetData($tlogfont, "Underline", $bunderline)
    DllStructSetData($tlogfont, "Strikeout", $bstrikethru)
    DllStructSetData($tlogfont, "FaceName", $sfontname)
    Local $acall = DllCall("comdlg32.dll", "bool", "ChooseFontW", "struct*", $tchoosefont)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] = 0x0 Then Return SetError(+ -3, + -3, + -1)
    Local $sfacename = DllStructGetData($tlogfont, "FaceName")
    If StringLen($sfacename) = 0x0 And StringLen($sfontname) > 0x0 Then $sfacename = $sfontname
    If DllStructGetData($tlogfont, "Italic") Then $iitalic = 0x2
    If DllStructGetData($tlogfont, "Underline") Then $iunderline = 0x4
    If DllStructGetData($tlogfont, "Strikeout") Then $istrikeout = 0x8
    Local $iattributes = BitOR($iitalic, $iunderline, $istrikeout)
    Local $isize = DllStructGetData($tchoosefont, "PointSize") / 0xa
    Local $icolorref = DllStructGetData($tchoosefont, "rgbColors")
    Local $iweight = DllStructGetData($tlogfont, "Weight")
    Local $scolor_picked = Hex(String($icolorref), 0x6)
    Return StringSplit($iattributes & "," & $sfacename & "," & $isize & "," & $iweight & "," & $icolorref & "," & "0x" & $scolor_picked & "," & "0x" & StringMid($scolor_picked, 0x5, 0x2) & StringMid($scolor_picked, 0x3, 0x2) & StringMid($scolor_picked, 0x1, 0x2), ",")
EndFunc    ; -> _ChooseFont

Func _ClipPutFile($sfilepath, $SDELIMITER = "|")
    Local Const $GMEM_MOVEABLE = 0x2, $CF_HDROP = 0xf
    $sfilepath &= $SDELIMITER & $SDELIMITER
    Local $nglobmemsize = 0x2 * (StringLen($sfilepath) + 0x14)
    Local $acall = DllCall("user32.dll", "bool", "OpenClipboard", "hwnd", 0x0)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, _WinAPI_GetLastError(), False)
    Local $ierror = 0x0, $ilasterror = 0x0
    $acall = DllCall("user32.dll", "bool", "EmptyClipboard")
    If @error Or Not $acall[0x0] Then
        $ierror = @error + 0x14
        $ilasterror = _WinAPI_GetLastError()
    Else
        $acall = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $nglobmemsize)
        If @error Or Not $acall[0x0] Then
            $ierror = @error + 0x1e
            $ilasterror = _WinAPI_GetLastError()
        Else
            Local $hglobal = $acall[0x0]
            $acall = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hglobal)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x28
                $ilasterror = _WinAPI_GetLastError()
            Else
                Local $hlock = $acall[0x0]
                Local $tdropfiles = DllStructCreate("dword pFiles;" & $TAGPOINT & ";bool fNC;bool fWide;wchar[" & StringLen($sfilepath) + 0x1 & "]", $hlock)
                If @error Then Return SetError(@error + 0x32, 0x6, False)
                Local $tstruct = DllStructCreate("dword;long;long;bool;bool")
                DllStructSetData($tdropfiles, "pFiles", DllStructGetSize($tstruct))
                DllStructSetData($tdropfiles, "X", 0x0)
                DllStructSetData($tdropfiles, "Y", 0x0)
                DllStructSetData($tdropfiles, "fNC", 0x0)
                DllStructSetData($tdropfiles, "fWide", 0x1)
                DllStructSetData($tdropfiles, 0x6, $sfilepath)
                For $i = 0x1 To StringLen($sfilepath)
                    If DllStructGetData($tdropfiles, 0x6, $i) = $SDELIMITER Then DllStructSetData($tdropfiles, 0x6, Chr(0x0), $i)
                Next
                $acall = DllCall("user32.dll", "handle", "SetClipboardData", "uint", $CF_HDROP, "handle", $hglobal)
                If @error Or Not $acall[0x0] Then
                    $ierror = @error + 0x3c
                    $ilasterror = _WinAPI_GetLastError()
                EndIf
                $acall = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hglobal)
                If (@error Or Not $acall[0x0]) And Not $ierror And _WinAPI_GetLastError() Then
                    $ierror = @error + 0x50
                    $ilasterror = _WinAPI_GetLastError()
                EndIf
            EndIf
            $acall = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hglobal)
            If (@error Or $acall[0x0]) And Not $ierror Then
                $ierror = @error + 0x5a
                $ilasterror = _WinAPI_GetLastError()
            EndIf
        EndIf
    EndIf
    $acall = DllCall("user32.dll", "bool", "CloseClipboard")
    If (@error Or Not $acall[0x0]) And Not $ierror Then Return SetError(@error + 0x46, _WinAPI_GetLastError(), False)
    If $ierror Then Return SetError($ierror, $ilasterror, False)
    Return True
EndFunc    ; -> _ClipPutFile

Func _MouseTrap($ileft = 0x0, $itop = 0x0, $iright = 0x0, $ibottom = 0x0)
    Local $acall
    If $ileft = Default Then $ileft = 0x0
    If $itop = Default Then $itop = 0x0
    If $iright = Default Then $iright = 0x0
    If $ibottom = Default Then $ibottom = 0x0
    If @NumParams = 0x0 Then
        $acall = DllCall("user32.dll", "bool", "ClipCursor", "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(0x1, _WinAPI_GetLastError(), False)
    Else
        If @NumParams = 0x2 Then
            $iright = $ileft + 0x1
            $ibottom = $itop + 0x1
        EndIf
        Local $trect = DllStructCreate($TAGRECT)
        DllStructSetData($trect, "Left", $ileft)
        DllStructSetData($trect, "Top", $itop)
        DllStructSetData($trect, "Right", $iright)
        DllStructSetData($trect, "Bottom", $ibottom)
        $acall = DllCall("user32.dll", "bool", "ClipCursor", "struct*", $trect)
        If @error Or Not $acall[0x0] Then Return SetError(0x2, _WinAPI_GetLastError(), False)
    EndIf
    Return True
EndFunc    ; -> _MouseTrap

Func _Singleton($soccurrencename, $IFLAG = 0x0)
    Local Const $ERROR_ALREADY_EXISTS = 0xb7
    Local Const $SECURITY_DESCRIPTOR_REVISION = 0x1
    Local $tsecurityattributes = 0x0
    If BitAND($IFLAG, 0x2) Then
        Local $tsecuritydescriptor = DllStructCreate("byte;byte;word;ptr[4]")
        Local $acall = DllCall("advapi32.dll", "bool", "InitializeSecurityDescriptor", "struct*", $tsecuritydescriptor, "dword", $SECURITY_DESCRIPTOR_REVISION)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then
            $acall = DllCall("advapi32.dll", "bool", "SetSecurityDescriptorDacl", "struct*", $tsecuritydescriptor, "bool", 0x1, "ptr", 0x0, "bool", 0x0)
            If @error Then Return SetError(@error, @extended, 0x0)
            If $acall[0x0] Then
                $tsecurityattributes = DllStructCreate($TAGSECURITY_ATTRIBUTES)
                DllStructSetData($tsecurityattributes, 0x1, DllStructGetSize($tsecurityattributes))
                DllStructSetData($tsecurityattributes, 0x2, DllStructGetPtr($tsecuritydescriptor))
                DllStructSetData($tsecurityattributes, 0x3, 0x0)
            EndIf
        EndIf
    EndIf
    Local $AHANDLE = DllCall("kernel32.dll", "handle", "CreateMutexW", "struct*", $tsecurityattributes, "bool", 0x1, "wstr", $soccurrencename)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $alasterror = DllCall("kernel32.dll", "dword", "GetLastError")
    If @error Then Return SetError(@error, @extended, 0x0)
    If $alasterror[0x0] = $ERROR_ALREADY_EXISTS Then
        If BitAND($IFLAG, 0x1) Then
            DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $AHANDLE[0x0])
            If @error Then Return SetError(@error, @extended, 0x0)
            Return SetError($alasterror[0x0], $alasterror[0x0], 0x0)
        Else
            Exit + -1
        EndIf
    EndIf
    Return $AHANDLE[0x0]
EndFunc    ; -> _Singleton

Func _IsPressed($shexkey, $vdll = "user32.dll")
    Local $acall = DllCall($vdll, "short", "GetAsyncKeyState", "int", "0x" & $shexkey)
    If @error Then Return SetError(@error, @extended, False)
    Return BitAND($acall[0x0], 0x8000) <> 0x0
EndFunc    ; -> _IsPressed

Func _VersionCompare($sversion1, $sversion2)
    If $sversion1 = $sversion2 Then Return 0x0
    Local $ssubversion1 = '', $ssubversion2 = ''
    If StringIsAlpha(StringRight($sversion1, 0x1)) Then
        $ssubversion1 = StringRight($sversion1, 0x1)
        $sversion1 = StringTrimRight($sversion1, 0x1)
    EndIf
    If StringIsAlpha(StringRight($sversion2, 0x1)) Then
        $ssubversion2 = StringRight($sversion2, 0x1)
        $sversion2 = StringTrimRight($sversion2, 0x1)
    EndIf
    Local $aversion1 = StringSplit($sversion1, ".,"), $aversion2 = StringSplit($sversion2, ".,")
    Local $ipartdifference = ($aversion1[0x0] - $aversion2[0x0])
    If $ipartdifference < 0x0 Then
        ReDim $aversion1[UBound($aversion2)]
        $aversion1[0x0] = UBound($aversion1) + -1
        For $i = (UBound($aversion1) - Abs($ipartdifference)) To $aversion1[0x0]
            $aversion1[$i] = "0"
        Next
    ElseIf $ipartdifference > 0x0 Then
        ReDim $aversion2[UBound($aversion1)]
        $aversion2[0x0] = UBound($aversion2) + -1
        For $i = (UBound($aversion2) - Abs($ipartdifference)) To $aversion2[0x0]
            $aversion2[$i] = "0"
        Next
    EndIf
    For $i = 0x1 To $aversion1[0x0]
        If StringIsDigit($aversion1[$i]) And StringIsDigit($aversion2[$i]) Then
            If Number($aversion1[$i]) > Number($aversion2[$i]) Then
                Return SetExtended(0x2, 0x1)
            ElseIf Number($aversion1[$i]) < Number($aversion2[$i]) Then
                Return SetExtended(0x2, + -1)
            ElseIf $i = $aversion1[0x0] Then
                If $ssubversion1 > $ssubversion2 Then
                    Return SetExtended(0x3, 0x1)
                ElseIf $ssubversion1 < $ssubversion2 Then
                    Return SetExtended(0x3, + -1)
                EndIf
            EndIf
        Else
            If $aversion1[$i] > $aversion2[$i] Then
                Return SetExtended(0x1, 0x1)
            ElseIf $aversion1[$i] < $aversion2[$i] Then
                Return SetExtended(0x1, + -1)
            EndIf
        EndIf
    Next
    Return SetExtended(Abs($ipartdifference), 0x0)
EndFunc    ; -> _VersionCompare

Func __MISC_GetDC($hwnd)
    Local $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
    If @error Or Not $acall[0x0] Then Return SetError(0x1, _WinAPI_GetLastError(), 0x0)
    Return $acall[0x0]
EndFunc    ; -> __MISC_GetDC

Func __MISC_GetDeviceCaps($hdc, $iindex)
    Local $acall = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hdc, "int", $iindex)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return $acall[0x0]
EndFunc    ; -> __MISC_GetDeviceCaps

Func __MISC_ReleaseDC($hwnd, $hdc)
    Local $acall = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0] <> 0x0
EndFunc    ; -> __MISC_ReleaseDC

Global Const $PIPE_FLAG_FIRST_PIPE_INSTANCE = 0x1
Global Const $PIPE_FLAG_OVERLAPPED = 0x2
Global Const $PIPE_FLAG_WRITE_THROUGH = 0x4
Global Const $__FILE_FLAG_FIRST_PIPE_INSTANCE = 0x80000
Global Const $__FILE_FLAG_OVERLAPPED = 0x40000000
Global Const $__FILE_FLAG_WRITE_THROUGH = -2147483648
Global Const $__PIPE_ACCESS_INBOUND = 0x1
Global Const $__PIPE_ACCESS_OUTBOUND = 0x2
Global Const $__PIPE_ACCESS_DUPLEX = 0x3
Global Const $__PIPE_WAIT = 0x0
Global Const $__PIPE_NOWAIT = 0x1
Global Const $__PIPE_READMODE_BYTE = 0x0
Global Const $__PIPE_READMODE_MESSAGE = 0x2
Global Const $__PIPE_TYPE_BYTE = 0x0
Global Const $__PIPE_TYPE_MESSAGE = 0x4
Global Const $__PIPE_CLIENT_END = 0x0
Global Const $__PIPE_SERVER_END = 0x1
Global Const $__WRITE_DAC = 0x40000
Global Const $__WRITE_OWNER = 0x80000
Global Const $__ACCESS_SYSTEM_SECURITY = 0x1000000
Func _NamedPipes_CallNamedPipe($spipename, $pinpbuf, $iinpsize, $poutbuf, $ioutsize, ByRef $iread, $itimeout = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "CallNamedPipeW", "wstr", $spipename, "struct*", $pinpbuf, "dword", $iinpsize, "struct*", $poutbuf, "dword", $ioutsize, "dword*", 0x0, "dword", $itimeout)
    If @error Then Return SetError(@error, @extended, False)
    $iread = $acall[0x6]
    Return $acall[0x0]
EndFunc    ; -> _NamedPipes_CallNamedPipe

Func _NamedPipes_ConnectNamedPipe($hnamedpipe, $toverlapped = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "ConnectNamedPipe", "handle", $hnamedpipe, "struct*", $toverlapped)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _NamedPipes_ConnectNamedPipe

Func _NamedPipes_CreateNamedPipe($sname, $iaccess = 0x2, $IFLAGS = 0x2, $iacl = 0x0, $itype = 0x1, $iread = 0x1, $iwait = 0x0, $imaxinst = 0x19, $ioutbufsize = 0x1000, $iinpbufsize = 0x1000, $idefaulttimeout = 0x1388, $tsecurity = 0x0)
    Local $iopenmode, $ipipemode
    Switch $iaccess
    Case 0x1
        $iopenmode = $__PIPE_ACCESS_OUTBOUND
    Case 0x2
        $iopenmode = $__PIPE_ACCESS_DUPLEX
    Case Else
        $iopenmode = $__PIPE_ACCESS_INBOUND
    EndSwitch
    If BitAND($IFLAGS, 0x1) <> 0x0 Then $iopenmode = BitOR($iopenmode, $__FILE_FLAG_FIRST_PIPE_INSTANCE)
    If BitAND($IFLAGS, 0x2) <> 0x0 Then $iopenmode = BitOR($iopenmode, $__FILE_FLAG_OVERLAPPED)
    If BitAND($IFLAGS, 0x4) <> 0x0 Then $iopenmode = BitOR($iopenmode, $__FILE_FLAG_WRITE_THROUGH)
    If BitAND($iacl, 0x1) <> 0x0 Then $iopenmode = BitOR($iopenmode, $__WRITE_DAC)
    If BitAND($iacl, 0x2) <> 0x0 Then $iopenmode = BitOR($iopenmode, $__WRITE_OWNER)
    If BitAND($iacl, 0x4) <> 0x0 Then $iopenmode = BitOR($iopenmode, $__ACCESS_SYSTEM_SECURITY)
    Switch $itype
    Case 0x1
        $ipipemode = $__PIPE_TYPE_MESSAGE
    Case Else
        $ipipemode = $__PIPE_TYPE_BYTE
    EndSwitch
    Switch $iread
    Case 0x1
        $ipipemode = BitOR($ipipemode, $__PIPE_READMODE_MESSAGE)
    Case Else
        $ipipemode = BitOR($ipipemode, $__PIPE_READMODE_BYTE)
    EndSwitch
    Switch $iwait
    Case 0x1
        $ipipemode = BitOR($ipipemode, $__PIPE_NOWAIT)
    Case Else
        $ipipemode = BitOR($ipipemode, $__PIPE_WAIT)
    EndSwitch
    Local $acall = DllCall("kernel32.dll", "handle", "CreateNamedPipeW", "wstr", $sname, "dword", $iopenmode, "dword", $ipipemode, "dword", $imaxinst, "dword", $ioutbufsize, "dword", $iinpbufsize, "dword", $idefaulttimeout, "struct*", $tsecurity)
    If @error Then Return SetError(@error, @extended, + -1)
    Return $acall[0x0]
EndFunc    ; -> _NamedPipes_CreateNamedPipe

Func _NamedPipes_CreatePipe(ByRef $hreadpipe, ByRef $hwritepipe, $tsecurity = 0x0, $isize = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "CreatePipe", "handle*", 0x0, "handle*", 0x0, "struct*", $tsecurity, "dword", $isize)
    If @error Then Return SetError(@error, @extended, False)
    $hreadpipe = $acall[0x1]
    $hwritepipe = $acall[0x2]
    Return $acall[0x0]
EndFunc    ; -> _NamedPipes_CreatePipe

Func _NamedPipes_DisconnectNamedPipe($hnamedpipe)
    Local $acall = DllCall("kernel32.dll", "bool", "DisconnectNamedPipe", "handle", $hnamedpipe)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _NamedPipes_DisconnectNamedPipe

Func _NamedPipes_GetNamedPipeHandleState($hnamedpipe)
    Local $acall = DllCall("kernel32.dll", "bool", "GetNamedPipeHandleStateW", "handle", $hnamedpipe, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "wstr", '', "dword", 0x1000)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $astate[0x6]
    $astate[0x0] = BitAND($acall[0x2], $__PIPE_NOWAIT) <> 0x0
    $astate[0x1] = BitAND($acall[0x2], $__PIPE_READMODE_MESSAGE) <> 0x0
    $astate[0x2] = $acall[0x3]
    $astate[0x3] = $acall[0x4]
    $astate[0x4] = $acall[0x5]
    $astate[0x5] = $acall[0x6]
    Return SetError(0x0, $acall[0x0], $astate)
EndFunc    ; -> _NamedPipes_GetNamedPipeHandleState

Func _NamedPipes_GetNamedPipeInfo($hnamedpipe)
    Local $acall = DllCall("kernel32.dll", "bool", "GetNamedPipeInfo", "handle", $hnamedpipe, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $ainfo[0x5]
    $ainfo[0x0] = BitAND($acall[0x2], $__PIPE_SERVER_END) <> 0x0
    $ainfo[0x1] = BitAND($acall[0x2], $__PIPE_TYPE_MESSAGE) <> 0x0
    $ainfo[0x2] = $acall[0x3]
    $ainfo[0x3] = $acall[0x4]
    $ainfo[0x4] = $acall[0x5]
    Return SetError(0x0, $acall[0x0], $ainfo)
EndFunc    ; -> _NamedPipes_GetNamedPipeInfo

Func _NamedPipes_PeekNamedPipe($hnamedpipe)
    Local $tbuffer = DllStructCreate("char Text[4096]")
    Local $acall = DllCall("kernel32.dll", "bool", "PeekNamedPipe", "handle", $hnamedpipe, "struct*", $tbuffer, "int", 0x1000, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Local $ainfo[0x4]
    $ainfo[0x0] = DllStructGetData($tbuffer, "Text")
    $ainfo[0x1] = $acall[0x4]
    $ainfo[0x2] = $acall[0x5]
    $ainfo[0x3] = $acall[0x6]
    Return SetError(0x0, $acall[0x0], $ainfo)
EndFunc    ; -> _NamedPipes_PeekNamedPipe

Func _NamedPipes_SetNamedPipeHandleState($hnamedpipe, $iread, $iwait, $ibytes = 0x0, $itimeout = 0x0)
    Local $imode = 0x0, $pbytes = 0x0, $ptimeout = 0x0
    Local $tint = DllStructCreate("dword Bytes;dword Timeout")
    If $iread = 0x1 Then $imode = BitOR($imode, $__PIPE_READMODE_MESSAGE)
    If $iwait = 0x1 Then $imode = BitOR($imode, $__PIPE_NOWAIT)
    If $ibytes <> 0x0 Then
        $pbytes = DllStructGetPtr($tint, "Bytes")
        DllStructSetData($tint, "Bytes", $ibytes)
    EndIf
    If $itimeout <> 0x0 Then
        $ptimeout = DllStructGetPtr($tint, "TimeOut")
        DllStructSetData($tint, "TimeOut", $itimeout)
    EndIf
    Local $acall = DllCall("kernel32.dll", "bool", "SetNamedPipeHandleState", "handle", $hnamedpipe, "dword*", $imode, "ptr", $pbytes, "ptr", $ptimeout)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _NamedPipes_SetNamedPipeHandleState

Func _NamedPipes_TransactNamedPipe($hnamedpipe, $pinpbuf, $iinpsize, $poutbuf, $ioutsize, $toverlapped = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "TransactNamedPipe", "handle", $hnamedpipe, "struct*", $pinpbuf, "dword", $iinpsize, "struct*", $poutbuf, "dword", $ioutsize, "dword*", 0x0, "struct*", $toverlapped)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetError(0x0, $acall[0x0], $acall[0x6])
EndFunc    ; -> _NamedPipes_TransactNamedPipe

Func _NamedPipes_WaitNamedPipe($spipename, $itimeout = 0x0)
    Local $acall = DllCall("kernel32.dll", "bool", "WaitNamedPipeW", "wstr", $spipename, "dword", $itimeout)
    If @error Then Return SetError(@error, @extended, False)
    Return $acall[0x0]
EndFunc    ; -> _NamedPipes_WaitNamedPipe

Global Const $STYPE_DISKTREE = 0x0
Global Const $STYPE_PRINTQ = 0x1
Global Const $STYPE_DEVICE = 0x2
Global Const $STYPE_IPC = 0x3
Global Const $STYPE_TEMPORARY = 0x40000000
Global Const $STYPE_SPECIAL = -2147483648
Global Const $TAGCONNECTION_INFO_1 = "dword ID;dword Type;dword Opens;dword Users;dword Time;ptr Username;ptr NetName"
Global Const $TAGFILE_INFO_3 = "dword ID;dword Permissions;dword Locks;ptr Pathname;ptr Username"
Global Const $TAGSESSION_INFO_2 = "ptr CName;ptr Username;dword Opens;dword Time;dword Idle;dword Flags;ptr TypeName"
Global Const $TAGSESSION_INFO_502 = "ptr CName;ptr Username;dword Opens;dword Time;dword Idle;dword Flags;ptr TypeName;ptr Transport"
Global Const $TAGSHARE_INFO_2 = "ptr NetName;dword Type;ptr Remark;dword Permissions;dword MaxUses;dword CurrentUses;ptr Path;ptr Password"
Global Const $TAGSTAT_SERVER_0 = "align 4;dword Start;dword FOpens;dword DevOpens;dword JobsQueued;dword SOpens;dword STimedOut;dword SErrorOut;" & "dword PWErrors;dword PermErrors;dword SysErrors;uint64 ByteSent;uint64 ByteRecv;dword AvResponse;dword ReqBufNeed;dword BigBufNeed"
Global Const $TAGSTAT_WORKSTATION_0 = "int64 StartTime;int64 BytesRecv;int64 SMBSRecv;int64 PageRead;int64 NonPageRead;" & "int64 CacheRead;int64 NetRead;int64 BytesTran;int64 SMBSTran;int64 PageWrite;int64 NonPageWrite;int64 CacheWrite;" & "int64 NetWrite;dword InitFailed;dword FailedComp;dword ReadOp;dword RandomReadOp;dword ReadSMBS;dword LargeReadSMBS;" & "dword SmallReadSMBS;dword WriteOp;dword RandomWriteOp;dword WriteSMBS;dword LargeWriteSMBS;dword SmallWriteSMBS;" & "dword RawReadsDenied;dword RawWritesDenied;dword NetworkErrors;dword Sessions;dword FailedSessions;dword Reconnects;" & "dword CoreConnects;dword LM20Connects;dword LM21Connects;dword LMNTConnects;dword ServerDisconnects;dword HungSessions;" & "dword UseCount;dword FailedUseCount;dword CurrentCommands"
Func __Net_Share_APIBufferFree($pbuffer)
    Local $acall = DllCall("netapi32.dll", "int", "NetApiBufferFree", "ptr", $pbuffer)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> __Net_Share_APIBufferFree

Func _Net_Share_ConnectionEnum($SSERVER, $SQUALIFIER)
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    Local $acall = DllCall("netapi32.dll", "int", "NetConnectionEnum", "wstr", $SSERVER, "wstr", $SQUALIFIER, "dword", 0x1, "ptr*", 0x0, "dword", + -1, "dword*", 0x0, "dword*", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $icount = $acall[0x6]
    Local $ainfo[$icount + 0x1][0x7]
    $ainfo[0x0][0x0] = $icount
    Local $PINFO = $acall[0x4]
    Local $tinfo
    For $ii = 0x1 To $icount
        $tinfo = DllStructCreate($TAGCONNECTION_INFO_1, $PINFO)
        $ainfo[$ii][0x0] = DllStructGetData($tinfo, "ID")
        $ainfo[$ii][0x1] = DllStructGetData($tinfo, "Type")
        $ainfo[$ii][0x2] = DllStructGetData($tinfo, "Opens")
        $ainfo[$ii][0x3] = DllStructGetData($tinfo, "Users")
        $ainfo[$ii][0x4] = DllStructGetData($tinfo, "Time")
        $ainfo[$ii][0x5] = _WinAPI_GetString(DllStructGetData($tinfo, "UserName"))
        $ainfo[$ii][0x6] = _WinAPI_GetString(DllStructGetData($tinfo, "NetName"))
        $PINFO += DllStructGetSize($tinfo)
    Next
    __Net_Share_APIBufferFree($acall[0x4])
    Return $ainfo
EndFunc    ; -> _Net_Share_ConnectionEnum

Func _Net_Share_FileClose($SSERVER, $ifileid)
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    Local $acall = DllCall("netapi32.dll", "int", "NetFileClose", "wstr", $SSERVER, "dword", $ifileid)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _Net_Share_FileClose

Func _Net_Share_FileEnum($SSERVER = '', $SBASENAME = '', $susername = '')
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    Local $acall = DllCall("netapi32.dll", "int", "NetFileEnum", "wstr", $SSERVER, "wstr", $SBASENAME, "wstr", $susername, "dword", 0x3, "ptr*", 0x0, "INT", + -1, "dword*", 0x0, "dword*", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $icount = $acall[0x7]
    Local $ainfo[$icount + 0x1][0x5]
    $ainfo[0x0][0x0] = $icount
    Local $PINFO = $acall[0x5]
    Local $tinfo
    For $ii = 0x1 To $icount
        $tinfo = DllStructCreate($TAGFILE_INFO_3, $PINFO)
        $ainfo[$ii][0x0] = DllStructGetData($tinfo, "ID")
        $ainfo[$ii][0x1] = DllStructGetData($tinfo, "Permissions")
        $ainfo[$ii][0x2] = DllStructGetData($tinfo, "Locks")
        $ainfo[$ii][0x3] = _WinAPI_GetString(DllStructGetData($tinfo, "PathName"))
        $ainfo[$ii][0x4] = _WinAPI_GetString(DllStructGetData($tinfo, "UserName"))
        $PINFO += DllStructGetSize($tinfo)
    Next
    __Net_Share_APIBufferFree($acall[0x5])
    Return $ainfo
EndFunc    ; -> _Net_Share_FileEnum

Func _Net_Share_FileGetInfo($SSERVER, $ifileid)
    Local $ainfo[0x5]
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    Local $acall = DllCall("netapi32.dll", "int", "NetFileGetInfo", "wstr", $SSERVER, "dword", $ifileid, "dword", 0x3, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $tinfo
    $tinfo = DllStructCreate($TAGFILE_INFO_3, $acall[0x4])
    $ainfo[0x0] = DllStructGetData($tinfo, "ID")
    $ainfo[0x1] = DllStructGetData($tinfo, "Permissions")
    $ainfo[0x2] = DllStructGetData($tinfo, "Locks")
    $ainfo[0x3] = _WinAPI_GetString(DllStructGetData($tinfo, "PathName"))
    $ainfo[0x4] = _WinAPI_GetString(DllStructGetData($tinfo, "UserName"))
    __Net_Share_APIBufferFree($acall[0x4])
    Return $ainfo
EndFunc    ; -> _Net_Share_FileGetInfo

Func _Net_Share_PermStr($iperm)
    Local $stype = "-------"
    If BitAND($iperm, 0x1) Then __Str_Set_Char($stype, 0x1, "R")
    If BitAND($iperm, 0x2) Then __Str_Set_Char($stype, 0x2, "W")
    If BitAND($iperm, 0x4) Then __Str_Set_Char($stype, 0x3, "C")
    If BitAND($iperm, 0x8) Then __Str_Set_Char($stype, 0x4, "E")
    If BitAND($iperm, 0x10) Then __Str_Set_Char($stype, 0x5, "D")
    If BitAND($iperm, 0x20) Then __Str_Set_Char($stype, 0x6, "A")
    If BitAND($iperm, 0x40) Then __Str_Set_Char($stype, 0x7, "P")
    Return $stype
EndFunc    ; -> _Net_Share_PermStr

Func _Net_Share_ResourceStr($iresource)
    Local $sresource = "Unknown"
    Switch BitAND($iresource, BitOR($STYPE_DISKTREE, $STYPE_PRINTQ, $STYPE_DEVICE, $STYPE_IPC))
    Case $STYPE_DISKTREE
        $sresource = "Disk drive"
    Case $STYPE_PRINTQ
        $sresource = "Print queue"
    Case $STYPE_DEVICE
        $sresource = "Communication"
    Case $STYPE_IPC
        $sresource = "IPC"
    EndSwitch
    Switch BitAND($iresource, BitOR($STYPE_TEMPORARY, $STYPE_SPECIAL))
    Case $STYPE_TEMPORARY
        $sresource &= " (Temporary)"
    Case $STYPE_SPECIAL
        $sresource &= " (Special)"
    EndSwitch
    Return $sresource
EndFunc    ; -> _Net_Share_ResourceStr

Func _Net_Share_SessionDel($SSERVER = '', $sclientname = '', $susername = '')
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    If ($sclientname <> '') And (StringLeft($sclientname, 0x2) <> "\\\\") Then $sclientname = "\\\\" & $sclientname
    Local $acall = DllCall("netapi32.dll", "int", "NetSessionDel", "wstr", $SSERVER, "wstr", $sclientname, "wstr", $susername)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _Net_Share_SessionDel

Func _Net_Share_SessionEnum($SSERVER = '', $sclientname = '', $susername = '')
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    If ($sclientname <> '') And StringLeft($sclientname, 0x2) <> "\\\\" Then $sclientname = "\\\\" & $sclientname
    Local $acall = DllCall("netapi32.dll", "int", "NetSessionEnum", "wstr", $SSERVER, "wstr", $sclientname, "wstr", $susername, "dword", 0x1f6, "ptr*", 0x0, "dword", + -1, "dword*", 0x0, "dword*", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $icount = $acall[0x7]
    Local $ainfo[$icount + 0x1][0x8]
    $ainfo[0x0][0x0] = $icount
    Local $PINFO = $acall[0x5]
    Local $tinfo
    For $ii = 0x1 To $icount
        $tinfo = DllStructCreate($TAGSESSION_INFO_502, $PINFO)
        $ainfo[$ii][0x0] = _WinAPI_GetString(DllStructGetData($tinfo, "CName"))
        $ainfo[$ii][0x1] = _WinAPI_GetString(DllStructGetData($tinfo, "UserName"))
        $ainfo[$ii][0x2] = DllStructGetData($tinfo, "Opens")
        $ainfo[$ii][0x3] = DllStructGetData($tinfo, "Time")
        $ainfo[$ii][0x4] = DllStructGetData($tinfo, "Idle")
        $ainfo[$ii][0x5] = DllStructGetData($tinfo, "Flags")
        $ainfo[$ii][0x6] = _WinAPI_GetString(DllStructGetData($tinfo, "TypeName"))
        $ainfo[$ii][0x7] = _WinAPI_GetString(DllStructGetData($tinfo, "Transport"))
        $PINFO += DllStructGetSize($tinfo)
    Next
    __Net_Share_APIBufferFree($acall[0x5])
    Return $ainfo
EndFunc    ; -> _Net_Share_SessionEnum

Func _Net_Share_SessionGetInfo($SSERVER, $sclientname, $susername)
    Local $ainfo[0x8]
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    If StringLeft($sclientname, 0x2) <> "\\\\" Then $sclientname = "\\\\" & $sclientname
    Local $acall = DllCall("netapi32.dll", "int", "NetSessionGetInfo", "wstr", $SSERVER, "wstr", $sclientname, "wstr", $susername, "dword", 0x2, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $tinfo
    $tinfo = DllStructCreate($TAGSESSION_INFO_2, $acall[0x5])
    $ainfo[0x0] = _WinAPI_GetString(DllStructGetData($tinfo, "CName"))
    $ainfo[0x1] = _WinAPI_GetString(DllStructGetData($tinfo, "UserName"))
    $ainfo[0x2] = DllStructGetData($tinfo, "Opens")
    $ainfo[0x3] = DllStructGetData($tinfo, "Time")
    $ainfo[0x4] = DllStructGetData($tinfo, "Idle")
    $ainfo[0x5] = DllStructGetData($tinfo, "Flags")
    $ainfo[0x6] = _WinAPI_GetString(DllStructGetData($tinfo, "TypeName"))
    __Net_Share_APIBufferFree($acall[0x5])
    Return $ainfo
EndFunc    ; -> _Net_Share_SessionGetInfo

Func _Net_Share_ShareAdd($SSERVER, $sshare, $itype, $sresourcepath, $scomment = '', $imaxuses = + -1)
    Local $tdata = DllStructCreate("char Share[512];char Path[512];char Comment[512]")
    Local $pshare = DllStructGetPtr($tdata, "Share")
    Local $ppath = DllStructGetPtr($tdata, "Path")
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    _WinAPI_MultiByteToWideCharEx($sshare, DllStructGetPtr($tdata, "Share"))
    _WinAPI_MultiByteToWideCharEx($sresourcepath, DllStructGetPtr($tdata, "Path"))
    Local $pcomment = 0x0
    If $scomment <> '' Then
        _WinAPI_MultiByteToWideCharEx($scomment, DllStructGetPtr($tdata, "Comment"))
        $pcomment = DllStructGetPtr($tdata, "Comment")
    EndIf
    Local $tinfo = DllStructCreate($TAGSHARE_INFO_2)
    DllStructSetData($tinfo, "NetName", $pshare)
    DllStructSetData($tinfo, "Type", $itype)
    DllStructSetData($tinfo, "Remark", $pcomment)
    DllStructSetData($tinfo, "Path", $ppath)
    DllStructSetData($tinfo, "MaxUses", $imaxuses)
    Local $acall = DllCall("netapi32.dll", "int", "NetShareAdd", "wstr", $SSERVER, "dword", 0x2, "struct*", $tinfo, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _Net_Share_ShareAdd

Func _Net_Share_ShareCheck($SSERVER, $sresourcepath)
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    Local $acall = DllCall("netapi32.dll", "int", "NetShareCheck", "wstr", $SSERVER, "wstr", $sresourcepath, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], + -1)
    Return $acall[0x3]
EndFunc    ; -> _Net_Share_ShareCheck

Func _Net_Share_ShareDel($SSERVER, $sshare)
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    Local $acall = DllCall("netapi32.dll", "int", "NetShareDel", "wstr", $SSERVER, "wstr", $sshare, "dword", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _Net_Share_ShareDel

Func _Net_Share_ShareEnum($SSERVER = '')
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    Local $acall = DllCall("netapi32.dll", "int", "NetShareEnum", "wstr", $SSERVER, "dword", 0x2, "ptr*", 0x0, "dword", + -1, "dword*", 0x0, "dword*", 0x0, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $icount = $acall[0x5]
    Local $ainfo[$icount + 0x1][0x8]
    $ainfo[0x0][0x0] = $icount
    Local $PINFO = $acall[0x3]
    Local $tinfo
    For $ii = 0x1 To $icount
        $tinfo = DllStructCreate($TAGSHARE_INFO_2, $PINFO)
        $ainfo[$ii][0x0] = _WinAPI_GetString(DllStructGetData($tinfo, "NetName"))
        $ainfo[$ii][0x1] = DllStructGetData($tinfo, "Type")
        $ainfo[$ii][0x2] = _WinAPI_GetString(DllStructGetData($tinfo, "Remark"))
        $ainfo[$ii][0x3] = DllStructGetData($tinfo, "Permissions")
        $ainfo[$ii][0x4] = DllStructGetData($tinfo, "MaxUses")
        $ainfo[$ii][0x5] = DllStructGetData($tinfo, "CurrentUses")
        $ainfo[$ii][0x6] = _WinAPI_GetString(DllStructGetData($tinfo, "Path"))
        $ainfo[$ii][0x7] = _WinAPI_GetString(DllStructGetData($tinfo, "Password"))
        $PINFO += DllStructGetSize($tinfo)
    Next
    __Net_Share_APIBufferFree($acall[0x3])
    Return $ainfo
EndFunc    ; -> _Net_Share_ShareEnum

Func _Net_Share_ShareGetInfo($SSERVER, $sshare)
    Local $ainfo[0x8]
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    Local $acall = DllCall("netapi32.dll", "int", "NetShareGetInfo", "wstr", $SSERVER, "wstr", $sshare, "dword", 0x2, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $tinfo
    $tinfo = DllStructCreate($TAGSHARE_INFO_2, $acall[0x4])
    $ainfo[0x0] = _WinAPI_GetString(DllStructGetData($tinfo, "NetName"))
    $ainfo[0x1] = DllStructGetData($tinfo, "Type")
    $ainfo[0x2] = _WinAPI_GetString(DllStructGetData($tinfo, "Remark"))
    $ainfo[0x3] = DllStructGetData($tinfo, "Permissions")
    $ainfo[0x4] = DllStructGetData($tinfo, "MaxUses")
    $ainfo[0x5] = DllStructGetData($tinfo, "CurrentUses")
    $ainfo[0x6] = _WinAPI_GetString(DllStructGetData($tinfo, "Path"))
    $ainfo[0x7] = _WinAPI_GetString(DllStructGetData($tinfo, "Password"))
    __Net_Share_APIBufferFree($acall[0x4])
    Return $ainfo
EndFunc    ; -> _Net_Share_ShareGetInfo

Func _Net_Share_ShareSetInfo($SSERVER, $sshare, $scomment, $imaxuses)
    Local $tdata = DllStructCreate("char Comment[512]")
    Local $pcomment = DllStructGetPtr($tdata, "Comment")
    If $SSERVER = '' Then $SSERVER = "127.0.0.1"
    If StringLeft($SSERVER, 0x2) <> "\\\\" Then $SSERVER = "\\\\" & $SSERVER
    _WinAPI_MultiByteToWideCharEx($scomment, $pcomment)
    Local $tinfo = DllStructCreate($TAGSHARE_INFO_2)
    DllStructSetData($tinfo, "Remark", $pcomment)
    DllStructSetData($tinfo, "MaxUses", $imaxuses)
    Local $acall = DllCall("netapi32.dll", "int", "NetShareSetInfo", "wstr", $SSERVER, "wstr", $sshare, "dword", 0x2, "struct*", $tinfo, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], False)
    Return True
EndFunc    ; -> _Net_Share_ShareSetInfo

Func _Net_Share_StatisticsGetSvr($SSERVER = '')
    Local $astats[0xf]
    Local $tservice = _WinAPI_MultiByteToWideChar("LanmanServer")
    Local $acall = DllCall("netapi32.dll", "int", "NetStatisticsGet", "wstr", $SSERVER, "struct*", $tservice, "dword", 0x0, "dword", 0x0, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $tstatinfo = DllStructCreate($TAGSTAT_SERVER_0, $acall[0x5])
    $astats[0x0] = DllStructGetData($tstatinfo, "Start")
    $astats[0x1] = DllStructGetData($tstatinfo, "FOpens")
    $astats[0x2] = DllStructGetData($tstatinfo, "DevOpens")
    $astats[0x3] = DllStructGetData($tstatinfo, "JobsQueued")
    $astats[0x4] = DllStructGetData($tstatinfo, "SOpens")
    $astats[0x5] = DllStructGetData($tstatinfo, "STimedOut")
    $astats[0x6] = DllStructGetData($tstatinfo, "SErrorOut")
    $astats[0x7] = DllStructGetData($tstatinfo, "PWErrors")
    $astats[0x8] = DllStructGetData($tstatinfo, "PermErrors")
    $astats[0x9] = DllStructGetData($tstatinfo, "SysErrors")
    $astats[0xa] = DllStructGetData($tstatinfo, "ByteSent")
    $astats[0xb] = DllStructGetData($tstatinfo, "ByteRecv")
    $astats[0xc] = DllStructGetData($tstatinfo, "AvResponse")
    $astats[0xd] = DllStructGetData($tstatinfo, "ReqBufNeed")
    $astats[0xe] = DllStructGetData($tstatinfo, "BigBufNeed")
    __Net_Share_APIBufferFree($acall[0x5])
    Return $astats
EndFunc    ; -> _Net_Share_StatisticsGetSvr

Func _Net_Share_StatisticsGetWrk($sworkstation = '')
    Local $astats[0x28]
    Local $tservice = _WinAPI_MultiByteToWideChar("LanmanWorkstation")
    Local $acall = DllCall("netapi32.dll", "int", "NetStatisticsGet", "wstr", $sworkstation, "struct*", $tservice, "dword", 0x0, "dword", 0x0, "ptr*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
    Local $tstatinfo = DllStructCreate($TAGSTAT_WORKSTATION_0, $acall[0x5])
    $astats[0x0] = DllStructGetData($tstatinfo, "StartTime")
    $astats[0x1] = DllStructGetData($tstatinfo, "BytesRecv")
    $astats[0x2] = DllStructGetData($tstatinfo, "SMBSRecv")
    $astats[0x3] = DllStructGetData($tstatinfo, "PageRead")
    $astats[0x4] = DllStructGetData($tstatinfo, "NonPageRead")
    $astats[0x5] = DllStructGetData($tstatinfo, "CacheRead")
    $astats[0x6] = DllStructGetData($tstatinfo, "NetRead")
    $astats[0x7] = DllStructGetData($tstatinfo, "BytesTran")
    $astats[0x8] = DllStructGetData($tstatinfo, "SMBSTran")
    $astats[0x9] = DllStructGetData($tstatinfo, "PageWrite")
    $astats[0xa] = DllStructGetData($tstatinfo, "NonPageWrite")
    $astats[0xb] = DllStructGetData($tstatinfo, "CacheWrite")
    $astats[0xc] = DllStructGetData($tstatinfo, "NetWrite")
    $astats[0xd] = DllStructGetData($tstatinfo, "InitFailed")
    $astats[0xe] = DllStructGetData($tstatinfo, "FailedComp")
    $astats[0xf] = DllStructGetData($tstatinfo, "ReadOp")
    $astats[0x10] = DllStructGetData($tstatinfo, "RandomReadOp")
    $astats[0x11] = DllStructGetData($tstatinfo, "ReadSMBS")
    $astats[0x12] = DllStructGetData($tstatinfo, "LargeReadSMBS")
    $astats[0x13] = DllStructGetData($tstatinfo, "SmallReadSMBS")
    $astats[0x14] = DllStructGetData($tstatinfo, "WriteOp")
    $astats[0x15] = DllStructGetData($tstatinfo, "RandomWriteOp")
    $astats[0x16] = DllStructGetData($tstatinfo, "WriteSMBS")
    $astats[0x17] = DllStructGetData($tstatinfo, "LargeWriteSMBS")
    $astats[0x18] = DllStructGetData($tstatinfo, "SmallWriteSMBS")
    $astats[0x19] = DllStructGetData($tstatinfo, "RawReadsDenied")
    $astats[0x1a] = DllStructGetData($tstatinfo, "RawWritesDenied")
    $astats[0x1b] = DllStructGetData($tstatinfo, "NetworkErrors")
    $astats[0x1c] = DllStructGetData($tstatinfo, "Sessions")
    $astats[0x1d] = DllStructGetData($tstatinfo, "FailedSessions")
    $astats[0x1e] = DllStructGetData($tstatinfo, "Reconnects")
    $astats[0x1f] = DllStructGetData($tstatinfo, "CoreConnects")
    $astats[0x20] = DllStructGetData($tstatinfo, "LM20Connects")
    $astats[0x21] = DllStructGetData($tstatinfo, "LM21Connects")
    $astats[0x22] = DllStructGetData($tstatinfo, "LMNTConnects")
    $astats[0x23] = DllStructGetData($tstatinfo, "ServerDisconnects")
    $astats[0x24] = DllStructGetData($tstatinfo, "HungSessions")
    $astats[0x25] = DllStructGetData($tstatinfo, "UseCount")
    $astats[0x26] = DllStructGetData($tstatinfo, "FailedUseCount")
    $astats[0x27] = DllStructGetData($tstatinfo, "CurrentCommands")
    __Net_Share_APIBufferFree($acall[0x5])
    Return $astats
EndFunc    ; -> _Net_Share_StatisticsGetWrk

Func __Str_Set_Char(ByRef $stext, $iindex, $schar)
    $stext = StringLeft($stext, $iindex + -1) & $schar & StringMid($stext, $iindex + StringLen($schar))
EndFunc    ; -> __Str_Set_Char

Global Const $STATUS_SUCCESS = 0x0
Global Const $STATUS_WAIT_0 = 0x0
Global Const $STATUS_WAIT_1 = 0x1
Global Const $STATUS_WAIT_2 = 0x2
Global Const $STATUS_WAIT_3 = 0x3
Global Const $STATUS_WAIT_63 = 0x3f
Global Const $STATUS_ABANDONED = 0x80
Global Const $STATUS_ABANDONED_WAIT_0 = 0x80
Global Const $STATUS_ABANDONED_WAIT_63 = 0xbf
Global Const $STATUS_USER_APC = 0xc0
Global Const $STATUS_ALERTED = 0x101
Global Const $STATUS_TIMEOUT = 0x102
Global Const $STATUS_PENDING = 0x103
Global Const $STATUS_REPARSE = 0x104
Global Const $STATUS_MORE_ENTRIES = 0x105
Global Const $STATUS_NOT_ALL_ASSIGNED = 0x106
Global Const $STATUS_SOME_NOT_MAPPED = 0x107
Global Const $STATUS_OPLOCK_BREAK_IN_PROGRESS = 0x108
Global Const $STATUS_VOLUME_MOUNTED = 0x109
Global Const $STATUS_RXACT_COMMITTED = 0x10a
Global Const $STATUS_NOTIFY_CLEANUP = 0x10b
Global Const $STATUS_NOTIFY_ENUM_DIR = 0x10c
Global Const $STATUS_NO_QUOTAS_FOR_ACCOUNT = 0x10d
Global Const $STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED = 0x10e
Global Const $STATUS_PAGE_FAULT_TRANSITION = 0x110
Global Const $STATUS_PAGE_FAULT_DEMAND_ZERO = 0x111
Global Const $STATUS_PAGE_FAULT_COPY_ON_WRITE = 0x112
Global Const $STATUS_PAGE_FAULT_GUARD_PAGE = 0x113
Global Const $STATUS_PAGE_FAULT_PAGING_FILE = 0x114
Global Const $STATUS_CACHE_PAGE_LOCKED = 0x115
Global Const $STATUS_CRASH_DUMP = 0x116
Global Const $STATUS_BUFFER_ALL_ZEROS = 0x117
Global Const $STATUS_REPARSE_OBJECT = 0x118
Global Const $STATUS_RESOURCE_REQUIREMENTS_CHANGED = 0x119
Global Const $STATUS_TRANSLATION_COMPLETE = 0x120
Global Const $STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY = 0x121
Global Const $STATUS_NOTHING_TO_TERMINATE = 0x122
Global Const $STATUS_PROCESS_NOT_IN_JOB = 0x123
Global Const $STATUS_PROCESS_IN_JOB = 0x124
Global Const $STATUS_VOLSNAP_HIBERNATE_READY = 0x125
Global Const $STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY = 0x126
Global Const $STATUS_INTERRUPT_VECTOR_ALREADY_CONNECTED = 0x127
Global Const $STATUS_INTERRUPT_STILL_CONNECTED = 0x128
Global Const $STATUS_PROCESS_CLONED = 0x129
Global Const $STATUS_FILE_LOCKED_WITH_ONLY_READERS = 0x12a
Global Const $STATUS_FILE_LOCKED_WITH_WRITERS = 0x12b
Global Const $STATUS_RESOURCEMANAGER_READ_ONLY = 0x202
Global Const $STATUS_WAIT_FOR_OPLOCK = 0x367
Global Const $STATUS_FLT_IO_COMPLETE = 0x1c0001
Global Const $STATUS_FILE_NOT_AVAILABLE = -1073740697
Global Const $STATUS_CALLBACK_RETURNED_THREAD_AFFINITY = -1073739999
Global Const $STATUS_OBJECT_NAME_EXISTS = 0x40000000
Global Const $STATUS_THREAD_WAS_SUSPENDED = 0x40000001
Global Const $STATUS_WORKING_SET_LIMIT_RANGE = 0x40000002
Global Const $STATUS_IMAGE_NOT_AT_BASE = 0x40000003
Global Const $STATUS_RXACT_STATE_CREATED = 0x40000004
Global Const $STATUS_SEGMENT_NOTIFICATION = 0x40000005
Global Const $STATUS_LOCAL_USER_SESSION_KEY = 0x40000006
Global Const $STATUS_BAD_CURRENT_DIRECTORY = 0x40000007
Global Const $STATUS_SERIAL_MORE_WRITES = 0x40000008
Global Const $STATUS_REGISTRY_RECOVERED = 0x40000009
Global Const $STATUS_FT_READ_RECOVERY_FROM_BACKUP = 0x4000000a
Global Const $STATUS_FT_WRITE_RECOVERY = 0x4000000b
Global Const $STATUS_SERIAL_COUNTER_TIMEOUT = 0x4000000c
Global Const $STATUS_NULL_LM_PASSWORD = 0x4000000d
Global Const $STATUS_IMAGE_MACHINE_TYPE_MISMATCH = 0x4000000e
Global Const $STATUS_RECEIVE_PARTIAL = 0x4000000f
Global Const $STATUS_RECEIVE_EXPEDITED = 0x40000010
Global Const $STATUS_RECEIVE_PARTIAL_EXPEDITED = 0x40000011
Global Const $STATUS_EVENT_DONE = 0x40000012
Global Const $STATUS_EVENT_PENDING = 0x40000013
Global Const $STATUS_CHECKING_FILE_SYSTEM = 0x40000014
Global Const $STATUS_FATAL_APP_EXIT = 0x40000015
Global Const $STATUS_PREDEFINED_HANDLE = 0x40000016
Global Const $STATUS_WAS_UNLOCKED = 0x40000017
Global Const $STATUS_SERVICE_NOTIFICATION = 0x40000018
Global Const $STATUS_WAS_LOCKED = 0x40000019
Global Const $STATUS_LOG_HARD_ERROR = 0x4000001a
Global Const $STATUS_ALREADY_WIN32 = 0x4000001b
Global Const $STATUS_WX86_UNSIMULATE = 0x4000001c
Global Const $STATUS_WX86_CONTINUE = 0x4000001d
Global Const $STATUS_WX86_SINGLE_STEP = 0x4000001e
Global Const $STATUS_WX86_BREAKPOINT = 0x4000001f
Global Const $STATUS_WX86_EXCEPTION_CONTINUE = 0x40000020
Global Const $STATUS_WX86_EXCEPTION_LASTCHANCE = 0x40000021
Global Const $STATUS_WX86_EXCEPTION_CHAIN = 0x40000022
Global Const $STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE = 0x40000023
Global Const $STATUS_NO_YIELD_PERFORMED = 0x40000024
Global Const $STATUS_TIMER_RESUME_IGNORED = 0x40000025
Global Const $STATUS_ARBITRATION_UNHANDLED = 0x40000026
Global Const $STATUS_CARDBUS_NOT_SUPPORTED = 0x40000027
Global Const $STATUS_WX86_CREATEWX86TIB = 0x40000028
Global Const $STATUS_MP_PROCESSOR_MISMATCH = 0x40000029
Global Const $STATUS_HIBERNATED = 0x4000002a
Global Const $STATUS_RESUME_HIBERNATION = 0x4000002b
Global Const $STATUS_FIRMWARE_UPDATED = 0x4000002c
Global Const $STATUS_DRIVERS_LEAKING_LOCKED_PAGES = 0x4000002d
Global Const $STATUS_MESSAGE_RETRIEVED = 0x4000002e
Global Const $STATUS_SYSTEM_POWERSTATE_TRANSITION = 0x4000002f
Global Const $STATUS_ALPC_CHECK_COMPLETION_LIST = 0x40000030
Global Const $STATUS_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = 0x40000031
Global Const $STATUS_ACCESS_AUDIT_BY_POLICY = 0x40000032
Global Const $STATUS_ABANDON_HIBERFILE = 0x40000033
Global Const $STATUS_BIZRULES_NOT_ENABLED = 0x40000034
Global Const $STATUS_WAKE_SYSTEM = 0x40000294
Global Const $STATUS_DS_SHUTTING_DOWN = 0x40000370
Global Const $STATUS_CTX_CDM_CONNECT = 0x400a0004
Global Const $STATUS_CTX_CDM_DISCONNECT = 0x400a0005
Global Const $STATUS_SXS_RELEASE_ACTIVATION_CONTEXT = 0x4015000d
Global Const $STATUS_RECOVERY_NOT_NEEDED = 0x40190034
Global Const $STATUS_RM_ALREADY_STARTED = 0x40190035
Global Const $STATUS_LOG_NO_RESTART = 0x401a000c
Global Const $STATUS_VIDEO_DRIVER_DEBUG_REPORT_REQUEST = 0x401b00ec
Global Const $STATUS_GRAPHICS_PARTIAL_DATA_POPULATED = 0x401e000a
Global Const $STATUS_GRAPHICS_DRIVER_MISMATCH = 0x401e0117
Global Const $STATUS_GRAPHICS_MODE_NOT_PINNED = 0x401e0307
Global Const $STATUS_GRAPHICS_NO_PREFERRED_MODE = 0x401e031e
Global Const $STATUS_GRAPHICS_DATASET_IS_EMPTY = 0x401e034b
Global Const $STATUS_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET = 0x401e034c
Global Const $STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED = 0x401e0351
Global Const $STATUS_GRAPHICS_UNKNOWN_CHILD_STATUS = 0x401e042f
Global Const $STATUS_GRAPHICS_LEADLINK_START_DEFERRED = 0x401e0437
Global Const $STATUS_GRAPHICS_POLLING_TOO_FREQUENTLY = 0x401e0439
Global Const $STATUS_GRAPHICS_START_DEFERRED = 0x401e043a
Global Const $STATUS_NDIS_INDICATION_REQUIRED = 0x40230001
Global Const $STATUS_GUARD_PAGE_VIOLATION = -2147483647
Global Const $STATUS_DATATYPE_MISALIGNMENT = -2147483646
Global Const $STATUS_BREAKPOINT = -2147483645
Global Const $STATUS_SINGLE_STEP = -2147483644
Global Const $STATUS_BUFFER_OVERFLOW = -2147483643
Global Const $STATUS_NO_MORE_FILES = -2147483642
Global Const $STATUS_WAKE_SYSTEM_DEBUGGER = -2147483641
Global Const $STATUS_HANDLES_CLOSED = -2147483638
Global Const $STATUS_NO_INHERITANCE = -2147483637
Global Const $STATUS_GUID_SUBSTITUTION_MADE = -2147483636
Global Const $STATUS_PARTIAL_COPY = -2147483635
Global Const $STATUS_DEVICE_PAPER_EMPTY = -2147483634
Global Const $STATUS_DEVICE_POWERED_OFF = -2147483633
Global Const $STATUS_DEVICE_OFF_LINE = -2147483632
Global Const $STATUS_DEVICE_BUSY = -2147483631
Global Const $STATUS_NO_MORE_EAS = -2147483630
Global Const $STATUS_INVALID_EA_NAME = -2147483629
Global Const $STATUS_EA_LIST_INCONSISTENT = -2147483628
Global Const $STATUS_INVALID_EA_FLAG = -2147483627
Global Const $STATUS_VERIFY_REQUIRED = -2147483626
Global Const $STATUS_EXTRANEOUS_INFORMATION = -2147483625
Global Const $STATUS_RXACT_COMMIT_NECESSARY = -2147483624
Global Const $STATUS_NO_MORE_ENTRIES = -2147483622
Global Const $STATUS_FILEMARK_DETECTED = -2147483621
Global Const $STATUS_MEDIA_CHANGED = -2147483620
Global Const $STATUS_BUS_RESET = -2147483619
Global Const $STATUS_END_OF_MEDIA = -2147483618
Global Const $STATUS_BEGINNING_OF_MEDIA = -2147483617
Global Const $STATUS_MEDIA_CHECK = -2147483616
Global Const $STATUS_SETMARK_DETECTED = -2147483615
Global Const $STATUS_NO_DATA_DETECTED = -2147483614
Global Const $STATUS_REDIRECTOR_HAS_OPEN_HANDLES = -2147483613
Global Const $STATUS_SERVER_HAS_OPEN_HANDLES = -2147483612
Global Const $STATUS_ALREADY_DISCONNECTED = -2147483611
Global Const $STATUS_LONGJUMP = -2147483610
Global Const $STATUS_CLEANER_CARTRIDGE_INSTALLED = -2147483609
Global Const $STATUS_PLUGPLAY_QUERY_VETOED = -2147483608
Global Const $STATUS_UNWIND_CONSOLIDATE = -2147483607
Global Const $STATUS_REGISTRY_HIVE_RECOVERED = -2147483606
Global Const $STATUS_DLL_MIGHT_BE_INSECURE = -2147483605
Global Const $STATUS_DLL_MIGHT_BE_INCOMPATIBLE = -2147483604
Global Const $STATUS_STOPPED_ON_SYMLINK = -2147483603
Global Const $STATUS_DEVICE_REQUIRES_CLEANING = -2147483000
Global Const $STATUS_DEVICE_DOOR_OPEN = -2147482999
Global Const $STATUS_DATA_LOST_REPAIR = -2147481597
Global Const $STATUS_CLUSTER_NODE_ALREADY_UP = -2146238463
Global Const $STATUS_CLUSTER_NODE_ALREADY_DOWN = -2146238462
Global Const $STATUS_CLUSTER_NETWORK_ALREADY_ONLINE = -2146238461
Global Const $STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE = -2146238460
Global Const $STATUS_CLUSTER_NODE_ALREADY_MEMBER = -2146238459
Global Const $STATUS_COULD_NOT_RESIZE_LOG = -2145845239
Global Const $STATUS_NO_TXF_METADATA = -2145845207
Global Const $STATUS_CANT_RECOVER_WITH_HANDLE_OPEN = -2145845199
Global Const $STATUS_TXF_METADATA_ALREADY_PRESENT = -2145845183
Global Const $STATUS_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = -2145845182
Global Const $STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD_RECOVERED = -2145713941
Global Const $STATUS_FLT_BUFFER_TOO_SMALL = -2145648639
Global Const $STATUS_FVE_PARTIAL_METADATA = -2145320959
Global Const $STATUS_FVE_TRANSIENT_STATE = -2145320958
Global Const $STATUS_UNSUCCESSFUL = -1073741823
Global Const $STATUS_NOT_IMPLEMENTED = -1073741822
Global Const $STATUS_INVALID_INFO_CLASS = -1073741821
Global Const $STATUS_INFO_LENGTH_MISMATCH = -1073741820
Global Const $STATUS_ACCESS_VIOLATION = -1073741819
Global Const $STATUS_IN_PAGE_ERROR = -1073741818
Global Const $STATUS_PAGEFILE_QUOTA = -1073741817
Global Const $STATUS_INVALID_HANDLE = -1073741816
Global Const $STATUS_BAD_INITIAL_STACK = -1073741815
Global Const $STATUS_BAD_INITIAL_PC = -1073741814
Global Const $STATUS_INVALID_CID = -1073741813
Global Const $STATUS_TIMER_NOT_CANCELED = -1073741812
Global Const $STATUS_INVALID_PARAMETER = -1073741811
Global Const $STATUS_NO_SUCH_DEVICE = -1073741810
Global Const $STATUS_NO_SUCH_FILE = -1073741809
Global Const $STATUS_INVALID_DEVICE_REQUEST = -1073741808
Global Const $STATUS_END_OF_FILE = -1073741807
Global Const $STATUS_WRONG_VOLUME = -1073741806
Global Const $STATUS_NO_MEDIA_IN_DEVICE = -1073741805
Global Const $STATUS_UNRECOGNIZED_MEDIA = -1073741804
Global Const $STATUS_NONEXISTENT_SECTOR = -1073741803
Global Const $STATUS_MORE_PROCESSING_REQUIRED = -1073741802
Global Const $STATUS_NO_MEMORY = -1073741801
Global Const $STATUS_CONFLICTING_ADDRESSES = -1073741800
Global Const $STATUS_NOT_MAPPED_VIEW = -1073741799
Global Const $STATUS_UNABLE_TO_FREE_VM = -1073741798
Global Const $STATUS_UNABLE_TO_DELETE_SECTION = -1073741797
Global Const $STATUS_INVALID_SYSTEM_SERVICE = -1073741796
Global Const $STATUS_ILLEGAL_INSTRUCTION = -1073741795
Global Const $STATUS_INVALID_LOCK_SEQUENCE = -1073741794
Global Const $STATUS_INVALID_VIEW_SIZE = -1073741793
Global Const $STATUS_INVALID_FILE_FOR_SECTION = -1073741792
Global Const $STATUS_ALREADY_COMMITTED = -1073741791
Global Const $STATUS_ACCESS_DENIED = -1073741790
Global Const $STATUS_BUFFER_TOO_SMALL = -1073741789
Global Const $STATUS_OBJECT_TYPE_MISMATCH = -1073741788
Global Const $STATUS_NONCONTINUABLE_EXCEPTION = -1073741787
Global Const $STATUS_INVALID_DISPOSITION = -1073741786
Global Const $STATUS_UNWIND = -1073741785
Global Const $STATUS_BAD_STACK = -1073741784
Global Const $STATUS_INVALID_UNWIND_TARGET = -1073741783
Global Const $STATUS_NOT_LOCKED = -1073741782
Global Const $STATUS_PARITY_ERROR = -1073741781
Global Const $STATUS_UNABLE_TO_DECOMMIT_VM = -1073741780
Global Const $STATUS_NOT_COMMITTED = -1073741779
Global Const $STATUS_INVALID_PORT_ATTRIBUTES = -1073741778
Global Const $STATUS_PORT_MESSAGE_TOO_LONG = -1073741777
Global Const $STATUS_INVALID_PARAMETER_MIX = -1073741776
Global Const $STATUS_INVALID_QUOTA_LOWER = -1073741775
Global Const $STATUS_DISK_CORRUPT_ERROR = -1073741774
Global Const $STATUS_OBJECT_NAME_INVALID = -1073741773
Global Const $STATUS_OBJECT_NAME_NOT_FOUND = -1073741772
Global Const $STATUS_OBJECT_NAME_COLLISION = -1073741771
Global Const $STATUS_PORT_DISCONNECTED = -1073741769
Global Const $STATUS_DEVICE_ALREADY_ATTACHED = -1073741768
Global Const $STATUS_OBJECT_PATH_INVALID = -1073741767
Global Const $STATUS_OBJECT_PATH_NOT_FOUND = -1073741766
Global Const $STATUS_OBJECT_PATH_SYNTAX_BAD = -1073741765
Global Const $STATUS_DATA_OVERRUN = -1073741764
Global Const $STATUS_DATA_LATE_ERROR = -1073741763
Global Const $STATUS_DATA_ERROR = -1073741762
Global Const $STATUS_CRC_ERROR = -1073741761
Global Const $STATUS_SECTION_TOO_BIG = -1073741760
Global Const $STATUS_PORT_CONNECTION_REFUSED = -1073741759
Global Const $STATUS_INVALID_PORT_HANDLE = -1073741758
Global Const $STATUS_SHARING_VIOLATION = -1073741757
Global Const $STATUS_QUOTA_EXCEEDED = -1073741756
Global Const $STATUS_INVALID_PAGE_PROTECTION = -1073741755
Global Const $STATUS_MUTANT_NOT_OWNED = -1073741754
Global Const $STATUS_SEMAPHORE_LIMIT_EXCEEDED = -1073741753
Global Const $STATUS_PORT_ALREADY_SET = -1073741752
Global Const $STATUS_SECTION_NOT_IMAGE = -1073741751
Global Const $STATUS_SUSPEND_COUNT_EXCEEDED = -1073741750
Global Const $STATUS_THREAD_IS_TERMINATING = -1073741749
Global Const $STATUS_BAD_WORKING_SET_LIMIT = -1073741748
Global Const $STATUS_INCOMPATIBLE_FILE_MAP = -1073741747
Global Const $STATUS_SECTION_PROTECTION = -1073741746
Global Const $STATUS_EAS_NOT_SUPPORTED = -1073741745
Global Const $STATUS_EA_TOO_LARGE = -1073741744
Global Const $STATUS_NONEXISTENT_EA_ENTRY = -1073741743
Global Const $STATUS_NO_EAS_ON_FILE = -1073741742
Global Const $STATUS_EA_CORRUPT_ERROR = -1073741741
Global Const $STATUS_FILE_LOCK_CONFLICT = -1073741740
Global Const $STATUS_LOCK_NOT_GRANTED = -1073741739
Global Const $STATUS_DELETE_PENDING = -1073741738
Global Const $STATUS_CTL_FILE_NOT_SUPPORTED = -1073741737
Global Const $STATUS_UNKNOWN_REVISION = -1073741736
Global Const $STATUS_REVISION_MISMATCH = -1073741735
Global Const $STATUS_INVALID_OWNER = -1073741734
Global Const $STATUS_INVALID_PRIMARY_GROUP = -1073741733
Global Const $STATUS_NO_IMPERSONATION_TOKEN = -1073741732
Global Const $STATUS_CANT_DISABLE_MANDATORY = -1073741731
Global Const $STATUS_NO_LOGON_SERVERS = -1073741730
Global Const $STATUS_NO_SUCH_LOGON_SESSION = -1073741729
Global Const $STATUS_NO_SUCH_PRIVILEGE = -1073741728
Global Const $STATUS_PRIVILEGE_NOT_HELD = -1073741727
Global Const $STATUS_INVALID_ACCOUNT_NAME = -1073741726
Global Const $STATUS_USER_EXISTS = -1073741725
Global Const $STATUS_NO_SUCH_USER = -1073741724
Global Const $STATUS_GROUP_EXISTS = -1073741723
Global Const $STATUS_NO_SUCH_GROUP = -1073741722
Global Const $STATUS_MEMBER_IN_GROUP = -1073741721
Global Const $STATUS_MEMBER_NOT_IN_GROUP = -1073741720
Global Const $STATUS_LAST_ADMIN = -1073741719
Global Const $STATUS_WRONG_PASSWORD = -1073741718
Global Const $STATUS_ILL_FORMED_PASSWORD = -1073741717
Global Const $STATUS_PASSWORD_RESTRICTION = -1073741716
Global Const $STATUS_LOGON_FAILURE = -1073741715
Global Const $STATUS_ACCOUNT_RESTRICTION = -1073741714
Global Const $STATUS_INVALID_LOGON_HOURS = -1073741713
Global Const $STATUS_INVALID_WORKSTATION = -1073741712
Global Const $STATUS_PASSWORD_EXPIRED = -1073741711
Global Const $STATUS_ACCOUNT_DISABLED = -1073741710
Global Const $STATUS_NONE_MAPPED = -1073741709
Global Const $STATUS_TOO_MANY_LUIDS_REQUESTED = -1073741708
Global Const $STATUS_LUIDS_EXHAUSTED = -1073741707
Global Const $STATUS_INVALID_SUB_AUTHORITY = -1073741706
Global Const $STATUS_INVALID_ACL = -1073741705
Global Const $STATUS_INVALID_SID = -1073741704
Global Const $STATUS_INVALID_SECURITY_DESCR = -1073741703
Global Const $STATUS_PROCEDURE_NOT_FOUND = -1073741702
Global Const $STATUS_INVALID_IMAGE_FORMAT = -1073741701
Global Const $STATUS_NO_TOKEN = -1073741700
Global Const $STATUS_BAD_INHERITANCE_ACL = -1073741699
Global Const $STATUS_RANGE_NOT_LOCKED = -1073741698
Global Const $STATUS_DISK_FULL = -1073741697
Global Const $STATUS_SERVER_DISABLED = -1073741696
Global Const $STATUS_SERVER_NOT_DISABLED = -1073741695
Global Const $STATUS_TOO_MANY_GUIDS_REQUESTED = -1073741694
Global Const $STATUS_GUIDS_EXHAUSTED = -1073741693
Global Const $STATUS_INVALID_ID_AUTHORITY = -1073741692
Global Const $STATUS_AGENTS_EXHAUSTED = -1073741691
Global Const $STATUS_INVALID_VOLUME_LABEL = -1073741690
Global Const $STATUS_SECTION_NOT_EXTENDED = -1073741689
Global Const $STATUS_NOT_MAPPED_DATA = -1073741688
Global Const $STATUS_RESOURCE_DATA_NOT_FOUND = -1073741687
Global Const $STATUS_RESOURCE_TYPE_NOT_FOUND = -1073741686
Global Const $STATUS_RESOURCE_NAME_NOT_FOUND = -1073741685
Global Const $STATUS_ARRAY_BOUNDS_EXCEEDED = -1073741684
Global Const $STATUS_FLOAT_DENORMAL_OPERAND = -1073741683
Global Const $STATUS_FLOAT_DIVIDE_BY_ZERO = -1073741682
Global Const $STATUS_FLOAT_INEXACT_RESULT = -1073741681
Global Const $STATUS_FLOAT_INVALID_OPERATION = -1073741680
Global Const $STATUS_FLOAT_OVERFLOW = -1073741679
Global Const $STATUS_FLOAT_STACK_CHECK = -1073741678
Global Const $STATUS_FLOAT_UNDERFLOW = -1073741677
Global Const $STATUS_INTEGER_DIVIDE_BY_ZERO = -1073741676
Global Const $STATUS_INTEGER_OVERFLOW = -1073741675
Global Const $STATUS_PRIVILEGED_INSTRUCTION = -1073741674
Global Const $STATUS_TOO_MANY_PAGING_FILES = -1073741673
Global Const $STATUS_FILE_INVALID = -1073741672
Global Const $STATUS_ALLOTTED_SPACE_EXCEEDED = -1073741671
Global Const $STATUS_INSUFFICIENT_RESOURCES = -1073741670
Global Const $STATUS_DFS_EXIT_PATH_FOUND = -1073741669
Global Const $STATUS_DEVICE_DATA_ERROR = -1073741668
Global Const $STATUS_DEVICE_NOT_CONNECTED = -1073741667
Global Const $STATUS_FREE_VM_NOT_AT_BASE = -1073741665
Global Const $STATUS_MEMORY_NOT_ALLOCATED = -1073741664
Global Const $STATUS_WORKING_SET_QUOTA = -1073741663
Global Const $STATUS_MEDIA_WRITE_PROTECTED = -1073741662
Global Const $STATUS_DEVICE_NOT_READY = -1073741661
Global Const $STATUS_INVALID_GROUP_ATTRIBUTES = -1073741660
Global Const $STATUS_BAD_IMPERSONATION_LEVEL = -1073741659
Global Const $STATUS_CANT_OPEN_ANONYMOUS = -1073741658
Global Const $STATUS_BAD_VALIDATION_CLASS = -1073741657
Global Const $STATUS_BAD_TOKEN_TYPE = -1073741656
Global Const $STATUS_BAD_MASTER_BOOT_RECORD = -1073741655
Global Const $STATUS_INSTRUCTION_MISALIGNMENT = -1073741654
Global Const $STATUS_INSTANCE_NOT_AVAILABLE = -1073741653
Global Const $STATUS_PIPE_NOT_AVAILABLE = -1073741652
Global Const $STATUS_INVALID_PIPE_STATE = -1073741651
Global Const $STATUS_PIPE_BUSY = -1073741650
Global Const $STATUS_ILLEGAL_FUNCTION = -1073741649
Global Const $STATUS_PIPE_DISCONNECTED = -1073741648
Global Const $STATUS_PIPE_CLOSING = -1073741647
Global Const $STATUS_PIPE_CONNECTED = -1073741646
Global Const $STATUS_PIPE_LISTENING = -1073741645
Global Const $STATUS_INVALID_READ_MODE = -1073741644
Global Const $STATUS_IO_TIMEOUT = -1073741643
Global Const $STATUS_FILE_FORCED_CLOSED = -1073741642
Global Const $STATUS_PROFILING_NOT_STARTED = -1073741641
Global Const $STATUS_PROFILING_NOT_STOPPED = -1073741640
Global Const $STATUS_COULD_NOT_INTERPRET = -1073741639
Global Const $STATUS_FILE_IS_A_DIRECTORY = -1073741638
Global Const $STATUS_NOT_SUPPORTED = -1073741637
Global Const $STATUS_REMOTE_NOT_LISTENING = -1073741636
Global Const $STATUS_DUPLICATE_NAME = -1073741635
Global Const $STATUS_BAD_NETWORK_PATH = -1073741634
Global Const $STATUS_NETWORK_BUSY = -1073741633
Global Const $STATUS_DEVICE_DOES_NOT_EXIST = -1073741632
Global Const $STATUS_TOO_MANY_COMMANDS = -1073741631
Global Const $STATUS_ADAPTER_HARDWARE_ERROR = -1073741630
Global Const $STATUS_INVALID_NETWORK_RESPONSE = -1073741629
Global Const $STATUS_UNEXPECTED_NETWORK_ERROR = -1073741628
Global Const $STATUS_BAD_REMOTE_ADAPTER = -1073741627
Global Const $STATUS_PRINT_QUEUE_FULL = -1073741626
Global Const $STATUS_NO_SPOOL_SPACE = -1073741625
Global Const $STATUS_PRINT_CANCELLED = -1073741624
Global Const $STATUS_NETWORK_NAME_DELETED = -1073741623
Global Const $STATUS_NETWORK_ACCESS_DENIED = -1073741622
Global Const $STATUS_BAD_DEVICE_TYPE = -1073741621
Global Const $STATUS_BAD_NETWORK_NAME = -1073741620
Global Const $STATUS_TOO_MANY_NAMES = -1073741619
Global Const $STATUS_TOO_MANY_SESSIONS = -1073741618
Global Const $STATUS_SHARING_PAUSED = -1073741617
Global Const $STATUS_REQUEST_NOT_ACCEPTED = -1073741616
Global Const $STATUS_REDIRECTOR_PAUSED = -1073741615
Global Const $STATUS_NET_WRITE_FAULT = -1073741614
Global Const $STATUS_PROFILING_AT_LIMIT = -1073741613
Global Const $STATUS_NOT_SAME_DEVICE = -1073741612
Global Const $STATUS_FILE_RENAMED = -1073741611
Global Const $STATUS_VIRTUAL_CIRCUIT_CLOSED = -1073741610
Global Const $STATUS_NO_SECURITY_ON_OBJECT = -1073741609
Global Const $STATUS_CANT_WAIT = -1073741608
Global Const $STATUS_PIPE_EMPTY = -1073741607
Global Const $STATUS_CANT_ACCESS_DOMAIN_INFO = -1073741606
Global Const $STATUS_CANT_TERMINATE_SELF = -1073741605
Global Const $STATUS_INVALID_SERVER_STATE = -1073741604
Global Const $STATUS_INVALID_DOMAIN_STATE = -1073741603
Global Const $STATUS_INVALID_DOMAIN_ROLE = -1073741602
Global Const $STATUS_NO_SUCH_DOMAIN = -1073741601
Global Const $STATUS_DOMAIN_EXISTS = -1073741600
Global Const $STATUS_DOMAIN_LIMIT_EXCEEDED = -1073741599
Global Const $STATUS_OPLOCK_NOT_GRANTED = -1073741598
Global Const $STATUS_INVALID_OPLOCK_PROTOCOL = -1073741597
Global Const $STATUS_INTERNAL_DB_CORRUPTION = -1073741596
Global Const $STATUS_INTERNAL_ERROR = -1073741595
Global Const $STATUS_GENERIC_NOT_MAPPED = -1073741594
Global Const $STATUS_BAD_DESCRIPTOR_FORMAT = -1073741593
Global Const $STATUS_INVALID_USER_BUFFER = -1073741592
Global Const $STATUS_UNEXPECTED_IO_ERROR = -1073741591
Global Const $STATUS_UNEXPECTED_MM_CREATE_ERR = -1073741590
Global Const $STATUS_UNEXPECTED_MM_MAP_ERROR = -1073741589
Global Const $STATUS_UNEXPECTED_MM_EXTEND_ERR = -1073741588
Global Const $STATUS_NOT_LOGON_PROCESS = -1073741587
Global Const $STATUS_LOGON_SESSION_EXISTS = -1073741586
Global Const $STATUS_INVALID_PARAMETER_1 = -1073741585
Global Const $STATUS_INVALID_PARAMETER_2 = -1073741584
Global Const $STATUS_INVALID_PARAMETER_3 = -1073741583
Global Const $STATUS_INVALID_PARAMETER_4 = -1073741582
Global Const $STATUS_INVALID_PARAMETER_5 = -1073741581
Global Const $STATUS_INVALID_PARAMETER_6 = -1073741580
Global Const $STATUS_INVALID_PARAMETER_7 = -1073741579
Global Const $STATUS_INVALID_PARAMETER_8 = -1073741578
Global Const $STATUS_INVALID_PARAMETER_9 = -1073741577
Global Const $STATUS_INVALID_PARAMETER_10 = -1073741576
Global Const $STATUS_INVALID_PARAMETER_11 = -1073741575
Global Const $STATUS_INVALID_PARAMETER_12 = -1073741574
Global Const $STATUS_REDIRECTOR_NOT_STARTED = -1073741573
Global Const $STATUS_REDIRECTOR_STARTED = -1073741572
Global Const $STATUS_STACK_OVERFLOW = -1073741571
Global Const $STATUS_NO_SUCH_PACKAGE = -1073741570
Global Const $STATUS_BAD_FUNCTION_TABLE = -1073741569
Global Const $STATUS_VARIABLE_NOT_FOUND = -1073741568
Global Const $STATUS_DIRECTORY_NOT_EMPTY = -1073741567
Global Const $STATUS_FILE_CORRUPT_ERROR = -1073741566
Global Const $STATUS_NOT_A_DIRECTORY = -1073741565
Global Const $STATUS_BAD_LOGON_SESSION_STATE = -1073741564
Global Const $STATUS_LOGON_SESSION_COLLISION = -1073741563
Global Const $STATUS_NAME_TOO_LONG = -1073741562
Global Const $STATUS_FILES_OPEN = -1073741561
Global Const $STATUS_CONNECTION_IN_USE = -1073741560
Global Const $STATUS_MESSAGE_NOT_FOUND = -1073741559
Global Const $STATUS_PROCESS_IS_TERMINATING = -1073741558
Global Const $STATUS_INVALID_LOGON_TYPE = -1073741557
Global Const $STATUS_NO_GUID_TRANSLATION = -1073741556
Global Const $STATUS_CANNOT_IMPERSONATE = -1073741555
Global Const $STATUS_IMAGE_ALREADY_LOADED = -1073741554
Global Const $STATUS_NO_LDT = -1073741545
Global Const $STATUS_INVALID_LDT_SIZE = -1073741544
Global Const $STATUS_INVALID_LDT_OFFSET = -1073741543
Global Const $STATUS_INVALID_LDT_DESCRIPTOR = -1073741542
Global Const $STATUS_INVALID_IMAGE_NE_FORMAT = -1073741541
Global Const $STATUS_RXACT_INVALID_STATE = -1073741540
Global Const $STATUS_RXACT_COMMIT_FAILURE = -1073741539
Global Const $STATUS_MAPPED_FILE_SIZE_ZERO = -1073741538
Global Const $STATUS_TOO_MANY_OPENED_FILES = -1073741537
Global Const $STATUS_CANCELLED = -1073741536
Global Const $STATUS_CANNOT_DELETE = -1073741535
Global Const $STATUS_INVALID_COMPUTER_NAME = -1073741534
Global Const $STATUS_FILE_DELETED = -1073741533
Global Const $STATUS_SPECIAL_ACCOUNT = -1073741532
Global Const $STATUS_SPECIAL_GROUP = -1073741531
Global Const $STATUS_SPECIAL_USER = -1073741530
Global Const $STATUS_MEMBERS_PRIMARY_GROUP = -1073741529
Global Const $STATUS_FILE_CLOSED = -1073741528
Global Const $STATUS_TOO_MANY_THREADS = -1073741527
Global Const $STATUS_THREAD_NOT_IN_PROCESS = -1073741526
Global Const $STATUS_TOKEN_ALREADY_IN_USE = -1073741525
Global Const $STATUS_PAGEFILE_QUOTA_EXCEEDED = -1073741524
Global Const $STATUS_COMMITMENT_LIMIT = -1073741523
Global Const $STATUS_INVALID_IMAGE_LE_FORMAT = -1073741522
Global Const $STATUS_INVALID_IMAGE_NOT_MZ = -1073741521
Global Const $STATUS_INVALID_IMAGE_PROTECT = -1073741520
Global Const $STATUS_INVALID_IMAGE_WIN_16 = -1073741519
Global Const $STATUS_LOGON_SERVER_CONFLICT = -1073741518
Global Const $STATUS_TIME_DIFFERENCE_AT_DC = -1073741517
Global Const $STATUS_SYNCHRONIZATION_REQUIRED = -1073741516
Global Const $STATUS_DLL_NOT_FOUND = -1073741515
Global Const $STATUS_OPEN_FAILED = -1073741514
Global Const $STATUS_IO_PRIVILEGE_FAILED = -1073741513
Global Const $STATUS_ORDINAL_NOT_FOUND = -1073741512
Global Const $STATUS_ENTRYPOINT_NOT_FOUND = -1073741511
Global Const $STATUS_CONTROL_C_EXIT = -1073741510
Global Const $STATUS_LOCAL_DISCONNECT = -1073741509
Global Const $STATUS_REMOTE_DISCONNECT = -1073741508
Global Const $STATUS_REMOTE_RESOURCES = -1073741507
Global Const $STATUS_LINK_FAILED = -1073741506
Global Const $STATUS_LINK_TIMEOUT = -1073741505
Global Const $STATUS_INVALID_CONNECTION = -1073741504
Global Const $STATUS_INVALID_ADDRESS = -1073741503
Global Const $STATUS_DLL_INIT_FAILED = -1073741502
Global Const $STATUS_MISSING_SYSTEMFILE = -1073741501
Global Const $STATUS_UNHANDLED_EXCEPTION = -1073741500
Global Const $STATUS_APP_INIT_FAILURE = -1073741499
Global Const $STATUS_PAGEFILE_CREATE_FAILED = -1073741498
Global Const $STATUS_NO_PAGEFILE = -1073741497
Global Const $STATUS_INVALID_LEVEL = -1073741496
Global Const $STATUS_WRONG_PASSWORD_CORE = -1073741495
Global Const $STATUS_ILLEGAL_FLOAT_CONTEXT = -1073741494
Global Const $STATUS_PIPE_BROKEN = -1073741493
Global Const $STATUS_REGISTRY_CORRUPT = -1073741492
Global Const $STATUS_REGISTRY_IO_FAILED = -1073741491
Global Const $STATUS_NO_EVENT_PAIR = -1073741490
Global Const $STATUS_UNRECOGNIZED_VOLUME = -1073741489
Global Const $STATUS_SERIAL_NO_DEVICE_INITED = -1073741488
Global Const $STATUS_NO_SUCH_ALIAS = -1073741487
Global Const $STATUS_MEMBER_NOT_IN_ALIAS = -1073741486
Global Const $STATUS_MEMBER_IN_ALIAS = -1073741485
Global Const $STATUS_ALIAS_EXISTS = -1073741484
Global Const $STATUS_LOGON_NOT_GRANTED = -1073741483
Global Const $STATUS_TOO_MANY_SECRETS = -1073741482
Global Const $STATUS_SECRET_TOO_LONG = -1073741481
Global Const $STATUS_INTERNAL_DB_ERROR = -1073741480
Global Const $STATUS_FULLSCREEN_MODE = -1073741479
Global Const $STATUS_TOO_MANY_CONTEXT_IDS = -1073741478
Global Const $STATUS_LOGON_TYPE_NOT_GRANTED = -1073741477
Global Const $STATUS_NOT_REGISTRY_FILE = -1073741476
Global Const $STATUS_NT_CROSS_ENCRYPTION_REQUIRED = -1073741475
Global Const $STATUS_DOMAIN_CTRLR_CONFIG_ERROR = -1073741474
Global Const $STATUS_FT_MISSING_MEMBER = -1073741473
Global Const $STATUS_ILL_FORMED_SERVICE_ENTRY = -1073741472
Global Const $STATUS_ILLEGAL_CHARACTER = -1073741471
Global Const $STATUS_UNMAPPABLE_CHARACTER = -1073741470
Global Const $STATUS_UNDEFINED_CHARACTER = -1073741469
Global Const $STATUS_FLOPPY_VOLUME = -1073741468
Global Const $STATUS_FLOPPY_ID_MARK_NOT_FOUND = -1073741467
Global Const $STATUS_FLOPPY_WRONG_CYLINDER = -1073741466
Global Const $STATUS_FLOPPY_UNKNOWN_ERROR = -1073741465
Global Const $STATUS_FLOPPY_BAD_REGISTERS = -1073741464
Global Const $STATUS_DISK_RECALIBRATE_FAILED = -1073741463
Global Const $STATUS_DISK_OPERATION_FAILED = -1073741462
Global Const $STATUS_DISK_RESET_FAILED = -1073741461
Global Const $STATUS_SHARED_IRQ_BUSY = -1073741460
Global Const $STATUS_FT_ORPHANING = -1073741459
Global Const $STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT = -1073741458
Global Const $STATUS_PARTITION_FAILURE = -1073741454
Global Const $STATUS_INVALID_BLOCK_LENGTH = -1073741453
Global Const $STATUS_DEVICE_NOT_PARTITIONED = -1073741452
Global Const $STATUS_UNABLE_TO_LOCK_MEDIA = -1073741451
Global Const $STATUS_UNABLE_TO_UNLOAD_MEDIA = -1073741450
Global Const $STATUS_EOM_OVERFLOW = -1073741449
Global Const $STATUS_NO_MEDIA = -1073741448
Global Const $STATUS_NO_SUCH_MEMBER = -1073741446
Global Const $STATUS_INVALID_MEMBER = -1073741445
Global Const $STATUS_KEY_DELETED = -1073741444
Global Const $STATUS_NO_LOG_SPACE = -1073741443
Global Const $STATUS_TOO_MANY_SIDS = -1073741442
Global Const $STATUS_LM_CROSS_ENCRYPTION_REQUIRED = -1073741441
Global Const $STATUS_KEY_HAS_CHILDREN = -1073741440
Global Const $STATUS_CHILD_MUST_BE_VOLATILE = -1073741439
Global Const $STATUS_DEVICE_CONFIGURATION_ERROR = -1073741438
Global Const $STATUS_DRIVER_INTERNAL_ERROR = -1073741437
Global Const $STATUS_INVALID_DEVICE_STATE = -1073741436
Global Const $STATUS_IO_DEVICE_ERROR = -1073741435
Global Const $STATUS_DEVICE_PROTOCOL_ERROR = -1073741434
Global Const $STATUS_BACKUP_CONTROLLER = -1073741433
Global Const $STATUS_LOG_FILE_FULL = -1073741432
Global Const $STATUS_TOO_LATE = -1073741431
Global Const $STATUS_NO_TRUST_LSA_SECRET = -1073741430
Global Const $STATUS_NO_TRUST_SAM_ACCOUNT = -1073741429
Global Const $STATUS_TRUSTED_DOMAIN_FAILURE = -1073741428
Global Const $STATUS_TRUSTED_RELATIONSHIP_FAILURE = -1073741427
Global Const $STATUS_EVENTLOG_FILE_CORRUPT = -1073741426
Global Const $STATUS_EVENTLOG_CANT_START = -1073741425
Global Const $STATUS_TRUST_FAILURE = -1073741424
Global Const $STATUS_MUTANT_LIMIT_EXCEEDED = -1073741423
Global Const $STATUS_NETLOGON_NOT_STARTED = -1073741422
Global Const $STATUS_ACCOUNT_EXPIRED = -1073741421
Global Const $STATUS_POSSIBLE_DEADLOCK = -1073741420
Global Const $STATUS_NETWORK_CREDENTIAL_CONFLICT = -1073741419
Global Const $STATUS_REMOTE_SESSION_LIMIT = -1073741418
Global Const $STATUS_EVENTLOG_FILE_CHANGED = -1073741417
Global Const $STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = -1073741416
Global Const $STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT = -1073741415
Global Const $STATUS_NOLOGON_SERVER_TRUST_ACCOUNT = -1073741414
Global Const $STATUS_DOMAIN_TRUST_INCONSISTENT = -1073741413
Global Const $STATUS_FS_DRIVER_REQUIRED = -1073741412
Global Const $STATUS_IMAGE_ALREADY_LOADED_AS_DLL = -1073741411
Global Const $STATUS_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = -1073741410
Global Const $STATUS_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = -1073741409
Global Const $STATUS_SECURITY_STREAM_IS_INCONSISTENT = -1073741408
Global Const $STATUS_INVALID_LOCK_RANGE = -1073741407
Global Const $STATUS_INVALID_ACE_CONDITION = -1073741406
Global Const $STATUS_IMAGE_SUBSYSTEM_NOT_PRESENT = -1073741405
Global Const $STATUS_NOTIFICATION_GUID_ALREADY_DEFINED = -1073741404
Global Const $STATUS_NETWORK_OPEN_RESTRICTION = -1073741311
Global Const $STATUS_NO_USER_SESSION_KEY = -1073741310
Global Const $STATUS_USER_SESSION_DELETED = -1073741309
Global Const $STATUS_RESOURCE_LANG_NOT_FOUND = -1073741308
Global Const $STATUS_INSUFF_SERVER_RESOURCES = -1073741307
Global Const $STATUS_INVALID_BUFFER_SIZE = -1073741306
Global Const $STATUS_INVALID_ADDRESS_COMPONENT = -1073741305
Global Const $STATUS_INVALID_ADDRESS_WILDCARD = -1073741304
Global Const $STATUS_TOO_MANY_ADDRESSES = -1073741303
Global Const $STATUS_ADDRESS_ALREADY_EXISTS = -1073741302
Global Const $STATUS_ADDRESS_CLOSED = -1073741301
Global Const $STATUS_CONNECTION_DISCONNECTED = -1073741300
Global Const $STATUS_CONNECTION_RESET = -1073741299
Global Const $STATUS_TOO_MANY_NODES = -1073741298
Global Const $STATUS_TRANSACTION_ABORTED = -1073741297
Global Const $STATUS_TRANSACTION_TIMED_OUT = -1073741296
Global Const $STATUS_TRANSACTION_NO_RELEASE = -1073741295
Global Const $STATUS_TRANSACTION_NO_MATCH = -1073741294
Global Const $STATUS_TRANSACTION_RESPONDED = -1073741293
Global Const $STATUS_TRANSACTION_INVALID_ID = -1073741292
Global Const $STATUS_TRANSACTION_INVALID_TYPE = -1073741291
Global Const $STATUS_NOT_SERVER_SESSION = -1073741290
Global Const $STATUS_NOT_CLIENT_SESSION = -1073741289
Global Const $STATUS_CANNOT_LOAD_REGISTRY_FILE = -1073741288
Global Const $STATUS_DEBUG_ATTACH_FAILED = -1073741287
Global Const $STATUS_SYSTEM_PROCESS_TERMINATED = -1073741286
Global Const $STATUS_DATA_NOT_ACCEPTED = -1073741285
Global Const $STATUS_NO_BROWSER_SERVERS_FOUND = -1073741284
Global Const $STATUS_VDM_HARD_ERROR = -1073741283
Global Const $STATUS_DRIVER_CANCEL_TIMEOUT = -1073741282
Global Const $STATUS_REPLY_MESSAGE_MISMATCH = -1073741281
Global Const $STATUS_MAPPED_ALIGNMENT = -1073741280
Global Const $STATUS_IMAGE_CHECKSUM_MISMATCH = -1073741279
Global Const $STATUS_LOST_WRITEBEHIND_DATA = -1073741278
Global Const $STATUS_CLIENT_SERVER_PARAMETERS_INVALID = -1073741277
Global Const $STATUS_PASSWORD_MUST_CHANGE = -1073741276
Global Const $STATUS_NOT_FOUND = -1073741275
Global Const $STATUS_NOT_TINY_STREAM = -1073741274
Global Const $STATUS_RECOVERY_FAILURE = -1073741273
Global Const $STATUS_STACK_OVERFLOW_READ = -1073741272
Global Const $STATUS_FAIL_CHECK = -1073741271
Global Const $STATUS_DUPLICATE_OBJECTID = -1073741270
Global Const $STATUS_OBJECTID_EXISTS = -1073741269
Global Const $STATUS_CONVERT_TO_LARGE = -1073741268
Global Const $STATUS_RETRY = -1073741267
Global Const $STATUS_FOUND_OUT_OF_SCOPE = -1073741266
Global Const $STATUS_ALLOCATE_BUCKET = -1073741265
Global Const $STATUS_PROPSET_NOT_FOUND = -1073741264
Global Const $STATUS_MARSHALL_OVERFLOW = -1073741263
Global Const $STATUS_INVALID_VARIANT = -1073741262
Global Const $STATUS_DOMAIN_CONTROLLER_NOT_FOUND = -1073741261
Global Const $STATUS_ACCOUNT_LOCKED_OUT = -1073741260
Global Const $STATUS_HANDLE_NOT_CLOSABLE = -1073741259
Global Const $STATUS_CONNECTION_REFUSED = -1073741258
Global Const $STATUS_GRACEFUL_DISCONNECT = -1073741257
Global Const $STATUS_ADDRESS_ALREADY_ASSOCIATED = -1073741256
Global Const $STATUS_ADDRESS_NOT_ASSOCIATED = -1073741255
Global Const $STATUS_CONNECTION_INVALID = -1073741254
Global Const $STATUS_CONNECTION_ACTIVE = -1073741253
Global Const $STATUS_NETWORK_UNREACHABLE = -1073741252
Global Const $STATUS_HOST_UNREACHABLE = -1073741251
Global Const $STATUS_PROTOCOL_UNREACHABLE = -1073741250
Global Const $STATUS_PORT_UNREACHABLE = -1073741249
Global Const $STATUS_REQUEST_ABORTED = -1073741248
Global Const $STATUS_CONNECTION_ABORTED = -1073741247
Global Const $STATUS_BAD_COMPRESSION_BUFFER = -1073741246
Global Const $STATUS_USER_MAPPED_FILE = -1073741245
Global Const $STATUS_AUDIT_FAILED = -1073741244
Global Const $STATUS_TIMER_RESOLUTION_NOT_SET = -1073741243
Global Const $STATUS_CONNECTION_COUNT_LIMIT = -1073741242
Global Const $STATUS_LOGIN_TIME_RESTRICTION = -1073741241
Global Const $STATUS_LOGIN_WKSTA_RESTRICTION = -1073741240
Global Const $STATUS_IMAGE_MP_UP_MISMATCH = -1073741239
Global Const $STATUS_INSUFFICIENT_LOGON_INFO = -1073741232
Global Const $STATUS_BAD_DLL_ENTRYPOINT = -1073741231
Global Const $STATUS_BAD_SERVICE_ENTRYPOINT = -1073741230
Global Const $STATUS_LPC_REPLY_LOST = -1073741229
Global Const $STATUS_IP_ADDRESS_CONFLICT1 = -1073741228
Global Const $STATUS_IP_ADDRESS_CONFLICT2 = -1073741227
Global Const $STATUS_REGISTRY_QUOTA_LIMIT = -1073741226
Global Const $STATUS_PATH_NOT_COVERED = -1073741225
Global Const $STATUS_NO_CALLBACK_ACTIVE = -1073741224
Global Const $STATUS_LICENSE_QUOTA_EXCEEDED = -1073741223
Global Const $STATUS_PWD_TOO_SHORT = -1073741222
Global Const $STATUS_PWD_TOO_RECENT = -1073741221
Global Const $STATUS_PWD_HISTORY_CONFLICT = -1073741220
Global Const $STATUS_PLUGPLAY_NO_DEVICE = -1073741218
Global Const $STATUS_UNSUPPORTED_COMPRESSION = -1073741217
Global Const $STATUS_INVALID_HW_PROFILE = -1073741216
Global Const $STATUS_INVALID_PLUGPLAY_DEVICE_PATH = -1073741215
Global Const $STATUS_DRIVER_ORDINAL_NOT_FOUND = -1073741214
Global Const $STATUS_DRIVER_ENTRYPOINT_NOT_FOUND = -1073741213
Global Const $STATUS_RESOURCE_NOT_OWNED = -1073741212
Global Const $STATUS_TOO_MANY_LINKS = -1073741211
Global Const $STATUS_QUOTA_LIST_INCONSISTENT = -1073741210
Global Const $STATUS_FILE_IS_OFFLINE = -1073741209
Global Const $STATUS_EVALUATION_EXPIRATION = -1073741208
Global Const $STATUS_ILLEGAL_DLL_RELOCATION = -1073741207
Global Const $STATUS_LICENSE_VIOLATION = -1073741206
Global Const $STATUS_DLL_INIT_FAILED_LOGOFF = -1073741205
Global Const $STATUS_DRIVER_UNABLE_TO_LOAD = -1073741204
Global Const $STATUS_DFS_UNAVAILABLE = -1073741203
Global Const $STATUS_VOLUME_DISMOUNTED = -1073741202
Global Const $STATUS_WX86_INTERNAL_ERROR = -1073741201
Global Const $STATUS_WX86_FLOAT_STACK_CHECK = -1073741200
Global Const $STATUS_VALIDATE_CONTINUE = -1073741199
Global Const $STATUS_NO_MATCH = -1073741198
Global Const $STATUS_NO_MORE_MATCHES = -1073741197
Global Const $STATUS_NOT_A_REPARSE_POINT = -1073741195
Global Const $STATUS_IO_REPARSE_TAG_INVALID = -1073741194
Global Const $STATUS_IO_REPARSE_TAG_MISMATCH = -1073741193
Global Const $STATUS_IO_REPARSE_DATA_INVALID = -1073741192
Global Const $STATUS_IO_REPARSE_TAG_NOT_HANDLED = -1073741191
Global Const $STATUS_REPARSE_POINT_NOT_RESOLVED = -1073741184
Global Const $STATUS_DIRECTORY_IS_A_REPARSE_POINT = -1073741183
Global Const $STATUS_RANGE_LIST_CONFLICT = -1073741182
Global Const $STATUS_SOURCE_ELEMENT_EMPTY = -1073741181
Global Const $STATUS_DESTINATION_ELEMENT_FULL = -1073741180
Global Const $STATUS_ILLEGAL_ELEMENT_ADDRESS = -1073741179
Global Const $STATUS_MAGAZINE_NOT_PRESENT = -1073741178
Global Const $STATUS_REINITIALIZATION_NEEDED = -1073741177
Global Const $STATUS_ENCRYPTION_FAILED = -1073741174
Global Const $STATUS_DECRYPTION_FAILED = -1073741173
Global Const $STATUS_RANGE_NOT_FOUND = -1073741172
Global Const $STATUS_NO_RECOVERY_POLICY = -1073741171
Global Const $STATUS_NO_EFS = -1073741170
Global Const $STATUS_WRONG_EFS = -1073741169
Global Const $STATUS_NO_USER_KEYS = -1073741168
Global Const $STATUS_FILE_NOT_ENCRYPTED = -1073741167
Global Const $STATUS_NOT_EXPORT_FORMAT = -1073741166
Global Const $STATUS_FILE_ENCRYPTED = -1073741165
Global Const $STATUS_WMI_GUID_NOT_FOUND = -1073741163
Global Const $STATUS_WMI_INSTANCE_NOT_FOUND = -1073741162
Global Const $STATUS_WMI_ITEMID_NOT_FOUND = -1073741161
Global Const $STATUS_WMI_TRY_AGAIN = -1073741160
Global Const $STATUS_SHARED_POLICY = -1073741159
Global Const $STATUS_POLICY_OBJECT_NOT_FOUND = -1073741158
Global Const $STATUS_POLICY_ONLY_IN_DS = -1073741157
Global Const $STATUS_VOLUME_NOT_UPGRADED = -1073741156
Global Const $STATUS_REMOTE_STORAGE_NOT_ACTIVE = -1073741155
Global Const $STATUS_REMOTE_STORAGE_MEDIA_ERROR = -1073741154
Global Const $STATUS_NO_TRACKING_SERVICE = -1073741153
Global Const $STATUS_SERVER_SID_MISMATCH = -1073741152
Global Const $STATUS_DS_NO_ATTRIBUTE_OR_VALUE = -1073741151
Global Const $STATUS_DS_INVALID_ATTRIBUTE_SYNTAX = -1073741150
Global Const $STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED = -1073741149
Global Const $STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS = -1073741148
Global Const $STATUS_DS_BUSY = -1073741147
Global Const $STATUS_DS_UNAVAILABLE = -1073741146
Global Const $STATUS_DS_NO_RIDS_ALLOCATED = -1073741145
Global Const $STATUS_DS_NO_MORE_RIDS = -1073741144
Global Const $STATUS_DS_INCORRECT_ROLE_OWNER = -1073741143
Global Const $STATUS_DS_RIDMGR_INIT_ERROR = -1073741142
Global Const $STATUS_DS_OBJ_CLASS_VIOLATION = -1073741141
Global Const $STATUS_DS_CANT_ON_NON_LEAF = -1073741140
Global Const $STATUS_DS_CANT_ON_RDN = -1073741139
Global Const $STATUS_DS_CANT_MOD_OBJ_CLASS = -1073741138
Global Const $STATUS_DS_CROSS_DOM_MOVE_FAILED = -1073741137
Global Const $STATUS_DS_GC_NOT_AVAILABLE = -1073741136
Global Const $STATUS_DIRECTORY_SERVICE_REQUIRED = -1073741135
Global Const $STATUS_REPARSE_ATTRIBUTE_CONFLICT = -1073741134
Global Const $STATUS_CANT_ENABLE_DENY_ONLY = -1073741133
Global Const $STATUS_FLOAT_MULTIPLE_FAULTS = -1073741132
Global Const $STATUS_FLOAT_MULTIPLE_TRAPS = -1073741131
Global Const $STATUS_DEVICE_REMOVED = -1073741130
Global Const $STATUS_JOURNAL_DELETE_IN_PROGRESS = -1073741129
Global Const $STATUS_JOURNAL_NOT_ACTIVE = -1073741128
Global Const $STATUS_NOINTERFACE = -1073741127
Global Const $STATUS_DS_ADMIN_LIMIT_EXCEEDED = -1073741119
Global Const $STATUS_DRIVER_FAILED_SLEEP = -1073741118
Global Const $STATUS_MUTUAL_AUTHENTICATION_FAILED = -1073741117
Global Const $STATUS_CORRUPT_SYSTEM_FILE = -1073741116
Global Const $STATUS_DATATYPE_MISALIGNMENT_ERROR = -1073741115
Global Const $STATUS_WMI_READ_ONLY = -1073741114
Global Const $STATUS_WMI_SET_FAILURE = -1073741113
Global Const $STATUS_COMMITMENT_MINIMUM = -1073741112
Global Const $STATUS_REG_NAT_CONSUMPTION = -1073741111
Global Const $STATUS_TRANSPORT_FULL = -1073741110
Global Const $STATUS_DS_SAM_INIT_FAILURE = -1073741109
Global Const $STATUS_ONLY_IF_CONNECTED = -1073741108
Global Const $STATUS_DS_SENSITIVE_GROUP_VIOLATION = -1073741107
Global Const $STATUS_PNP_RESTART_ENUMERATION = -1073741106
Global Const $STATUS_JOURNAL_ENTRY_DELETED = -1073741105
Global Const $STATUS_DS_CANT_MOD_PRIMARYGROUPID = -1073741104
Global Const $STATUS_SYSTEM_IMAGE_BAD_SIGNATURE = -1073741103
Global Const $STATUS_PNP_REBOOT_REQUIRED = -1073741102
Global Const $STATUS_POWER_STATE_INVALID = -1073741101
Global Const $STATUS_DS_INVALID_GROUP_TYPE = -1073741100
Global Const $STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = -1073741099
Global Const $STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = -1073741098
Global Const $STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = -1073741097
Global Const $STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = -1073741096
Global Const $STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = -1073741095
Global Const $STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = -1073741094
Global Const $STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = -1073741093
Global Const $STATUS_DS_HAVE_PRIMARY_MEMBERS = -1073741092
Global Const $STATUS_WMI_NOT_SUPPORTED = -1073741091
Global Const $STATUS_INSUFFICIENT_POWER = -1073741090
Global Const $STATUS_SAM_NEED_BOOTKEY_PASSWORD = -1073741089
Global Const $STATUS_SAM_NEED_BOOTKEY_FLOPPY = -1073741088
Global Const $STATUS_DS_CANT_START = -1073741087
Global Const $STATUS_DS_INIT_FAILURE = -1073741086
Global Const $STATUS_SAM_INIT_FAILURE = -1073741085
Global Const $STATUS_DS_GC_REQUIRED = -1073741084
Global Const $STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = -1073741083
Global Const $STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS = -1073741082
Global Const $STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = -1073741081
Global Const $STATUS_CURRENT_DOMAIN_NOT_ALLOWED = -1073741079
Global Const $STATUS_CANNOT_MAKE = -1073741078
Global Const $STATUS_SYSTEM_SHUTDOWN = -1073741077
Global Const $STATUS_DS_INIT_FAILURE_CONSOLE = -1073741076
Global Const $STATUS_DS_SAM_INIT_FAILURE_CONSOLE = -1073741075
Global Const $STATUS_UNFINISHED_CONTEXT_DELETED = -1073741074
Global Const $STATUS_NO_TGT_REPLY = -1073741073
Global Const $STATUS_OBJECTID_NOT_FOUND = -1073741072
Global Const $STATUS_NO_IP_ADDRESSES = -1073741071
Global Const $STATUS_WRONG_CREDENTIAL_HANDLE = -1073741070
Global Const $STATUS_CRYPTO_SYSTEM_INVALID = -1073741069
Global Const $STATUS_MAX_REFERRALS_EXCEEDED = -1073741068
Global Const $STATUS_MUST_BE_KDC = -1073741067
Global Const $STATUS_STRONG_CRYPTO_NOT_SUPPORTED = -1073741066
Global Const $STATUS_TOO_MANY_PRINCIPALS = -1073741065
Global Const $STATUS_NO_PA_DATA = -1073741064
Global Const $STATUS_PKINIT_NAME_MISMATCH = -1073741063
Global Const $STATUS_SMARTCARD_LOGON_REQUIRED = -1073741062
Global Const $STATUS_KDC_INVALID_REQUEST = -1073741061
Global Const $STATUS_KDC_UNABLE_TO_REFER = -1073741060
Global Const $STATUS_KDC_UNKNOWN_ETYPE = -1073741059
Global Const $STATUS_SHUTDOWN_IN_PROGRESS = -1073741058
Global Const $STATUS_SERVER_SHUTDOWN_IN_PROGRESS = -1073741057
Global Const $STATUS_NOT_SUPPORTED_ON_SBS = -1073741056
Global Const $STATUS_WMI_GUID_DISCONNECTED = -1073741055
Global Const $STATUS_WMI_ALREADY_DISABLED = -1073741054
Global Const $STATUS_WMI_ALREADY_ENABLED = -1073741053
Global Const $STATUS_MFT_TOO_FRAGMENTED = -1073741052
Global Const $STATUS_COPY_PROTECTION_FAILURE = -1073741051
Global Const $STATUS_CSS_AUTHENTICATION_FAILURE = -1073741050
Global Const $STATUS_CSS_KEY_NOT_PRESENT = -1073741049
Global Const $STATUS_CSS_KEY_NOT_ESTABLISHED = -1073741048
Global Const $STATUS_CSS_SCRAMBLED_SECTOR = -1073741047
Global Const $STATUS_CSS_REGION_MISMATCH = -1073741046
Global Const $STATUS_CSS_RESETS_EXHAUSTED = -1073741045
Global Const $STATUS_PKINIT_FAILURE = -1073741024
Global Const $STATUS_SMARTCARD_SUBSYSTEM_FAILURE = -1073741023
Global Const $STATUS_NO_KERB_KEY = -1073741022
Global Const $STATUS_HOST_DOWN = -1073740976
Global Const $STATUS_UNSUPPORTED_PREAUTH = -1073740975
Global Const $STATUS_EFS_ALG_BLOB_TOO_BIG = -1073740974
Global Const $STATUS_PORT_NOT_SET = -1073740973
Global Const $STATUS_DEBUGGER_INACTIVE = -1073740972
Global Const $STATUS_DS_VERSION_CHECK_FAILURE = -1073740971
Global Const $STATUS_AUDITING_DISABLED = -1073740970
Global Const $STATUS_PRENT4_MACHINE_ACCOUNT = -1073740969
Global Const $STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = -1073740968
Global Const $STATUS_INVALID_IMAGE_WIN_32 = -1073740967
Global Const $STATUS_INVALID_IMAGE_WIN_64 = -1073740966
Global Const $STATUS_BAD_BINDINGS = -1073740965
Global Const $STATUS_NETWORK_SESSION_EXPIRED = -1073740964
Global Const $STATUS_APPHELP_BLOCK = -1073740963
Global Const $STATUS_ALL_SIDS_FILTERED = -1073740962
Global Const $STATUS_NOT_SAFE_MODE_DRIVER = -1073740961
Global Const $STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT = -1073740959
Global Const $STATUS_ACCESS_DISABLED_BY_POLICY_PATH = -1073740958
Global Const $STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER = -1073740957
Global Const $STATUS_ACCESS_DISABLED_BY_POLICY_OTHER = -1073740956
Global Const $STATUS_FAILED_DRIVER_ENTRY = -1073740955
Global Const $STATUS_DEVICE_ENUMERATION_ERROR = -1073740954
Global Const $STATUS_MOUNT_POINT_NOT_RESOLVED = -1073740952
Global Const $STATUS_INVALID_DEVICE_OBJECT_PARAMETER = -1073740951
Global Const $STATUS_MCA_OCCURED = -1073740950
Global Const $STATUS_DRIVER_BLOCKED_CRITICAL = -1073740949
Global Const $STATUS_DRIVER_BLOCKED = -1073740948
Global Const $STATUS_DRIVER_DATABASE_ERROR = -1073740947
Global Const $STATUS_SYSTEM_HIVE_TOO_LARGE = -1073740946
Global Const $STATUS_INVALID_IMPORT_OF_NON_DLL = -1073740945
Global Const $STATUS_NO_SECRETS = -1073740943
Global Const $STATUS_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = -1073740942
Global Const $STATUS_FAILED_STACK_SWITCH = -1073740941
Global Const $STATUS_HEAP_CORRUPTION = -1073740940
Global Const $STATUS_SMARTCARD_WRONG_PIN = -1073740928
Global Const $STATUS_SMARTCARD_CARD_BLOCKED = -1073740927
Global Const $STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED = -1073740926
Global Const $STATUS_SMARTCARD_NO_CARD = -1073740925
Global Const $STATUS_SMARTCARD_NO_KEY_CONTAINER = -1073740924
Global Const $STATUS_SMARTCARD_NO_CERTIFICATE = -1073740923
Global Const $STATUS_SMARTCARD_NO_KEYSET = -1073740922
Global Const $STATUS_SMARTCARD_IO_ERROR = -1073740921
Global Const $STATUS_DOWNGRADE_DETECTED = -1073740920
Global Const $STATUS_SMARTCARD_CERT_REVOKED = -1073740919
Global Const $STATUS_ISSUING_CA_UNTRUSTED = -1073740918
Global Const $STATUS_REVOCATION_OFFLINE_C = -1073740917
Global Const $STATUS_PKINIT_CLIENT_FAILURE = -1073740916
Global Const $STATUS_SMARTCARD_CERT_EXPIRED = -1073740915
Global Const $STATUS_DRIVER_FAILED_PRIOR_UNLOAD = -1073740914
Global Const $STATUS_SMARTCARD_SILENT_CONTEXT = -1073740913
Global Const $STATUS_PER_USER_TRUST_QUOTA_EXCEEDED = -1073740799
Global Const $STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED = -1073740798
Global Const $STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED = -1073740797
Global Const $STATUS_DS_NAME_NOT_UNIQUE = -1073740796
Global Const $STATUS_DS_DUPLICATE_ID_FOUND = -1073740795
Global Const $STATUS_DS_GROUP_CONVERSION_ERROR = -1073740794
Global Const $STATUS_VOLSNAP_PREPARE_HIBERNATE = -1073740793
Global Const $STATUS_USER2USER_REQUIRED = -1073740792
Global Const $STATUS_STACK_BUFFER_OVERRUN = -1073740791
Global Const $STATUS_NO_S4U_PROT_SUPPORT = -1073740790
Global Const $STATUS_CROSSREALM_DELEGATION_FAILURE = -1073740789
Global Const $STATUS_REVOCATION_OFFLINE_KDC = -1073740788
Global Const $STATUS_ISSUING_CA_UNTRUSTED_KDC = -1073740787
Global Const $STATUS_KDC_CERT_EXPIRED = -1073740786
Global Const $STATUS_KDC_CERT_REVOKED = -1073740785
Global Const $STATUS_PARAMETER_QUOTA_EXCEEDED = -1073740784
Global Const $STATUS_HIBERNATION_FAILURE = -1073740783
Global Const $STATUS_DELAY_LOAD_FAILED = -1073740782
Global Const $STATUS_AUTHENTICATION_FIREWALL_FAILED = -1073740781
Global Const $STATUS_VDM_DISALLOWED = -1073740780
Global Const $STATUS_HUNG_DISPLAY_DRIVER_THREAD = -1073740779
Global Const $STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = -1073740778
Global Const $STATUS_INVALID_CRUNTIME_PARAMETER = -1073740777
Global Const $STATUS_NTLM_BLOCKED = -1073740776
Global Const $STATUS_DS_SRC_SID_EXISTS_IN_FOREST = -1073740775
Global Const $STATUS_DS_DOMAIN_NAME_EXISTS_IN_FOREST = -1073740774
Global Const $STATUS_DS_FLAT_NAME_EXISTS_IN_FOREST = -1073740773
Global Const $STATUS_INVALID_USER_PRINCIPAL_NAME = -1073740772
Global Const $STATUS_ASSERTION_FAILURE = -1073740768
Global Const $STATUS_VERIFIER_STOP = -1073740767
Global Const $STATUS_CALLBACK_POP_STACK = -1073740765
Global Const $STATUS_INCOMPATIBLE_DRIVER_BLOCKED = -1073740764
Global Const $STATUS_HIVE_UNLOADED = -1073740763
Global Const $STATUS_COMPRESSION_DISABLED = -1073740762
Global Const $STATUS_FILE_SYSTEM_LIMITATION = -1073740761
Global Const $STATUS_INVALID_IMAGE_HASH = -1073740760
Global Const $STATUS_NOT_CAPABLE = -1073740759
Global Const $STATUS_REQUEST_OUT_OF_SEQUENCE = -1073740758
Global Const $STATUS_IMPLEMENTATION_LIMIT = -1073740757
Global Const $STATUS_ELEVATION_REQUIRED = -1073740756
Global Const $STATUS_NO_SECURITY_CONTEXT = -1073740755
Global Const $STATUS_PKU2U_CERT_FAILURE = -1073740754
Global Const $STATUS_BEYOND_VDL = -1073740750
Global Const $STATUS_ENCOUNTERED_WRITE_IN_PROGRESS = -1073740749
Global Const $STATUS_PTE_CHANGED = -1073740748
Global Const $STATUS_PURGE_FAILED = -1073740747
Global Const $STATUS_CRED_REQUIRES_CONFIRMATION = -1073740736
Global Const $STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = -1073740735
Global Const $STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER = -1073740734
Global Const $STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = -1073740733
Global Const $STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = -1073740732
Global Const $STATUS_CS_ENCRYPTION_FILE_NOT_CSE = -1073740731
Global Const $STATUS_INVALID_LABEL = -1073740730
Global Const $STATUS_DRIVER_PROCESS_TERMINATED = -1073740720
Global Const $STATUS_AMBIGUOUS_SYSTEM_DEVICE = -1073740719
Global Const $STATUS_SYSTEM_DEVICE_NOT_FOUND = -1073740718
Global Const $STATUS_RESTART_BOOT_APPLICATION = -1073740717
Global Const $STATUS_INSUFFICIENT_NVRAM_RESOURCES = -1073740716
Global Const $STATUS_INVALID_TASK_NAME = -1073740544
Global Const $STATUS_INVALID_TASK_INDEX = -1073740543
Global Const $STATUS_THREAD_ALREADY_IN_TASK = -1073740542
Global Const $STATUS_CALLBACK_BYPASS = -1073740541
Global Const $STATUS_FAIL_FAST_EXCEPTION = -1073740286
Global Const $STATUS_IMAGE_CERT_REVOKED = -1073740285
Global Const $STATUS_PORT_CLOSED = -1073740032
Global Const $STATUS_MESSAGE_LOST = -1073740031
Global Const $STATUS_INVALID_MESSAGE = -1073740030
Global Const $STATUS_REQUEST_CANCELED = -1073740029
Global Const $STATUS_RECURSIVE_DISPATCH = -1073740028
Global Const $STATUS_LPC_RECEIVE_BUFFER_EXPECTED = -1073740027
Global Const $STATUS_LPC_INVALID_CONNECTION_USAGE = -1073740026
Global Const $STATUS_LPC_REQUESTS_NOT_ALLOWED = -1073740025
Global Const $STATUS_RESOURCE_IN_USE = -1073740024
Global Const $STATUS_HARDWARE_MEMORY_ERROR = -1073740023
Global Const $STATUS_THREADPOOL_HANDLE_EXCEPTION = -1073740022
Global Const $STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED = -1073740021
Global Const $STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED = -1073740020
Global Const $STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED = -1073740019
Global Const $STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED = -1073740018
Global Const $STATUS_THREADPOOL_RELEASED_DURING_OPERATION = -1073740017
Global Const $STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING = -1073740016
Global Const $STATUS_APC_RETURNED_WHILE_IMPERSONATING = -1073740015
Global Const $STATUS_PROCESS_IS_PROTECTED = -1073740014
Global Const $STATUS_MCA_EXCEPTION = -1073740013
Global Const $STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE = -1073740012
Global Const $STATUS_SYMLINK_CLASS_DISABLED = -1073740011
Global Const $STATUS_INVALID_IDN_NORMALIZATION = -1073740010
Global Const $STATUS_NO_UNICODE_TRANSLATION = -1073740009
Global Const $STATUS_ALREADY_REGISTERED = -1073740008
Global Const $STATUS_CONTEXT_MISMATCH = -1073740007
Global Const $STATUS_PORT_ALREADY_HAS_COMPLETION_LIST = -1073740006
Global Const $STATUS_CALLBACK_RETURNED_THREAD_PRIORITY = -1073740005
Global Const $STATUS_INVALID_THREAD = -1073740004
Global Const $STATUS_CALLBACK_RETURNED_TRANSACTION = -1073740003
Global Const $STATUS_CALLBACK_RETURNED_LDR_LOCK = -1073740002
Global Const $STATUS_CALLBACK_RETURNED_LANG = -1073740001
Global Const $STATUS_CALLBACK_RETURNED_PRI_BACK = -1073740000
Global Const $STATUS_DISK_REPAIR_DISABLED = -1073739776
Global Const $STATUS_DS_DOMAIN_RENAME_IN_PROGRESS = -1073739775
Global Const $STATUS_DISK_QUOTA_EXCEEDED = -1073739774
Global Const $STATUS_CONTENT_BLOCKED = -1073739772
Global Const $STATUS_BAD_CLUSTERS = -1073739771
Global Const $STATUS_VOLUME_DIRTY = -1073739770
Global Const $STATUS_FILE_CHECKED_OUT = -1073739519
Global Const $STATUS_CHECKOUT_REQUIRED = -1073739518
Global Const $STATUS_BAD_FILE_TYPE = -1073739517
Global Const $STATUS_FILE_TOO_LARGE = -1073739516
Global Const $STATUS_FORMS_AUTH_REQUIRED = -1073739515
Global Const $STATUS_VIRUS_INFECTED = -1073739514
Global Const $STATUS_VIRUS_DELETED = -1073739513
Global Const $STATUS_BAD_MCFG_TABLE = -1073739512
Global Const $STATUS_CANNOT_BREAK_OPLOCK = -1073739511
Global Const $STATUS_WOW_ASSERTION = -1073702760
Global Const $STATUS_INVALID_SIGNATURE = -1073700864
Global Const $STATUS_HMAC_NOT_SUPPORTED = -1073700863
Global Const $STATUS_IPSEC_QUEUE_OVERFLOW = -1073700848
Global Const $STATUS_ND_QUEUE_OVERFLOW = -1073700847
Global Const $STATUS_HOPLIMIT_EXCEEDED = -1073700846
Global Const $STATUS_PROTOCOL_NOT_SUPPORTED = -1073700845
Global Const $STATUS_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = -1073700736
Global Const $STATUS_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = -1073700735
Global Const $STATUS_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = -1073700734
Global Const $STATUS_XML_PARSE_ERROR = -1073700733
Global Const $STATUS_XMLDSIG_ERROR = -1073700732
Global Const $STATUS_WRONG_COMPARTMENT = -1073700731
Global Const $STATUS_AUTHIP_FAILURE = -1073700730
Global Const $STATUS_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = -1073700729
Global Const $STATUS_DS_OID_NOT_FOUND = -1073700728
Global Const $STATUS_HASH_NOT_SUPPORTED = -1073700608
Global Const $STATUS_HASH_NOT_PRESENT = -1073700607
Global Const $STATUS_PNP_BAD_MPS_TABLE = -1073479627
Global Const $STATUS_PNP_TRANSLATION_FAILED = -1073479626
Global Const $STATUS_PNP_IRQ_TRANSLATION_FAILED = -1073479625
Global Const $STATUS_PNP_INVALID_ID = -1073479624
Global Const $STATUS_IO_REISSUE_AS_CACHED = -1073479623
Global Const $STATUS_CTX_WINSTATION_NAME_INVALID = -1073086463
Global Const $STATUS_CTX_INVALID_PD = -1073086462
Global Const $STATUS_CTX_PD_NOT_FOUND = -1073086461
Global Const $STATUS_CTX_CLOSE_PENDING = -1073086458
Global Const $STATUS_CTX_NO_OUTBUF = -1073086457
Global Const $STATUS_CTX_MODEM_INF_NOT_FOUND = -1073086456
Global Const $STATUS_CTX_INVALID_MODEMNAME = -1073086455
Global Const $STATUS_CTX_RESPONSE_ERROR = -1073086454
Global Const $STATUS_CTX_MODEM_RESPONSE_TIMEOUT = -1073086453
Global Const $STATUS_CTX_MODEM_RESPONSE_NO_CARRIER = -1073086452
Global Const $STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE = -1073086451
Global Const $STATUS_CTX_MODEM_RESPONSE_BUSY = -1073086450
Global Const $STATUS_CTX_MODEM_RESPONSE_VOICE = -1073086449
Global Const $STATUS_CTX_TD_ERROR = -1073086448
Global Const $STATUS_CTX_LICENSE_CLIENT_INVALID = -1073086446
Global Const $STATUS_CTX_LICENSE_NOT_AVAILABLE = -1073086445
Global Const $STATUS_CTX_LICENSE_EXPIRED = -1073086444
Global Const $STATUS_CTX_WINSTATION_NOT_FOUND = -1073086443
Global Const $STATUS_CTX_WINSTATION_NAME_COLLISION = -1073086442
Global Const $STATUS_CTX_WINSTATION_BUSY = -1073086441
Global Const $STATUS_CTX_BAD_VIDEO_MODE = -1073086440
Global Const $STATUS_CTX_GRAPHICS_INVALID = -1073086430
Global Const $STATUS_CTX_NOT_CONSOLE = -1073086428
Global Const $STATUS_CTX_CLIENT_QUERY_TIMEOUT = -1073086426
Global Const $STATUS_CTX_CONSOLE_DISCONNECT = -1073086425
Global Const $STATUS_CTX_CONSOLE_CONNECT = -1073086424
Global Const $STATUS_CTX_SHADOW_DENIED = -1073086422
Global Const $STATUS_CTX_WINSTATION_ACCESS_DENIED = -1073086421
Global Const $STATUS_CTX_INVALID_WD = -1073086418
Global Const $STATUS_CTX_WD_NOT_FOUND = -1073086417
Global Const $STATUS_CTX_SHADOW_INVALID = -1073086416
Global Const $STATUS_CTX_SHADOW_DISABLED = -1073086415
Global Const $STATUS_RDP_PROTOCOL_ERROR = -1073086414
Global Const $STATUS_CTX_CLIENT_LICENSE_NOT_SET = -1073086413
Global Const $STATUS_CTX_CLIENT_LICENSE_IN_USE = -1073086412
Global Const $STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE = -1073086411
Global Const $STATUS_CTX_SHADOW_NOT_RUNNING = -1073086410
Global Const $STATUS_CTX_LOGON_DISABLED = -1073086409
Global Const $STATUS_CTX_SECURITY_LAYER_ERROR = -1073086408
Global Const $STATUS_TS_INCOMPATIBLE_SESSIONS = -1073086407
Global Const $STATUS_MUI_FILE_NOT_FOUND = -1073020927
Global Const $STATUS_MUI_INVALID_FILE = -1073020926
Global Const $STATUS_MUI_INVALID_RC_CONFIG = -1073020925
Global Const $STATUS_MUI_INVALID_LOCALE_NAME = -1073020924
Global Const $STATUS_MUI_INVALID_ULTIMATEFALLBACK_NAME = -1073020923
Global Const $STATUS_MUI_FILE_NOT_LOADED = -1073020922
Global Const $STATUS_RESOURCE_ENUM_USER_STOP = -1073020921
Global Const $STATUS_CLUSTER_INVALID_NODE = -1072496639
Global Const $STATUS_CLUSTER_NODE_EXISTS = -1072496638
Global Const $STATUS_CLUSTER_JOIN_IN_PROGRESS = -1072496637
Global Const $STATUS_CLUSTER_NODE_NOT_FOUND = -1072496636
Global Const $STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND = -1072496635
Global Const $STATUS_CLUSTER_NETWORK_EXISTS = -1072496634
Global Const $STATUS_CLUSTER_NETWORK_NOT_FOUND = -1072496633
Global Const $STATUS_CLUSTER_NETINTERFACE_EXISTS = -1072496632
Global Const $STATUS_CLUSTER_NETINTERFACE_NOT_FOUND = -1072496631
Global Const $STATUS_CLUSTER_INVALID_REQUEST = -1072496630
Global Const $STATUS_CLUSTER_INVALID_NETWORK_PROVIDER = -1072496629
Global Const $STATUS_CLUSTER_NODE_DOWN = -1072496628
Global Const $STATUS_CLUSTER_NODE_UNREACHABLE = -1072496627
Global Const $STATUS_CLUSTER_NODE_NOT_MEMBER = -1072496626
Global Const $STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS = -1072496625
Global Const $STATUS_CLUSTER_INVALID_NETWORK = -1072496624
Global Const $STATUS_CLUSTER_NO_NET_ADAPTERS = -1072496623
Global Const $STATUS_CLUSTER_NODE_UP = -1072496622
Global Const $STATUS_CLUSTER_NODE_PAUSED = -1072496621
Global Const $STATUS_CLUSTER_NODE_NOT_PAUSED = -1072496620
Global Const $STATUS_CLUSTER_NO_SECURITY_CONTEXT = -1072496619
Global Const $STATUS_CLUSTER_NETWORK_NOT_INTERNAL = -1072496618
Global Const $STATUS_CLUSTER_POISONED = -1072496617
Global Const $STATUS_ACPI_INVALID_OPCODE = -1072431103
Global Const $STATUS_ACPI_STACK_OVERFLOW = -1072431102
Global Const $STATUS_ACPI_ASSERT_FAILED = -1072431101
Global Const $STATUS_ACPI_INVALID_INDEX = -1072431100
Global Const $STATUS_ACPI_INVALID_ARGUMENT = -1072431099
Global Const $STATUS_ACPI_FATAL = -1072431098
Global Const $STATUS_ACPI_INVALID_SUPERNAME = -1072431097
Global Const $STATUS_ACPI_INVALID_ARGTYPE = -1072431096
Global Const $STATUS_ACPI_INVALID_OBJTYPE = -1072431095
Global Const $STATUS_ACPI_INVALID_TARGETTYPE = -1072431094
Global Const $STATUS_ACPI_INCORRECT_ARGUMENT_COUNT = -1072431093
Global Const $STATUS_ACPI_ADDRESS_NOT_MAPPED = -1072431092
Global Const $STATUS_ACPI_INVALID_EVENTTYPE = -1072431091
Global Const $STATUS_ACPI_HANDLER_COLLISION = -1072431090
Global Const $STATUS_ACPI_INVALID_DATA = -1072431089
Global Const $STATUS_ACPI_INVALID_REGION = -1072431088
Global Const $STATUS_ACPI_INVALID_ACCESS_SIZE = -1072431087
Global Const $STATUS_ACPI_ACQUIRE_GLOBAL_LOCK = -1072431086
Global Const $STATUS_ACPI_ALREADY_INITIALIZED = -1072431085
Global Const $STATUS_ACPI_NOT_INITIALIZED = -1072431084
Global Const $STATUS_ACPI_INVALID_MUTEX_LEVEL = -1072431083
Global Const $STATUS_ACPI_MUTEX_NOT_OWNED = -1072431082
Global Const $STATUS_ACPI_MUTEX_NOT_OWNER = -1072431081
Global Const $STATUS_ACPI_RS_ACCESS = -1072431080
Global Const $STATUS_ACPI_INVALID_TABLE = -1072431079
Global Const $STATUS_ACPI_REG_HANDLER_FAILED = -1072431072
Global Const $STATUS_ACPI_POWER_REQUEST_FAILED = -1072431071
Global Const $STATUS_SXS_SECTION_NOT_FOUND = -1072365567
Global Const $STATUS_SXS_CANT_GEN_ACTCTX = -1072365566
Global Const $STATUS_SXS_INVALID_ACTCTXDATA_FORMAT = -1072365565
Global Const $STATUS_SXS_ASSEMBLY_NOT_FOUND = -1072365564
Global Const $STATUS_SXS_MANIFEST_FORMAT_ERROR = -1072365563
Global Const $STATUS_SXS_MANIFEST_PARSE_ERROR = -1072365562
Global Const $STATUS_SXS_ACTIVATION_CONTEXT_DISABLED = -1072365561
Global Const $STATUS_SXS_KEY_NOT_FOUND = -1072365560
Global Const $STATUS_SXS_VERSION_CONFLICT = -1072365559
Global Const $STATUS_SXS_WRONG_SECTION_TYPE = -1072365558
Global Const $STATUS_SXS_THREAD_QUERIES_DISABLED = -1072365557
Global Const $STATUS_SXS_ASSEMBLY_MISSING = -1072365556
Global Const $STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET = -1072365554
Global Const $STATUS_SXS_EARLY_DEACTIVATION = -1072365553
Global Const $STATUS_SXS_INVALID_DEACTIVATION = -1072365552
Global Const $STATUS_SXS_MULTIPLE_DEACTIVATION = -1072365551
Global Const $STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = -1072365550
Global Const $STATUS_SXS_PROCESS_TERMINATION_REQUESTED = -1072365549
Global Const $STATUS_SXS_CORRUPT_ACTIVATION_STACK = -1072365548
Global Const $STATUS_SXS_CORRUPTION = -1072365547
Global Const $STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = -1072365546
Global Const $STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = -1072365545
Global Const $STATUS_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = -1072365544
Global Const $STATUS_SXS_IDENTITY_PARSE_ERROR = -1072365543
Global Const $STATUS_SXS_COMPONENT_STORE_CORRUPT = -1072365542
Global Const $STATUS_SXS_FILE_HASH_MISMATCH = -1072365541
Global Const $STATUS_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = -1072365540
Global Const $STATUS_SXS_IDENTITIES_DIFFERENT = -1072365539
Global Const $STATUS_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = -1072365538
Global Const $STATUS_SXS_FILE_NOT_PART_OF_ASSEMBLY = -1072365537
Global Const $STATUS_ADVANCED_INSTALLER_FAILED = -1072365536
Global Const $STATUS_XML_ENCODING_MISMATCH = -1072365535
Global Const $STATUS_SXS_MANIFEST_TOO_BIG = -1072365534
Global Const $STATUS_SXS_SETTING_NOT_REGISTERED = -1072365533
Global Const $STATUS_SXS_TRANSACTION_CLOSURE_INCOMPLETE = -1072365532
Global Const $STATUS_SMI_PRIMITIVE_INSTALLER_FAILED = -1072365531
Global Const $STATUS_GENERIC_COMMAND_FAILED = -1072365530
Global Const $STATUS_SXS_FILE_HASH_MISSING = -1072365529
Global Const $STATUS_TRANSACTIONAL_CONFLICT = -1072103423
Global Const $STATUS_INVALID_TRANSACTION = -1072103422
Global Const $STATUS_TRANSACTION_NOT_ACTIVE = -1072103421
Global Const $STATUS_TM_INITIALIZATION_FAILED = -1072103420
Global Const $STATUS_RM_NOT_ACTIVE = -1072103419
Global Const $STATUS_RM_METADATA_CORRUPT = -1072103418
Global Const $STATUS_TRANSACTION_NOT_JOINED = -1072103417
Global Const $STATUS_DIRECTORY_NOT_RM = -1072103416
Global Const $STATUS_TRANSACTIONS_UNSUPPORTED_REMOTE = -1072103414
Global Const $STATUS_LOG_RESIZE_INVALID_SIZE = -1072103413
Global Const $STATUS_REMOTE_FILE_VERSION_MISMATCH = -1072103412
Global Const $STATUS_CRM_PROTOCOL_ALREADY_EXISTS = -1072103409
Global Const $STATUS_TRANSACTION_PROPAGATION_FAILED = -1072103408
Global Const $STATUS_CRM_PROTOCOL_NOT_FOUND = -1072103407
Global Const $STATUS_TRANSACTION_SUPERIOR_EXISTS = -1072103406
Global Const $STATUS_TRANSACTION_REQUEST_NOT_VALID = -1072103405
Global Const $STATUS_TRANSACTION_NOT_REQUESTED = -1072103404
Global Const $STATUS_TRANSACTION_ALREADY_ABORTED = -1072103403
Global Const $STATUS_TRANSACTION_ALREADY_COMMITTED = -1072103402
Global Const $STATUS_TRANSACTION_INVALID_MARSHALL_BUFFER = -1072103401
Global Const $STATUS_CURRENT_TRANSACTION_NOT_VALID = -1072103400
Global Const $STATUS_LOG_GROWTH_FAILED = -1072103399
Global Const $STATUS_OBJECT_NO_LONGER_EXISTS = -1072103391
Global Const $STATUS_STREAM_MINIVERSION_NOT_FOUND = -1072103390
Global Const $STATUS_STREAM_MINIVERSION_NOT_VALID = -1072103389
Global Const $STATUS_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = -1072103388
Global Const $STATUS_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = -1072103387
Global Const $STATUS_CANT_CREATE_MORE_STREAM_MINIVERSIONS = -1072103386
Global Const $STATUS_HANDLE_NO_LONGER_VALID = -1072103384
Global Const $STATUS_LOG_CORRUPTION_DETECTED = -1072103376
Global Const $STATUS_RM_DISCONNECTED = -1072103374
Global Const $STATUS_ENLISTMENT_NOT_SUPERIOR = -1072103373
Global Const $STATUS_FILE_IDENTITY_NOT_PERSISTENT = -1072103370
Global Const $STATUS_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = -1072103369
Global Const $STATUS_CANT_CROSS_RM_BOUNDARY = -1072103368
Global Const $STATUS_TXF_DIR_NOT_EMPTY = -1072103367
Global Const $STATUS_INDOUBT_TRANSACTIONS_EXIST = -1072103366
Global Const $STATUS_TM_VOLATILE = -1072103365
Global Const $STATUS_ROLLBACK_TIMER_EXPIRED = -1072103364
Global Const $STATUS_TXF_ATTRIBUTE_CORRUPT = -1072103363
Global Const $STATUS_EFS_NOT_ALLOWED_IN_TRANSACTION = -1072103362
Global Const $STATUS_TRANSACTIONAL_OPEN_NOT_ALLOWED = -1072103361
Global Const $STATUS_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = -1072103360
Global Const $STATUS_TRANSACTION_REQUIRED_PROMOTION = -1072103357
Global Const $STATUS_CANNOT_EXECUTE_FILE_IN_TRANSACTION = -1072103356
Global Const $STATUS_TRANSACTIONS_NOT_FROZEN = -1072103355
Global Const $STATUS_TRANSACTION_FREEZE_IN_PROGRESS = -1072103354
Global Const $STATUS_NOT_SNAPSHOT_VOLUME = -1072103353
Global Const $STATUS_NO_SAVEPOINT_WITH_OPEN_FILES = -1072103352
Global Const $STATUS_SPARSE_NOT_ALLOWED_IN_TRANSACTION = -1072103351
Global Const $STATUS_TM_IDENTITY_MISMATCH = -1072103350
Global Const $STATUS_FLOATED_SECTION = -1072103349
Global Const $STATUS_CANNOT_ACCEPT_TRANSACTED_WORK = -1072103348
Global Const $STATUS_CANNOT_ABORT_TRANSACTIONS = -1072103347
Global Const $STATUS_TRANSACTION_NOT_FOUND = -1072103346
Global Const $STATUS_RESOURCEMANAGER_NOT_FOUND = -1072103345
Global Const $STATUS_ENLISTMENT_NOT_FOUND = -1072103344
Global Const $STATUS_TRANSACTIONMANAGER_NOT_FOUND = -1072103343
Global Const $STATUS_TRANSACTIONMANAGER_NOT_ONLINE = -1072103342
Global Const $STATUS_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = -1072103341
Global Const $STATUS_TRANSACTION_NOT_ROOT = -1072103340
Global Const $STATUS_TRANSACTION_OBJECT_EXPIRED = -1072103339
Global Const $STATUS_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = -1072103338
Global Const $STATUS_TRANSACTION_RESPONSE_NOT_ENLISTED = -1072103337
Global Const $STATUS_TRANSACTION_RECORD_TOO_LONG = -1072103336
Global Const $STATUS_NO_LINK_TRACKING_IN_TRANSACTION = -1072103335
Global Const $STATUS_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = -1072103334
Global Const $STATUS_TRANSACTION_INTEGRITY_VIOLATED = -1072103333
Global Const $STATUS_EXPIRED_HANDLE = -1072103328
Global Const $STATUS_TRANSACTION_NOT_ENLISTED = -1072103327
Global Const $STATUS_LOG_SECTOR_INVALID = -1072037887
Global Const $STATUS_LOG_SECTOR_PARITY_INVALID = -1072037886
Global Const $STATUS_LOG_SECTOR_REMAPPED = -1072037885
Global Const $STATUS_LOG_BLOCK_INCOMPLETE = -1072037884
Global Const $STATUS_LOG_INVALID_RANGE = -1072037883
Global Const $STATUS_LOG_BLOCKS_EXHAUSTED = -1072037882
Global Const $STATUS_LOG_READ_CONTEXT_INVALID = -1072037881
Global Const $STATUS_LOG_RESTART_INVALID = -1072037880
Global Const $STATUS_LOG_BLOCK_VERSION = -1072037879
Global Const $STATUS_LOG_BLOCK_INVALID = -1072037878
Global Const $STATUS_LOG_READ_MODE_INVALID = -1072037877
Global Const $STATUS_LOG_METADATA_CORRUPT = -1072037875
Global Const $STATUS_LOG_METADATA_INVALID = -1072037874
Global Const $STATUS_LOG_METADATA_INCONSISTENT = -1072037873
Global Const $STATUS_LOG_RESERVATION_INVALID = -1072037872
Global Const $STATUS_LOG_CANT_DELETE = -1072037871
Global Const $STATUS_LOG_CONTAINER_LIMIT_EXCEEDED = -1072037870
Global Const $STATUS_LOG_START_OF_LOG = -1072037869
Global Const $STATUS_LOG_POLICY_ALREADY_INSTALLED = -1072037868
Global Const $STATUS_LOG_POLICY_NOT_INSTALLED = -1072037867
Global Const $STATUS_LOG_POLICY_INVALID = -1072037866
Global Const $STATUS_LOG_POLICY_CONFLICT = -1072037865
Global Const $STATUS_LOG_PINNED_ARCHIVE_TAIL = -1072037864
Global Const $STATUS_LOG_RECORD_NONEXISTENT = -1072037863
Global Const $STATUS_LOG_RECORDS_RESERVED_INVALID = -1072037862
Global Const $STATUS_LOG_SPACE_RESERVED_INVALID = -1072037861
Global Const $STATUS_LOG_TAIL_INVALID = -1072037860
Global Const $STATUS_LOG_FULL = -1072037859
Global Const $STATUS_LOG_MULTIPLEXED = -1072037858
Global Const $STATUS_LOG_DEDICATED = -1072037857
Global Const $STATUS_LOG_ARCHIVE_NOT_IN_PROGRESS = -1072037856
Global Const $STATUS_LOG_ARCHIVE_IN_PROGRESS = -1072037855
Global Const $STATUS_LOG_EPHEMERAL = -1072037854
Global Const $STATUS_LOG_NOT_ENOUGH_CONTAINERS = -1072037853
Global Const $STATUS_LOG_CLIENT_ALREADY_REGISTERED = -1072037852
Global Const $STATUS_LOG_CLIENT_NOT_REGISTERED = -1072037851
Global Const $STATUS_LOG_FULL_HANDLER_IN_PROGRESS = -1072037850
Global Const $STATUS_LOG_CONTAINER_READ_FAILED = -1072037849
Global Const $STATUS_LOG_CONTAINER_WRITE_FAILED = -1072037848
Global Const $STATUS_LOG_CONTAINER_OPEN_FAILED = -1072037847
Global Const $STATUS_LOG_CONTAINER_STATE_INVALID = -1072037846
Global Const $STATUS_LOG_STATE_INVALID = -1072037845
Global Const $STATUS_LOG_PINNED = -1072037844
Global Const $STATUS_LOG_METADATA_FLUSH_FAILED = -1072037843
Global Const $STATUS_LOG_INCONSISTENT_SECURITY = -1072037842
Global Const $STATUS_LOG_APPENDED_FLUSH_FAILED = -1072037841
Global Const $STATUS_LOG_PINNED_RESERVATION = -1072037840
Global Const $STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD = -1071972118
Global Const $STATUS_FLT_NO_HANDLER_DEFINED = -1071906815
Global Const $STATUS_FLT_CONTEXT_ALREADY_DEFINED = -1071906814
Global Const $STATUS_FLT_INVALID_ASYNCHRONOUS_REQUEST = -1071906813
Global Const $STATUS_FLT_DISALLOW_FAST_IO = -1071906812
Global Const $STATUS_FLT_INVALID_NAME_REQUEST = -1071906811
Global Const $STATUS_FLT_NOT_SAFE_TO_POST_OPERATION = -1071906810
Global Const $STATUS_FLT_NOT_INITIALIZED = -1071906809
Global Const $STATUS_FLT_FILTER_NOT_READY = -1071906808
Global Const $STATUS_FLT_POST_OPERATION_CLEANUP = -1071906807
Global Const $STATUS_FLT_INTERNAL_ERROR = -1071906806
Global Const $STATUS_FLT_DELETING_OBJECT = -1071906805
Global Const $STATUS_FLT_MUST_BE_NONPAGED_POOL = -1071906804
Global Const $STATUS_FLT_DUPLICATE_ENTRY = -1071906803
Global Const $STATUS_FLT_CBDQ_DISABLED = -1071906802
Global Const $STATUS_FLT_DO_NOT_ATTACH = -1071906801
Global Const $STATUS_FLT_DO_NOT_DETACH = -1071906800
Global Const $STATUS_FLT_INSTANCE_ALTITUDE_COLLISION = -1071906799
Global Const $STATUS_FLT_INSTANCE_NAME_COLLISION = -1071906798
Global Const $STATUS_FLT_FILTER_NOT_FOUND = -1071906797
Global Const $STATUS_FLT_VOLUME_NOT_FOUND = -1071906796
Global Const $STATUS_FLT_INSTANCE_NOT_FOUND = -1071906795
Global Const $STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND = -1071906794
Global Const $STATUS_FLT_INVALID_CONTEXT_REGISTRATION = -1071906793
Global Const $STATUS_FLT_NAME_CACHE_MISS = -1071906792
Global Const $STATUS_FLT_NO_DEVICE_OBJECT = -1071906791
Global Const $STATUS_FLT_VOLUME_ALREADY_MOUNTED = -1071906790
Global Const $STATUS_FLT_ALREADY_ENLISTED = -1071906789
Global Const $STATUS_FLT_CONTEXT_ALREADY_LINKED = -1071906788
Global Const $STATUS_FLT_NO_WAITER_FOR_REPLY = -1071906784
Global Const $STATUS_MONITOR_NO_DESCRIPTOR = -1071841279
Global Const $STATUS_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT = -1071841278
Global Const $STATUS_MONITOR_INVALID_DESCRIPTOR_CHECKSUM = -1071841277
Global Const $STATUS_MONITOR_INVALID_STANDARD_TIMING_BLOCK = -1071841276
Global Const $STATUS_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED = -1071841275
Global Const $STATUS_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK = -1071841274
Global Const $STATUS_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK = -1071841273
Global Const $STATUS_MONITOR_NO_MORE_DESCRIPTOR_DATA = -1071841272
Global Const $STATUS_MONITOR_INVALID_DETAILED_TIMING_BLOCK = -1071841271
Global Const $STATUS_MONITOR_INVALID_MANUFACTURE_DATE = -1071841270
Global Const $STATUS_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER = -1071775744
Global Const $STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER = -1071775743
Global Const $STATUS_GRAPHICS_INVALID_DISPLAY_ADAPTER = -1071775742
Global Const $STATUS_GRAPHICS_ADAPTER_WAS_RESET = -1071775741
Global Const $STATUS_GRAPHICS_INVALID_DRIVER_MODEL = -1071775740
Global Const $STATUS_GRAPHICS_PRESENT_MODE_CHANGED = -1071775739
Global Const $STATUS_GRAPHICS_PRESENT_OCCLUDED = -1071775738
Global Const $STATUS_GRAPHICS_PRESENT_DENIED = -1071775737
Global Const $STATUS_GRAPHICS_CANNOTCOLORCONVERT = -1071775736
Global Const $STATUS_GRAPHICS_PRESENT_REDIRECTION_DISABLED = -1071775733
Global Const $STATUS_GRAPHICS_PRESENT_UNOCCLUDED = -1071775732
Global Const $STATUS_GRAPHICS_NO_VIDEO_MEMORY = -1071775488
Global Const $STATUS_GRAPHICS_CANT_LOCK_MEMORY = -1071775487
Global Const $STATUS_GRAPHICS_ALLOCATION_BUSY = -1071775486
Global Const $STATUS_GRAPHICS_TOO_MANY_REFERENCES = -1071775485
Global Const $STATUS_GRAPHICS_TRY_AGAIN_LATER = -1071775484
Global Const $STATUS_GRAPHICS_TRY_AGAIN_NOW = -1071775483
Global Const $STATUS_GRAPHICS_ALLOCATION_INVALID = -1071775482
Global Const $STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE = -1071775481
Global Const $STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED = -1071775480
Global Const $STATUS_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION = -1071775479
Global Const $STATUS_GRAPHICS_INVALID_ALLOCATION_USAGE = -1071775472
Global Const $STATUS_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION = -1071775471
Global Const $STATUS_GRAPHICS_ALLOCATION_CLOSED = -1071775470
Global Const $STATUS_GRAPHICS_INVALID_ALLOCATION_INSTANCE = -1071775469
Global Const $STATUS_GRAPHICS_INVALID_ALLOCATION_HANDLE = -1071775468
Global Const $STATUS_GRAPHICS_WRONG_ALLOCATION_DEVICE = -1071775467
Global Const $STATUS_GRAPHICS_ALLOCATION_CONTENT_LOST = -1071775466
Global Const $STATUS_GRAPHICS_GPU_EXCEPTION_ON_DEVICE = -1071775232
Global Const $STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY = -1071774976
Global Const $STATUS_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED = -1071774975
Global Const $STATUS_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED = -1071774974
Global Const $STATUS_GRAPHICS_INVALID_VIDPN = -1071774973
Global Const $STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE = -1071774972
Global Const $STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET = -1071774971
Global Const $STATUS_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED = -1071774970
Global Const $STATUS_GRAPHICS_INVALID_VIDPN_SOURCEMODESET = -1071774968
Global Const $STATUS_GRAPHICS_INVALID_VIDPN_TARGETMODESET = -1071774967
Global Const $STATUS_GRAPHICS_INVALID_FREQUENCY = -1071774966
Global Const $STATUS_GRAPHICS_INVALID_ACTIVE_REGION = -1071774965
Global Const $STATUS_GRAPHICS_INVALID_TOTAL_REGION = -1071774964
Global Const $STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE = -1071774960
Global Const $STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE = -1071774959
Global Const $STATUS_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET = -1071774958
Global Const $STATUS_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY = -1071774957
Global Const $STATUS_GRAPHICS_MODE_ALREADY_IN_MODESET = -1071774956
Global Const $STATUS_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET = -1071774955
Global Const $STATUS_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET = -1071774954
Global Const $STATUS_GRAPHICS_SOURCE_ALREADY_IN_SET = -1071774953
Global Const $STATUS_GRAPHICS_TARGET_ALREADY_IN_SET = -1071774952
Global Const $STATUS_GRAPHICS_INVALID_VIDPN_PRESENT_PATH = -1071774951
Global Const $STATUS_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY = -1071774950
Global Const $STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET = -1071774949
Global Const $STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE = -1071774948
Global Const $STATUS_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET = -1071774947
Global Const $STATUS_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET = -1071774945
Global Const $STATUS_GRAPHICS_STALE_MODESET = -1071774944
Global Const $STATUS_GRAPHICS_INVALID_MONITOR_SOURCEMODESET = -1071774943
Global Const $STATUS_GRAPHICS_INVALID_MONITOR_SOURCE_MODE = -1071774942
Global Const $STATUS_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN = -1071774941
Global Const $STATUS_GRAPHICS_MODE_ID_MUST_BE_UNIQUE = -1071774940
Global Const $STATUS_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION = -1071774939
Global Const $STATUS_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES = -1071774938
Global Const $STATUS_GRAPHICS_PATH_NOT_IN_TOPOLOGY = -1071774937
Global Const $STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE = -1071774936
Global Const $STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET = -1071774935
Global Const $STATUS_GRAPHICS_INVALID_MONITORDESCRIPTORSET = -1071774934
Global Const $STATUS_GRAPHICS_INVALID_MONITORDESCRIPTOR = -1071774933
Global Const $STATUS_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET = -1071774932
Global Const $STATUS_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET = -1071774931
Global Const $STATUS_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE = -1071774930
Global Const $STATUS_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE = -1071774929
Global Const $STATUS_GRAPHICS_RESOURCES_NOT_RELATED = -1071774928
Global Const $STATUS_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE = -1071774927
Global Const $STATUS_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE = -1071774926
Global Const $STATUS_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET = -1071774925
Global Const $STATUS_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER = -1071774924
Global Const $STATUS_GRAPHICS_NO_VIDPNMGR = -1071774923
Global Const $STATUS_GRAPHICS_NO_ACTIVE_VIDPN = -1071774922
Global Const $STATUS_GRAPHICS_STALE_VIDPN_TOPOLOGY = -1071774921
Global Const $STATUS_GRAPHICS_MONITOR_NOT_CONNECTED = -1071774920
Global Const $STATUS_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY = -1071774919
Global Const $STATUS_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE = -1071774918
Global Const $STATUS_GRAPHICS_INVALID_VISIBLEREGION_SIZE = -1071774917
Global Const $STATUS_GRAPHICS_INVALID_STRIDE = -1071774916
Global Const $STATUS_GRAPHICS_INVALID_PIXELFORMAT = -1071774915
Global Const $STATUS_GRAPHICS_INVALID_COLORBASIS = -1071774914
Global Const $STATUS_GRAPHICS_INVALID_PIXELVALUEACCESSMODE = -1071774913
Global Const $STATUS_GRAPHICS_TARGET_NOT_IN_TOPOLOGY = -1071774912
Global Const $STATUS_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT = -1071774911
Global Const $STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE = -1071774910
Global Const $STATUS_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN = -1071774909
Global Const $STATUS_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL = -1071774908
Global Const $STATUS_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION = -1071774907
Global Const $STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED = -1071774906
Global Const $STATUS_GRAPHICS_INVALID_GAMMA_RAMP = -1071774905
Global Const $STATUS_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED = -1071774904
Global Const $STATUS_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED = -1071774903
Global Const $STATUS_GRAPHICS_MODE_NOT_IN_MODESET = -1071774902
Global Const $STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON = -1071774899
Global Const $STATUS_GRAPHICS_INVALID_PATH_CONTENT_TYPE = -1071774898
Global Const $STATUS_GRAPHICS_INVALID_COPYPROTECTION_TYPE = -1071774897
Global Const $STATUS_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS = -1071774896
Global Const $STATUS_GRAPHICS_INVALID_SCANLINE_ORDERING = -1071774894
Global Const $STATUS_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED = -1071774893
Global Const $STATUS_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS = -1071774892
Global Const $STATUS_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT = -1071774891
Global Const $STATUS_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM = -1071774890
Global Const $STATUS_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN = -1071774889
Global Const $STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT = -1071774888
Global Const $STATUS_GRAPHICS_MAX_NUM_PATHS_REACHED = -1071774887
Global Const $STATUS_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION = -1071774886
Global Const $STATUS_GRAPHICS_INVALID_CLIENT_TYPE = -1071774885
Global Const $STATUS_GRAPHICS_CLIENTVIDPN_NOT_SET = -1071774884
Global Const $STATUS_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED = -1071774720
Global Const $STATUS_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED = -1071774719
Global Const $STATUS_GRAPHICS_NOT_A_LINKED_ADAPTER = -1071774672
Global Const $STATUS_GRAPHICS_LEADLINK_NOT_ENUMERATED = -1071774671
Global Const $STATUS_GRAPHICS_CHAINLINKS_NOT_ENUMERATED = -1071774670
Global Const $STATUS_GRAPHICS_ADAPTER_CHAIN_NOT_READY = -1071774669
Global Const $STATUS_GRAPHICS_CHAINLINKS_NOT_STARTED = -1071774668
Global Const $STATUS_GRAPHICS_CHAINLINKS_NOT_POWERED_ON = -1071774667
Global Const $STATUS_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE = -1071774666
Global Const $STATUS_GRAPHICS_NOT_POST_DEVICE_DRIVER = -1071774664
Global Const $STATUS_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED = -1071774661
Global Const $STATUS_GRAPHICS_OPM_NOT_SUPPORTED = -1071774464
Global Const $STATUS_GRAPHICS_COPP_NOT_SUPPORTED = -1071774463
Global Const $STATUS_GRAPHICS_UAB_NOT_SUPPORTED = -1071774462
Global Const $STATUS_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS = -1071774461
Global Const $STATUS_GRAPHICS_OPM_PARAMETER_ARRAY_TOO_SMALL = -1071774460
Global Const $STATUS_GRAPHICS_OPM_NO_PROTECTED_OUTPUTS_EXIST = -1071774459
Global Const $STATUS_GRAPHICS_PVP_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME = -1071774458
Global Const $STATUS_GRAPHICS_PVP_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP = -1071774457
Global Const $STATUS_GRAPHICS_PVP_MIRRORING_DEVICES_NOT_SUPPORTED = -1071774456
Global Const $STATUS_GRAPHICS_OPM_INVALID_POINTER = -1071774454
Global Const $STATUS_GRAPHICS_OPM_INTERNAL_ERROR = -1071774453
Global Const $STATUS_GRAPHICS_OPM_INVALID_HANDLE = -1071774452
Global Const $STATUS_GRAPHICS_PVP_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE = -1071774451
Global Const $STATUS_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH = -1071774450
Global Const $STATUS_GRAPHICS_OPM_SPANNING_MODE_ENABLED = -1071774449
Global Const $STATUS_GRAPHICS_OPM_THEATER_MODE_ENABLED = -1071774448
Global Const $STATUS_GRAPHICS_PVP_HFS_FAILED = -1071774447
Global Const $STATUS_GRAPHICS_OPM_INVALID_SRM = -1071774446
Global Const $STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP = -1071774445
Global Const $STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP = -1071774444
Global Const $STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA = -1071774443
Global Const $STATUS_GRAPHICS_OPM_HDCP_SRM_NEVER_SET = -1071774442
Global Const $STATUS_GRAPHICS_OPM_RESOLUTION_TOO_HIGH = -1071774441
Global Const $STATUS_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE = -1071774440
Global Const $STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_NO_LONGER_EXISTS = -1071774438
Global Const $STATUS_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS = -1071774437
Global Const $STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS = -1071774436
Global Const $STATUS_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST = -1071774435
Global Const $STATUS_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR = -1071774434
Global Const $STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS = -1071774433
Global Const $STATUS_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED = -1071774432
Global Const $STATUS_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST = -1071774431
Global Const $STATUS_GRAPHICS_I2C_NOT_SUPPORTED = -1071774336
Global Const $STATUS_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST = -1071774335
Global Const $STATUS_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA = -1071774334
Global Const $STATUS_GRAPHICS_I2C_ERROR_RECEIVING_DATA = -1071774333
Global Const $STATUS_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED = -1071774332
Global Const $STATUS_GRAPHICS_DDCCI_INVALID_DATA = -1071774331
Global Const $STATUS_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE = -1071774330
Global Const $STATUS_GRAPHICS_DDCCI_INVALID_CAPABILITIES_STRING = -1071774329
Global Const $STATUS_GRAPHICS_MCA_INTERNAL_ERROR = -1071774328
Global Const $STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND = -1071774327
Global Const $STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH = -1071774326
Global Const $STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM = -1071774325
Global Const $STATUS_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE = -1071774324
Global Const $STATUS_GRAPHICS_MONITOR_NO_LONGER_EXISTS = -1071774323
Global Const $STATUS_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED = -1071774240
Global Const $STATUS_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME = -1071774239
Global Const $STATUS_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP = -1071774238
Global Const $STATUS_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED = -1071774237
Global Const $STATUS_GRAPHICS_INVALID_POINTER = -1071774236
Global Const $STATUS_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE = -1071774235
Global Const $STATUS_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL = -1071774234
Global Const $STATUS_GRAPHICS_INTERNAL_ERROR = -1071774233
Global Const $STATUS_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS = -1071774232
Global Const $STATUS_FVE_LOCKED_VOLUME = -1071579136
Global Const $STATUS_FVE_NOT_ENCRYPTED = -1071579135
Global Const $STATUS_FVE_BAD_INFORMATION = -1071579134
Global Const $STATUS_FVE_TOO_SMALL = -1071579133
Global Const $STATUS_FVE_FAILED_WRONG_FS = -1071579132
Global Const $STATUS_FVE_FAILED_BAD_FS = -1071579131
Global Const $STATUS_FVE_FS_NOT_EXTENDED = -1071579130
Global Const $STATUS_FVE_FS_MOUNTED = -1071579129
Global Const $STATUS_FVE_NO_LICENSE = -1071579128
Global Const $STATUS_FVE_ACTION_NOT_ALLOWED = -1071579127
Global Const $STATUS_FVE_BAD_DATA = -1071579126
Global Const $STATUS_FVE_VOLUME_NOT_BOUND = -1071579125
Global Const $STATUS_FVE_NOT_DATA_VOLUME = -1071579124
Global Const $STATUS_FVE_CONV_READ_ERROR = -1071579123
Global Const $STATUS_FVE_CONV_WRITE_ERROR = -1071579122
Global Const $STATUS_FVE_OVERLAPPED_UPDATE = -1071579121
Global Const $STATUS_FVE_FAILED_SECTOR_SIZE = -1071579120
Global Const $STATUS_FVE_FAILED_AUTHENTICATION = -1071579119
Global Const $STATUS_FVE_NOT_OS_VOLUME = -1071579118
Global Const $STATUS_FVE_KEYFILE_NOT_FOUND = -1071579117
Global Const $STATUS_FVE_KEYFILE_INVALID = -1071579116
Global Const $STATUS_FVE_KEYFILE_NO_VMK = -1071579115
Global Const $STATUS_FVE_TPM_DISABLED = -1071579114
Global Const $STATUS_FVE_TPM_SRK_AUTH_NOT_ZERO = -1071579113
Global Const $STATUS_FVE_TPM_INVALID_PCR = -1071579112
Global Const $STATUS_FVE_TPM_NO_VMK = -1071579111
Global Const $STATUS_FVE_PIN_INVALID = -1071579110
Global Const $STATUS_FVE_AUTH_INVALID_APPLICATION = -1071579109
Global Const $STATUS_FVE_AUTH_INVALID_CONFIG = -1071579108
Global Const $STATUS_FVE_DEBUGGER_ENABLED = -1071579107
Global Const $STATUS_FVE_DRY_RUN_FAILED = -1071579106
Global Const $STATUS_FVE_BAD_METADATA_POINTER = -1071579105
Global Const $STATUS_FVE_OLD_METADATA_COPY = -1071579104
Global Const $STATUS_FVE_REBOOT_REQUIRED = -1071579103
Global Const $STATUS_FVE_RAW_ACCESS = -1071579102
Global Const $STATUS_FVE_RAW_BLOCKED = -1071579101
Global Const $STATUS_FVE_NO_FEATURE_LICENSE = -1071579098
Global Const $STATUS_FVE_POLICY_USER_DISABLE_RDV_NOT_ALLOWED = -1071579097
Global Const $STATUS_FVE_CONV_RECOVERY_FAILED = -1071579096
Global Const $STATUS_FVE_VIRTUALIZED_SPACE_TOO_BIG = -1071579095
Global Const $STATUS_FVE_VOLUME_TOO_SMALL = -1071579088
Global Const $STATUS_FWP_CALLOUT_NOT_FOUND = -1071513599
Global Const $STATUS_FWP_CONDITION_NOT_FOUND = -1071513598
Global Const $STATUS_FWP_FILTER_NOT_FOUND = -1071513597
Global Const $STATUS_FWP_LAYER_NOT_FOUND = -1071513596
Global Const $STATUS_FWP_PROVIDER_NOT_FOUND = -1071513595
Global Const $STATUS_FWP_PROVIDER_CONTEXT_NOT_FOUND = -1071513594
Global Const $STATUS_FWP_SUBLAYER_NOT_FOUND = -1071513593
Global Const $STATUS_FWP_NOT_FOUND = -1071513592
Global Const $STATUS_FWP_ALREADY_EXISTS = -1071513591
Global Const $STATUS_FWP_IN_USE = -1071513590
Global Const $STATUS_FWP_DYNAMIC_SESSION_IN_PROGRESS = -1071513589
Global Const $STATUS_FWP_WRONG_SESSION = -1071513588
Global Const $STATUS_FWP_NO_TXN_IN_PROGRESS = -1071513587
Global Const $STATUS_FWP_TXN_IN_PROGRESS = -1071513586
Global Const $STATUS_FWP_TXN_ABORTED = -1071513585
Global Const $STATUS_FWP_SESSION_ABORTED = -1071513584
Global Const $STATUS_FWP_INCOMPATIBLE_TXN = -1071513583
Global Const $STATUS_FWP_TIMEOUT = -1071513582
Global Const $STATUS_FWP_NET_EVENTS_DISABLED = -1071513581
Global Const $STATUS_FWP_INCOMPATIBLE_LAYER = -1071513580
Global Const $STATUS_FWP_KM_CLIENTS_ONLY = -1071513579
Global Const $STATUS_FWP_LIFETIME_MISMATCH = -1071513578
Global Const $STATUS_FWP_BUILTIN_OBJECT = -1071513577
Global Const $STATUS_FWP_TOO_MANY_BOOTTIME_FILTERS = -1071513576
Global Const $STATUS_FWP_TOO_MANY_CALLOUTS = -1071513576
Global Const $STATUS_FWP_NOTIFICATION_DROPPED = -1071513575
Global Const $STATUS_FWP_TRAFFIC_MISMATCH = -1071513574
Global Const $STATUS_FWP_INCOMPATIBLE_SA_STATE = -1071513573
Global Const $STATUS_FWP_NULL_POINTER = -1071513572
Global Const $STATUS_FWP_INVALID_ENUMERATOR = -1071513571
Global Const $STATUS_FWP_INVALID_FLAGS = -1071513570
Global Const $STATUS_FWP_INVALID_NET_MASK = -1071513569
Global Const $STATUS_FWP_INVALID_RANGE = -1071513568
Global Const $STATUS_FWP_INVALID_INTERVAL = -1071513567
Global Const $STATUS_FWP_ZERO_LENGTH_ARRAY = -1071513566
Global Const $STATUS_FWP_NULL_DISPLAY_NAME = -1071513565
Global Const $STATUS_FWP_INVALID_ACTION_TYPE = -1071513564
Global Const $STATUS_FWP_INVALID_WEIGHT = -1071513563
Global Const $STATUS_FWP_MATCH_TYPE_MISMATCH = -1071513562
Global Const $STATUS_FWP_TYPE_MISMATCH = -1071513561
Global Const $STATUS_FWP_OUT_OF_BOUNDS = -1071513560
Global Const $STATUS_FWP_RESERVED = -1071513559
Global Const $STATUS_FWP_DUPLICATE_CONDITION = -1071513558
Global Const $STATUS_FWP_DUPLICATE_KEYMOD = -1071513557
Global Const $STATUS_FWP_ACTION_INCOMPATIBLE_WITH_LAYER = -1071513556
Global Const $STATUS_FWP_ACTION_INCOMPATIBLE_WITH_SUBLAYER = -1071513555
Global Const $STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_LAYER = -1071513554
Global Const $STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_CALLOUT = -1071513553
Global Const $STATUS_FWP_INCOMPATIBLE_AUTH_METHOD = -1071513552
Global Const $STATUS_FWP_INCOMPATIBLE_DH_GROUP = -1071513551
Global Const $STATUS_FWP_EM_NOT_SUPPORTED = -1071513550
Global Const $STATUS_FWP_NEVER_MATCH = -1071513549
Global Const $STATUS_FWP_PROVIDER_CONTEXT_MISMATCH = -1071513548
Global Const $STATUS_FWP_INVALID_PARAMETER = -1071513547
Global Const $STATUS_FWP_TOO_MANY_SUBLAYERS = -1071513546
Global Const $STATUS_FWP_CALLOUT_NOTIFICATION_FAILED = -1071513545
Global Const $STATUS_FWP_INCOMPATIBLE_AUTH_CONFIG = -1071513544
Global Const $STATUS_FWP_INCOMPATIBLE_CIPHER_CONFIG = -1071513543
Global Const $STATUS_FWP_DUPLICATE_AUTH_METHOD = -1071513540
Global Const $STATUS_FWP_TCPIP_NOT_READY = -1071513344
Global Const $STATUS_FWP_INJECT_HANDLE_CLOSING = -1071513343
Global Const $STATUS_FWP_INJECT_HANDLE_STALE = -1071513342
Global Const $STATUS_FWP_CANNOT_PEND = -1071513341
Global Const $STATUS_NDIS_CLOSING = -1071448062
Global Const $STATUS_NDIS_BAD_VERSION = -1071448060
Global Const $STATUS_NDIS_BAD_CHARACTERISTICS = -1071448059
Global Const $STATUS_NDIS_ADAPTER_NOT_FOUND = -1071448058
Global Const $STATUS_NDIS_OPEN_FAILED = -1071448057
Global Const $STATUS_NDIS_DEVICE_FAILED = -1071448056
Global Const $STATUS_NDIS_MULTICAST_FULL = -1071448055
Global Const $STATUS_NDIS_MULTICAST_EXISTS = -1071448054
Global Const $STATUS_NDIS_MULTICAST_NOT_FOUND = -1071448053
Global Const $STATUS_NDIS_REQUEST_ABORTED = -1071448052
Global Const $STATUS_NDIS_RESET_IN_PROGRESS = -1071448051
Global Const $STATUS_NDIS_INVALID_PACKET = -1071448049
Global Const $STATUS_NDIS_INVALID_DEVICE_REQUEST = -1071448048
Global Const $STATUS_NDIS_ADAPTER_NOT_READY = -1071448047
Global Const $STATUS_NDIS_INVALID_LENGTH = -1071448044
Global Const $STATUS_NDIS_INVALID_DATA = -1071448043
Global Const $STATUS_NDIS_BUFFER_TOO_SHORT = -1071448042
Global Const $STATUS_NDIS_INVALID_OID = -1071448041
Global Const $STATUS_NDIS_ADAPTER_REMOVED = -1071448040
Global Const $STATUS_NDIS_UNSUPPORTED_MEDIA = -1071448039
Global Const $STATUS_NDIS_GROUP_ADDRESS_IN_USE = -1071448038
Global Const $STATUS_NDIS_FILE_NOT_FOUND = -1071448037
Global Const $STATUS_NDIS_ERROR_READING_FILE = -1071448036
Global Const $STATUS_NDIS_ALREADY_MAPPED = -1071448035
Global Const $STATUS_NDIS_RESOURCE_CONFLICT = -1071448034
Global Const $STATUS_NDIS_MEDIA_DISCONNECTED = -1071448033
Global Const $STATUS_NDIS_INVALID_ADDRESS = -1071448030
Global Const $STATUS_NDIS_PAUSED = -1071448022
Global Const $STATUS_NDIS_INTERFACE_NOT_FOUND = -1071448021
Global Const $STATUS_NDIS_UNSUPPORTED_REVISION = -1071448020
Global Const $STATUS_NDIS_INVALID_PORT = -1071448019
Global Const $STATUS_NDIS_INVALID_PORT_STATE = -1071448018
Global Const $STATUS_NDIS_LOW_POWER_STATE = -1071448017
Global Const $STATUS_NDIS_NOT_SUPPORTED = -1071447877
Global Const $STATUS_NDIS_OFFLOAD_POLICY = -1071443953
Global Const $STATUS_NDIS_OFFLOAD_CONNECTION_REJECTED = -1071443950
Global Const $STATUS_NDIS_OFFLOAD_PATH_REJECTED = -1071443949
Global Const $STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED = -1071439872
Global Const $STATUS_NDIS_DOT11_MEDIA_IN_USE = -1071439871
Global Const $STATUS_NDIS_DOT11_POWER_STATE_INVALID = -1071439870
Global Const $STATUS_NDIS_PM_WOL_PATTERN_LIST_FULL = -1071439869
Global Const $STATUS_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL = -1071439868
Global Const $STATUS_IPSEC_BAD_SPI = -1070202879
Global Const $STATUS_IPSEC_SA_LIFETIME_EXPIRED = -1070202878
Global Const $STATUS_IPSEC_WRONG_SA = -1070202877
Global Const $STATUS_IPSEC_REPLAY_CHECK_FAILED = -1070202876
Global Const $STATUS_IPSEC_INVALID_PACKET = -1070202875
Global Const $STATUS_IPSEC_INTEGRITY_CHECK_FAILED = -1070202874
Global Const $STATUS_IPSEC_CLEAR_TEXT_DROP = -1070202873
Global Const $STATUS_IPSEC_AUTH_FIREWALL_DROP = -1070202872
Global Const $STATUS_IPSEC_THROTTLE_DROP = -1070202871
Global Const $STATUS_IPSEC_DOSP_BLOCK = -1070170112
Global Const $STATUS_IPSEC_DOSP_RECEIVED_MULTICAST = -1070170111
Global Const $STATUS_IPSEC_DOSP_INVALID_PACKET = -1070170110
Global Const $STATUS_IPSEC_DOSP_STATE_LOOKUP_FAILED = -1070170109
Global Const $STATUS_IPSEC_DOSP_MAX_ENTRIES = -1070170108
Global Const $STATUS_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = -1070170107
Global Const $STATUS_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = -1070170106
Global Const $STATUS_VOLMGR_MIRROR_NOT_SUPPORTED = -1070071717
Global Const $STATUS_VOLMGR_RAID5_NOT_SUPPORTED = -1070071716
Global Const $STATUS_VIRTDISK_PROVIDER_NOT_FOUND = -1069940716
Global Const $STATUS_VIRTDISK_NOT_VIRTUAL_DISK = -1069940715
Global Const $STATUS_VHD_PARENT_VHD_ACCESS_DENIED = -1069940714
Global Const $STATUS_VHD_CHILD_PARENT_SIZE_MISMATCH = -1069940713
Global Const $STATUS_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED = -1069940712
Global Const $STATUS_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT = -1069940711
Func _ProcessGetName($ipid)
    Local $aprocesslist = ProcessList()
    For $i = 0x1 To UBound($aprocesslist) + -1
        If $aprocesslist[$i][0x1] = $ipid Then
            Return $aprocesslist[$i][0x0]
        EndIf
    Next
    Return SetError(0x1, 0x0, '')
EndFunc    ; -> _ProcessGetName

Func _ProcessGetPriority($vprocess)
    Local $ierror = 0x0, $iextended = 0x0, $ireturn = + -1
    Local $ipid = ProcessExists($vprocess)
    If Not $ipid Then Return SetError(0x1, 0x0, + -1)
    Local $hdll = DllOpen("kernel32.dll")
    Do
        Local $aprocesshandle = DllCall($hdll, "handle", "OpenProcess", "dword", $PROCESS_QUERY_INFORMATION, "bool", False, "dword", $ipid)
        If @error Then
            $ierror = @error + 0xa
            $iextended = @extended
            ExitLoop
        EndIf
        If Not $aprocesshandle[0x0] Then ExitLoop
        Local $apriority = DllCall($hdll, "dword", "GetPriorityClass", "handle", $aprocesshandle[0x0])
        If @error Then
            $ierror = @error
            $iextended = @extended
        EndIf
        DllCall($hdll, "bool", "CloseHandle", "handle", $aprocesshandle[0x0])
        If $ierror Then ExitLoop
        Switch $apriority[0x0]
        Case 0x40
            $ireturn = 0x0
        Case 0x4000
            $ireturn = 0x1
        Case 0x20
            $ireturn = 0x2
        Case 0x8000
            $ireturn = 0x3
        Case 0x80
            $ireturn = 0x4
        Case 0x100
            $ireturn = 0x5
        Case Else
            $ierror = 0x1
            $iextended = $apriority[0x0]
            $ireturn = + -1
        EndSwitch
    Until True
    DllClose($hdll)
    Return SetError($ierror, $iextended, $ireturn)
EndFunc    ; -> _ProcessGetPriority

Func _RunDos($scommand)
    Local $iresult = RunWait(@ComSpec & " /C " & $scommand, '', @SW_HIDE)
    Return SetError(@error, @extended, $iresult)
EndFunc    ; -> _RunDos

Global $__g_ibmpformat = $GDIP_PXF24RGB
Global $__g_ijpgquality = 0x64
Global $__g_itifcolordepth = 0x18
Global $__g_itifcompression = $GDIP_EVTCOMPRESSIONLZW
Global Const $__SCREENCAPTURECONSTANT_SM_CXSCREEN = 0x0
Global Const $__SCREENCAPTURECONSTANT_SM_CYSCREEN = 0x1
Global Const $__SCREENCAPTURECONSTANT_SRCCOPY = 0xcc0020
Func _ScreenCapture_Capture($sfilename = '', $ileft = 0x0, $itop = 0x0, $iright = + -1, $ibottom = + -1, $bcursor = True)
    Local $bret = False
    If $iright = + -1 Then $iright = _WinAPI_GetSystemMetrics($__SCREENCAPTURECONSTANT_SM_CXSCREEN) + -1
    If $ibottom = + -1 Then $ibottom = _WinAPI_GetSystemMetrics($__SCREENCAPTURECONSTANT_SM_CYSCREEN) + -1
    If $iright < $ileft Then Return SetError(+ -1, 0x0, $bret)
    If $ibottom < $itop Then Return SetError(+ -2, 0x0, $bret)
    Local $iw = ($iright - $ileft) + 0x1
    Local $ih = ($ibottom - $itop) + 0x1
    Local $hwnd = _WinAPI_GetDesktopWindow()
    Local $hddc = _WinAPI_GetDC($hwnd)
    Local $hcdc = _WinAPI_CreateCompatibleDC($hddc)
    Local $hbmp = _WinAPI_CreateCompatibleBitmap($hddc, $iw, $ih)
    _WinAPI_SelectObject($hcdc, $hbmp)
    _WinAPI_BitBlt($hcdc, 0x0, 0x0, $iw, $ih, $hddc, $ileft, $itop, $__SCREENCAPTURECONSTANT_SRCCOPY)
    If $bcursor Then
        Local $acursor = _WinAPI_GetCursorInfo()
        If Not @error And $acursor[0x1] Then
            $bcursor = True
            Local $hicon = _WinAPI_CopyIcon($acursor[0x2])
            Local $aicon = _WinAPI_GetIconInfo($hicon)
            If Not @error Then
                _WinAPI_DeleteObject($aicon[0x4])
                If $aicon[0x5] <> 0x0 Then _WinAPI_DeleteObject($aicon[0x5])
                _WinAPI_DrawIcon($hcdc, $acursor[0x3] - $aicon[0x2] - $ileft, $acursor[0x4] - $aicon[0x3] - $itop, $hicon)
            EndIf
            _WinAPI_DestroyIcon($hicon)
        EndIf
    EndIf
    _WinAPI_ReleaseDC($hwnd, $hddc)
    _WinAPI_DeleteDC($hcdc)
    If $sfilename = '' Then Return $hbmp
    $bret = _ScreenCapture_SaveImage($sfilename, $hbmp, True)
    Return SetError(@error, @extended, $bret)
EndFunc    ; -> _ScreenCapture_Capture

Func _ScreenCapture_CaptureWnd($sfilename, $hwnd, $ileft = 0x0, $itop = 0x0, $iright = + -1, $ibottom = + -1, $bcursor = True)
    If Not IsHWnd($hwnd) Then $hwnd = WinGetHandle($hwnd)
    Local $trect = DllStructCreate($TAGRECT)
    Local Const $DWMWA_EXTENDED_FRAME_BOUNDS = 0x9
    Local $bret = DllCall("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $hwnd, "dword", $DWMWA_EXTENDED_FRAME_BOUNDS, "struct*", $trect, "dword", DllStructGetSize($trect))
    If (@error Or $bret[0x0] Or (Abs(DllStructGetData($trect, "Left")) + Abs(DllStructGetData($trect, "Top")) + Abs(DllStructGetData($trect, "Right")) + Abs(DllStructGetData($trect, "Bottom"))) = 0x0) Then
        $trect = _WinAPI_GetWindowRect($hwnd)
        If @error Then Return SetError(@error + 0xa, @extended, False)
    EndIf
    $ileft += DllStructGetData($trect, "Left")
    $itop += DllStructGetData($trect, "Top")
    If $iright = + -1 Then $iright = DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left") + -1
    If $ibottom = + -1 Then $ibottom = DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top") + -1
    $iright += DllStructGetData($trect, "Left")
    $ibottom += DllStructGetData($trect, "Top")
    If $ileft > DllStructGetData($trect, "Right") Then $ileft = DllStructGetData($trect, "Left")
    If $itop > DllStructGetData($trect, "Bottom") Then $itop = DllStructGetData($trect, "Top")
    If $iright > DllStructGetData($trect, "Right") Then $iright = DllStructGetData($trect, "Right") + -1
    If $ibottom > DllStructGetData($trect, "Bottom") Then $ibottom = DllStructGetData($trect, "Bottom") + -1
    $bret = _ScreenCapture_Capture($sfilename, $ileft, $itop, $iright, $ibottom, $bcursor)
    Return SetError(@error, @extended, $bret)
EndFunc    ; -> _ScreenCapture_CaptureWnd

Func _ScreenCapture_SaveImage($sfilename, $hbitmap, $bfreebmp = True)
    _GDIPlus_Startup()
    If @error Then Return SetError(+ -1, + -1, False)
    Local $sext = StringUpper(__GDIPlus_ExtractFileExt($sfilename))
    Local $sclsid = _GDIPlus_EncodersGetCLSID($sext)
    If $sclsid = '' Then Return SetError(+ -2, + -2, False)
    Local $himage = _GDIPlus_BitmapCreateFromHBITMAP($hbitmap)
    If @error Then Return SetError(+ -3, + -3, False)
    Local $tdata, $tparams
    Switch $sext
    Case "BMP"
        Local $ix = _GDIPlus_ImageGetWidth($himage)
        Local $iy = _GDIPlus_ImageGetHeight($himage)
        Local $hclone = _GDIPlus_BitmapCloneArea($himage, 0x0, 0x0, $ix, $iy, $__g_ibmpformat)
        _GDIPlus_ImageDispose($himage)
        $himage = $hclone
    Case "JPG", "JPEG"
        $tparams = _GDIPlus_ParamInit(0x1)
        $tdata = DllStructCreate("int Quality")
        DllStructSetData($tdata, "Quality", $__g_ijpgquality)
        _GDIPlus_ParamAdd($tparams, $GDIP_EPGQUALITY, 0x1, $GDIP_EPTLONG, DllStructGetPtr($tdata))
    Case "TIF", "TIFF"
        $tparams = _GDIPlus_ParamInit(0x2)
        $tdata = DllStructCreate("int ColorDepth;int Compression")
        DllStructSetData($tdata, "ColorDepth", $__g_itifcolordepth)
        DllStructSetData($tdata, "Compression", $__g_itifcompression)
        _GDIPlus_ParamAdd($tparams, $GDIP_EPGCOLORDEPTH, 0x1, $GDIP_EPTLONG, DllStructGetPtr($tdata, "ColorDepth"))
        _GDIPlus_ParamAdd($tparams, $GDIP_EPGCOMPRESSION, 0x1, $GDIP_EPTLONG, DllStructGetPtr($tdata, "Compression"))
    EndSwitch
    Local $pparams = 0x0
    If IsDllStruct($tparams) Then $pparams = $tparams
    Local $bret = _GDIPlus_ImageSaveToFileEx($himage, $sfilename, $sclsid, $pparams)
    _GDIPlus_ImageDispose($himage)
    If $bfreebmp Then _WinAPI_DeleteObject($hbitmap)
    _GDIPlus_Shutdown()
    Return SetError($bret = False, 0x0, $bret)
EndFunc    ; -> _ScreenCapture_SaveImage

Func _ScreenCapture_SetBMPFormat($iformat)
    Switch $iformat
    Case 0x0
        $__g_ibmpformat = $GDIP_PXF16RGB555
    Case 0x1
        $__g_ibmpformat = $GDIP_PXF16RGB565
    Case 0x2
        $__g_ibmpformat = $GDIP_PXF24RGB
    Case 0x3
        $__g_ibmpformat = $GDIP_PXF32RGB
    Case 0x4
        $__g_ibmpformat = $GDIP_PXF32ARGB
    Case Else
        $__g_ibmpformat = $GDIP_PXF24RGB
    EndSwitch
EndFunc    ; -> _ScreenCapture_SetBMPFormat

Func _ScreenCapture_SetJPGQuality($iquality)
    If $iquality < 0x0 Then $iquality = 0x0
    If $iquality > 0x64 Then $iquality = 0x64
    $__g_ijpgquality = $iquality
EndFunc    ; -> _ScreenCapture_SetJPGQuality

Func _ScreenCapture_SetTIFColorDepth($idepth)
    Switch $idepth
    Case 0x18
        $__g_itifcolordepth = 0x18
    Case 0x20
        $__g_itifcolordepth = 0x20
    Case Else
        $__g_itifcolordepth = 0x0
    EndSwitch
EndFunc    ; -> _ScreenCapture_SetTIFColorDepth

Func _ScreenCapture_SetTIFCompression($icompress)
    Switch $icompress
    Case 0x1
        $__g_itifcompression = $GDIP_EVTCOMPRESSIONNONE
    Case 0x2
        $__g_itifcompression = $GDIP_EVTCOMPRESSIONLZW
    Case Else
        $__g_itifcompression = 0x0
    EndSwitch
EndFunc    ; -> _ScreenCapture_SetTIFCompression

Global Const $__SOUNDCONSTANT_SNDID_MARKER = 0x49442d2d
Func _SoundOpen($sfilepath)
    If Not FileExists($sfilepath) Then Return SetError(0x2, 0x0, 0x0)
    Local $asndid[0x4]
    For $i = 0x1 To 0xa
        $asndid[0x0]&= Chr(Random(0x61, 0x7a, 0x1))
    Next
    Local $sdrive, $sdir, $sfname, $sext
    _PathSplit($sfilepath, $sdrive, $sdir, $sfname, $sext)
    Local $ssnddirname
    If $sdrive = '' Then
        $ssnddirname = @WorkingDir & "\\"
    Else
        $ssnddirname = $sdrive & $sdir
    EndIf
    Local $ssndfilename = $sfname & $sext
    Local $ssnddirshortname = FileGetShortName($ssnddirname, 0x1)
    __SoundMciSendString("open """ & $sfilepath & """ alias " & $asndid[0x0])
    If @error Then Return SetError(0x1, @error, 0x0)
    Local $stracklength, $btrynextmethod = False
    Local $oshell = ObjCreate("shell.application")
    If IsObj($oshell) Then
        Local $oshelldir = $oshell.NameSpace($ssnddirshortname)
        If IsObj($oshelldir) Then
            Local $oshelldirfile = $oshelldir.Parsename($ssndfilename)
            If IsObj($oshelldirfile) Then
                Local $sraw = $oshelldir.GetDetailsOf($oshelldirfile, + -1)
                Local $ainfo = StringRegExp($sraw, ": ([0-9]{2}:[0-9]{2}:[0-9]{2})", $STR_REGEXPARRAYGLOBALMATCH)
                If Not IsArray($ainfo) Then
                    $btrynextmethod = True
                Else
                    $stracklength = $ainfo[0x0]
                EndIf
            Else
                $btrynextmethod = True
            EndIf
        Else
            $btrynextmethod = True
        EndIf
    Else
        $btrynextmethod = True
    EndIf
    Local $stag
    If $btrynextmethod Then
        $btrynextmethod = False
        If $sext = ".mp3" Then
            Local $hfile = FileOpen(FileGetShortName($ssnddirname & $ssndfilename), $FO_READ)
            $stag = FileRead($hfile, 0x1424)
            FileClose($hfile)
            $stracklength = __SoundReadXingFromMP3($stag)
            If @error Then $btrynextmethod = True
        Else
            $btrynextmethod = True
        EndIf
    EndIf
    If $btrynextmethod Then
        $btrynextmethod = False
        If $sext = ".mp3" Then
            $stracklength = __SoundReadTLENFromMP3($stag)
            If @error Then $btrynextmethod = True
        Else
            $btrynextmethod = True
        EndIf
    EndIf
    If $btrynextmethod Then
        $btrynextmethod = False
        __SoundMciSendString("set " & $asndid[0x0] & " time format milliseconds")
        Local $isndlenms = __SoundMciSendString("status " & $asndid[0x0] & " length", 0xff)
        Local $isndlenmin, $isndlenhour, $isndlensecs
        __SoundTicksToTime($isndlenms, $isndlenhour, $isndlenmin, $isndlensecs)
        $stracklength = StringFormat("%02i:%02i:%02i", $isndlenhour, $isndlenmin, $isndlensecs)
    EndIf
    Local $aitime = StringSplit($stracklength, ":")
    Local $iactualticks = __SoundTimeToTicks($aitime[0x1], $aitime[0x2], $aitime[0x3])
    __SoundMciSendString("set " & $asndid[0x0] & " time format milliseconds")
    Local $isoundticks = __SoundMciSendString("status " & $asndid[0x0] & " length", 0xff)
    Local $ivbrratio
    If Abs($isoundticks - $iactualticks) < 0x3e8 Then
        $ivbrratio = 0x0
    Else
        $ivbrratio = $isoundticks / $iactualticks
    EndIf
    $asndid[0x1] = $ivbrratio
    $asndid[0x2] = 0x0
    $asndid[0x3] = $__SOUNDCONSTANT_SNDID_MARKER
    Return $asndid
EndFunc    ; -> _SoundOpen

Func _SoundClose($asndid)
    If Not IsArray($asndid) Or Not __SoundChkSndID($asndid) Then Return SetError(0x3, 0x0, 0x0)
    __SoundMciSendString("close " & $asndid[0x0])
    If @error Then Return SetError(0x1, @error, 0x0)
    Return 0x1
EndFunc    ; -> _SoundClose

Func _SoundPlay($asndid, $iwait = 0x0)
    If $iwait <> 0x0 And $iwait <> 0x1 Then Return SetError(0x2, 0x0, 0x0)
    If Not __SoundChkSndID($asndid) Then Return SetError(0x3, 0x0, 0x0)
    If _SoundPos($asndid, 0x2) = _SoundLength($asndid, 0x2) Then __SoundMciSendString("seek " & $asndid[0x0] & " to start")
    If $iwait = 0x1 Then
        __SoundMciSendString("play " & $asndid[0x0] & " wait")
    Else
        __SoundMciSendString("play " & $asndid[0x0])
    EndIf
    If @error Then Return SetError(0x1, @error, 0x0)
    Return 0x1
EndFunc    ; -> _SoundPlay

Func _SoundStop(ByRef $asndid)
    Local $vtemp = $asndid
    If Not __SoundChkSndID($vtemp) Then Return SetError(0x3, 0x0, 0x0)
    If IsArray($asndid) Then $asndid[0x2] = 0x0
    __SoundMciSendString("stop " & $vtemp[0x0])
    If @error Then Return SetError(0x2, @error, 0x0)
    __SoundMciSendString("seek " & $vtemp[0x0] & " to start")
    If @error Then Return SetError(0x1, @error, 0x0)
    Return 0x1
EndFunc    ; -> _SoundStop

Func _SoundPause($asndid)
    If Not __SoundChkSndID($asndid) Then Return SetError(0x3, 0x0, 0x0)
    __SoundMciSendString("pause " & $asndid[0x0])
    If @error Then Return SetError(0x1, @error, 0x0)
    Return 0x1
EndFunc    ; -> _SoundPause

Func _SoundResume($asndid)
    If Not __SoundChkSndID($asndid) Then Return SetError(0x3, 0x0, 0x0)
    __SoundMciSendString("resume " & $asndid[0x0])
    If @error Then Return SetError(0x1, @error, 0x0)
    Return 0x1
EndFunc    ; -> _SoundResume

Func _SoundLength($asndid, $imode = 0x1)
    If $imode <> 0x1 And $imode <> 0x2 Then Return SetError(0x1, 0x0, 0x0)
    Local $bfile = False
    If Not IsArray($asndid) Then
        If Not FileExists($asndid) Then Return SetError(0x3, 0x0, 0x0)
        $bfile = True
        $asndid = _SoundOpen($asndid)
    Else
        If Not __SoundChkSndID($asndid) Then Return SetError(0x3, 0x0, 0x0)
    EndIf
    __SoundMciSendString("set " & $asndid[0x0] & " time format milliseconds")
    Local $isndlenms = Number(__SoundMciSendString("status " & $asndid[0x0] & " length", 0xff))
    If $asndid[0x1] <> 0x0 Then $isndlenms = Round($isndlenms / $asndid[0x1])
    If $bfile Then _SoundClose($asndid)
    If $imode = 0x2 Then Return $isndlenms
    Local $isndlenmin, $isndlenhour, $isndlensecs
    __SoundTicksToTime($isndlenms, $isndlenhour, $isndlenmin, $isndlensecs)
    Local $ssndlenformat = StringFormat("%02i:%02i:%02i", $isndlenhour, $isndlenmin, $isndlensecs)
    Return $ssndlenformat
EndFunc    ; -> _SoundLength

Func _SoundSeek(ByRef $asndid, $ihour, $imin, $isec)
    If Not IsArray($asndid) Or Not __SoundChkSndID($asndid) Then Return SetError(0x3, 0x0, 0x0)
    __SoundMciSendString("set " & $asndid[0x0] & " time format milliseconds")
    Local $ims = $isec * 0x3e8
    $ims += $imin * 0x3c * 0x3e8
    $ims += $ihour * 0x3c * 0x3c * 0x3e8
    If $asndid[0x1] <> 0x0 Then
        $asndid[0x2] = Round($ims * $asndid[0x1]) - $ims
        $ims = Round($ims * $asndid[0x1])
    EndIf
    __SoundMciSendString("seek " & $asndid[0x0] & " to " & $ims)
    Local $ierror = @error
    If _SoundPos($asndid, 0x2) < 0x0 Then $asndid[0x2] = 0x0
    If $ierror Then Return SetError(0x1, $ierror, 0x0)
    Return 0x1
EndFunc    ; -> _SoundSeek

Func _SoundStatus($asndid)
    If Not __SoundChkSndID($asndid) Then Return SetError(0x3, 0x0, 0x0)
    Return __SoundMciSendString("status " & $asndid[0x0] & " mode", 0xff)
EndFunc    ; -> _SoundStatus

Func _SoundPos($asndid, $imode = 0x1)
    If $imode <> 0x1 And $imode <> 0x2 Then Return SetError(0x1, 0x0, 0x0)
    If Not __SoundChkSndID($asndid) Then Return SetError(0x3, 0x0, 0x0)
    __SoundMciSendString("set " & $asndid[0x0] & " time format milliseconds")
    Local $isndposms = Number(__SoundMciSendString("status " & $asndid[0x0] & " position", 0xff))
    If $asndid[0x1] <> 0x0 Then
        $isndposms -= $asndid[0x2]
    EndIf
    If $imode = 0x2 Then Return $isndposms
    Local $isndposmin, $isndposhour, $isndpossecs
    __SoundTicksToTime($isndposms, $isndposhour, $isndposmin, $isndpossecs)
    Local $ssndposhms = StringFormat("%02i:%02i:%02i", $isndposhour, $isndposmin, $isndpossecs)
    Return $ssndposhms
EndFunc    ; -> _SoundPos

Func __SoundChkSndID(ByRef $asndid)
    If Not IsArray($asndid) Then
        If Not FileExists($asndid) Then Return 0x0
        Local $vtemp = FileGetShortName($asndid)
        Dim $asndid[0x4] = [$vtemp, 0x0, 0x0, $__SOUNDCONSTANT_SNDID_MARKER]
    Else
        If UBound($asndid) <> 0x4 And $asndid[0x3] <> $__SOUNDCONSTANT_SNDID_MARKER Then Return 0x0
    EndIf
    Return 0x1
EndFunc    ; -> __SoundChkSndID

Func __SoundMciSendString($sstring, $ilen = 0x0)
    Local $acall = DllCall("winmm.dll", "dword", "mciSendStringW", "wstr", $sstring, "wstr", '', "uint", $ilen, "ptr", 0x0)
    If @error Then Return SetError(@error, @extended, '')
    If $acall[0x0] Then Return SetError(0xa, $acall[0x0], $acall[0x2])
    Return $acall[0x2]
EndFunc    ; -> __SoundMciSendString

Func __SoundReadTLENFromMP3($stag)
    If StringLeft($stag, 0xa) <> "0x49443303" Then Return SetError(0x1, 0x0, 0x0)
    Local $itemp = StringInStr($stag, "544C454E") + 0x15
    $stag = StringTrimLeft($stag, $itemp)
    Local $stemp = ''
    For $i = 0x1 To 0x20 Step 0x2
        If StringMid($stag, $i, 0x2) = "00" Then
            ExitLoop
        Else
            $stemp &= StringMid($stag, $i, 0x2)
        EndIf
    Next
    Local $ilengthms = Number(BinaryToString("0x" & $stemp))
    If $ilengthms <= 0x0 Then Return SetError(0x1, 0x0, 0x0)
    Local $ilengthhour, $ilengthmin, $ilengthsecs
    __SoundTicksToTime($ilengthms, $ilengthhour, $ilengthmin, $ilengthsecs)
    Return StringFormat("%02i:%02i:%02i", $ilengthhour, $ilengthmin, $ilengthsecs)
EndFunc    ; -> __SoundReadTLENFromMP3

Func __SoundReadXingFromMP3($stag)
    Local $ixingpos = StringInStr($stag, "58696E67")
    If $ixingpos = 0x0 Then Return SetError(0x1, 0x0, 0x0)
    Local $iframes, $IFLAGS = Number("0x" & StringMid($stag, $ixingpos + 0xe, 0x2))
    If BitAND($IFLAGS, 0x1) = 0x1 Then
        $iframes = Number("0x" & StringMid($stag, $ixingpos + 0x10, 0x8))
    Else
        Return SetError(0x1, 0x0, 0x0)
    EndIf
    Local $SHEADER = StringMid($stag, $ixingpos + -72, 0x8)
    Local $impegbyte = Number("0x" & StringMid($SHEADER, 0x4, 0x1))
    Local $ifreqbyte = Number("0x" & StringMid($SHEADER, 0x6, 0x1))
    Local $impegver = BitAND($impegbyte, 0x8)
    Local $ilayernum = BitAND($impegbyte, 0x6)
    Local $isamples
    Switch $ilayernum
    Case 0x6
        $isamples = 0x180
    Case 0x4
        $isamples = 0x480
    Case 0x2
        Switch $impegver
        Case 0x8
            $isamples = 0x480
        Case 0x0
            $isamples = 0x240
        Case Else
            $isamples = 0x0
        EndSwitch
    Case Else
        $isamples = 0x0
    EndSwitch
    If $isamples = 0x0 Then Return SetError(0x1, 0x0, 0x0)
    Local $ifrequency, $ifreqnum = BitAND($ifreqbyte, 0xc)
    Switch $ifreqnum
    Case 0x0
        $ifrequency = 0xac44
    Case 0x4
        $ifrequency = 0xbb80
    Case 0x8
        $ifrequency = 0x7d00
    Case Else
        $ifrequency = 0x0
    EndSwitch
    If $ifrequency = 0x0 Then Return SetError(0x1, 0x0, 0x0)
    If $impegver = 0x0 Then $ifrequency = $ifrequency / 0x2
    Local $ilengthms = Int(($iframes * $isamples / $ifrequency) * 0x3e8)
    Local $ilengthhours, $ilengthmins, $ilengthsecs
    __SoundTicksToTime($ilengthms, $ilengthhours, $ilengthmins, $ilengthsecs)
    Return StringFormat("%02i:%02i:%02i", $ilengthhours, $ilengthmins, $ilengthsecs)
EndFunc    ; -> __SoundReadXingFromMP3

Func __SoundTicksToTime($iticks, ByRef $ihours, ByRef $imins, ByRef $isecs)
    If Number($iticks) < 0x0 Then Return SetError(0x1, 0x0, 0x0)
    If Number($iticks) = 0x0 Then
        $ihours = 0x0
        $iticks = 0x0
        $imins = 0x0
        $isecs = 0x0
        Return 0x1
    EndIf
    $iticks = Round($iticks / 0x3e8)
    $ihours = Int($iticks / 0xe10)
    $iticks = Mod($iticks, 0xe10)
    $imins = Int($iticks / 0x3c)
    $isecs = Round(Mod($iticks, 0x3c))
    Return 0x1
EndFunc    ; -> __SoundTicksToTime

Func __SoundTimeToTicks($ihours = @HOUR, $imins = @MIN, $isecs = @SEC)
    If Not (StringIsInt($ihours) And StringIsInt($imins) And StringIsInt($isecs)) Then Return SetError(0x1, 0x0, 0x0)
    Return 0x3e8 * ((0xe10 * $ihours) + (0x3c * $imins) + $isecs)
EndFunc    ; -> __SoundTimeToTicks

#ignorefunc __SQLite_Inline_Version, __SQLite_Inline_Modified
Global $__g_hdll_sqlite = 0x0
Global $__g_hdb_sqlite = 0x0
Global $__g_butf8errormsg_sqlite = False
Global $__g_hprintcallback_sqlite = __SQLite_ConsoleWrite
Global $__g_bsafemodestate_sqlite = True
Global $__g_ahdbs_sqlite[0x1] = ['']
Global $__g_ahquerys_sqlite[0x1] = ['']
Global $__g_hmsvcrtdll_sqlite = 0x0
Global $__g_bautoittype_sqlite = False
Global Const $SQLITE_OK = 0x0
Global Const $SQLITE_ERROR = 0x1
Global Const $SQLITE_INTERNAL = 0x2
Global Const $SQLITE_PERM = 0x3
Global Const $SQLITE_ABORT = 0x4
Global Const $SQLITE_BUSY = 0x5
Global Const $SQLITE_LOCKED = 0x6
Global Const $SQLITE_NOMEM = 0x7
Global Const $SQLITE_READONLY = 0x8
Global Const $SQLITE_INTERRUPT = 0x9
Global Const $SQLITE_IOERR = 0xa
Global Const $SQLITE_CORRUPT = 0xb
Global Const $SQLITE_NOTFOUND = 0xc
Global Const $SQLITE_FULL = 0xd
Global Const $SQLITE_CANTOPEN = 0xe
Global Const $SQLITE_PROTOCOL = 0xf
Global Const $SQLITE_EMPTY = 0x10
Global Const $SQLITE_SCHEMA = 0x11
Global Const $SQLITE_TOOBIG = 0x12
Global Const $SQLITE_CONSTRAINT = 0x13
Global Const $SQLITE_MISMATCH = 0x14
Global Const $SQLITE_MISUSE = 0x15
Global Const $SQLITE_NOLFS = 0x16
Global Const $SQLITE_AUTH = 0x17
Global Const $SQLITE_ROW = 0x64
Global Const $SQLITE_DONE = 0x65
Global Const $SQLITE_OPEN_READONLY = 0x1
Global Const $SQLITE_OPEN_READWRITE = 0x2
Global Const $SQLITE_OPEN_CREATE = 0x4
Global Const $SQLITE_ENCODING_UTF8 = 0x0
Global Const $SQLITE_ENCODING_UTF16 = 0x1
Global Const $SQLITE_ENCODING_UTF16BE = 0x2
Global Const $SQLITE_TYPE_INTEGER = 0x1
Global Const $SQLITE_TYPE_FLOAT = 0x2
Global Const $SQLITE_TYPE_TEXT = 0x3
Global Const $SQLITE_TYPE_BLOB = 0x4
Global Const $SQLITE_TYPE_NULL = 0x5
Func _SQLite_Startup($sdll_filename = '', $butf8errormsg = False, $iforcelocal = 0x0, $hprintcallback = $__g_hprintcallback_sqlite, $bautoittypeconversion = False)
    If $sdll_filename = Default Or $sdll_filename = + -1 Then $sdll_filename = ''
    If $hprintcallback = Default Then $hprintcallback = __SQLite_ConsoleWrite
    $__g_hprintcallback_sqlite = $hprintcallback
    If $butf8errormsg = Default Then $butf8errormsg = False
    $__g_butf8errormsg_sqlite = $butf8errormsg
    If $sdll_filename = '' Then $sdll_filename = "sqlite3.dll"
    If @AutoItX64 And (StringInStr($sdll_filename, "_x64") = 0x0) Then $sdll_filename = StringReplace($sdll_filename, ".dll", "_x64.dll")
    Local $iextended = 0x0
    If Int($iforcelocal) < 0x1 Then
        $sdll_filename = __sqlite_getdownloadedpath($sdll_filename) & $sdll_filename
        $iextended = @extended
    EndIf
    Local $hdll = DllOpen($sdll_filename)
    If $hdll = + -1 Then
        $__g_hdll_sqlite = 0x0
        Return SetError(0x1, $iextended, '')
    Else
        $__g_hdll_sqlite = $hdll
        Return SetExtended($iextended, $sdll_filename)
    EndIf
    $__g_bautoittype_sqlite = $bautoittypeconversion
EndFunc    ; -> _SQLite_Startup

Func _SQLite_Shutdown()
    If $__g_hdll_sqlite > 0x0 Then DllClose($__g_hdll_sqlite)
    $__g_hdll_sqlite = 0x0
    If $__g_hmsvcrtdll_sqlite > 0x0 Then DllClose($__g_hmsvcrtdll_sqlite)
    $__g_hmsvcrtdll_sqlite = 0x0
EndFunc    ; -> _SQLite_Shutdown

Func _SQLite_Open($sdatabase_filename = Default, $iaccessmode = Default, $iencoding = Default)
    If Not $__g_hdll_sqlite Then Return SetError(0x3, $SQLITE_MISUSE, 0x0)
    If $sdatabase_filename = Default Or Not IsString($sdatabase_filename) Then $sdatabase_filename = ":memory:"
    Local $tfilename = __SQLite_StringToUtf8Struct($sdatabase_filename)
    If @error Then Return SetError(0x2, @error, 0x0)
    If $iaccessmode = Default Then $iaccessmode = BitOR($SQLITE_OPEN_READWRITE, $SQLITE_OPEN_CREATE)
    Local $boldbase = FileExists($sdatabase_filename)
    If $iencoding = Default Then
        $iencoding = $SQLITE_ENCODING_UTF8
    EndIf
    Local $avrval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_open_v2", "struct*", $tfilename, "ptr*", 0x0, "int", $iaccessmode, "ptr", 0x0)
    If @error Then Return SetError(0x1, @error, 0x0)
    If $avrval[0x0] <> $SQLITE_OK Then
        __SQLite_ReportError($avrval[0x2], "_SQLite_Open")
        _SQLite_Close($avrval[0x2])
        Return SetError(+ -1, $avrval[0x0], 0x0)
    EndIf
    $__g_hdb_sqlite = $avrval[0x2]
    __SQLite_hAdd($__g_ahdbs_sqlite, $avrval[0x2])
    If Not $boldbase Then
        Local $aencoding[0x3] = ["8", "16", "16be"]
        _SQLite_Exec($avrval[0x2], "PRAGMA encoding=""UTF-" & $aencoding[$iencoding] & """;")
    EndIf
    Return SetExtended($avrval[0x0], $avrval[0x2])
EndFunc    ; -> _SQLite_Open

Func _SQLite_GetTable($hdb, $ssql, ByRef $aresult, ByRef $irows, ByRef $icolumns, $icharsize = + -1)
    $aresult = ''
    If __SQLite_hChk($hdb, 0x1) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    If $icharsize = '' Or $icharsize < 0x1 Or $icharsize = Default Then $icharsize = + -1
    Local $hquery
    Local $r = _SQLite_Query($hdb, $ssql, $hquery)
    If @error Then Return SetError(0x2, @error, $r)
    Local $adatarow
    $r = _SQLite_FetchNames($hquery, $adatarow)
    Local $ierror = @error
    If $ierror Then
        _SQLite_QueryFinalize($hquery)
        Return SetError(0x3, $ierror, $r)
    EndIf
    $icolumns = UBound($adatarow)
    Local Const $IROWSINCR = 0x40
    $irows = 0x0
    Local $iallocrows = $IROWSINCR
    Dim $aresult[($iallocrows + 0x1) * $icolumns + 0x1]
    For $idx = 0x0 To $icolumns + -1
        If $icharsize > 0x0 Then
            $adatarow[$idx] = StringLeft($adatarow[$idx], $icharsize)
        EndIf
        $aresult[$idx + 0x1] = $adatarow[$idx]
    Next
    While 0x1
        $r = _SQLite_FetchData($hquery, $adatarow, 0x0, 0x0, $icolumns)
        $ierror = @error
        Switch $r
        Case $SQLITE_OK
            $irows += 0x1
            If $irows = $iallocrows Then
                $iallocrows = Round($iallocrows * 0x4 / 0x3)
                ReDim $aresult[($iallocrows + 0x1) * $icolumns + 0x1]
            EndIf
            For $j = 0x0 To $icolumns + -1
                If $icharsize > 0x0 Then
                    $adatarow[$j] = StringLeft($adatarow[$j], $icharsize)
                EndIf
                $idx += 0x1
                $aresult[$idx] = $adatarow[$j]
            Next
        Case $SQLITE_DONE
            ExitLoop
        Case Else
            $aresult = ''
            _SQLite_QueryFinalize($hquery)
            Return SetError(0x4, $ierror, $r)
        EndSwitch
    WEnd
    $aresult[0x0] = ($irows + 0x1) * $icolumns
    ReDim $aresult[$aresult[0x0] + 0x1]
    Return ($SQLITE_OK)
EndFunc    ; -> _SQLite_GetTable

Func _SQLite_Exec($hdb, $ssql, $scallback = '')
    If __SQLite_hChk($hdb, 0x2) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    If $scallback <> '' Then
        Local $irows, $icolumns
        Local $sresult = "SQLITE_CALLBACK:" & $scallback
        Local $irval = _SQLite_GetTable2d($hdb, $ssql, $sresult, $irows, $icolumns)
        If @error Then Return SetError(0x3, @error, $irval)
        Return $irval
    EndIf
    Local $tsql8 = __SQLite_StringToUtf8Struct($ssql)
    If @error Then Return SetError(0x4, @error, 0x0)
    Local $avrval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_exec", "ptr", $hdb, "struct*", $tsql8, "ptr", 0x0, "ptr", 0x0, "ptr*", 0x0)
    If @error Then Return SetError(0x1, @error, $SQLITE_MISUSE)
    __SQLite_szFree($avrval[0x5])
    If $avrval[0x0] <> $SQLITE_OK Then
        __SQLite_ReportError($hdb, "_SQLite_Exec", $ssql)
        SetError(+ -1)
    EndIf
    Return $avrval[0x0]
EndFunc    ; -> _SQLite_Exec

Func _SQLite_LibVersion()
    If $__g_hdll_sqlite = 0x0 Then Return SetError(0x1, $SQLITE_MISUSE, 0x0)
    Local $r = DllCall($__g_hdll_sqlite, "str:cdecl", "sqlite3_libversion")
    If @error Then Return SetError(0x1, @error, 0x0)
    Return $r[0x0]
EndFunc    ; -> _SQLite_LibVersion

Func _SQLite_LastInsertRowID($hdb = + -1)
    If __SQLite_hChk($hdb, 0x2) Then Return SetError(@error, @extended, 0x0)
    Local $r = DllCall($__g_hdll_sqlite, "long:cdecl", "sqlite3_last_insert_rowid", "ptr", $hdb)
    If @error Then Return SetError(0x1, @error, 0x0)
    Return $r[0x0]
EndFunc    ; -> _SQLite_LastInsertRowID

Func _SQLite_Changes($hdb = + -1)
    If __SQLite_hChk($hdb, 0x2) Then Return SetError(@error, @extended, 0x0)
    Local $r = DllCall($__g_hdll_sqlite, "long:cdecl", "sqlite3_changes", "ptr", $hdb)
    If @error Then Return SetError(0x1, @error, 0x0)
    Return $r[0x0]
EndFunc    ; -> _SQLite_Changes

Func _SQLite_TotalChanges($hdb = + -1)
    If __SQLite_hChk($hdb, 0x2) Then Return SetError(@error, @extended, 0x0)
    Local $r = DllCall($__g_hdll_sqlite, "long:cdecl", "sqlite3_total_changes", "ptr", $hdb)
    If @error Then Return SetError(0x1, @error, 0x0)
    Return $r[0x0]
EndFunc    ; -> _SQLite_TotalChanges

Func _SQLite_ErrCode($hdb = + -1)
    If __SQLite_hChk($hdb, 0x2) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    Local $r = DllCall($__g_hdll_sqlite, "long:cdecl", "sqlite3_errcode", "ptr", $hdb)
    If @error Then Return SetError(0x1, @error, $SQLITE_MISUSE)
    Return $r[0x0]
EndFunc    ; -> _SQLite_ErrCode

Func _SQLite_ErrMsg($hdb = + -1)
    If __SQLite_hChk($hdb, 0x2) Then Return SetError(@error, @extended, "Library used incorrectly")
    Local $r = DllCall($__g_hdll_sqlite, "wstr:cdecl", "sqlite3_errmsg16", "ptr", $hdb)
    If @error Then
        __SQLite_ReportError($hdb, "_SQLite_ErrMsg", Default, "Call Failed")
        Return SetError(0x1, @error, "Library used incorrectly")
    EndIf
    Return $r[0x0]
EndFunc    ; -> _SQLite_ErrMsg

Func _SQLite_Display2DResult($aresult, $icellwidth = 0x0, $breturn = False, $sdelim_col = '', $sdelim_row = @CRLF)
    If Not IsArray($aresult) Or UBound($aresult, $UBOUND_DIMENSIONS) <> 0x2 Or $icellwidth < 0x0 Then Return SetError(0x1, 0x0, '')
    Local $aicellwidth
    If $icellwidth = Default Then $icellwidth = 0x0
    If $sdelim_col = Default Then $sdelim_col = ''
    If $sdelim_row = Default Then $sdelim_row = @CRLF
    If $icellwidth = 0x0 Or $icellwidth = Default Then
        Local $icellwidthmax
        Dim $aicellwidth[UBound($aresult, $UBOUND_COLUMNS)]
        For $irow = 0x0 To UBound($aresult, $UBOUND_ROWS) + -1
            For $icol = 0x0 To UBound($aresult, $UBOUND_COLUMNS) + -1
                $icellwidthmax = StringLen($aresult[$irow][$icol])
                If $icellwidthmax > $aicellwidth[$icol] Then
                    $aicellwidth[$icol] = $icellwidthmax
                EndIf
            Next
        Next
    EndIf
    Local $sout = '', $icellwidthused
    Local $iubound_rows = UBound($aresult, $UBOUND_ROWS) + -1
    Local $iubound_cols = UBound($aresult, $UBOUND_COLUMNS) + -1
    For $irow = 0x0 To $iubound_rows
        For $icol = 0x0 To $iubound_cols
            If $icellwidth = 0x0 Then
                $icellwidthused = $aicellwidth[$icol]
            Else
                $icellwidthused = $icellwidth
            EndIf
            $sout &= StringFormat(" %-" & $icellwidthused & "." & $icellwidthused & "s ", $aresult[$irow][$icol])
            If $icol <> $iubound_cols Then $sout &= $sdelim_col
        Next
        $sout &= $sdelim_row
        If Not $breturn Then
            __SQLite_Print($sout)
            $sout = ''
        EndIf
    Next
    If $breturn Then
        If $sdelim_col <> '' Then $sout = StringTrimRight($sout, StringLen($sdelim_row))
        Return $sout
    EndIf
EndFunc    ; -> _SQLite_Display2DResult

Func _SQLite_GetTable2d($hdb, $ssql, ByRef $aresult, ByRef $irows, ByRef $icolumns, $icharsize = + -1, $bswichdimensions = False)
    If __SQLite_hChk($hdb, 0x1) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    If $icharsize = '' Or $icharsize < 0x1 Or $icharsize = Default Then $icharsize = + -1
    Local $scallback = '', $bcallback = False
    If IsString($aresult) Then
        If StringLeft($aresult, 0x10) = "SQLITE_CALLBACK:" Then
            $scallback = StringTrimLeft($aresult, 0x10)
            $bcallback = True
        EndIf
    EndIf
    $aresult = ''
    If $bswichdimensions = Default Then $bswichdimensions = False
    Local $hquery
    Local $r = _SQLite_Query($hdb, $ssql, $hquery)
    If @error Then Return SetError(0x2, @error, $r)
    If $r <> $SQLITE_OK Then
        __SQLite_ReportError($hdb, "_SQLite_GetTable2D", $ssql)
        _SQLite_QueryFinalize($hquery)
        Return SetError(+ -1, 0x0, $r)
    EndIf
    $irows = 0x0
    Local $arval_step, $ierror
    While True
        $arval_step = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_step", "ptr", $hquery)
        If @error Then
            $ierror = @error
            _SQLite_QueryFinalize($hquery)
            Return SetError(0x3, $ierror, $SQLITE_MISUSE)
        EndIf
        Switch $arval_step[0x0]
        Case $SQLITE_ROW
            $irows += 0x1
        Case $SQLITE_DONE
            ExitLoop
        Case Else
            _SQLite_QueryFinalize($hquery)
            Return SetError(0x3, $ierror, $arval_step[0x0])
        EndSwitch
    WEnd
    Local $iret = _SQLite_QueryReset($hquery)
    If @error Then
        $ierror = @error
        _SQLite_QueryFinalize($hquery)
        Return SetError(0x4, $ierror, $iret)
    EndIf
    Local $adatarow
    $r = _SQLite_FetchNames($hquery, $adatarow)
    If @error Then
        $ierror = @error
        _SQLite_QueryFinalize($hquery)
        Return SetError(0x5, $ierror, $r)
    EndIf
    $icolumns = UBound($adatarow)
    If $icolumns <= 0x0 Then
        _SQLite_QueryFinalize($hquery)
        Return SetError(+ -1, 0x0, $SQLITE_DONE)
    EndIf
    If Not $bcallback Then
        If $bswichdimensions Then
            Dim $aresult[$icolumns][$irows + 0x1]
            For $i = 0x0 To $icolumns + -1
                If $icharsize > 0x0 Then
                    $adatarow[$i] = StringLeft($adatarow[$i], $icharsize)
                EndIf
                $aresult[$i][0x0] = $adatarow[$i]
            Next
        Else
            Dim $aresult[$irows + 0x1][$icolumns]
            For $i = 0x0 To $icolumns + -1
                If $icharsize > 0x0 Then
                    $adatarow[$i] = StringLeft($adatarow[$i], $icharsize)
                EndIf
                $aresult[0x0][$i] = $adatarow[$i]
            Next
        EndIf
    Else
        Local $icbrval
        $icbrval = Call($scallback, $adatarow)
        If $icbrval = $SQLITE_ABORT Or $icbrval = $SQLITE_INTERRUPT Or @error Then
            $ierror = @error
            _SQLite_QueryFinalize($hquery)
            Return SetError(0x7, $ierror, $icbrval)
        EndIf
    EndIf
    If $irows > 0x0 Then
        For $i = 0x1 To $irows
            $r = _SQLite_FetchData($hquery, $adatarow, 0x0, 0x0, $icolumns)
            If @error Then
                $ierror = @error
                _SQLite_QueryFinalize($hquery)
                Return SetError(0x6, $ierror, $r)
            EndIf
            If $bcallback Then
                $icbrval = Call($scallback, $adatarow)
                If $icbrval = $SQLITE_ABORT Or $icbrval = $SQLITE_INTERRUPT Or @error Then
                    $ierror = @error
                    _SQLite_QueryFinalize($hquery)
                    Return SetError(0x7, $ierror, $icbrval)
                EndIf
            Else
                For $j = 0x0 To $icolumns + -1
                    If $icharsize > 0x0 Then
                        $adatarow[$j] = StringLeft($adatarow[$j], $icharsize)
                    EndIf
                    If $bswichdimensions Then
                        $aresult[$j][$i] = $adatarow[$j]
                    Else
                        $aresult[$i][$j] = $adatarow[$j]
                    EndIf
                Next
            EndIf
        Next
    EndIf
    Return (_SQLite_QueryFinalize($hquery))
EndFunc    ; -> _SQLite_GetTable2d

Func _SQLite_SetTimeout($hdb = + -1, $itimeout = 0x3e8)
    If __SQLite_hChk($hdb, 0x2) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    If $itimeout = Default Then $itimeout = 0x3e8
    Local $avrval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_busy_timeout", "ptr", $hdb, "int", $itimeout)
    If @error Then Return SetError(0x1, @error, $SQLITE_MISUSE)
    If $avrval[0x0] <> $SQLITE_OK Then SetError(+ -1)
    Return $avrval[0x0]
EndFunc    ; -> _SQLite_SetTimeout

Func _SQLite_Query($hdb, $ssql, ByRef $hquery)
    If __SQLite_hChk($hdb, 0x2) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    Local $irval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_prepare16_v2", "ptr", $hdb, "wstr", $ssql, "int", + -1, "ptr*", 0x0, "ptr*", 0x0)
    If @error Then Return SetError(0x1, @error, $SQLITE_MISUSE)
    If $irval[0x0] <> $SQLITE_OK Then
        __SQLite_ReportError($hdb, "_SQLite_Query", $ssql)
        Return SetError(+ -1, 0x0, $irval[0x0])
    EndIf
    $hquery = $irval[0x4]
    __SQLite_hAdd($__g_ahquerys_sqlite, $irval[0x4])
    Return $irval[0x0]
EndFunc    ; -> _SQLite_Query

Func _SQLite_FetchData($hquery, ByRef $arow, $bbinary = False, $bdonotfinalize = False, $icolumns = 0x0, $bautoittypeconversion = False)
    Dim $arow[0x1]
    If __SQLite_hChk($hquery, 0x7, False) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    If $bbinary = Default Then $bbinary = False
    If $bdonotfinalize = Default Then $bdonotfinalize = False
    Local $arval_step = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_step", "ptr", $hquery)
    If @error Then Return SetError(0x1, @error, $SQLITE_MISUSE)
    If $arval_step[0x0] <> $SQLITE_ROW Then
        If $bdonotfinalize = False And $arval_step[0x0] = $SQLITE_DONE Then
            _SQLite_QueryFinalize($hquery)
        EndIf
        Return SetError(+ -1, 0x0, $arval_step[0x0])
    EndIf
    If Not $icolumns Then
        Local $irval_colcnt = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_data_count", "ptr", $hquery)
        If @error Then Return SetError(0x2, @error, $SQLITE_MISUSE)
        If $irval_colcnt[0x0] <= 0x0 Then Return SetError(+ -1, 0x0, $SQLITE_DONE)
        $icolumns = $irval_colcnt[0x0]
    EndIf
    ReDim $arow[$icolumns]
    If Not $bautoittypeconversion Then $bautoittypeconversion = $__g_bautoittype_sqlite
    For $i = 0x0 To $icolumns + -1
        Local $irval_coltype = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_column_type", "ptr", $hquery, "int", $i)
        If @error Then Return SetError(0x4, @error, $SQLITE_MISUSE)
        If $irval_coltype[0x0] = $SQLITE_TYPE_NULL Then
            $arow[$i] = ''
            ContinueLoop
        EndIf
        If (Not $bbinary) And ($irval_coltype[0x0] <> $SQLITE_TYPE_BLOB) Then
            Local $vrval
            If $bautoittypeconversion Then
                Switch $irval_coltype[0x0]
                Case $SQLITE_TYPE_NULL
                    $arow[$i] = Null
                Case $SQLITE_TYPE_INTEGER
                    $vrval = DllCall($__g_hdll_sqlite, "int64:cdecl", "sqlite3_column_int64", "ptr", $hquery, "int", $i)
                    If @error Then Return SetError(0x8, 0x0, $SQLITE_MISUSE)
                    $arow[$i] = $vrval[0x0]
                Case $SQLITE_TYPE_FLOAT
                    $vrval = DllCall($__g_hdll_sqlite, "double:cdecl", "sqlite3_column_double", "ptr", $hquery, "int", $i)
                    If @error Then Return SetError(0x9, 0x0, $SQLITE_MISUSE)
                    $arow[$i] = $vrval[0x0]
                Case $SQLITE_TYPE_BLOB
                    Local $pblob = DllCall($__g_hdll_sqlite, "ptr:cdecl", "sqlite3_column_blob", "ptr", $hquery, "int", $i)
                    If @error Then Return SetError(0x10, @error, $SQLITE_MISUSE)
                    Local $iblobsize = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_column_bytes", "ptr", $hquery, "int", $i)
                    If @error Then Return SetError(0xf, @error, $SQLITE_MISUSE)
                    $arow[$i] = Binary(DllStructGetData(DllStructCreate("byte[" & $iblobsize[0x0] & "]", $pblob[0x0]), 0x1))
                Case $SQLITE_TYPE_TEXT
                    $vrval = DllCall($__g_hdll_sqlite, "wstr:cdecl", "sqlite3_column_text16", "ptr", $hquery, "int", $i)
                    If @error Then Return SetError(0xd, @error, $SQLITE_MISUSE)
                    $arow[$i] = $vrval[0x0]
                EndSwitch
            Else
                $vrval = DllCall($__g_hdll_sqlite, "wstr:cdecl", "sqlite3_column_text16", "ptr", $hquery, "int", $i)
                If @error Then Return SetError(0x3, @error, $SQLITE_MISUSE)
                $arow[$i] = $vrval[0x0]
            EndIf
        Else
            Local $acall = DllCall($__g_hdll_sqlite, "ptr:cdecl", "sqlite3_column_blob", "ptr", $hquery, "int", $i)
            If @error Then Return SetError(0x6, @error, $SQLITE_MISUSE)
            Local $icolbytes = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_column_bytes", "ptr", $hquery, "int", $i)
            If @error Then Return SetError(0x5, @error, $SQLITE_MISUSE)
            Local $tresultstruct = DllStructCreate("byte[" & $icolbytes[0x0] & "]", $acall[0x0])
            $arow[$i] = Binary(DllStructGetData($tresultstruct, 0x1))
        EndIf
    Next
    Return $SQLITE_OK
EndFunc    ; -> _SQLite_FetchData

Func _SQLite_Close($hdb = + -1)
    If __SQLite_hChk($hdb, 0x2) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    Local $irval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_close", "ptr", $hdb)
    If @error Then Return SetError(0x1, @error, $SQLITE_MISUSE)
    If $irval[0x0] <> $SQLITE_OK Then
        __SQLite_ReportError($hdb, "_SQLite_Close")
        Return SetError(+ -1, 0x0, $irval[0x0])
    EndIf
    $__g_hdb_sqlite = 0x0
    __SQLite_hDel($__g_ahdbs_sqlite, $hdb)
    Return $irval[0x0]
EndFunc    ; -> _SQLite_Close

Func _SQLite_SafeMode($bsafemodestate)
    $__g_bsafemodestate_sqlite = ($bsafemodestate = True)
    Return $SQLITE_OK
EndFunc    ; -> _SQLite_SafeMode

Func _SQLite_QueryFinalize($hquery)
    If __SQLite_hChk($hquery, 0x2, False) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    Local $avrval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_finalize", "ptr", $hquery)
    If @error Then Return SetError(0x1, @error, $SQLITE_MISUSE)
    __SQLite_hDel($__g_ahquerys_sqlite, $hquery)
    If $avrval[0x0] <> $SQLITE_OK Then SetError(+ -1)
    Return $avrval[0x0]
EndFunc    ; -> _SQLite_QueryFinalize

Func _SQLite_QueryReset($hquery)
    If __SQLite_hChk($hquery, 0x2, False) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    Local $avrval = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_reset", "ptr", $hquery)
    If @error Then Return SetError(0x1, @error, $SQLITE_MISUSE)
    If $avrval[0x0] <> $SQLITE_OK Then SetError(+ -1)
    Return $avrval[0x0]
EndFunc    ; -> _SQLite_QueryReset

Func _SQLite_FetchNames($hquery, ByRef $anames)
    Dim $anames[0x1]
    If __SQLite_hChk($hquery, 0x3, False) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    Local $avdatacnt = DllCall($__g_hdll_sqlite, "int:cdecl", "sqlite3_column_count", "ptr", $hquery)
    If @error Then Return SetError(0x1, @error, $SQLITE_MISUSE)
    If $avdatacnt[0x0] <= 0x0 Then Return SetError(+ -1, 0x0, $SQLITE_DONE)
    ReDim $anames[$avdatacnt[0x0]]
    Local $avcolname
    For $icnt = 0x0 To $avdatacnt[0x0] + -1
        $avcolname = DllCall($__g_hdll_sqlite, "wstr:cdecl", "sqlite3_column_name16", "ptr", $hquery, "int", $icnt)
        If @error Then Return SetError(0x2, @error, $SQLITE_MISUSE)
        $anames[$icnt] = $avcolname[0x0]
    Next
    Return $SQLITE_OK
EndFunc    ; -> _SQLite_FetchNames

Func _SQLite_QuerySingleRow($hdb, $ssql, ByRef $arow)
    $arow = ''
    If __SQLite_hChk($hdb, 0x2) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    Local $hquery
    Local $irval = _SQLite_Query($hdb, $ssql, $hquery)
    If @error Then
        _SQLite_QueryFinalize($hquery)
        Return SetError(0x1, 0x0, $irval)
    Else
        $irval = _SQLite_FetchData($hquery, $arow)
        If $irval = $SQLITE_OK Then
            _SQLite_QueryFinalize($hquery)
            If @error Then
                Return SetError(0x4, 0x0, $irval)
            Else
                Return $SQLITE_OK
            EndIf
        Else
            _SQLite_QueryFinalize($hquery)
            Return SetError(0x3, 0x0, $irval)
        EndIf
    EndIf
EndFunc    ; -> _SQLite_QuerySingleRow

Func _SQLite_SQLiteExe($sdatabasefile, $sinput, ByRef $soutput, $ssqliteexefilename = "sqlite3.exe", $BDEBUG = False)
    If $ssqliteexefilename = + -1 Or $ssqliteexefilename = Default Then
        $ssqliteexefilename = "sqlite3.exe"
        $ssqliteexefilename = __sqlite_getdownloadedpath($ssqliteexefilename) & $ssqliteexefilename
        If Not FileExists($ssqliteexefilename) Then Return SetError(0x2, 0x0, $SQLITE_MISUSE)
    EndIf
    If Not FileExists($sdatabasefile) Then
        Local $hnewfile = FileOpen($sdatabasefile, $FO_OVERWRITE + $FO_CREATEPATH)
        If $hnewfile = + -1 Then
            Return SetError(0x1, 0x0, $SQLITE_CANTOPEN)
        EndIf
        FileClose($hnewfile)
    EndIf
    Local $sinputfile = _TempFile(), $soutputfile = _TempFile(), $irval = $SQLITE_OK
    Local $hinputfile = FileOpen($sinputfile, $FO_OVERWRITE)
    If $hinputfile > + -1 Then
        $sinput = ".output stdout" & @CRLF & $sinput
        FileWrite($hinputfile, $sinput)
        FileClose($hinputfile)
        Local $scmd = @ComSpec & " /c " & FileGetShortName($ssqliteexefilename) & "  """ & FileGetShortName($sdatabasefile) & """ > """ & FileGetShortName($soutputfile) & """ < """ & FileGetShortName($sinputfile) & """"
        Local $nerrorlevel = RunWait($scmd, @WorkingDir, @SW_HIDE)
        If $BDEBUG = True Then
            Local $nerrortemp = @error
            If @error Then __SQLite_Print("@@ Debug(_SQLite_SQLiteExe) : $sCmd = " & $scmd & @CRLF & ">ErrorLevel: " & $nerrorlevel & @CRLF)
            SetError($nerrortemp)
        EndIf
        If @error = 0x1 Or $nerrorlevel = 0x1 Then
            $irval = $SQLITE_MISUSE
        Else
            $soutput = FileRead($soutputfile, FileGetSize($soutputfile))
            If StringInStr($soutput, "SQL error:", $STR_CASESENSE) > 0x0 Or StringInStr($soutput, "Incomplete SQL:", $STR_CASESENSE) > 0x0 Then $irval = $SQLITE_ERROR
        EndIf
    Else
        $irval = $SQLITE_CANTOPEN
    EndIf
    If FileExists($sinputfile) Then FileDelete($sinputfile)
    Switch $irval
    Case $SQLITE_MISUSE
        SetError(0x2)
    Case $SQLITE_ERROR
        SetError(0x3)
    Case $SQLITE_CANTOPEN
        SetError(0x4)
    EndSwitch
    Return $irval
EndFunc    ; -> _SQLite_SQLiteExe

Func _SQLite_Encode($vdata)
    If IsNumber($vdata) Then $vdata = String($vdata)
    If Not IsString($vdata) And Not IsBinary($vdata) Then Return SetError(0x1, 0x0, '')
    Local $vrval = "X'"
    If StringLower(StringLeft($vdata, 0x2)) = "0x" And Not IsBinary($vdata) Then
        For $icnt = 0x1 To StringLen($vdata)
            $vrval &= Hex(Asc(StringMid($vdata, $icnt, 0x1)), 0x2)
        Next
    Else
        If Not IsBinary($vdata) Then $vdata = StringToBinary($vdata, 0x4)
        $vrval &= Hex($vdata)
    EndIf
    $vrval &= "'"
    Return $vrval
EndFunc    ; -> _SQLite_Encode

Func _SQLite_Escape($sstring, $ibuffsize = Default)
    If $__g_hdll_sqlite = 0x0 Then Return SetError(0x1, $SQLITE_MISUSE, '')
    If IsNumber($sstring) Then $sstring = String($sstring)
    Local $tsql8 = __SQLite_StringToUtf8Struct($sstring)
    If @error Then Return SetError(0x2, @error, 0x0)
    Local $arval = DllCall($__g_hdll_sqlite, "ptr:cdecl", "sqlite3_mprintf", "str", "'%q'", "struct*", $tsql8)
    If @error Then Return SetError(0x1, @error, '')
    If $ibuffsize = Default Or $ibuffsize < 0x1 Then $ibuffsize = + -1
    Local $sresult = __SQLite_szStringRead($arval[0x0], $ibuffsize)
    If @error Then Return SetError(0x3, @error, '')
    DllCall($__g_hdll_sqlite, "none:cdecl", "sqlite3_free", "ptr", $arval[0x0])
    Return $sresult
EndFunc    ; -> _SQLite_Escape

Func _SQLite_FastEncode($vdata)
    If Not IsBinary($vdata) Then $vdata = Binary($vdata)
    Return "X'" & StringTrimLeft($vdata, 0x2) & "'"
EndFunc    ; -> _SQLite_FastEncode

Func _SQLite_FastEscape($sstring)
    If IsNumber($sstring) Then $sstring = String($sstring)
    If Not IsString($sstring) Then Return SetError(0x1, 0x0, '')
    Return ("'" & StringReplace($sstring, "'", "''", 0x0, $STR_CASESENSE) & "'")
EndFunc    ; -> _SQLite_FastEscape

Func _sqlite_gettabledata2d($hdb, $ssql, ByRef $aresult, ByRef $irows, ByRef $anames)
    If __SQLite_hChk($hdb, 0x1) Then Return SetError(@error, 0x0, $SQLITE_MISUSE)
    $aresult = ''
    Local $hquery
    Local $r = _SQLite_Query($hdb, $ssql, $hquery)
    If @error Then Return SetError(0x2, @error, $r)
    If $r <> $SQLITE_OK Then
        __SQLite_ReportError($hdb, "_SQLite_GetTableData", $ssql)
        Return SetError(+ -1, 0x0, $r)
    EndIf
    Local $adatarow
    $r = _SQLite_FetchNames($hquery, $anames)
    If @error Then
        Local $ierror = @error
        _SQLite_QueryFinalize($hquery)
        Return SetError(0x5, $ierror, $r)
    EndIf
    Local $icolumns = UBound($anames)
    Local Const $ICHUNK = 0x2000
    Local $nmaxrow = $ICHUNK
    Dim $aresult[$nmaxrow][$icolumns]
    $irows = 0x0
    While _SQLite_FetchData($hquery, $adatarow) = $SQLITE_OK
        If $irows = $nmaxrow Then
            $nmaxrow += $ICHUNK
            ReDim $aresult[$nmaxrow][$icolumns]
        EndIf
        For $j = 0x0 To $icolumns + -1
            $aresult[$irows][$j] = $adatarow[$j]
        Next
        $irows += 0x1
    WEnd
    If $irows = 0x0 Then
        $aresult = ''
    Else
        ReDim $aresult[$irows][$icolumns]
    EndIf
    Return $SQLITE_OK
EndFunc    ; -> _sqlite_gettabledata2d

#Region		SQLite.au3 Internal Functions
    Func __SQLite_hChk(ByRef $hgeneric, $nerror, $bdb = True)
        If $__g_hdll_sqlite = 0x0 Then Return SetError(0x1, $SQLITE_MISUSE, $SQLITE_MISUSE)
        If $hgeneric = + -1 Or $hgeneric = '' Or $hgeneric = Default Then
            If Not $bdb Then Return SetError($nerror, 0x0, $SQLITE_ERROR)
            $hgeneric = $__g_hdb_sqlite
        EndIf
        If Not $__g_bsafemodestate_sqlite Then Return $SQLITE_OK
        If $bdb Then
            If _ArraySearch($__g_ahdbs_sqlite, $hgeneric) > 0x0 Then Return $SQLITE_OK
        Else
            If _ArraySearch($__g_ahquerys_sqlite, $hgeneric) > 0x0 Then Return $SQLITE_OK
        EndIf
        Return SetError($nerror, 0x0, $SQLITE_ERROR)
    EndFunc    ; -> __SQLite_hChk

    Func __SQLite_hAdd(ByRef $ahlists, $hgeneric)
        _ArrayAdd($ahlists, $hgeneric)
    EndFunc    ; -> __SQLite_hAdd

    Func __SQLite_hDel(ByRef $ahlists, $hgeneric)
        Local $ielement = _ArraySearch($ahlists, $hgeneric)
        If $ielement > 0x0 Then _ArrayDelete($ahlists, $ielement)
    EndFunc    ; -> __SQLite_hDel

    Func __SQLite_VersCmp($sfile, $sversion)
        Local $avrval = DllCall($sfile, "str:cdecl", "sqlite3_libversion")
        If @error Then Return $SQLITE_CORRUPT
        Local $sfileversion = StringSplit($avrval[0x0], ".")
        Local $imaintversion = 0x0
        If $sfileversion[0x0] = 0x4 Then $imaintversion = $sfileversion[0x4]
        $sfileversion = (($sfileversion[0x1] * 0x3e8 + $sfileversion[0x2]) * 0x3e8 + $sfileversion[0x3]) * 0x64 + $imaintversion
        If $sversion < 0x989680 Then $sversion = $sversion * 0x64
        If $sfileversion >= $sversion Then Return $SQLITE_OK
        Return $SQLITE_MISMATCH
    EndFunc    ; -> __SQLite_VersCmp

    Func __SQLite_hDbg()
        __SQLite_Print("State : " & $__g_bsafemodestate_sqlite & @CRLF)
        Local $atmp = $__g_ahdbs_sqlite
        For $i = 0x0 To UBound($atmp) + -1
            __SQLite_Print("$__g_ahDBs_SQLite     -> [" & $i & "]" & $atmp[$i] & @CRLF)
        Next
        $atmp = $__g_ahquerys_sqlite
        For $i = 0x0 To UBound($atmp) + -1
            __SQLite_Print("$__g_ahQuerys_SQLite  -> [" & $i & "]" & $atmp[$i] & @CRLF)
        Next
    EndFunc    ; -> __SQLite_hDbg

    Func __SQLite_ReportError($hdb, $sfunction, $squery = Default, $serror = Default, $vreturnvalue = Default, $icurerr = @error, $icurext = @extended)
        If @Compiled Then Return SetError($icurerr, $icurext)
        If $serror = Default Then $serror = _SQLite_ErrMsg($hdb)
        If $squery = Default Then $squery = ''
        Local $sout = "!   SQLite.au3 Error" & @CRLF
        $sout &= "--> Function: " & $sfunction & @CRLF
        If $squery <> '' Then $sout &= "--> Query:    " & $squery & @CRLF
        $sout &= "--> Error:    " & $serror & @CRLF
        __SQLite_Print($sout & @CRLF)
        If Not ($vreturnvalue = Default) Then Return SetError($icurerr, $icurext, $vreturnvalue)
        Return SetError($icurerr, $icurext)
    EndFunc    ; -> __SQLite_ReportError

    Func __SQLite_szStringRead($pptr, $imaxlen = + -1)
        If $pptr = 0x0 Then Return ''
        If $__g_hmsvcrtdll_sqlite < 0x1 Then $__g_hmsvcrtdll_sqlite = DllOpen("msvcrt.dll")
        Local $astrlen = DllCall($__g_hmsvcrtdll_sqlite, "ulong_ptr:cdecl", "strlen", "ptr", $pptr)
        If @error Then Return SetError(0x1, @error, '')
        Local $ilen = $astrlen[0x0] + 0x1
        Local $tstring = DllStructCreate("byte[" & $ilen & "]", $pptr)
        If @error Then Return SetError(0x2, @error, '')
        Local $ierror = 0x0
        Local $srtn = __SQLite_Utf8StructToString($tstring)
        If @error Then
            $ierror = 0x3
        EndIf
        If $imaxlen <= 0x0 Then
            Return SetError($ierror, @extended, $srtn)
        Else
            Return SetError($ierror, @extended, StringLeft($srtn, $imaxlen))
        EndIf
    EndFunc    ; -> __SQLite_szStringRead

    Func __SQLite_szFree($pptr, $icurerr = @error)
        If $pptr <> 0x0 Then DllCall($__g_hdll_sqlite, "none:cdecl", "sqlite3_free", "ptr", $pptr)
        SetError($icurerr)
    EndFunc    ; -> __SQLite_szFree

    Func __SQLite_StringToUtf8Struct($sstring)
        Local $acall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", 0xfde9, "dword", 0x0, "wstr", $sstring, "int", + -1, "ptr", 0x0, "int", 0x0, "ptr", 0x0, "ptr", 0x0)
        If @error Then Return SetError(0x1, @error, '')
        Local $ttext = DllStructCreate("char[" & $acall[0x0] & "]")
        $acall = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", 0xfde9, "dword", 0x0, "wstr", $sstring, "int", + -1, "struct*", $ttext, "int", $acall[0x0], "ptr", 0x0, "ptr", 0x0)
        If @error Then Return SetError(0x2, @error, '')
        Return $ttext
    EndFunc    ; -> __SQLite_StringToUtf8Struct

    Func __SQLite_Utf8StructToString($ttext)
        Local $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", 0xfde9, "dword", 0x0, "struct*", $ttext, "int", + -1, "ptr", 0x0, "int", 0x0)
        If @error Then Return SetError(0x1, @error, '')
        Local $twstr = DllStructCreate("wchar[" & $acall[0x0] & "]")
        $acall = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", 0xfde9, "dword", 0x0, "struct*", $ttext, "int", + -1, "struct*", $twstr, "int", $acall[0x0])
        If @error Then Return SetError(0x2, @error, '')
        Return DllStructGetData($twstr, 0x1)
    EndFunc    ; -> __SQLite_Utf8StructToString

    Func __SQLite_ConsoleWrite($stext)
        ConsoleWrite($stext)
    EndFunc    ; -> __SQLite_ConsoleWrite

    Func __SQLite_Print($stext)
        If IsFunc($__g_hprintcallback_sqlite) Then
            If $__g_butf8errormsg_sqlite Then
                Local $tstr8 = __SQLite_StringToUtf8Struct($stext)
                $__g_hprintcallback_sqlite(DllStructGetData($tstr8, 0x1))
            Else
                $__g_hprintcallback_sqlite($stext)
            EndIf
        EndIf
    EndFunc    ; -> __SQLite_Print

    Func __sqlite_getdownloadedpath(ByRef $sdll_filename, $vinlineversion = '')
        Local $bdownloaddll = True, $iextended = 0x0
        If $vinlineversion = '' Then
            $vinlineversion = Call("__SQLite_Inline_Version")
            If @error Then $bdownloaddll = False
        Else
            Local $aversion = StringSplit($vinlineversion, ".")
            If @error = 0x0 Then
                Local $imaintversion = 0x0
                If $aversion[0x0] = 0x4 Then $imaintversion = $aversion[0x4]
                $vinlineversion = (($aversion[0x1] * 0x3e8 + $aversion[0x2]) * 0x3e8 + $aversion[0x3]) * 0x64 + $imaintversion
            EndIf
        EndIf
        Local $sdll_dirpath = '', $slocalpath = @LocalAppDataDir & "\\AutoIt v3\\SQLite\\"
        If __SQLite_VersCmp(@ScriptDir & "\\" & $sdll_filename, $vinlineversion) = $SQLITE_OK Then
            $sdll_dirpath = @ScriptDir & "\\"
            $bdownloaddll = False
        ElseIf __SQLite_VersCmp(@WorkingDir & "\\" & $sdll_filename, $vinlineversion) = $SQLITE_OK Then
            $sdll_dirpath = @WorkingDir & "\\"
            $bdownloaddll = False
        ElseIf __SQLite_VersCmp($slocalpath & $sdll_filename, $vinlineversion) = $SQLITE_OK Then
            $sdll_dirpath = $slocalpath
            $bdownloaddll = False
        ElseIf __SQLite_VersCmp(@SystemDir & "\\" & $sdll_filename, $vinlineversion) = $SQLITE_OK Then
            $sdll_dirpath = @SystemDir & "\\"
            $bdownloaddll = False
        ElseIf __SQLite_VersCmp(@WindowsDir & "\\" & $sdll_filename, $vinlineversion) = $SQLITE_OK Then
            $sdll_dirpath = @WindowsDir & "\\"
            $bdownloaddll = False
        ElseIf $bdownloaddll Then
            Local $sext = StringRight($sdll_filename, 0x4)
            Local $sdll_filename_ver = StringReplace($sdll_filename, $sext, '') & "_" & $vinlineversion & $sext
            If __SQLite_VersCmp(@ScriptDir & "\\" & $sdll_filename_ver, $vinlineversion) = $SQLITE_OK Then
                $sdll_dirpath = @ScriptDir & "\\"
                $bdownloaddll = False
            ElseIf __SQLite_VersCmp(@WorkingDir & "\\" & $sdll_filename_ver, $vinlineversion) = $SQLITE_OK Then
                $sdll_dirpath = @WorkingDir & "\\"
                $bdownloaddll = False
            ElseIf __SQLite_VersCmp($slocalpath & $sdll_filename_ver, $vinlineversion) = $SQLITE_OK Then
                $sdll_dirpath = $slocalpath
                $bdownloaddll = False
            ElseIf __SQLite_VersCmp(@SystemDir & "\\" & $sdll_filename_ver, $vinlineversion) = $SQLITE_OK Then
                $sdll_dirpath = @SystemDir & "\\"
                $bdownloaddll = False
            ElseIf __SQLite_VersCmp(@WindowsDir & "\\" & $sdll_filename_ver, $vinlineversion) = $SQLITE_OK Then
                $sdll_dirpath = @WindowsDir & "\\"
                $bdownloaddll = False
            EndIf
            If Not $bdownloaddll Then
                $iextended = 0x1
            Else
                $sdll_dirpath = $slocalpath
            EndIf
            $sdll_filename = $sdll_filename_ver
        EndIf
        Return SetExtended($iextended, $sdll_dirpath)
    EndFunc    ; -> __sqlite_getdownloadedpath

#EndRegion		SQLite.au3 Internal Functions
Func __SQLite_Inline_Modified()
    Return "20190512104318"
EndFunc    ; -> __SQLite_Inline_Modified

Func __SQLite_Inline_Version()
    Return "302800000"
EndFunc    ; -> __SQLite_Inline_Version

Func _HexToString($shex)
    If Not (StringLeft($shex, 0x2) == "0x") Then $shex = "0x" & $shex
    Return BinaryToString($shex, $SB_UTF8)
EndFunc    ; -> _HexToString

Func _StringBetween($sstring, $sstart, $send, $imode = $STR_ENDISSTART, $bcase = False)
    $sstart = $sstart  ? "\\Q" & $sstart & "\\E"  : "\\A"
    If $imode <> $STR_ENDNOTSTART Then $imode = $STR_ENDISSTART
    If $imode = $STR_ENDISSTART Then
        $send = $send  ? "(?=\\Q" & $send & "\\E)"  : "\\z"
    Else
        $send = $send  ? "\\Q" & $send & "\\E"  : "\\z"
    EndIf
    If $bcase = Default Then
        $bcase = False
    EndIf
    Local $aret = StringRegExp($sstring, "(?s" & (Not $bcase  ? "i"  : '') & ")" & $sstart & "(.*?)" & $send, $STR_REGEXPARRAYGLOBALMATCH)
    If @error Then Return SetError(0x1, 0x0, 0x0)
    Return $aret
EndFunc    ; -> _StringBetween

Func _StringExplode($sstring, $SDELIMITER, $ilimit = 0x0)
    If $ilimit = Default Then $ilimit = 0x0
    If $ilimit > 0x0 Then
        Local Const $NULL = Chr(0x0)
        $sstring = StringReplace($sstring, $SDELIMITER, $NULL, $ilimit)
        $SDELIMITER = $NULL
    ElseIf $ilimit < 0x0 Then
        Local $iindex = StringInStr($sstring, $SDELIMITER, $STR_NOCASESENSEBASIC, $ilimit)
        If $iindex Then
            $sstring = StringLeft($sstring, $iindex + -1)
        EndIf
    EndIf
    Return StringSplit($sstring, $SDELIMITER, BitOR($STR_ENTIRESPLIT, $STR_NOCOUNT))
EndFunc    ; -> _StringExplode

Func _StringInsert($sstring, $sinsertion, $iposition)
    Local $ilength = StringLen($sstring)
    $iposition = Int($iposition)
    If $iposition < 0x0 Then $iposition = $ilength + $iposition
    If $ilength < $iposition Or $iposition < 0x0 Then Return SetError(0x1, 0x0, $sstring)
    Return StringLeft($sstring, $iposition) & $sinsertion & StringRight($sstring, $ilength - $iposition)
EndFunc    ; -> _StringInsert

Func _StringProper($sstring)
    Local $bcapnext = True, $schr = '', $sreturn = ''
    Local $SPATTERN = "[a-zA-Z-]"
    For $i = 0x1 To StringLen($sstring)
        $schr = StringMid($sstring, $i, 0x1)
        Select
        Case $bcapnext = True
            If StringRegExp($schr, $SPATTERN) Then
                $schr = StringUpper($schr)
                $bcapnext = False
            EndIf
        Case Not StringRegExp($schr, $SPATTERN)
            $bcapnext = True
        Case Else
            $schr = StringLower($schr)
        EndSelect
        $sreturn &= $schr
    Next
    Return $sreturn
EndFunc    ; -> _StringProper

Func _StringRepeat($sstring, $irepeatcount)
    $irepeatcount = Int($irepeatcount)
    If $irepeatcount = 0x0 Then Return ''
    If StringLen($sstring) < 0x1 Or $irepeatcount < 0x0 Then Return SetError(0x1, 0x0, '')
    Local $sresult = ''
    While $irepeatcount > 0x1
        If BitAND($irepeatcount, 0x1) Then $sresult &= $sstring
        $sstring &= $sstring
        $irepeatcount = BitShift($irepeatcount, 0x1)
    WEnd
    Return $sstring & $sresult
EndFunc    ; -> _StringRepeat

Func _StringTitleCase($sstring)
    Local $bcapnext = True, $schr = '', $sreturn = ''
    For $i = 0x1 To StringLen($sstring)
        $schr = StringMid($sstring, $i, 0x1)
        Select
        Case $bcapnext = True
            If StringRegExp($schr, "[a-zA-Z\\xC0-\\xFF0-9]") Then
                $schr = StringUpper($schr)
                $bcapnext = False
            EndIf
        Case Not StringRegExp($schr, "[a-zA-Z\\xC0-\\xFF'0-9]")
            $bcapnext = True
        Case Else
            $schr = StringLower($schr)
        EndSelect
        $sreturn &= $schr
    Next
    Return $sreturn
EndFunc    ; -> _StringTitleCase

Func _StringToHex($sstring)
    Return Hex(StringToBinary($sstring, $SB_UTF8))
EndFunc    ; -> _StringToHex

Global $__g_atimers_atimerids[0x1][0x3]
Func _Timer_Diff($itimestamp)
    Return 0x3e8 * (__Timer_QueryPerformanceCounter() - $itimestamp) / __Timer_QueryPerformanceFrequency()
EndFunc    ; -> _Timer_Diff

Func _Timer_GetIdleTime()
    Local $tstruct = DllStructCreate("uint;dword")
    DllStructSetData($tstruct, 0x1, DllStructGetSize($tstruct))
    Local $acall = DllCall("user32.dll", "bool", "GetLastInputInfo", "struct*", $tstruct)
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
    Local $avticks = DllCall("kernel32.dll", "dword", "GetTickCount")
    If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
    Local $idiff = $avticks[0x0] - DllStructGetData($tstruct, 0x2)
    If $idiff < 0x0 Then Return SetExtended(0x1, $avticks[0x0])
    Return $idiff
EndFunc    ; -> _Timer_GetIdleTime

Func _Timer_GetTimerID($wparam)
    Local $_itimerid = Dec(Hex($wparam, 0x8)), $imax = UBound($__g_atimers_atimerids) + -1
    For $x = 0x1 To $imax
        If $_itimerid = $__g_atimers_atimerids[$x][0x1] Then Return $__g_atimers_atimerids[$x][0x0]
    Next
    Return 0x0
EndFunc    ; -> _Timer_GetTimerID

Func _Timer_Init()
    Return __Timer_QueryPerformanceCounter()
EndFunc    ; -> _Timer_Init

Func _Timer_KillAllTimers($hwnd)
    Local $inumtimers = $__g_atimers_atimerids[0x0][0x0]
    If $inumtimers = 0x0 Then Return False
    Local $acall, $hcallback = 0x0
    For $x = $inumtimers To 0x1 Step + -1
        If IsHWnd($hwnd) Then
            $acall = DllCall("user32.dll", "bool", "KillTimer", "hwnd", $hwnd, "uint_ptr", $__g_atimers_atimerids[$x][0x1])
        Else
            $acall = DllCall("user32.dll", "bool", "KillTimer", "hwnd", $hwnd, "uint_ptr", $__g_atimers_atimerids[$x][0x0])
        EndIf
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
        $hcallback = $__g_atimers_atimerids[$x][0x2]
        If $hcallback <> 0x0 Then DllCallbackFree($hcallback)
        $__g_atimers_atimerids[0x0][0x0]-= 0x1
    Next
    ReDim $__g_atimers_atimerids[0x1][0x3]
    Return True
EndFunc    ; -> _Timer_KillAllTimers

Func _Timer_KillTimer($hwnd, $itimerid)
    Local $acall[0x1] = [0x0], $hcallback = 0x0, $iubound = UBound($__g_atimers_atimerids) + -1
    For $x = 0x1 To $iubound
        If $__g_atimers_atimerids[$x][0x0] = $itimerid Then
            If IsHWnd($hwnd) Then
                $acall = DllCall("user32.dll", "bool", "KillTimer", "hwnd", $hwnd, "uint_ptr", $__g_atimers_atimerids[$x][0x1])
            Else
                $acall = DllCall("user32.dll", "bool", "KillTimer", "hwnd", $hwnd, "uint_ptr", $__g_atimers_atimerids[$x][0x0])
            EndIf
            If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, False)
            $hcallback = $__g_atimers_atimerids[$x][0x2]
            If $hcallback <> 0x0 Then DllCallbackFree($hcallback)
            For $i = $x To $iubound + -1
                $__g_atimers_atimerids[$i][0x0] = $__g_atimers_atimerids[$i + 0x1][0x0]
                $__g_atimers_atimerids[$i][0x1] = $__g_atimers_atimerids[$i + 0x1][0x1]
                $__g_atimers_atimerids[$i][0x2] = $__g_atimers_atimerids[$i + 0x1][0x2]
            Next
            ReDim $__g_atimers_atimerids[UBound($__g_atimers_atimerids + -1)][0x3]
            $__g_atimers_atimerids[0x0][0x0]-= 0x1
            ExitLoop
        EndIf
    Next
    Return $acall[0x0] <> 0x0
EndFunc    ; -> _Timer_KillTimer

Func __Timer_QueryPerformanceCounter()
    Local $acall = DllCall("kernel32.dll", "bool", "QueryPerformanceCounter", "int64*", 0x0)
    If @error Then Return SetError(@error, @extended, + -1)
    Return SetExtended($acall[0x0], $acall[0x1])
EndFunc    ; -> __Timer_QueryPerformanceCounter

Func __Timer_QueryPerformanceFrequency()
    Local $acall = DllCall("kernel32.dll", "bool", "QueryPerformanceFrequency", "int64*", 0x0)
    If @error Then Return SetError(@error, @extended, 0x0)
    Return SetExtended($acall[0x0], $acall[0x1])
EndFunc    ; -> __Timer_QueryPerformanceFrequency

Func _Timer_SetTimer($hwnd, $ielapse = 0xfa, $stimerfunc = '', $itimerid = + -1)
    #Au3Stripper_Ignore_Funcs=$sTimerFunc
    Local $acall[0x1] = [0x0], $ptimerfunc = 0x0, $hcallback = 0x0, $iindex = $__g_atimers_atimerids[0x0][0x0] + 0x1
    If $itimerid = + -1 Then
        ReDim $__g_atimers_atimerids[$iindex + 0x1][0x3]
        $__g_atimers_atimerids[0x0][0x0] = $iindex
        $itimerid = $iindex + 0x3e8
        For $x = 0x1 To $iindex
            If $__g_atimers_atimerids[$x][0x0] = $itimerid Then
                $itimerid = $itimerid + 0x1
                $x = 0x0
            EndIf
        Next
        If $stimerfunc <> '' Then
            $hcallback = DllCallbackRegister($stimerfunc, "none", "hwnd;uint;uint_ptr;dword")
            If $hcallback = 0x0 Then Return SetError(+ -1, + -1, 0x0)
            $ptimerfunc = DllCallbackGetPtr($hcallback)
            If $ptimerfunc = 0x0 Then Return SetError(+ -1, + -2, 0x0)
        EndIf
        $acall = DllCall("user32.dll", "uint_ptr", "SetTimer", "hwnd", $hwnd, "uint_ptr", $itimerid, "uint", $ielapse, "ptr", $ptimerfunc)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        $__g_atimers_atimerids[$iindex][0x0] = $acall[0x0]
        $__g_atimers_atimerids[$iindex][0x1] = $itimerid
        $__g_atimers_atimerids[$iindex][0x2] = $hcallback
    Else
        For $x = 0x1 To $iindex + -1
            If $__g_atimers_atimerids[$x][0x0] = $itimerid Then
                If IsHWnd($hwnd) Then $itimerid = $__g_atimers_atimerids[$x][0x1]
                $hcallback = $__g_atimers_atimerids[$x][0x2]
                If $hcallback <> 0x0 Then
                    $ptimerfunc = DllCallbackGetPtr($hcallback)
                    If $ptimerfunc = 0x0 Then Return SetError(+ -1, + -12, 0x0)
                EndIf
                $acall = DllCall("user32.dll", "uint_ptr", "SetTimer", "hwnd", $hwnd, "uint_ptr", $itimerid, "uint", $ielapse, "ptr", $ptimerfunc)
                If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
                ExitLoop
            EndIf
        Next
    EndIf
    Return $acall[0x0]
EndFunc    ; -> _Timer_SetTimer

Global $__g_hvisa_default_rm = + -1
Global Const $VI_SUCCESS = 0x0
Global Const $VI_NULL = 0x0
Global Const $VI_TRUE = 0x1
Global Const $VI_FALSE = 0x0
Global Const $VI_GPIB_REN_DEASSERT = 0x0
Global Const $VI_GPIB_REN_ASSERT = 0x1
Global Const $VI_GPIB_REN_DEASSERT_GTL = 0x2
Global Const $VI_GPIB_REN_ASSERT_ADDRESS = 0x3
Global Const $VI_GPIB_REN_ASSERT_LLO = 0x4
Global Const $VI_GPIB_REN_ASSERT_ADDRESS_LLO = 0x5
Global Const $VI_GPIB_REN_ADDRESS_GTL = 0x6
Global Const $VI_ATTR_TMO_VALUE = 0x3fff001a
Global Const $VI_ATTR_ASRL_BAUD = 0x3fff0021
Global Const $VI_ATTR_ASRL_DATA_BITS = 0x3fff0022
Global Const $VI_ATTR_ASRL_PARITY = 0x3fff0023
Global Const $VI_ATTR_ASRL_STOP_BITS = 0x3fff0024
Global Const $VI_ATTR_ASRL_FLOW_CNTRL = 0x3fff0025
Global Const $VI_ATTR_TERMCHAR = 0x3fff0018
Global Const $VI_ATTR_TERMCHAR_EN = 0x3fff0038
Global Const $VI_ATTR_SEND_END_EN = 0x3fff0016
Global Const $VI_TMO_IMMEDIATE = 0x0
Global Const $VI_TMO_INFINITE = 0xfffffff
Global Const $VI_ASRL_PAR_NONE = 0x0
Global Const $VI_ASRL_PAR_ODD = 0x1
Global Const $VI_ASRL_PAR_EVEN = 0x2
Global Const $VI_ASRL_PAR_MARK = 0x3
Global Const $VI_ASRL_PAR_SPACE = 0x4
Global Const $VI_ASRL_STOP_ONE = 0xa
Global Const $VI_ASRL_STOP_ONE5 = 0xf
Global Const $VI_ASRL_STOP_TWO = 0x14
Global Const $VI_ASRL_FLOW_NONE = 0x0
Global Const $VI_ASRL_FLOW_XON_XOFF = 0x1
Global Const $VI_ASRL_FLOW_RTS_CTS = 0x2
Global Const $VI_ASRL_FLOW_DTR_DSR = 0x4
Func _viExecCommand($hsession, $scommand, $itimeoutms = + -1, $smode = @LF)
    If StringInStr($scommand, "?") = 0x0 Then
        Return __viPrintf($hsession, $scommand, $itimeoutms, $smode)
    Else
        Return __viQueryf($hsession, $scommand, $itimeoutms)
    EndIf
EndFunc    ; -> _viExecCommand

Func _viOpen($svisa_address, $svisa_secondary_address = 0x0)
    Local $hsession = + -1
    If IsNumber($svisa_address) Or StringInStr($svisa_address, "::") = 0x0 Then
        $svisa_address = "GPIB0::" & $svisa_address & "::" & $svisa_secondary_address
    EndIf
    __viOpenDefaultRM()
    Local $a_results
    $a_results = DllCall("visa32.dll", "long", "viOpen", "long", $__g_hvisa_default_rm, "str", $svisa_address, "long", $VI_NULL, "long", $VI_NULL, "long*", + -1)
    If @error Then Return SetError(@error, @extended, + -1)
    Local $ierrstatus = $a_results[0x0]
    If $ierrstatus <> 0x0 Then
        Return SetError(0x1, 0x0, + -2)
    EndIf
    If UBound($a_results) < 0x6 Then
        Return SetError(0x1, 0x0, + -3)
    EndIf
    $hsession = $a_results[0x5]
    If $hsession <= 0x0 Then
        Return SetError(0x1, 0x0, + -4)
    EndIf
    Return $hsession
EndFunc    ; -> _viOpen

Func _viClose($hsession)
    Local $a_results
    $a_results = DllCall("visa32.dll", "int", "viClose", "int", $hsession)
    If @error Then Return SetError(@error, @extended, + -1)
    Local $ierrstatus = $a_results[0x0]
    If $ierrstatus <> 0x0 Then
        Return SetError(0x1, 0x0, $ierrstatus)
    EndIf
    Return 0x0
EndFunc    ; -> _viClose

Func _viFindGpib(ByRef $adescriptorlist, ByRef $aidnlist, $ishow_search_results = 0x0)
    __viOpenDefaultRM()
    Local $a_results = DllCall("visa32.dll", "long", "viFindRsrc", "long", $__g_hvisa_default_rm, "str", "GPIB?*INSTR", "long*", + -1, "int*", + -1, "str", '')
    If @error Then Return SetError(@error, @extended, + -1)
    Local $ierrstatus = $a_results[0x0]
    If $ierrstatus <> 0x0 Then
        Return SetError(0x1, 0x0, + -2)
    EndIf
    If UBound($a_results) < 0x5 Then
        Return SetError(0x1, 0x0, + -3)
    EndIf
    Local $h_list_pointer = $a_results[0x3]
    Local $i_num_instr = $a_results[0x4]
    Local $s_first_descriptor = $a_results[0x5]
    If $i_num_instr < 0x1 Then
        If $ishow_search_results = 0x1 Then
            MsgBox($MB_SYSTEMMODAL, "GPIB search results", "NO INSTRUMENTS FOUND in the GPIB bus")
        EndIf
        Return $i_num_instr
    EndIf
    ReDim $adescriptorlist[$i_num_instr], $aidnlist[$i_num_instr]
    $adescriptorlist[0x0] = $s_first_descriptor
    $aidnlist[0x0] = _viExecCommand($s_first_descriptor, "*IDN?")
    For $n = 0x1 To $i_num_instr + -1
        $a_results = DllCall("visa32.dll", "long", "viFindNext", "long", $h_list_pointer, "str", '')
        If @error Then Return SetError(@error, @extended, + -1)
        $ierrstatus = $a_results[0x0]
        If $ierrstatus <> 0x0 Then
            Return SetError(0x1, 0x0, + -2)
        EndIf
        If UBound($a_results) < 0x3 Then
            Return SetError(0x1, 0x0, + -3)
        EndIf
        $adescriptorlist[$n] = $a_results[0x2]
        $aidnlist[$n] = _viExecCommand($adescriptorlist[$n], "*IDN?")
    Next
    If $ishow_search_results = 0x1 Then
        Local $s_search_results = ''
        For $n = 0x0 To $i_num_instr + -1
            $s_search_results = $s_search_results & $adescriptorlist[$n] & " - " & $aidnlist[$n] & @CR
        Next
        MsgBox($MB_SYSTEMMODAL, "GPIB search results", $s_search_results)
    EndIf
    Return $i_num_instr
EndFunc    ; -> _viFindGpib

Func __viOpenDefaultRM()
    Local $h_visa_rm = $__g_hvisa_default_rm
    If $__g_hvisa_default_rm < 0x0 Then
        $h_visa_rm = $__g_hvisa_default_rm
        Local $a_results
        $a_results = DllCall("visa32.dll", "int", "viOpenDefaultRM", "int*", $__g_hvisa_default_rm)
        If @error Then Return SetError(@error, @extended, + -1)
        Local $ierrstatus = $a_results[0x0]
        If $ierrstatus <> 0x0 Then
            Return SetError(0x1, 0x0, + -2)
        EndIf
        $__g_hvisa_default_rm = $a_results[0x1]
        If $__g_hvisa_default_rm <= 0x0 Then
            $__g_hvisa_default_rm = + -1
            SetError(0x1)
            Return + -3
        EndIf
        $h_visa_rm = $__g_hvisa_default_rm
    EndIf
    Return $h_visa_rm
EndFunc    ; -> __viOpenDefaultRM

Func __viPrintf($hsession, $scommand, $itimeout_ms = + -1, $soption = @LF)
    Local $b_close_session_before_return = 0x0
    If IsString($hsession) Then
        $b_close_session_before_return = 0x1
        $hsession = _viOpen($hsession)
    EndIf
    If $itimeout_ms >= 0x0 Then
        _viSetTimeout($hsession, $itimeout_ms)
    EndIf
    Local $a_results
    Select
    Case $soption = "str"
        $a_results = DllCall("visa32.dll", "int:cdecl", "viPrintf", "int", $hsession, "str", "%s", "str", $scommand)
    Case ($soption = @CR Or $soption = @LF Or $soption = @CRLF)
        $a_results = DllCall("visa32.dll", "int:cdecl", "viPrintf", "int", $hsession, "str", $scommand & $soption)
    Case Else
        $a_results = DllCall("visa32.dll", "int:cdecl", "viPrintf", "int", $hsession, "str", $scommand)
    EndSelect
    If @error Then Return SetError(@error, @extended, + -1)
    Local $ierrstatus = $a_results[0x0]
    If $ierrstatus <> 0x0 Then
        Return SetError(0x1, 0x0, $ierrstatus)
    EndIf
    If $b_close_session_before_return = 0x1 Then
        _viClose($hsession)
    EndIf
EndFunc    ; -> __viPrintf

Func __viQueryf($hsession, $squery, $itimeout_ms = + -1)
    Local $b_close_session_before_return = 0x0
    If IsString($hsession) Then
        $b_close_session_before_return = 0x1
        $hsession = _viOpen($hsession)
    EndIf
    If $itimeout_ms >= 0x0 Then
        _viSetTimeout($hsession, $itimeout_ms)
    EndIf
    Local $a_results, $s_answer = ''
    $a_results = DllCall("visa32.dll", "int:cdecl", "viQueryf", "int", $hsession, "str", $squery, "str", "%t", "str", $s_answer)
    If @error Then Return SetError(@error, @extended, + -1)
    Local $ierrstatus = $a_results[0x0]
    If $ierrstatus <> 0x0 Then
        Return SetError(0x1, 0x0, $ierrstatus)
    EndIf
    If UBound($a_results) < 0x5 Then
        Return SetError(0x1, 0x0, + -3)
    EndIf
    $s_answer = $a_results[0x4]
    If $b_close_session_before_return = 0x1 Then
        _viClose($hsession)
    EndIf
    Return $s_answer
EndFunc    ; -> __viQueryf

Func _viSetTimeout($hsession, $itimeoutms)
    If String($itimeoutms) = "INF" Then
        $itimeoutms = $VI_TMO_INFINITE
    EndIf
    Return _viSetAttribute($hsession, $VI_ATTR_TMO_VALUE, $itimeoutms)
EndFunc    ; -> _viSetTimeout

Func _viSetAttribute($hsession, $iattribute, $ivalue)
    Local $b_close_session_before_return = 0x0
    If IsString($hsession) Then
        $b_close_session_before_return = 0x1
        $hsession = _viOpen($hsession)
    EndIf
    Local $a_results
    $a_results = DllCall("visa32.dll", "int", "viSetAttribute", "int", $hsession, "int", $iattribute, "int", $ivalue)
    If @error Then Return SetError(@error, @extended, + -1)
    Local $ierrstatus = $a_results[0x0]
    If $ierrstatus <> 0x0 Then
        Return SetError(0x1, 0x0, $ierrstatus)
    EndIf
    If $b_close_session_before_return = 0x1 Then
        _viClose($hsession)
    EndIf
    Return 0x0
EndFunc    ; -> _viSetAttribute

Func _viGTL($hsession)
    Return __viGpibControlREN($hsession, $VI_GPIB_REN_ADDRESS_GTL)
EndFunc    ; -> _viGTL

Func _viGpibBusReset()
    Return __viGpibControlREN("GPIB0::INTFC", $VI_GPIB_REN_DEASSERT)
EndFunc    ; -> _viGpibBusReset

Func __viGpibControlREN($hsession, $imode)
    Local $b_close_session_before_return = 0x0
    If IsString($hsession) Then
        $b_close_session_before_return = 0x1
        $hsession = _viOpen($hsession)
    EndIf
    Local $a_results
    $a_results = DllCall("visa32.dll", "int", "viGpibControlREN", "int", $hsession, "int", $imode)
    If @error Then Return SetError(@error, @extended, + -1)
    Local $ierrstatus = $a_results[0x0]
    If $ierrstatus <> 0x0 Then
        Return SetError(0x1, 0x0, $ierrstatus)
    EndIf
    If $b_close_session_before_return = 0x1 Then
        _viClose($hsession)
    EndIf
    Return 0x0
EndFunc    ; -> __viGpibControlREN

Func _viInteractiveControl($scommand_save_filepath = '')
    Local $s_vi_id = "FIND"
    Local $scommand = "*IDN?"
    Local $itimeout_ms = 0x2710
    Local $s_answer = ''
    Local $adescriptor_list[0x1], $aidn_list[0x1]
    Local $s_empty_command_list = "#include <Visa.au3>" & @CR & @CR & "Local $s_Answer" & @CR & @CR
    Local $s_new_command = ''
    Local $scommand_list = $s_empty_command_list
    While 0x1
        $s_vi_id = InputBox("Instrument Device Descriptor", "- Type the Instrument Device Descriptor (e.g. 'GPIB::1::0' or 'GPIB::1::INSTR')" & @CR & @CR & "- Type FIND to perform a GPIB search" & @CR & @CR & "- Click CANCEL to STOP the VISA interactive tool", $s_vi_id, '', 0x1f4, 0xfa)
        If @error = 0x1 Then
            ExitLoop
        EndIf
        If $s_vi_id = "FIND" Then
            $scommand_list = $scommand_list & "Local $aDescriptor_list[1], $aIdn_list[1]" & @CR & @CR & "_viFindGpib($aDescriptor_list, $aIdn_list, 1)" & @CR & @CR
            _viFindGpib($adescriptor_list, $aidn_list, 0x1)
            If UBound($adescriptor_list) >= 0x1 Then
                $s_vi_id = $adescriptor_list[0x0]
            EndIf
            ContinueLoop
        EndIf
        $s_answer = InputBox("SCPI command", "Type the SCPI command", $scommand)
        If @error = 0x1 Then
            ContinueLoop
        EndIf
        $scommand = $s_answer
        $s_answer = InputBox("Command Timeout (ms)", "Type the command timeout (in milliseconds)", $itimeout_ms)
        If @error = 0x1 Then
            ContinueLoop
        EndIf
        $itimeout_ms = 0x0 + $s_answer
        $s_new_command = "$s_Answer = _viExecCommand(""" & $s_vi_id & """, """ & $scommand & """, " & $itimeout_ms & ")"
        $scommand_list = $scommand_list & $s_new_command & @CR
        $s_answer = _viExecCommand($s_vi_id, $scommand, $itimeout_ms)
        If IsString($s_answer) Then
            MsgBox($MB_SYSTEMMODAL, "Query results", "[" & $s_vi_id & "] " & $scommand & " -> " & $s_answer)
        ElseIf $s_answer = 0x0 Then
            MsgBox($MB_SYSTEMMODAL, "Command result", "The command:" & @CR & @CR & "         '" & $scommand & "'" & @CR & @CR & "was SUCCESSFULLY executed on the device: " & @CR & @CR & "         '" & $s_vi_id & "'")
        ElseIf $s_answer < 0x0 Then
            $s_answer = MsgBox($MB_SYSTEMMODAL, "VISA Error", "There was a VISA error when executing the command:" & @CR & @CR & "'" & $scommand & "'" & @CR & @CR & "on the Device '" & $s_vi_id & "'" & @CR & @CR & "Do you want to RESET the GPIB bus before continuing?")
            If $s_answer = 0x6 Then
                _viGpibBusReset()
                MsgBox($MB_SYSTEMMODAL, "VISA", "The GPIB bus was RESET!")
            EndIf
        EndIf
    WEnd
    If $scommand_list <> $s_empty_command_list Then
        If $scommand_save_filepath = '' Then
            $s_answer = MsgBox(0x40 + 0x4, "Save commands to AutoIt3 script?", "Do you want to save the commands that you issued into an AutoIt3 script?")
            If $s_answer = 0x6 Then
                $scommand_save_filepath = FileSaveDialog("Save as...", @ScriptDir, "AutoIt3 scripts (*.au3)", 0x10, "visa_log.au3")
                If @error Then
                    $scommand_save_filepath = ''
                EndIf
            EndIf
        EndIf
        If $scommand_save_filepath <> '' Then
            If FileExists($scommand_save_filepath) Then
                FileDelete($scommand_save_filepath)
            EndIf
            FileWrite($scommand_save_filepath, $scommand_list)
        EndIf
    EndIf
    Return $scommand_list
EndFunc    ; -> _viInteractiveControl

#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_CommandLineToArgv($scmd)
        Local $aret[0x1] = [0x0]
        $scmd = StringStripWS($scmd, $STR_STRIPLEADING + $STR_STRIPTRAILING)
        If Not $scmd Then
            Return $aret
        EndIf
        Local $acall = DllCall("shell32.dll", "ptr", "CommandLineToArgvW", "wstr", $scmd, "int*", 0x0)
        If @error Or Not $acall[0x0] Or (Not $acall[0x2]) Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $tptr = DllStructCreate("ptr[" & $acall[0x2] & "]", $acall[0x0])
        Dim $aret[$acall[0x2] + 0x1] = [$acall[0x2]]
        For $i = 0x1 To $acall[0x2]
            $aret[$i] = _WinAPI_GetString(DllStructGetData($tptr, 0x1, $i))
        Next
        DllCall("kernel32.dll", "handle", "LocalFree", "handle", $acall[0x0])
        Return $aret
    EndFunc    ; -> _WinAPI_CommandLineToArgv

    Func _WinAPI_IsNameInExpression($sstring, $SPATTERN, $bcasesensitive = False)
        If Not $bcasesensitive Then $SPATTERN = StringUpper($SPATTERN)
        Local $tus1 = __us($SPATTERN)
        Local $tus2 = __us($sstring)
        Local $acall = DllCall("ntdll.dll", "boolean", "RtlIsNameInExpression", "struct*", $tus1, "struct*", $tus2, "boolean", Not $bcasesensitive, "ptr", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsNameInExpression

    Func _WinAPI_ParseURL($surl)
        Local $tagparsedurl = "dword Size;ptr Protocol;uint cchProtocol;ptr Suffix;uint cchSuffix;uint Scheme"
        Local $tpurl = DllStructCreate($tagparsedurl)
        DllStructSetData($tpurl, 0x1, DllStructGetSize($tpurl))
        Local $turl = DllStructCreate("wchar[4096]")
        DllStructSetData($turl, 0x1, $surl)
        Local $acall = DllCall("shlwapi.dll", "long", "ParseURLW", "struct*", $turl, "struct*", $tpurl)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Local $aret[0x3]
        $aret[0x0] = DllStructGetData(DllStructCreate("wchar[" & DllStructGetData($tpurl, 0x3) & "]", DllStructGetData($tpurl, 0x2)), 0x1)
        $aret[0x1] = DllStructGetData(DllStructCreate("wchar[" & DllStructGetData($tpurl, 0x5) & "]", DllStructGetData($tpurl, 0x4)), 0x1)
        $aret[0x2] = DllStructGetData($tpurl, 0x6)
        Return $aret
    EndFunc    ; -> _WinAPI_ParseURL

    Func _WinAPI_ParseUserName($suser)
        If Not __dll("credui.dll") Then Return SetError(0x67, 0x0, 0x0)
        Local $acall = DllCall("credui.dll", "dword", "CredUIParseUserNameW", "wstr", $suser, "wstr", '', "ulong", 0x1000, "wstr", '', "ulong", 0x1000)
        If @error Then Return SetError(@error, @extended, 0x0)
        Switch $acall[0x0]
        Case 0x0
        Case 0x523
            If StringStripWS($suser, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
                $acall[0x2] = $suser
                $acall[0x4] = ''
            Else
                ContinueCase
            EndIf
        Case Else
            Return SetError(0xa, $acall[0x0], 0x0)
        EndSwitch
        Local $aret[0x2]
        $aret[0x0] = $acall[0x4]
        $aret[0x1] = $acall[0x2]
        Return $aret
    EndFunc    ; -> _WinAPI_ParseUserName

    Func _WinAPI_PathAddBackslash($sfilepath)
        Local $tpath = DllStructCreate("wchar[260]")
        DllStructSetData($tpath, 0x1, $sfilepath)
        Local $acall = DllCall("shlwapi.dll", "ptr", "PathAddBackslashW", "struct*", $tpath)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return DllStructGetData($tpath, 0x1)
    EndFunc    ; -> _WinAPI_PathAddBackslash

    Func _WinAPI_PathAddExtension($sfilepath, $sext = '')
        Local $tpath = DllStructCreate("wchar[260]")
        DllStructSetData($tpath, 0x1, $sfilepath)
        If Not StringStripWS($sext, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sext = Null
        Local $acall = DllCall("shlwapi.dll", "bool", "PathAddExtensionW", "struct*", $tpath, "wstr", $sext)
        If @error Then Return SetError(@error, @extended, '')
        Return SetExtended($acall[0x0], DllStructGetData($tpath, 0x1))
    EndFunc    ; -> _WinAPI_PathAddExtension

    Func _WinAPI_PathAppend($sfilepath, $smore)
        Local $tpath = DllStructCreate("wchar[260]")
        DllStructSetData($tpath, 0x1, $sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathAppendW", "struct*", $tpath, "wstr", $smore)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return DllStructGetData($tpath, 0x1)
    EndFunc    ; -> _WinAPI_PathAppend

    Func _WinAPI_PathBuildRoot($idrive)
        Local $acall = DllCall("shlwapi.dll", "ptr", "PathBuildRootW", "wstr", '', "int", $idrive)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathBuildRoot

    Func _WinAPI_PathCanonicalize($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathCanonicalizeW", "wstr", '', "wstr", $sfilepath)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, $sfilepath)
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathCanonicalize

    Func _WinAPI_PathCommonPrefix($spath1, $spath2)
        Local $acall = DllCall("shlwapi.dll", "int", "PathCommonPrefixW", "wstr", $spath1, "wstr", $spath2, "wstr", '')
        If @error Then Return SetError(@error, @extended, '')
        Return SetExtended($acall[0x0], $acall[0x3])
    EndFunc    ; -> _WinAPI_PathCommonPrefix

    Func _WinAPI_PathCompactPath($hwnd, $sfilepath, $iwidth = 0x0)
        If $iwidth < 0x1 Then
            Local $trect = DllStructCreate($TAGRECT)
            DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hwnd, "struct*", $trect)
            $iwidth += DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
        EndIf
        Local $acall = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, $sfilepath)
        Local $hdc = $acall[0x0]
        Local Const $WM_GETFONT = 0x31
        $acall = DllCall("user32.dll", "ptr", "SendMessage", "hwnd", $hwnd, "uint", $WM_GETFONT, "wparam", 0x0, "lparam", 0x0)
        Local $hback = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $acall[0x0])
        Local $ierror = 0x0
        $acall = DllCall("shlwapi.dll", "bool", "PathCompactPathW", "handle", $hdc, "wstr", $sfilepath, "int", $iwidth)
        If @error Or Not $acall[0x0] Then $ierror = @error + 0xa
        DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $hback[0x0])
        DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
        If $ierror Then Return SetError($ierror, 0x0, $sfilepath)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_PathCompactPath

    Func _WinAPI_PathCompactPathEx($sfilepath, $imax)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathCompactPathExW", "wstr", '', "wstr", $sfilepath, "uint", $imax + 0x1, "dword", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, $sfilepath)
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathCompactPathEx

    Func _WinAPI_PathCreateFromUrl($surl)
        Local $acall = DllCall("shlwapi.dll", "long", "PathCreateFromUrlW", "wstr", $surl, "wstr", '', "dword*", 0x1000, "dword", 0x0)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_PathCreateFromUrl

    Func _WinAPI_PathFindExtension($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "wstr", "PathFindExtensionW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathFindExtension

    Func _WinAPI_PathFindFileName($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "wstr", "PathFindFileNameW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, $sfilepath)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathFindFileName

    Func _WinAPI_PathFindNextComponent($sfilepath)
        Local $tpath = DllStructCreate("wchar[" & (StringLen($sfilepath) + 0x1) & "]")
        DllStructSetData($tpath, 0x1, $sfilepath)
        Local $acall = DllCall("shlwapi.dll", "ptr", "PathFindNextComponentW", "struct*", $tpath)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return _WinAPI_GetString($acall[0x0])
    EndFunc    ; -> _WinAPI_PathFindNextComponent

    Func _WinAPI_PathFindOnPath(Const $sfilepath, $AEXTRAPATHS = '', Const $SPATHDELIMITER = @LF)
        Local $iextracount = 0x0
        If IsString($AEXTRAPATHS) Then
            If StringLen($AEXTRAPATHS) Then
                $AEXTRAPATHS = StringSplit($AEXTRAPATHS, $SPATHDELIMITER, $STR_ENTIRESPLIT + $STR_NOCOUNT)
                $iextracount = UBound($AEXTRAPATHS, $UBOUND_ROWS)
            EndIf
        ElseIf IsArray($AEXTRAPATHS) Then
            $iextracount = UBound($AEXTRAPATHS)
        EndIf
        Local $tpaths, $tpathptrs
        If $iextracount Then
            Local $tagstruct = ''
            For $path In $AEXTRAPATHS
                $tagstruct &= "wchar[" & StringLen($path) + 0x1 & "];"
            Next
            $tpaths = DllStructCreate($tagstruct)
            $tpathptrs = DllStructCreate("ptr[" & $iextracount + 0x1 & "]")
            For $i = 0x1 To $iextracount
                DllStructSetData($tpaths, $i, $AEXTRAPATHS[$i + -1])
                DllStructSetData($tpathptrs, 0x1, DllStructGetPtr($tpaths, $i), $i)
            Next
            DllStructSetData($tpathptrs, 0x1, Ptr(0x0), $iextracount + 0x1)
        EndIf
        Local $acall = DllCall("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $sfilepath, "struct*", $tpathptrs)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, $sfilepath)
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathFindOnPath

    Func _WinAPI_PathGetArgs($sfilepath)
        Local $tpath = DllStructCreate("wchar[" & (StringLen($sfilepath) + 0x1) & "]")
        DllStructSetData($tpath, 0x1, $sfilepath)
        Local $acall = DllCall("shlwapi.dll", "ptr", "PathGetArgsW", "struct*", $tpath)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return _WinAPI_GetString($acall[0x0])
    EndFunc    ; -> _WinAPI_PathGetArgs

    Func _WinAPI_PathGetCharType($schar)
        Local $acall = DllCall("shlwapi.dll", "uint", "PathGetCharTypeW", "word", AscW($schar))
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathGetCharType

    Func _WinAPI_PathGetDriveNumber($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "int", "PathGetDriveNumberW", "wstr", $sfilepath)
        If @error Or ($acall[0x0] = + -1) Then Return SetError(@error, @extended, '')
        Return Chr($acall[0x0] + 0x41) & ":"
    EndFunc    ; -> _WinAPI_PathGetDriveNumber

    Func _WinAPI_PathIsContentType($sfilepath, $stype)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsContentTypeW", "wstr", $sfilepath, "wstr", $stype)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsContentType

    Func _WinAPI_PathIsExe($sfilepath)
        Local $acall = DllCall("shell32.dll", "bool", "PathIsExe", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsExe

    Func _WinAPI_PathIsFileSpec($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsFileSpecW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsFileSpec

    Func _WinAPI_PathIsLFNFileSpec($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsLFNFileSpecW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsLFNFileSpec

    Func _WinAPI_PathIsRelative($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsRelativeW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsRelative

    Func _WinAPI_PathIsRoot($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsRootW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsRoot

    Func _WinAPI_PathIsSameRoot($spath1, $spath2)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsSameRootW", "wstr", $spath1, "wstr", $spath2)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsSameRoot

    Func _WinAPI_PathIsSystemFolder($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsSystemFolderW", "wstr", $sfilepath, "dword", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsSystemFolder

    Func _WinAPI_PathIsUNC($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsUNCW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsUNC

    Func _WinAPI_PathIsUNCServer($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsUNCServerW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsUNCServer

    Func _WinAPI_PathIsUNCServerShare($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsUNCServerShareW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsUNCServerShare

    Func _WinAPI_PathMakeSystemFolder($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathMakeSystemFolderW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathMakeSystemFolder

    Func _WinAPI_PathMatchSpec($sfilepath, $sspec)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathMatchSpecW", "wstr", $sfilepath, "wstr", $sspec)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathMatchSpec

    Func _WinAPI_PathParseIconLocation($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "int", "PathParseIconLocationW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, 0x0)
        Local $aret[0x2]
        $aret[0x0] = $acall[0x1]
        $aret[0x1] = $acall[0x0]
        Return $aret
    EndFunc    ; -> _WinAPI_PathParseIconLocation

    Func _WinAPI_PathRelativePathTo($spathfrom, $bdirfrom, $spathto, $bdirto)
        If $bdirfrom Then
            $bdirfrom = 0x10
        EndIf
        If $bdirto Then
            $bdirto = 0x10
        EndIf
        Local $acall = DllCall("shlwapi.dll", "bool", "PathRelativePathToW", "wstr", '', "wstr", $spathfrom, "dword", $bdirfrom, "wstr", $spathto, "dword", $bdirto)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathRelativePathTo

    Func _WinAPI_PathRemoveArgs($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "none", "PathRemoveArgsW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathRemoveArgs

    Func _WinAPI_PathRemoveBackslash($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "ptr", "PathRemoveBackslashW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathRemoveBackslash

    Func _WinAPI_PathRemoveExtension($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "none", "PathRemoveExtensionW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathRemoveExtension

    Func _WinAPI_PathRemoveFileSpec($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathRemoveFileSpecW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, '')
        Return SetExtended($acall[0x0], $acall[0x1])
    EndFunc    ; -> _WinAPI_PathRemoveFileSpec

    Func _WinAPI_PathRenameExtension($sfilepath, $sext)
        Local $tpath = DllStructCreate("wchar[260]")
        DllStructSetData($tpath, 0x1, $sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathRenameExtensionW", "struct*", $tpath, "wstr", $sext)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return DllStructGetData($tpath, 0x1)
    EndFunc    ; -> _WinAPI_PathRenameExtension

    Func _WinAPI_PathSearchAndQualify($sfilepath, $bexists = False)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathSearchAndQualifyW", "wstr", $sfilepath, "wstr", '', "int", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        If $bexists And Not FileExists($acall[0x2]) Then Return SetError(0x14, 0x0, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_PathSearchAndQualify

    Func _WinAPI_PathSkipRoot($sfilepath)
        Local $tpath = DllStructCreate("wchar[" & (StringLen($sfilepath) + 0x1) & "]")
        DllStructSetData($tpath, 0x1, $sfilepath)
        Local $acall = DllCall("shlwapi.dll", "ptr", "PathSkipRootW", "struct*", $tpath)
        If @error Then Return SetError(@error, @extended, '')
        If Not $acall[0x0] Then Return $sfilepath
        Return _WinAPI_GetString($acall[0x0])
    EndFunc    ; -> _WinAPI_PathSkipRoot

    Func _WinAPI_PathStripPath($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "none", "PathStripPathW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathStripPath

    Func _WinAPI_PathStripToRoot($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathStripToRootW", "wstr", $sfilepath)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathStripToRoot

    Func _WinAPI_PathUndecorate($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "none", "PathUndecorateW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathUndecorate

    Func _WinAPI_PathUnExpandEnvStrings($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathUnExpandEnvStringsW", "wstr", $sfilepath, "wstr", '', "uint", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_PathUnExpandEnvStrings

    Func _WinAPI_PathUnmakeSystemFolder($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathUnmakeSystemFolderW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathUnmakeSystemFolder

    Func _WinAPI_PathUnquoteSpaces($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "none", "PathUnquoteSpacesW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathUnquoteSpaces

    Func _WinAPI_PathYetAnotherMakeUniqueName($sfilepath)
        Local $acall = DllCall("shell32.dll", "int", "PathYetAnotherMakeUniqueName", "wstr", '', "wstr", $sfilepath, "ptr", 0x0, "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_PathYetAnotherMakeUniqueName

    Func _WinAPI_ShellGetImageList($bsmall = False)
        Local $plarge, $psmall, $tptr = DllStructCreate("ptr")
        If $bsmall Then
            $plarge = 0x0
            $psmall = DllStructGetPtr($tptr)
        Else
            $plarge = DllStructGetPtr($tptr)
            $psmall = 0x0
        EndIf
        Local $acall = DllCall("shell32.dll", "int", "Shell_GetImageLists", "ptr", $plarge, "ptr", $psmall)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return DllStructGetData($tptr, 0x1)
    EndFunc    ; -> _WinAPI_ShellGetImageList

    Func _WinAPI_UrlApplyScheme($surl, $IFLAGS = 0x1)
        Local $acall = DllCall("shlwapi.dll", "long", "UrlApplySchemeW", "wstr", $surl, "wstr", '', "dword*", 0x1000, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_UrlApplyScheme

    Func _WinAPI_UrlCanonicalize($surl, $IFLAGS)
        Local $acall = DllCall("shlwapi.dll", "long", "UrlCanonicalizeW", "wstr", $surl, "wstr", '', "dword*", 0x1000, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_UrlCanonicalize

    Func _WinAPI_UrlCombine($surl, $spart, $IFLAGS = 0x0)
        Local $acall = DllCall("shlwapi.dll", "long", "UrlCombineW", "wstr", $surl, "wstr", $spart, "wstr", '', "dword*", 0x1000, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_UrlCombine

    Func _WinAPI_UrlCompare($surl1, $surl2, $bignoreslash = False)
        Local $acall = DllCall("shlwapi.dll", "int", "UrlCompareW", "wstr", $surl1, "wstr", $surl2, "bool", $bignoreslash)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UrlCompare

    Func _WinAPI_UrlCreateFromPath($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "long", "UrlCreateFromPathW", "wstr", $sfilepath, "wstr", '', "dword*", 0x1000, "dword", 0x0)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] < 0x0 Or $acall[0x0] > 0x1 Then
            Return SetError(0xa, $acall[0x0], '')
        EndIf
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_UrlCreateFromPath

    Func _WinAPI_UrlFixup($surl)
        Local $acall = DllCall("shlwapi.dll", "long", "UrlFixupW", "wstr", $surl, "wstr", '', "dword", 0x1000)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_UrlFixup

    Func _WinAPI_UrlGetPart($surl, $ipart)
        Local $acall = DllCall("shlwapi.dll", "long", "UrlGetPartW", "wstr", $surl, "wstr", '', "dword*", 0x1000, "dword", $ipart, "dword", 0x0)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_UrlGetPart

    Func _WinAPI_UrlHash($surl, $ilength = 0x20)
        If $ilength <= 0x0 Or $ilength > 0x100 Then Return SetError(0x100, 0x0, 0x0)
        Local $tdata = DllStructCreate("byte[" & $ilength & "]")
        Local $acall = DllCall("shlwapi.dll", "long", "UrlHashW", "wstr", $surl, "struct*", $tdata, "dword", $ilength)
        If @error Then Return SetError(@error + 0xa, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return DllStructGetData($tdata, 0x1)
    EndFunc    ; -> _WinAPI_UrlHash

    Func _WinAPI_UrlIs($surl, $itype = 0x0)
        Local $acall = DllCall("shlwapi.dll", "bool", "UrlIsW", "wstr", $surl, "uint", $itype)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UrlIs

#EndRegion Public Functions
#Region Internal Functions
    Func __us($sstring, $ilength = 0x0)
        If $ilength Then
            $sstring = StringLeft($sstring, $ilength)
        Else
            $ilength = StringLen($sstring)
        EndIf
        Local $tus = DllStructCreate("ushort;ushort;ptr;wchar[" & ($ilength + 0x1) & "]")
        DllStructSetData($tus, 0x1, 0x2 * StringLen($sstring))
        DllStructSetData($tus, 0x2, 0x2 * $ilength)
        DllStructSetData($tus, 0x3, DllStructGetPtr($tus, 0x4))
        DllStructSetData($tus, 0x4, $sstring)
        Return $tus
    EndFunc    ; -> __us

#EndRegion Internal Functions
#Region Global Variables and Constants
    Global Const $TAGNOTIFYICONDATA = "struct;dword Size;hwnd hWnd;uint ID;uint Flags;uint CallbackMessage;ptr hIcon;wchar Tip[128];dword State;dword StateMask;wchar Info[256];uint Version;wchar Info" & _
        "Title[64];dword InfoFlags;endstruct"
    Global Const $TAGNOTIFYICONDATA_V3 = $TAGNOTIFYICONDATA & ";" & $TAGGUID
    Global Const $TAGNOTIFYICONDATA_V4 = $TAGNOTIFYICONDATA_V3 & ";ptr hBalloonIcon;"
    Global Const $TAGSHELLEXECUTEINFO = "dword Size;ulong Mask;hwnd hWnd;ptr Verb;ptr File;ptr Parameters;ptr Directory;int Show;ulong_ptr hInstApp;ptr IDList;ptr Class;ulong_ptr hKeyClass;dword HotKey" & _
        ";ptr hMonitor;ptr hProcess"
    Global Const $TAGSHFILEINFO = "ptr hIcon;int iIcon;dword Attributes;wchar DisplayName[260];wchar TypeName[80]"
    Global Const $TAGSHFILEOPSTRUCT = "hwnd hWnd;uint Func;ptr From;ptr To;dword Flags;int fAnyOperationsAborted;ptr hNameMappings;ptr ProgressTitle"
    Global Const $TAGSHFOLDERCUSTOMSETTINGS = "dword Size;dword Mask;ptr GUID;ptr WebViewTemplate;dword SizeWVT;ptr WebViewTemplateVersion;ptr InfoTip;dword SizeIT;ptr CLSID;dword Flags;ptr IconFile;dword Si" & _
        "zeIF;int IconIndex;ptr Logo;dword SizeL"
    Global Const $TAGSHSTOCKICONINFO = "dword Size;ptr hIcon;int SysImageIndex;int iIcon;wchar Path[260]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_DefSubclassProc($hwnd, $imsg, $wparam, $lparam)
        Local $acall = DllCall("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DefSubclassProc

    Func _WinAPI_DllGetVersion($sfilepath)
        Local $tversion = DllStructCreate("dword[5]")
        DllStructSetData($tversion, 0x1, DllStructGetSize($tversion), 0x1)
        Local $acall = DllCall($sfilepath, "uint", "DllGetVersion", "struct*", $tversion)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Local $aret[0x4]
        For $i = 0x0 To 0x3
            $aret[$i] = DllStructGetData($tversion, 0x1, $i + 0x2)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_DllGetVersion

    Func _WinAPI_FindExecutable($sfilename, $sdirectory = '')
        Local $acall = DllCall("shell32.dll", "INT", "FindExecutableW", "wstr", $sfilename, "wstr", $sdirectory, "wstr", '')
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] <= 0x20 Then Return SetError(0xa, $acall[0x0], '')
        Return SetExtended($acall[0x0], $acall[0x3])
    EndFunc    ; -> _WinAPI_FindExecutable

    Func _WinAPI_GetAllUsersProfileDirectory()
        Local $acall = DllCall("userenv.dll", "bool", "GetAllUsersProfileDirectoryW", "wstr", '', "dword*", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_GetAllUsersProfileDirectory

    Func _WinAPI_GetDefaultUserProfileDirectory()
        Local $acall = DllCall("userenv.dll", "bool", "GetDefaultUserProfileDirectoryW", "wstr", '', "dword*", 0x1000)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_GetDefaultUserProfileDirectory

    Func _WinAPI_GetWindowSubclass($hwnd, $psubclassproc, $idsubclass)
        Local $acall = DllCall("comctl32.dll", "bool", "GetWindowSubclass", "hwnd", $hwnd, "ptr", $psubclassproc, "uint_ptr", $idsubclass, "dword_ptr*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x4]
    EndFunc    ; -> _WinAPI_GetWindowSubclass

    Func _WinAPI_RemoveWindowSubclass($hwnd, $psubclassproc, $idsubclass)
        Local $acall = DllCall("comctl32.dll", "bool", "RemoveWindowSubclass", "hwnd", $hwnd, "ptr", $psubclassproc, "uint_ptr", $idsubclass)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RemoveWindowSubclass

    Func _WinAPI_SetCurrentProcessExplicitAppUserModelID($sappid)
        Local $acall = DllCall("shell32.dll", "long", "SetCurrentProcessExplicitAppUserModelID", "wstr", $sappid)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_SetCurrentProcessExplicitAppUserModelID

    Func _WinAPI_SetWindowSubclass($hwnd, $psubclassproc, $idsubclass, $pdata = 0x0)
        Local $acall = DllCall("comctl32.dll", "bool", "SetWindowSubclass", "hwnd", $hwnd, "ptr", $psubclassproc, "uint_ptr", $idsubclass, "dword_ptr", $pdata)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetWindowSubclass

    Func _WinAPI_ShellAddToRecentDocs($sfilepath)
        If StringStripWS($sfilepath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
            $sfilepath = _WinAPI_PathSearchAndQualify($sfilepath, 0x1)
            If Not $sfilepath Then
                Return SetError(0x1, 0x0, 0x0)
            EndIf
        Else
            $sfilepath = Null
        EndIf
        DllCall("shell32.dll", "none", "SHAddToRecentDocs", "uint", 0x3, "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellAddToRecentDocs

    Func _WinAPI_ShellChangeNotify($ievent, $IFLAGS, $iitem1 = 0x0, $iitem2 = 0x0)
        Local $stypeofitem1 = "dword_ptr", $stypeofitem2 = "dword_ptr"
        If IsString($iitem1) Then
            $stypeofitem1 = "wstr"
        EndIf
        If IsString($iitem2) Then
            $stypeofitem2 = "wstr"
        EndIf
        DllCall("shell32.dll", "none", "SHChangeNotify", "long", $ievent, "uint", $IFLAGS, $stypeofitem1, $iitem1, $stypeofitem2, $iitem2)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellChangeNotify

    Func _WinAPI_ShellChangeNotifyDeregister($iid)
        Local $acall = DllCall("shell32.dll", "bool", "SHChangeNotifyDeregister", "ulong", $iid)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShellChangeNotifyDeregister

    Func _WinAPI_ShellChangeNotifyRegister($hwnd, $imsg, $ievents, $isources, $apaths, $brecursive = False)
        Local $ipath = $apaths, $tagstruct = ''
        If IsArray($apaths) Then
            If UBound($apaths, $UBOUND_COLUMNS) Then Return SetError(0x1, 0x0, 0x0)
        Else
            Dim $apaths[0x1] = [$ipath]
        EndIf
        For $i = 0x0 To UBound($apaths) + -1
            If Not _WinAPI_PathIsDirectory($apaths[$i]) Then Return SetError(0x2, 0x0, 0x0)
        Next
        For $i = 0x0 To UBound($apaths) + -1
            $tagstruct &= "ptr;int;"
        Next
        Local $tentry = DllStructCreate($tagstruct)
        For $i = 0x0 To UBound($apaths) + -1
            $apaths[$i] = _WinAPI_ShellILCreateFromPath(_WinAPI_PathSearchAndQualify($apaths[$i]))
            DllStructSetData($tentry, 0x2 * $i + 0x1, $apaths[$i])
            DllStructSetData($tentry, 0x2 * $i + 0x2, $brecursive)
        Next
        Local $ierror = 0x0
        Local $acall = DllCall("shell32.dll", "ulong", "SHChangeNotifyRegister", "hwnd", $hwnd, "int", $isources, "long", $ievents, "uint", $imsg, "int", UBound($apaths), "struct*", $tentry)
        If @error Or Not $acall[0x0] Then $ierror = @error + 0xa
        For $i = 0x0 To UBound($apaths) + -1
            _WinAPI_CoTaskMemFree($apaths[$i])
        Next
        Return SetError($ierror, 0x0, $acall[0x0])
    EndFunc    ; -> _WinAPI_ShellChangeNotifyRegister

    Func _WinAPI_ShellCreateDirectory($sfilepath, $hparent = 0x0, $tsecurity = 0x0)
        Local $acall = DllCall("shell32.dll", "int", "SHCreateDirectoryExW", "hwnd", $hparent, "wstr", $sfilepath, "struct*", $tsecurity)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellCreateDirectory

    Func _WinAPI_ShellEmptyRecycleBin($sroot = '', $IFLAGS = 0x0, $hparent = 0x0)
        Local $acall = DllCall("shell32.dll", "long", "SHEmptyRecycleBinW", "hwnd", $hparent, "wstr", $sroot, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellEmptyRecycleBin

    Func _WinAPI_ShellExecute($sfilepath, $sargs = '', $sdir = '', $sverb = '', $ishow = 0x1, $hparent = 0x0)
        If Not StringStripWS($sargs, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sargs = Null
        If Not StringStripWS($sdir, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sdir = Null
        If Not StringStripWS($sverb, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sverb = Null
        Local $acall = DllCall("shell32.dll", "ULONG_PTR", "ShellExecuteW", "hwnd", $hparent, "wstr", $sverb, "wstr", $sfilepath, "wstr", $sargs, "wstr", $sdir, "int", $ishow)
        If @error Then Return SetError(@error, @extended, False)
        If $acall[0x0] <= 0x20 Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShellExecute

    Func _WinAPI_ShellExecuteEx(ByRef $tshexinfo)
        Local $acall = DllCall("shell32.dll", "bool", "ShellExecuteExW", "struct*", $tshexinfo)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShellExecuteEx

    Func _WinAPI_ShellExtractAssociatedIcon($sfilepath, $bsmall = False)
        Local $IFLAGS = 0x100
        If Not _WinAPI_PathIsDirectory($sfilepath) Then
            $IFLAGS = BitOR($IFLAGS, 0x10)
        EndIf
        If $bsmall Then
            $IFLAGS = BitOR($IFLAGS, 0x1)
        EndIf
        Local $tshfileinfo = DllStructCreate($TAGSHFILEINFO)
        If Not _WinAPI_ShellGetFileInfo($sfilepath, $IFLAGS, 0x0, $tshfileinfo) Then Return SetError(@error + 0xa, @extended, 0x0)
        Return DllStructGetData($tshfileinfo, "hIcon")
    EndFunc    ; -> _WinAPI_ShellExtractAssociatedIcon

    Func _WinAPI_ShellExtractIcon($sicon, $iindex, $iwidth, $iheight)
        Local $acall = DllCall("shell32.dll", "int", "SHExtractIconsW", "wstr", $sicon, "int", $iindex, "int", $iwidth, "int", $iheight, "ptr*", 0x0, "ptr*", 0x0, "int", 0x1, "int", 0x0)
        If @error Or Not $acall[0x0] Or Not $acall[0x5] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_ShellExtractIcon

    Func _WinAPI_ShellFileOperation($sfrom, $sto, $ifunc, $IFLAGS, $STITLE = '', $hparent = 0x0)
        Local $idata
        If Not IsArray($sfrom) Then
            $idata = $sfrom
            Dim $sfrom[0x1] = [$idata]
        EndIf
        Local $tfrom = _WinAPI_ArrayToStruct($sfrom)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        If Not IsArray($sto) Then
            $idata = $sto
            Dim $sto[0x1] = [$idata]
        EndIf
        Local $tto = _WinAPI_ArrayToStruct($sto)
        If @error Then Return SetError(@error + 0x1e, @extended, 0x0)
        Local $tshfileopstruct = DllStructCreate($TAGSHFILEOPSTRUCT)
        DllStructSetData($tshfileopstruct, "hWnd", $hparent)
        DllStructSetData($tshfileopstruct, "Func", $ifunc)
        DllStructSetData($tshfileopstruct, "From", DllStructGetPtr($tfrom))
        DllStructSetData($tshfileopstruct, "To", DllStructGetPtr($tto))
        DllStructSetData($tshfileopstruct, "Flags", $IFLAGS)
        DllStructSetData($tshfileopstruct, "ProgressTitle", $STITLE)
        Local $acall = DllCall("shell32.dll", "int", "SHFileOperationW", "struct*", $tshfileopstruct)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $tshfileopstruct
    EndFunc    ; -> _WinAPI_ShellFileOperation

    Func _WinAPI_ShellFlushSFCache()
        DllCall("shell32.dll", "none", "SHFlushSFCache")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellFlushSFCache

    Func _WinAPI_ShellGetFileInfo($sfilepath, $IFLAGS, $iattributes, ByRef $tshfileinfo)
        Local $acall = DllCall("shell32.dll", "dword_ptr", "SHGetFileInfoW", "wstr", $sfilepath, "dword", $iattributes, "struct*", $tshfileinfo, "uint", DllStructGetSize($tshfileinfo), "uint", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShellGetFileInfo

    Func _WinAPI_ShellGetIconOverlayIndex($sicon, $iindex)
        If Not StringStripWS($sicon, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sicon = Null
        Local $acall = DllCall("shell32.dll", "int", "SHGetIconOverlayIndexW", "wstr", $sicon, "int", $iindex)
        If @error Or ($acall[0x0] = + -1) Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShellGetIconOverlayIndex

    Func _WinAPI_ShellGetKnownFolderIDList($sguid, $IFLAGS = 0x0, $htoken = 0x0)
        Local $tguid = DllStructCreate($TAGGUID)
        Local $acall = DllCall("ole32.dll", "uint", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
        If @error Or $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        $acall = DllCall("shell32.dll", "uint", "SHGetKnownFolderIDList", "struct*", $tguid, "dword", $IFLAGS, "handle", $htoken, "ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x4]
    EndFunc    ; -> _WinAPI_ShellGetKnownFolderIDList

    Func _WinAPI_ShellGetKnownFolderPath($sguid, $IFLAGS = 0x0, $htoken = 0x0)
        Local $tguid = DllStructCreate($TAGGUID)
        Local $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
        If @error Or $acall[0x0] Then Return SetError(@error + 0x14, @extended, '')
        $acall = DllCall("shell32.dll", "long", "SHGetKnownFolderPath", "struct*", $tguid, "dword", $IFLAGS, "handle", $htoken, "ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Local $spath = _WinAPI_GetString($acall[0x4])
        _WinAPI_CoTaskMemFree($acall[0x4])
        Return $spath
    EndFunc    ; -> _WinAPI_ShellGetKnownFolderPath

    Func _WinAPI_ShellGetLocalizedName($sfilepath)
        Local $acall = DllCall("shell32.dll", "long", "SHGetLocalizedName", "wstr", $sfilepath, "wstr", '', "uint*", 0x0, "int*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Local $aret[0x2]
        Local $acall1 = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $acall[0x2], "wstr", '', "dword", 0x1000)
        $aret[0x0] = $acall1[0x2]
        $aret[0x1] = $acall[0x4]
        Return $aret
    EndFunc    ; -> _WinAPI_ShellGetLocalizedName

    Func _WinAPI_ShellGetPathFromIDList($ppidl)
        Local $acall = DllCall("shell32.dll", "bool", "SHGetPathFromIDListW", "struct*", $ppidl, "wstr", '')
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_ShellGetPathFromIDList

    Func _WinAPI_ShellGetSetFolderCustomSettings($sfilepath, $IFLAG, ByRef $tshfcs)
        Local $sproc = "SHGetSetFolderCustomSettings"
        If _WinAPI_GetVersion() < 6 Then $sproc &= "W"
        Local $acall = DllCall("shell32.dll", "long", $sproc, "struct*", $tshfcs, "wstr", $sfilepath, "dword", $IFLAG)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellGetSetFolderCustomSettings

    Func _WinAPI_ShellGetSettings($IFLAGS)
        Local $tshellstate = DllStructCreate("uint[8]")
        DllCall("shell32.dll", "none", "SHGetSetSettings", "struct*", $tshellstate, "dword", $IFLAGS, "bool", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        Local $ival1 = DllStructGetData($tshellstate, 0x1, 0x1)
        Local $ival2 = DllStructGetData($tshellstate, 0x1, 0x8)
        Local $iresult = 0x0
        Local $aopt[0x14][0x2] = [[0x1, 0x1], [0x2, 0x2], [0x4, 0x8000], [0x8, 0x20], [0x10, 0x8], [0x20, 0x80], [0x40, 0x200], [0x80, 0x400], [0x100, 0x800], [0x400, 0x1000], [0x800, 0x2000], [0x1000, 0x4000], [0x2000, 0x20000], [0x8000, 0x40000], [0x10000, 0x100000], [0x1, 0x80000], [0x2, 0x200000], [0x8, 0x800000], [0x10, 0x1000000], [0x20, 0x2000000]]
        For $i = 0x0 To 0xe
            If BitAND($ival1, $aopt[$i][0x0]) Then
                $iresult += $aopt[$i][0x1]
            EndIf
        Next
        For $i = 0xf To 0x13
            If BitAND($ival2, $aopt[$i][0x0]) Then
                $iresult += $aopt[$i][0x1]
            EndIf
        Next
        Return $iresult
    EndFunc    ; -> _WinAPI_ShellGetSettings

    Func _WinAPI_ShellGetSpecialFolderLocation($icsidl)
        Local $acall = DllCall("shell32.dll", "long", "SHGetSpecialFolderLocation", "hwnd", 0x0, "int", $icsidl, "ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_ShellGetSpecialFolderLocation

    Func _WinAPI_ShellGetSpecialFolderPath($icsidl, $bcreate = False)
        Local $acall = DllCall("shell32.dll", "bool", "SHGetSpecialFolderPathW", "hwnd", 0x0, "wstr", '', "int", $icsidl, "bool", $bcreate)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_ShellGetSpecialFolderPath

    Func _WinAPI_ShellGetStockIconInfo($isiid, $IFLAGS)
        Local $tshstockiconinfo = DllStructCreate($TAGSHSTOCKICONINFO)
        DllStructSetData($tshstockiconinfo, "Size", DllStructGetSize($tshstockiconinfo))
        Local $acall = DllCall("shell32.dll", "long", "SHGetStockIconInfo", "int", $isiid, "uint", $IFLAGS, "struct*", $tshstockiconinfo)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $tshstockiconinfo
    EndFunc    ; -> _WinAPI_ShellGetStockIconInfo

    Func _WinAPI_ShellILCreateFromPath($sfilepath)
        Local $acall = DllCall("shell32.dll", "long", "SHILCreateFromPath", "wstr", $sfilepath, "ptr*", 0x0, "dword*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_ShellILCreateFromPath

    Func _WinAPI_ShellNotifyIcon($imessage, ByRef $tnotifyicondata)
        Local $acall = DllCall("shell32.dll", "bool", "Shell_NotifyIconW", "dword", $imessage, "struct*", $tnotifyicondata)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShellNotifyIcon

    Func _WinAPI_ShellNotifyIconGetRect($hwnd, $iid, $tguid = 0x0)
        Local $tnii = DllStructCreate("dword;hwnd;uint;" & $TAGGUID)
        DllStructSetData($tnii, 0x1, DllStructGetSize($tnii))
        DllStructSetData($tnii, 0x2, $hwnd)
        DllStructSetData($tnii, 0x3, $iid)
        If IsDllStruct($tguid) Then
            If Not _WinAPI_MoveMemory(DllStructGetPtr($tnii, 0x4), $tguid, 0x10) Then Return SetError(@error + 0xa, @extended, 0x0)
        EndIf
        Local $trect = DllStructCreate($TAGRECT)
        Local $acall = DllCall("shell32.dll", "long", "Shell_NotifyIconGetRect", "struct*", $tnii, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_ShellNotifyIconGetRect

    Func _WinAPI_ShellObjectProperties($sfilepath, $itype = 0x2, $sproperty = '', $hparent = 0x0)
        If Not StringStripWS($sproperty, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sproperty = Null
        Local $acall = DllCall("shell32.dll", "bool", "SHObjectProperties", "hwnd", $hparent, "dword", $itype, "wstr", $sfilepath, "wstr", $sproperty)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShellObjectProperties

    Func _WinAPI_ShellOpenFolderAndSelectItems($sfilepath, $anames = 0x0, $istart = 0x0, $IEND = + -1, $IFLAGS = 0x0)
        Local $ppidl, $acall, $tptr = 0x0, $icount = 0x0, $iobj = 0x0, $ierror = 0x0
        $sfilepath = _WinAPI_PathRemoveBackslash(_WinAPI_PathSearchAndQualify($sfilepath))
        If IsArray($anames) Then
            If $sfilepath And Not _WinAPI_PathIsDirectory($sfilepath) Then Return SetError(@error + 0x14, @extended, 0x0)
        EndIf
        $ppidl = _WinAPI_ShellILCreateFromPath($sfilepath)
        If @error Then Return SetError(@error + 0x1e, @extended, 0x0)
        If Not __CheckErrorArrayBounds($anames, $istart, $IEND) Then
            $tptr = DllStructCreate("ptr[" & ($IEND - $istart + 0x1) & "]")
            For $i = $istart To $IEND
                $icount += 0x1
                If $anames[$i] Then
                    DllStructSetData($tptr, 0x1, _WinAPI_ShellILCreateFromPath($sfilepath & "\\" & $anames[$i]), $icount)
                Else
                    DllStructSetData($tptr, 0x1, 0x0, $icount)
                EndIf
            Next
        EndIf
        If _WinAPI_CoInitialize() Then $iobj = 0x1
        $acall = DllCall("shell32.dll", "long", "SHOpenFolderAndSelectItems", "ptr", $ppidl, "uint", $icount, "struct*", $tptr, "dword", $IFLAGS)
        If @error Then
            $ierror = @error + 0xa
        Else
            If $acall[0x0] Then $ierror = 0xa
        EndIf
        If $iobj Then _WinAPI_CoUninitialize()
        _WinAPI_CoTaskMemFree($ppidl)
        For $i = 0x1 To $icount
            $ppidl = DllStructGetData($tptr, $i)
            If $ppidl Then
                _WinAPI_CoTaskMemFree($ppidl)
            EndIf
        Next
        If $ierror = 0xa Then Return SetError(0xa, $acall[0x0], 0x0)
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellOpenFolderAndSelectItems

    Func _WinAPI_ShellQueryRecycleBin($sroot = '')
        Local $tagshqueryrbinfo = (@AutoItX64  ? ''  : "align 1;") & "dword cbSize;int64 Size;int64 nbFiles"
        Local $tshqrbi = DllStructCreate($tagshqueryrbinfo)
        DllStructSetData($tshqrbi, 0x1, DllStructGetSize($tshqrbi))
        Local $acall = DllCall("shell32.dll", "long", "SHQueryRecycleBinW", "wstr", $sroot, "struct*", $tshqrbi)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Local $aret[0x2]
        $aret[0x0] = DllStructGetData($tshqrbi, 0x2)
        $aret[0x1] = DllStructGetData($tshqrbi, 0x3)
        Return $aret
    EndFunc    ; -> _WinAPI_ShellQueryRecycleBin

    Func _WinAPI_ShellQueryUserNotificationState()
        Local $acall = DllCall("shell32.dll", "long", "SHQueryUserNotificationState", "uint*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_ShellQueryUserNotificationState

    Func _WinAPI_ShellRemoveLocalizedName($sfilepath)
        Local $acall = DllCall("shell32.dll", "long", "SHRemoveLocalizedName", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellRemoveLocalizedName

    Func _WinAPI_ShellRestricted($irestriction)
        Local $acall = DllCall("shell32.dll", "dword", "SHRestricted", "uint", $irestriction)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShellRestricted

    Func _WinAPI_ShellSetKnownFolderPath($sguid, $sfilepath, $IFLAGS = 0x0, $htoken = 0x0)
        Local $tguid = DllStructCreate($TAGGUID)
        Local $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
        If @error Or $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        $acall = DllCall("shell32.dll", "long", "SHSetKnownFolderPath", "struct*", $tguid, "dword", $IFLAGS, "handle", $htoken, "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellSetKnownFolderPath

    Func _WinAPI_ShellSetLocalizedName($sfilepath, $smodule, $iresid)
        Local $acall = DllCall("shell32.dll", "long", "SHSetLocalizedName", "wstr", $sfilepath, "wstr", $smodule, "int", $iresid)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellSetLocalizedName

    Func _WinAPI_ShellSetSettings($IFLAGS, $bset)
        Local $ival1 = 0x0, $ival2 = 0x0
        Local $aopt[0x14][0x2] = [[0x1, 0x1], [0x2, 0x2], [0x4, 0x8000], [0x8, 0x20], [0x10, 0x8], [0x20, 0x80], [0x40, 0x200], [0x80, 0x400], [0x100, 0x800], [0x400, 0x1000], [0x800, 0x2000], [0x1000, 0x4000], [0x2000, 0x20000], [0x8000, 0x40000], [0x10000, 0x100000], [0x1, 0x80000], [0x2, 0x200000], [0x8, 0x800000], [0x10, 0x1000000], [0x20, 0x2000000]]
        If $bset Then
            For $i = 0x0 To 0xe
                If BitAND($IFLAGS, $aopt[$i][0x1]) Then
                    $ival1 += $aopt[$i][0x0]
                EndIf
            Next
            For $i = 0xf To 0x13
                If BitAND($IFLAGS, $aopt[$i][0x1]) Then
                    $ival2 += $aopt[$i][0x0]
                EndIf
            Next
        EndIf
        Local $tshellstate = DllStructCreate("uint[8]")
        DllStructSetData($tshellstate, 0x1, $ival1, 0x1)
        DllStructSetData($tshellstate, 0x1, $ival2, 0x8)
        DllCall("shell32.dll", "none", "SHGetSetSettings", "struct*", $tshellstate, "dword", $IFLAGS, "bool", 0x1)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellSetSettings

    Func _WinAPI_ShellUpdateImage($sicon, $iindex, $iimage, $IFLAGS = 0x0)
        DllCall("shell32.dll", "none", "SHUpdateImageW", "wstr", $sicon, "int", $iindex, "uint", $IFLAGS, "int", $iimage)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellUpdateImage

#EndRegion Public Functions
#Region Global Variables and Constants
    Global $__g_pfrbuffer = 0x0, $__g_ifrbuffersize = 0x4001
    Global Const $TAGDEVNAMES = "ushort DriverOffset;ushort DeviceOffset;ushort OutputOffset;ushort Default"
    Global Const $TAGFINDREPLACE = "dword Size;hwnd hOwner;ptr hInstance;dword Flags;ptr FindWhat;ptr ReplaceWith;ushort FindWhatLen;ushort ReplaceWithLen;lparam lParam;ptr Hook;ptr TemplateName"
    Global Const $TAGMSGBOXPARAMS = "uint Size;hwnd hOwner;ptr hInstance;int_ptr Text;int_ptr Caption;dword Style;int_ptr Icon;dword_ptr ContextHelpId;ptr MsgBoxCallback;dword LanguageId"
    Global Const $TAGPAGESETUPDLG = "dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;dword Flags;long PaperWidth;long PaperHeight;long MarginMinLeft;long MarginMinTop;long MarginMinRight;long Mar" & _
        "ginMinBottom;long MarginLeft;long MarginTop;long MarginRight;long MarginBottom;ptr hInstance;lparam lParam;ptr PageSetupHook;ptr PagePaintHook;ptr PageSetupTemp" & _
        "lateName;ptr hPageSetupTemplate"
    Global Const $TAGPRINTDLG = (@AutoItX64  ? ''  : "align 1;") & "dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;word FromPage;word ToPage;word MinPage;word MaxPage;word Copies;handle hInstance;" & _
        "lparam lParam;ptr PrintHook;ptr SetupHook;ptr PrintTemplateName;ptr SetupTemplateName;handle hPrintTemplate;handle hSetupTemplate"
    Global Const $TAGPRINTDLGEX = "dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;dword Flags2;dword ExclusionFlags;dword NumPageRanges;dword MaxPageRanges;ptr Pag" & _
        "eRanges;dword MinPage;dword MaxPage;dword Copies;handle hInstance;ptr PrintTemplateName;lparam lParam;dword NumPropertyPages;ptr hPropertyPages;dword StartPage;" & _
        "dword ResultAction"
    Global Const $TAGPRINTPAGERANGE = "dword FromPage;dword ToPage"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_BrowseForFolderDlg($sroot = '', $stext = '', $IFLAGS = 0x0, $pbrowseproc = 0x0, $lparam = 0x0, $hparent = 0x0)
        Local Const $TAGBROWSEINFO = "hwnd hwndOwner;ptr pidlRoot;ptr pszDisplayName; ptr lpszTitle;uint ulFlags;ptr lpfn;lparam lParam;int iImage"
        Local $tbrowseinfo = DllStructCreate($TAGBROWSEINFO & ";wchar[" & (StringLen($stext) + 0x1) & "];wchar[260]")
        Local $ppidl = 0x0, $sresult = ''
        If StringStripWS($sroot, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
            Local $spath = _WinAPI_PathSearchAndQualify($sroot, 0x1)
            If @error Then
                $spath = $sroot
            EndIf
            $ppidl = _WinAPI_ShellILCreateFromPath($spath)
            If @error Then
            EndIf
        EndIf
        DllStructSetData($tbrowseinfo, 0x1, $hparent)
        DllStructSetData($tbrowseinfo, 0x2, $ppidl)
        DllStructSetData($tbrowseinfo, 0x3, DllStructGetPtr($tbrowseinfo, 0xa))
        DllStructSetData($tbrowseinfo, 0x4, DllStructGetPtr($tbrowseinfo, 0x9))
        DllStructSetData($tbrowseinfo, 0x5, $IFLAGS)
        DllStructSetData($tbrowseinfo, 0x6, $pbrowseproc)
        DllStructSetData($tbrowseinfo, 0x7, $lparam)
        DllStructSetData($tbrowseinfo, 0x8, 0x0)
        DllStructSetData($tbrowseinfo, 0x9, $stext)
        Local $acall = DllCall("shell32.dll", "ptr", "SHBrowseForFolderW", "struct*", $tbrowseinfo)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        $sresult = _WinAPI_ShellGetPathFromIDList($acall[0x0])
        _WinAPI_CoTaskMemFree($acall[0x0])
        If $ppidl Then
            _WinAPI_CoTaskMemFree($ppidl)
        EndIf
        If Not $sresult Then Return SetError(0xa, 0x0, '')
        Return $sresult
    EndFunc    ; -> _WinAPI_BrowseForFolderDlg

    Func _WinAPI_CommDlgExtendedError()
        Local Const $CDERR_DIALOGFAILURE = 0xffff
        Local Const $CDERR_FINDRESFAILURE = 0x6
        Local Const $CDERR_INITIALIZATION = 0x2
        Local Const $CDERR_LOADRESFAILURE = 0x7
        Local Const $CDERR_LOADSTRFAILURE = 0x5
        Local Const $CDERR_LOCKRESFAILURE = 0x8
        Local Const $CDERR_MEMALLOCFAILURE = 0x9
        Local Const $CDERR_MEMLOCKFAILURE = 0xa
        Local Const $CDERR_NOHINSTANCE = 0x4
        Local Const $CDERR_NOHOOK = 0xb
        Local Const $CDERR_NOTEMPLATE = 0x3
        Local Const $CDERR_REGISTERMSGFAIL = 0xc
        Local Const $CDERR_STRUCTSIZE = 0x1
        Local Const $FNERR_BUFFERTOOSMALL = 0x3003
        Local Const $FNERR_INVALIDFILENAME = 0x3002
        Local Const $FNERR_SUBCLASSFAILURE = 0x3001
        Local $acall = DllCall("comdlg32.dll", "dword", "CommDlgExtendedError")
        If Not @error Then
            Switch $acall[0x0]
            Case $CDERR_DIALOGFAILURE
                Return SetError($acall[0x0], 0x0, "The dialog box could not be created." & @LF & "The common dialog box function's call to the DialogBox function failed." & @LF & "For example, this error occurs if the common dialog box call specifies an invalid window handle.")
            Case $CDERR_FINDRESFAILURE
                Return SetError($acall[0x0], 0x0, "The common dialog box function failed to find a specified resource.")
            Case $CDERR_INITIALIZATION
                Return SetError($acall[0x0], 0x0, "The common dialog box function failed during initialization." & @LF & "This error often occurs when sufficient memory is not available.")
            Case $CDERR_LOADRESFAILURE
                Return SetError($acall[0x0], 0x0, "The common dialog box function failed to load a specified resource.")
            Case $CDERR_LOADSTRFAILURE
                Return SetError($acall[0x0], 0x0, "The common dialog box function failed to load a specified string.")
            Case $CDERR_LOCKRESFAILURE
                Return SetError($acall[0x0], 0x0, "The common dialog box function failed to lock a specified resource.")
            Case $CDERR_MEMALLOCFAILURE
                Return SetError($acall[0x0], 0x0, "The common dialog box function was unable to allocate memory for internal structures.")
            Case $CDERR_MEMLOCKFAILURE
                Return SetError($acall[0x0], 0x0, "The common dialog box function was unable to lock the memory associated with a handle.")
            Case $CDERR_NOHINSTANCE
                Return SetError($acall[0x0], 0x0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding instance handle.")
            Case $CDERR_NOHOOK
                Return SetError($acall[0x0], 0x0, "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a pointer to a corresponding hook procedure.")
            Case $CDERR_NOTEMPLATE
                Return SetError($acall[0x0], 0x0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding template.")
            Case $CDERR_REGISTERMSGFAIL
                Return SetError($acall[0x0], 0x0, "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function.")
            Case $CDERR_STRUCTSIZE
                Return SetError($acall[0x0], 0x0, "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid")
            Case $FNERR_BUFFERTOOSMALL
                Return SetError($acall[0x0], 0x0, "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure is too small for the file name specified by the user." & @LF & "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in TCHARs, required to receive the full name.")
            Case $FNERR_INVALIDFILENAME
                Return SetError($acall[0x0], 0x0, "A file name is invalid.")
            Case $FNERR_SUBCLASSFAILURE
                Return SetError($acall[0x0], 0x0, "An attempt to subclass a list box failed because sufficient memory was not available.")
            EndSwitch
        EndIf
        Return SetError(@error, @extended, "0x" & Hex($acall[0x0]))
    EndFunc    ; -> _WinAPI_CommDlgExtendedError

    Func _WinAPI_CommDlgExtendedErrorEx()
        Local $acall = DllCall("comdlg32.dll", "dword", "CommDlgExtendedError")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CommDlgExtendedErrorEx

    Func _WinAPI_ConfirmCredentials($starget, $bconfirm)
        If Not __dll("credui.dll") Then Return SetError(0x67, 0x0, 0x0)
        Local $acall = DllCall("credui.dll", "dword", "CredUIConfirmCredentialsW", "wstr", $starget, "bool", $bconfirm)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ConfirmCredentials

    Func _WinAPI_FindTextDlg($howner, $sfindwhat = '', $IFLAGS = 0x0, $pfindproc = 0x0, $lparam = 0x0)
        $__g_pfrbuffer = __HeapReAlloc($__g_pfrbuffer, 0x2 * $__g_ifrbuffersize)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        DllStructSetData(DllStructCreate("wchar[" & $__g_ifrbuffersize & "]", $__g_pfrbuffer), 0x1, StringLeft($sfindwhat, $__g_ifrbuffersize + -1))
        Local $tfr = DllStructCreate($TAGFINDREPLACE)
        DllStructSetData($tfr, "Size", DllStructGetSize($tfr))
        DllStructSetData($tfr, "hOwner", $howner)
        DllStructSetData($tfr, "hInstance", 0x0)
        DllStructSetData($tfr, "Flags", $IFLAGS)
        DllStructSetData($tfr, "FindWhat", $__g_pfrbuffer)
        DllStructSetData($tfr, "ReplaceWith", 0x0)
        DllStructSetData($tfr, "FindWhatLen", $__g_ifrbuffersize * 0x2)
        DllStructSetData($tfr, "ReplaceWithLen", 0x0)
        DllStructSetData($tfr, "lParam", $lparam)
        DllStructSetData($tfr, "Hook", $pfindproc)
        DllStructSetData($tfr, "TemplateName", 0x0)
        Local $acall = DllCall("comdlg32.dll", "hwnd", "FindTextW", "struct*", $tfr)
        If @error Or Not $acall[0x0] Then
            Local $ierror = @error + 0x1e
            __HeapFree($__g_pfrbuffer)
            If IsArray($acall) Then
                Return SetError(0xa, _WinAPI_CommDlgExtendedErrorEx(), 0x0)
            Else
                Return SetError($ierror, @extended, 0x0)
            EndIf
        EndIf
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindTextDlg

    Func _WinAPI_FlushFRBuffer()
        If Not __HeapFree($__g_pfrbuffer, 0x1) Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_FlushFRBuffer

    Func _WinAPI_FormatDriveDlg($sdrive, $ioption = 0x0, $hparent = 0x0)
        If Not IsString($sdrive) Then Return SetError(0xa, 0x0, 0x0)
        $sdrive = StringLeft(StringUpper(StringStripWS($sdrive, $STR_STRIPLEADING)), 0x1)
        If Not $sdrive Then Return SetError(0xb, 0x0, 0x0)
        $sdrive = Asc($sdrive) + -65
        If ($sdrive < 0x0) Or ($sdrive > 0x19) Then Return SetError(0xc, 0x0, 0x0)
        Local $acall = DllCall("shell32.dll", "dword", "SHFormatDrive", "hwnd", $hparent, "uint", $sdrive, "uint", 0xffff, "uint", $ioption)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] < 0x0 Then Return SetError($acall[0x0], 0x0, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FormatDriveDlg

    Func _WinAPI_GetConnectedDlg($idlg, $IFLAGS = 0x0, $hparent = 0x0)
        If Not __dll("connect.dll") Then Return SetError(0x67, 0x0, 0x0)
        Switch $idlg
        Case 0x0
            $idlg = "GetNetworkConnected"
        Case 0x1
            $idlg = "GetInternetConnected"
        Case 0x2
            $idlg = "GetVPNConnected"
        Case Else
            Return SetError(0x1, 0x0, 0x0)
        EndSwitch
        Local $sstr = ''
        If BitAND($IFLAGS, 0x1) Then
            $sstr &= "-SkipInternetDetection "
        EndIf
        If BitAND($IFLAGS, 0x2) Then
            $sstr &= "-SkipExistingConnections "
        EndIf
        If BitAND($IFLAGS, 0x4) Then
            $sstr &= "-HideFinishPage "
        EndIf
        Local $acall = DllCall("connect.dll", "long", $idlg, "hwnd", $hparent, "dword", 0x0, "dword", 0x0, "dword", 0x0, "handle", 0x0, "wstr", StringStripWS($sstr, $STR_STRIPTRAILING))
        If @error Then Return SetError(@error, @extended, 0x0)
        If Not ($acall[0x0] = 0x0 Or $acall[0x0] = 0x1) Then Return SetError(0xa, $acall[0x0], 0x0)
        Return Number(Not $acall[0x0])
    EndFunc    ; -> _WinAPI_GetConnectedDlg

    Func _WinAPI_GetFRBuffer()
        Return $__g_ifrbuffersize + -1
    EndFunc    ; -> _WinAPI_GetFRBuffer

    Func _WinAPI_GetOpenFileName($STITLE = '', $sfilter = "All files (*.*)", $sinitaldir = ".", $sdefaultfile = '', $sdefaultext = '', $ifilterindex = 0x1, $IFLAGS = 0x0, $iflagsex = 0x0, $hwndowner = 0x0)
        Local $vresult = __OFNDlg(0x0, $STITLE, $sinitaldir, $sfilter, $ifilterindex, $sdefaultfile, $sdefaultext, $IFLAGS, $iflagsex, 0x0, 0x0, $hwndowner)
        If @error Then Return SetError(@error, @extended, $vresult)
        If BitAND($IFLAGS, $OFN_ALLOWMULTISELECT) Then
            Return __WinAPI_ParseMultiSelectFileDialogPath($vresult)
        Else
            Return __WinAPI_ParseFileDialogPath($vresult)
        EndIf
    EndFunc    ; -> _WinAPI_GetOpenFileName

    Func _WinAPI_GetSaveFileName($STITLE = '', $sfilter = "All files (*.*)", $sinitaldir = ".", $sdefaultfile = '', $sdefaultext = '', $ifilterindex = 0x1, $IFLAGS = 0x0, $iflagsex = 0x0, $hwndowner = 0x0)
        Local $vreturn = __OFNDlg(0x1, $STITLE, $sinitaldir, $sfilter, $ifilterindex, $sdefaultfile, $sdefaultext, $IFLAGS, $iflagsex, 0x0, 0x0, $hwndowner)
        If @error Then Return SetError(@error, @extended, $vreturn)
        Return __WinAPI_ParseFileDialogPath($vreturn)
    EndFunc    ; -> _WinAPI_GetSaveFileName

    Func _WinAPI_MessageBoxCheck($itype, $STITLE, $stext, $sregval, $IDEFAULT = + -1, $hparent = 0x0)
        Local $acall = DllCall("shlwapi.dll", "int", "SHMessageBoxCheckW", "hwnd", $hparent, "wstr", $stext, "wstr", $STITLE, "uint", $itype, "int", $IDEFAULT, "wstr", $sregval)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MessageBoxCheck

    Func _WinAPI_MessageBoxIndirect($tmsgboxparams)
        Local $acall = DllCall("user32.dll", "int", "MessageBoxIndirectW", "struct*", $tmsgboxparams)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MessageBoxIndirect

    Func _WinAPI_OpenFileDlg($STITLE = '', $sinitdir = '', $sfilters = '', $idefaultfilter = 0x0, $sdefaultfilepath = '', $sdefaultext = '', $IFLAGS = 0x0, $iflagsex = 0x0, $pofnproc = 0x0, $pdata = 0x0, $hparent = 0x0)
        Local $vresult = __OFNDlg(0x0, $STITLE, $sinitdir, $sfilters, $idefaultfilter, $sdefaultfilepath, $sdefaultext, $IFLAGS, $iflagsex, $pofnproc, $pdata, $hparent)
        If @error Then Return SetError(@error, @extended, $vresult)
        Return $vresult
    EndFunc    ; -> _WinAPI_OpenFileDlg

    Func _WinAPI_PageSetupDlg(ByRef $tpagesetupdlg)
        Local $acall = DllCall("comdlg32.dll", "int", "PageSetupDlgW", "struct*", $tpagesetupdlg)
        If @error Then Return SetError(@error, @extended, 0x0)
        If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_CommDlgExtendedErrorEx(), 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PageSetupDlg

    Func _WinAPI_PickIconDlg($sicon = '', $iindex = 0x0, $hparent = 0x0)
        Local $acall = DllCall("shell32.dll", "int", "PickIconDlg", "hwnd", $hparent, "wstr", $sicon, "int", 0x1000, "int*", $iindex)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x2]
        Local $ares = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $acall[0x2], "wstr", '', "dword", 0x1000)
        $aret[0x0] = $ares[0x2]
        $aret[0x1] = $acall[0x4]
        Return $aret
    EndFunc    ; -> _WinAPI_PickIconDlg

    Func _WinAPI_PrintDlg(ByRef $tprintdlg)
        Local $acall = DllCall("comdlg32.dll", "long", "PrintDlgW", "struct*", $tprintdlg)
        If @error Then Return SetError(@error, @extended, 0x0)
        If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_CommDlgExtendedErrorEx(), 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PrintDlg

    Func _WinAPI_PrintDlgEx(ByRef $tprintdlgex)
        Local $tpdex = DllStructCreate($TAGPRINTDLGEX, DllStructGetPtr($tprintdlgex))
        Local $acall = DllCall("comdlg32.dll", "long", "PrintDlgExW", "struct*", $tpdex)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return SetExtended(DllStructGetData($tpdex, "ResultAction"), 0x1)
    EndFunc    ; -> _WinAPI_PrintDlgEx

    Func _WinAPI_ReplaceTextDlg($howner, $sfindwhat = '', $sreplacewith = '', $IFLAGS = 0x0, $preplaceproc = 0x0, $lparam = 0x0)
        $__g_pfrbuffer = __HeapReAlloc($__g_pfrbuffer, 0x4 * $__g_ifrbuffersize)
        If @error Then Return SetError(@error + 0x64, @extended, 0x0)
        Local $tbuff = DllStructCreate("wchar[" & $__g_ifrbuffersize & "];wchar[" & $__g_ifrbuffersize & "]", $__g_pfrbuffer)
        DllStructSetData($tbuff, 0x1, StringLeft($sfindwhat, $__g_ifrbuffersize + -1))
        DllStructSetData($tbuff, 0x2, StringLeft($sreplacewith, $__g_ifrbuffersize + -1))
        Local $tfr = DllStructCreate($TAGFINDREPLACE)
        DllStructSetData($tfr, "Size", DllStructGetSize($tfr))
        DllStructSetData($tfr, "hOwner", $howner)
        DllStructSetData($tfr, "hInstance", 0x0)
        DllStructSetData($tfr, "Flags", $IFLAGS)
        DllStructSetData($tfr, "FindWhat", DllStructGetPtr($tbuff, 0x1))
        DllStructSetData($tfr, "ReplaceWith", DllStructGetPtr($tbuff, 0x2))
        DllStructSetData($tfr, "FindWhatLen", $__g_ifrbuffersize * 0x2)
        DllStructSetData($tfr, "ReplaceWithLen", $__g_ifrbuffersize * 0x2)
        DllStructSetData($tfr, "lParam", $lparam)
        DllStructSetData($tfr, "Hook", $preplaceproc)
        DllStructSetData($tfr, "TemplateName", 0x0)
        Local $acall = DllCall("comdlg32.dll", "hwnd", "ReplaceTextW", "struct*", $tfr)
        If @error Or Not $acall[0x0] Then
            Local $ierror = @error
            __HeapFree($__g_pfrbuffer)
            If IsArray($acall) Then
                Return SetError(0xa, _WinAPI_CommDlgExtendedErrorEx(), 0x0)
            Else
                Return SetError($ierror, 0x0, 0x0)
            EndIf
        EndIf
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ReplaceTextDlg

    Func _WinAPI_RestartDlg($stext = '', $IFLAGS = 0x2, $hparent = 0x0)
        Local $acall = DllCall("shell32.dll", "int", "RestartDialog", "hwnd", $hparent, "wstr", $stext, "int", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RestartDlg

    Func _WinAPI_SaveFileDlg($STITLE = '', $sinitdir = '', $sfilters = '', $idefaultfilter = 0x0, $sdefaultfilepath = '', $sdefaultext = '', $IFLAGS = 0x0, $iflagsex = 0x0, $pofnproc = 0x0, $pdata = 0x0, $hparent = 0x0)
        Local $vresult = __OFNDlg(0x1, $STITLE, $sinitdir, $sfilters, $idefaultfilter, $sdefaultfilepath, $sdefaultext, $IFLAGS, $iflagsex, $pofnproc, $pdata, $hparent)
        If @error Then Return SetError(@error, @extended, $vresult)
        Return $vresult
    EndFunc    ; -> _WinAPI_SaveFileDlg

    Func _WinAPI_SetFRBuffer($ichars)
        $ichars = Number($ichars)
        If $ichars < 0x50 Then
            $ichars = 0x50
        EndIf
        $__g_ifrbuffersize = $ichars + 0x1
        Return 0x1
    EndFunc    ; -> _WinAPI_SetFRBuffer

    Func _WinAPI_ShellAboutDlg($STITLE, $sname, $stext, $hicon = 0x0, $hparent = 0x0)
        Local $acall = DllCall("shell32.dll", "int", "ShellAboutW", "hwnd", $hparent, "wstr", $STITLE & "#" & $sname, "wstr", $stext, "handle", $hicon)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ShellAboutDlg

    Func _WinAPI_ShellOpenWithDlg($sfilepath, $IFLAGS = 0x0, $hparent = 0x0)
        Local $topenasinfo = DllStructCreate("ptr;ptr;dword;wchar[" & (StringLen($sfilepath) + 0x1) & "]")
        DllStructSetData($topenasinfo, 0x1, DllStructGetPtr($topenasinfo, 0x4))
        DllStructSetData($topenasinfo, 0x2, 0x0)
        DllStructSetData($topenasinfo, 0x3, $IFLAGS)
        DllStructSetData($topenasinfo, 0x4, $sfilepath)
        Local $acall = DllCall("shell32.dll", "long", "SHOpenWithDialog", "hwnd", $hparent, "struct*", $topenasinfo)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellOpenWithDlg

    Func _WinAPI_ShellStartNetConnectionDlg($sremote = '', $IFLAGS = 0x0, $hparent = 0x0)
        If Not StringStripWS($sremote, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sremote = Null
        DllCall("shell32.dll", "long", "SHStartNetConnectionDialogW", "hwnd", $hparent, "wstr", $sremote, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_ShellStartNetConnectionDlg

    Func _WinAPI_ShellUserAuthenticationDlg($scaption, $smessage, $suser, $spassword, $starget, $IFLAGS = 0x0, $ierror = 0x0, $bsave = False, $hbitmap = 0x0, $hparent = 0x0)
        If Not __dll("credui.dll") Then Return SetError(0x67, 0x0, 0x0)
        Local $tinfo = DllStructCreate("dword;hwnd;ptr;ptr;ptr;wchar[" & (StringLen($smessage) + 0x1) & "];wchar[" & (StringLen($scaption) + 0x1) & "]")
        DllStructSetData($tinfo, 0x1, DllStructGetPtr($tinfo, 0x6) - DllStructGetPtr($tinfo))
        DllStructSetData($tinfo, 0x2, $hparent)
        DllStructSetData($tinfo, 0x3, DllStructGetPtr($tinfo, 0x6))
        DllStructSetData($tinfo, 0x4, DllStructGetPtr($tinfo, 0x7))
        DllStructSetData($tinfo, 0x5, $hbitmap)
        DllStructSetData($tinfo, 0x6, $smessage)
        DllStructSetData($tinfo, 0x7, $scaption)
        Local $acall = DllCall("credui.dll", "dword", "CredUIPromptForCredentialsW", "struct*", $tinfo, "wstr", $starget, "ptr", 0x0, "dword", $ierror, "wstr", $suser, "ulong", 0x1000, "wstr", $spassword, "ulong", 0x1000, "bool*", $bsave, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Local $aret[0x3]
        $aret[0x0] = $acall[0x5]
        $aret[0x1] = $acall[0x7]
        $aret[0x2] = $acall[0x9]
        Return $aret
    EndFunc    ; -> _WinAPI_ShellUserAuthenticationDlg

    Func _WinAPI_ShellUserAuthenticationDlgEx($scaption, $smessage, $suser, $spassword, $IFLAGS = 0x0, $iautherror = 0x0, $bsave = False, $ipackage = 0x0, $hparent = 0x0)
        If Not __dll("credui.dll") Then Return SetError(0x67, 0x0, 0x0)
        Local $tblob = 0x0, $acall
        If StringLen($suser) Then
            $acall = DllCall("credui.dll", "bool", "CredPackAuthenticationBufferW", "dword", 0x1, "wstr", $suser, "wstr", $spassword, "ptr", 0x0, "dword*", 0x0)
            If @error Or Not $acall[0x5] Then Return SetError(@error + 0xa, @extended, 0x0)
            $tblob = DllStructCreate("byte[" & $acall[0x5] & "]")
            $acall = DllCall("credui.dll", "bool", "CredPackAuthenticationBufferW", "dword", 0x1, "wstr", $suser, "wstr", $spassword, "struct*", $tblob, "dword*", $acall[0x5])
            If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        EndIf
        Local $tinfo = DllStructCreate("dword;hwnd;ptr;ptr;ptr;wchar[" & (StringLen($smessage) + 0x1) & "];wchar[" & (StringLen($scaption) + 0x1) & "]")
        DllStructSetData($tinfo, 0x1, DllStructGetPtr($tinfo, 0x6) - DllStructGetPtr($tinfo))
        DllStructSetData($tinfo, 0x2, $hparent)
        DllStructSetData($tinfo, 0x3, DllStructGetPtr($tinfo, 0x6))
        DllStructSetData($tinfo, 0x4, DllStructGetPtr($tinfo, 0x7))
        DllStructSetData($tinfo, 0x5, 0x0)
        DllStructSetData($tinfo, 0x6, $smessage)
        DllStructSetData($tinfo, 0x7, $scaption)
        $acall = DllCall("credui.dll", "dword", "CredUIPromptForWindowsCredentialsW", "struct*", $tinfo, "dword", $iautherror, "ulong*", $ipackage, "struct*", $tblob, "ulong", DllStructGetSize($tblob), "ptr*", 0x0, "ulong*", 0x0, "bool*", $bsave, "dword", $IFLAGS)
        If @error Then Return SetError(@error + 0x1e, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0x1e, $acall[0x0], 0x0)
        Local $aret[0x4], $ierror = 0x0
        $aret[0x2] = $acall[0x8]
        $aret[0x3] = $acall[0x3]
        Local $pblob = $acall[0x6]
        Local $isize = $acall[0x7]
        $acall = DllCall("credui.dll", "bool", "CredUnPackAuthenticationBufferW", "dword", 0x1, "ptr", $pblob, "dword", $isize, "wstr", '', "dword*", 0x1000, "wstr", '', "dword*", 0x1000, "wstr", '', "dword*", 0x1000)
        If Not @error And $acall[0x0] Then
            $aret[0x0] = $acall[0x4]
            $aret[0x1] = $acall[0x8]
        Else
            $ierror = @error + 0x28
        EndIf
        If Not _WinAPI_ZeroMemory($pblob, $isize) Then
        EndIf
        _WinAPI_CoTaskMemFree($pblob)
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $aret
    EndFunc    ; -> _WinAPI_ShellUserAuthenticationDlgEx

#EndRegion Public Functions
#Region Internal Functions
    Func __OFNDlg($idlg, $STITLE, $sinitdir, $sfilters, $ideffilter, $sdeffile, $sdefext, $IFLAGS, $iflagsex, $pofnproc, $pdata, $hparent)
        Local $verror[0x1] = [0x0]
        If BitAND($IFLAGS, $OFN_ALLOWMULTISELECT) = 0x0 Then $verror = ''
        Local $tbuffer = DllStructCreate("wchar[32768]")
        Local $tfilters = 0x0, $tdefext = 0x0, $tinitdir = 0x0, $ttitle = 0x0
        Local $tofn = DllStructCreate($TAGOPENFILENAME)
        DllStructSetData($tofn, "StructSize", DllStructGetSize($tofn))
        DllStructSetData($tofn, "hwndOwner", $hparent)
        DllStructSetData($tofn, 0x3, 0x0)
        Local $ADATA = StringSplit($sfilters, "|")
        Local $afilters[$ADATA[0x0] * 0x2]
        Local $icount = 0x0
        For $i = 0x1 To $ADATA[0x0]
            $afilters[$icount + 0x0] = StringStripWS($ADATA[$i], $STR_STRIPLEADING + $STR_STRIPTRAILING)
            $afilters[$icount + 0x1] = StringStripWS(StringRegExpReplace($ADATA[$i], ".*\\((.*)\\)", "\\1"), $STR_STRIPALL)
            If $afilters[$icount + 0x1] Then
                $icount += 0x2
            EndIf
        Next
        If $icount Then
            $tfilters = _WinAPI_ArrayToStruct($afilters, 0x0, $icount + -1)
            If @error Then
            EndIf
        EndIf
        DllStructSetData($tofn, "lpstrFilter", DllStructGetPtr($tfilters))
        DllStructSetData($tofn, 0x5, 0x0)
        DllStructSetData($tofn, 0x6, 0x0)
        DllStructSetData($tofn, "nFilterIndex", $ideffilter)
        $sdeffile = StringStripWS($sdeffile, $STR_STRIPLEADING + $STR_STRIPTRAILING)
        If $sdeffile Then
            DllStructSetData($tbuffer, 0x1, $sdeffile)
        EndIf
        DllStructSetData($tofn, "lpstrFile", DllStructGetPtr($tbuffer))
        DllStructSetData($tofn, "nMaxFile", 0x8000)
        DllStructSetData($tofn, 0xa, 0x0)
        DllStructSetData($tofn, 0xb, 0x0)
        $sinitdir = StringStripWS($sinitdir, $STR_STRIPLEADING + $STR_STRIPTRAILING)
        If $sinitdir Then
            $tinitdir = DllStructCreate("wchar[" & (StringLen($sinitdir) + 0x1) & "]")
        EndIf
        DllStructSetData($tinitdir, 0x1, $sinitdir)
        DllStructSetData($tofn, "lpstrInitialDir", DllStructGetPtr($tinitdir))
        $STITLE = StringStripWS($STITLE, $STR_STRIPLEADING + $STR_STRIPTRAILING)
        If $STITLE Then
            $ttitle = DllStructCreate("wchar[" & (StringLen($STITLE) + 0x1) & "]")
        EndIf
        DllStructSetData($ttitle, 0x1, $STITLE)
        DllStructSetData($tofn, "lpstrTitle", DllStructGetPtr($ttitle))
        DllStructSetData($tofn, "Flags", $IFLAGS)
        DllStructSetData($tofn, 0xf, 0x0)
        DllStructSetData($tofn, 0x10, 0x0)
        $sdefext = StringStripWS($sdefext, $STR_STRIPLEADING + $STR_STRIPTRAILING)
        If $sdefext Then
            $tdefext = DllStructCreate("wchar[" & (StringLen($tdefext) + 0x1) & "]")
        EndIf
        DllStructSetData($tdefext, 0x1, StringReplace($sdefext, ".", ''))
        DllStructSetData($tofn, "lpstrDefExt", DllStructGetPtr($tdefext))
        DllStructSetData($tofn, "lCustData", $pdata)
        DllStructSetData($tofn, "lpfnHook", $pofnproc)
        DllStructSetData($tofn, 0x14, 0x0)
        DllStructSetData($tofn, 0x15, 0x0)
        DllStructSetData($tofn, 0x16, 0x0)
        DllStructSetData($tofn, "FlagsEx", $iflagsex)
        Local $acall
        Switch $idlg
        Case 0x0
            $acall = DllCall("comdlg32.dll", "bool", "GetOpenFileNameW", "struct*", $tofn)
        Case 0x1
            $acall = DllCall("comdlg32.dll", "bool", "GetSaveFileNameW", "struct*", $tofn)
        Case Else
        EndSwitch
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, _WinAPI_CommDlgExtendedErrorEx(), $verror)
        If BitAND($IFLAGS, $OFN_ALLOWMULTISELECT) Then
            If BitAND($IFLAGS, $OFN_EXPLORER) Then
                $ADATA = _WinAPI_StructToArray($tbuffer)
                If @error Then
                    Return SetError(0xb, 0x0, $verror)
                EndIf
            Else
                $ADATA = StringSplit(DllStructGetData($tbuffer, 0x1), " ")
            EndIf
            Switch $ADATA[0x0]
            Case 0x0
                Return SetError(0xc, 0x0, $verror)
            Case 0x1
            Case Else
                Local $spath = $ADATA[0x1]
                For $i = 0x2 To $ADATA[0x0]
                    $ADATA[$i + -1] = _WinAPI_PathAppend($spath, $ADATA[$i])
                Next
                ReDim $ADATA[$ADATA[0x0]]
                $ADATA[0x0]-= 0x1
            EndSwitch
        Else
            $ADATA = DllStructGetData($tbuffer, 0x1)
        EndIf
        $__g_vext = $tofn
        Return $ADATA
    EndFunc    ; -> __OFNDlg

    Func __WinAPI_ParseMultiSelectFileDialogPath($apath)
        Local $afiles[UBound($apath) + 0x1]
        $afiles[0x0] = UBound($apath)
        $afiles[0x1] = StringMid($apath[0x1], 0x1, StringInStr($apath[0x1], "\\", $STR_NOCASESENSEBASIC, + -1) + -1)
        For $i = 0x1 To UBound($apath) + -1
            $afiles[$i + 0x1] = StringMid($apath[$i], StringInStr($apath[$i], "\\", $STR_NOCASESENSEBASIC, + -1) + 0x1)
        Next
        Return $afiles
    EndFunc    ; -> __WinAPI_ParseMultiSelectFileDialogPath

    Func __WinAPI_ParseFileDialogPath($spath)
        Local $afiles[0x3]
        $afiles[0x0] = 0x2
        $afiles[0x1] = StringMid($spath, 0x1, StringInStr($spath, "\\", $STR_NOCASESENSEBASIC, + -1) + -1)
        $afiles[0x2] = StringMid($spath, StringInStr($spath, "\\", $STR_NOCASESENSEBASIC, + -1) + 0x1)
        Return $afiles
    EndFunc    ; -> __WinAPI_ParseFileDialogPath

#EndRegion Internal Functions
#Region Global Variables and Constants
    Global $__g_iheapsize = 0x800000
    Global Const $TAGFILEINFO = "uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;uint64 ChangeTime;dword Attributes"
    Global Const $TAGFILE_ID_DESCRIPTOR = "dword Size;uint Type;" & $TAGGUID
    Global Const $TAGWIN32_FIND_STREAM_DATA = "int64 StreamSize;wchar StreamName[296]"
    Global Const $TAGWIN32_STREAM_ID = "dword StreamId;dword StreamAttributes;int64 Size;dword StreamNameSize;wchar StreamName[1]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_BackupRead($hfile, $pbuffer, $ilength, ByRef $ibytes, ByRef $pcontext, $bsecurity = False)
        $ibytes = 0x0
        Local $acall = DllCall("kernel32.dll", "bool", "BackupRead", "handle", $hfile, "struct*", $pbuffer, "dword", $ilength, "dword*", 0x0, "bool", 0x0, "bool", $bsecurity, "ptr*", $pcontext)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
        $ibytes = $acall[0x4]
        $pcontext = $acall[0x7]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BackupRead

    Func _WinAPI_BackupReadAbort(ByRef $pcontext)
        Local $acall = DllCall("kernel32.dll", "bool", "BackupRead", "handle", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "bool", 0x1, "bool", 0x0, "ptr*", $pcontext)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
        $pcontext = $acall[0x7]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BackupReadAbort

    Func _WinAPI_BackupSeek($hfile, $iseek, ByRef $ibytes, ByRef $pcontext)
        $ibytes = 0x0
        Local $acall = DllCall("kernel32.dll", "bool", "BackupSeek", "handle", $hfile, "dword", _WinAPI_LoDWord($iseek), "dword", _WinAPI_HiDWord($iseek), "dword*", 0x0, "dword*", 0x0, "ptr*", $pcontext)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
        $ibytes = __WinAPI_MakeQWord($acall[0x4], $acall[0x5])
        $pcontext = $acall[0x6]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BackupSeek

    Func _WinAPI_BackupWrite($hfile, $pbuffer, $ilength, ByRef $ibytes, ByRef $pcontext, $bsecurity = False)
        $ibytes = 0x0
        Local $acall = DllCall("kernel32.dll", "bool", "BackupWrite", "handle", $hfile, "struct*", $pbuffer, "dword", $ilength, "dword*", 0x0, "bool", 0x0, "bool", $bsecurity, "ptr*", $pcontext)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
        $ibytes = $acall[0x4]
        $pcontext = $acall[0x7]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BackupWrite

    Func _WinAPI_BackupWriteAbort(ByRef $pcontext)
        Local $acall = DllCall("kernel32.dll", "bool", "BackupWrite", "handle", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "bool", 0x1, "bool", 0x0, "ptr*", $pcontext)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
        $pcontext = $acall[0x7]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BackupWriteAbort

    Func _WinAPI_CopyFileEx($sexistingfile, $snewfile, $IFLAGS = 0x0, $pprogressproc = 0x0, $pdata = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "CopyFileExW", "wstr", $sexistingfile, "wstr", $snewfile, "ptr", $pprogressproc, "struct*", $pdata, "bool*", 0x0, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CopyFileEx

    Func _WinAPI_CreateDirectory($sdir, $tsecurity = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "CreateDirectoryW", "wstr", $sdir, "struct*", $tsecurity)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateDirectory

    Func _WinAPI_CreateDirectoryEx($snewdir, $stemplatedir, $tsecurity = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "CreateDirectoryExW", "wstr", $stemplatedir, "wstr", $snewdir, "struct*", $tsecurity)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateDirectoryEx

    Func _WinAPI_CreateFileEx($sfilepath, $icreation, $iaccess = 0x0, $ishare = 0x0, $iflagsandattributes = 0x0, $tsecurity = 0x0, $htemplate = 0x0)
        Local $acall = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sfilepath, "dword", $iaccess, "dword", $ishare, "struct*", $tsecurity, "dword", $icreation, "dword", $iflagsandattributes, "handle", $htemplate)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = Ptr(+ -1) Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateFileEx

    Func _WinAPI_CreateFileMapping($hfile, $isize = 0x0, $sname = '', $iprotect = 0x4, $tsecurity = 0x0)
        If Not StringStripWS($sname, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sname = Null
        Local $acall = DllCall("kernel32.dll", "handle", "CreateFileMappingW", "handle", $hfile, "struct*", $tsecurity, "dword", $iprotect, "dword", _WinAPI_HiDWord($isize), "dword", _WinAPI_LoDWord($isize), "wstr", $sname)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return SetExtended(_WinAPI_GetLastError(), $acall[0x0])
    EndFunc    ; -> _WinAPI_CreateFileMapping

    Func _WinAPI_CreateHardLink($snewfile, $sexistingfile)
        Local $acall = DllCall("kernel32.dll", "bool", "CreateHardLinkW", "wstr", $snewfile, "wstr", $sexistingfile, "ptr", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateHardLink

    Func _WinAPI_CreateObjectID($sfilepath)
        Local $hfile = _WinAPI_CreateFileEx($sfilepath, $OPEN_EXISTING, 0x0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $tfoid = DllStructCreate("byte[16];byte[48]")
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x900c0, "ptr", 0x0, "dword", 0x0, "struct*", $tfoid, "dword", DllStructGetSize($tfoid), "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
        Local $tguid = DllStructCreate($TAGGUID)
        _WinAPI_MoveMemory($tguid, $tfoid, 0x10)
        Return $tguid
    EndFunc    ; -> _WinAPI_CreateObjectID

    Func _WinAPI_CreateSymbolicLink($ssymlink, $starget, $bdirectory = False)
        If $bdirectory Then
            $bdirectory = 0x1
        EndIf
        Local $acall = DllCall("kernel32.dll", "boolean", "CreateSymbolicLinkW", "wstr", $ssymlink, "wstr", $starget, "dword", $bdirectory)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateSymbolicLink

    Func _WinAPI_DecryptFile($sfilepath)
        Local $acall = DllCall("advapi32.dll", "bool", "DecryptFileW", "wstr", $sfilepath, "dword", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DecryptFile

    Func _WinAPI_DefineDosDevice($SDEVICE, $IFLAGS, $sfilepath = '')
        If Not StringStripWS($sfilepath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sfilepath = Null
        Local $acall = DllCall("kernel32.dll", "bool", "DefineDosDeviceW", "dword", $IFLAGS, "wstr", $SDEVICE, "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DefineDosDevice

    Func _WinAPI_DeleteFile($sfilepath)
        Local $acall = DllCall("kernel32.dll", "bool", "DeleteFileW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DeleteFile

    Func _WinAPI_DeleteObjectID($sfilepath)
        Local $hfile = _WinAPI_CreateFileEx($sfilepath, $OPEN_EXISTING, $GENERIC_WRITE, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x900a0, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DeleteObjectID

    Func _WinAPI_DeleteVolumeMountPoint($smountedpath)
        Local $acall = DllCall("kernel32.dll", "bool", "DeleteVolumeMountPointW", "wstr", $smountedpath)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_DeleteVolumeMountPoint

    Func _WinAPI_DeviceIoControl($hdevice, $icontrolcode, $pinbuffer = 0x0, $iinbuffersize = 0x0, $poutbuffer = 0x0, $ioutbuffersize = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hdevice, "dword", $icontrolcode, "struct*", $pinbuffer, "dword", $iinbuffersize, "struct*", $poutbuffer, "dword", $ioutbuffersize, "dword*", 0x0, "ptr", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        Return SetExtended($acall[0x7], $acall[0x0])
    EndFunc    ; -> _WinAPI_DeviceIoControl

    Func _WinAPI_DuplicateEncryptionInfoFile($ssrcfilepath, $sdestfilepath, $icreation = 0x2, $iattributes = 0x0, $tsecurity = 0x0)
        Local $acall = DllCall("advapi32.dll", "dword", "DuplicateEncryptionInfoFile", "wstr", $ssrcfilepath, "wstr", $sdestfilepath, "dword", $icreation, "dword", $iattributes, "struct*", $tsecurity)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DuplicateEncryptionInfoFile

    Func _WinAPI_EjectMedia($sdrive)
        Local $hfile = _WinAPI_CreateFileEx("\\\\.\\" & $sdrive, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d4808, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_EjectMedia

    Func _WinAPI_EncryptFile($sfilepath)
        Local $acall = DllCall("advapi32.dll", "bool", "EncryptFileW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_EncryptFile

    Func _WinAPI_EncryptionDisable($sdir, $bdisable)
        Local $acall = DllCall("advapi32.dll", "bool", "EncryptionDisable", "wstr", $sdir, "bool", $bdisable)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_EncryptionDisable

    Func _WinAPI_EnumFiles($sdir, $IFLAG = 0x0, $STEMPLATE = '', $BEXCLUDE = False)
        Local $acall, $ierror = 0x0
        Local $ADATA[0x1f5][0x7] = [[0x0]]
        Local $hdir = _WinAPI_CreateFileEx($sdir, $OPEN_EXISTING, 0x1, $FILE_SHARE_ANY, $FILE_FLAG_BACKUP_SEMANTICS)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $pbuffer = __HeapAlloc($__g_iheapsize)
        If @error Then
            $ierror = @error
        Else
            Local $tiosb = DllStructCreate("ptr;ulong_ptr")
            $acall = DllCall("ntdll.dll", "uint", "ZwQueryDirectoryFile", "handle", $hdir, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "struct*", $tiosb, "struct*", $pbuffer, "ulong", 0x800000, "uint", 0x1, "boolean", 0x0, "ptr", 0x0, "boolean", 0x1)
            If @error Or $acall[0x0] Then
                $ierror = @error + 0x28
            EndIf
        EndIf
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hdir)
        If $ierror Then
            __HeapFree($pbuffer, 0x1)
            If IsArray($acall) Then
                Return SetError(0xa, $acall[0x0], 0x0)
            Else
                Return SetError($ierror, 0x0, 0x0)
            EndIf
        EndIf
        Local $tfdi, $iattrib, $starget, $ilength = 0x0, $ioffset = 0x0
        Do
            $ilength += $ioffset
            $tfdi = DllStructCreate("ulong;ulong;int64;int64;int64;int64;int64;int64;ulong;ulong;wchar[" & (DllStructGetData(DllStructCreate("ulong", $pbuffer + $ilength + 0x3c), 0x1) / 0x2) & "]", $pbuffer + $ilength)
            $starget = DllStructGetData($tfdi, 0xb)
            $iattrib = DllStructGetData($tfdi, 0x9)
            $ioffset = DllStructGetData($tfdi, 0x1)
            Switch $starget
            Case ".", ".."
                ContinueLoop
            Case Else
                Switch $IFLAG
                Case 0x1, 0x2
                    If BitAND($iattrib, 0x10) Then
                        If $IFLAG = 0x1 Then
                            ContinueLoop
                        EndIf
                    Else
                        If $IFLAG = 0x2 Then
                            ContinueLoop
                        EndIf
                    EndIf
                EndSwitch
                If $STEMPLATE Then
                    $acall = DllCall("shlwapi.dll", "int", "PathMatchSpecW", "wstr", $starget, "wstr", $STEMPLATE)
                    If @error Or ($acall[0x0] And $BEXCLUDE) Or (Not $acall[0x0] And Not $BEXCLUDE) Then
                        ContinueLoop
                    EndIf
                EndIf
            EndSwitch
            __Inc($ADATA, 0x1f4)
            $ADATA[$ADATA[0x0][0x0]][0x0] = $starget
            $ADATA[$ADATA[0x0][0x0]][0x1] = DllStructGetData($tfdi, 0x3)
            $ADATA[$ADATA[0x0][0x0]][0x2] = DllStructGetData($tfdi, 0x4)
            $ADATA[$ADATA[0x0][0x0]][0x3] = DllStructGetData($tfdi, 0x5)
            $ADATA[$ADATA[0x0][0x0]][0x4] = DllStructGetData($tfdi, 0x7)
            $ADATA[$ADATA[0x0][0x0]][0x5] = DllStructGetData($tfdi, 0x8)
            $ADATA[$ADATA[0x0][0x0]][0x6] = $iattrib
        Until Not $ioffset
        __HeapFree($pbuffer)
        __Inc($ADATA, + -1)
        Return $ADATA
    EndFunc    ; -> _WinAPI_EnumFiles

    Func _WinAPI_EnumFileStreams($sfilepath)
        Local $tdata = DllStructCreate("byte[32768]")
        Local $pdata = DllStructGetPtr($tdata)
        Local $ADATA[0x65][0x2] = [[0x0]]
        Local $hfile = _WinAPI_CreateFileEx($sfilepath, $OPEN_EXISTING, 0x0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $ierror = 0x0
        Local $tiosb = DllStructCreate("ptr;ulong_ptr")
        Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "ptr", $pdata, "ulong", 0x8000, "uint", 0x16)
        If @error Then $ierror = @error
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Local $tfsi, $ilength = 0x0, $ioffset = 0x0
        Do
            $ilength += $ioffset
            $tfsi = DllStructCreate("ulong;ulong;int64;int64;wchar[" & (DllStructGetData(DllStructCreate("ulong", $pdata + $ilength + 0x4), 0x1) / 0x2) & "]", $pdata + $ilength)
            __Inc($ADATA)
            $ADATA[$ADATA[0x0][0x0]][0x0] = DllStructGetData($tfsi, 0x5)
            $ADATA[$ADATA[0x0][0x0]][0x1] = DllStructGetData($tfsi, 0x3)
            $ioffset = DllStructGetData($tfsi, 0x1)
        Until Not $ioffset
        __Inc($ADATA, + -1)
        Return $ADATA
    EndFunc    ; -> _WinAPI_EnumFileStreams

    Func _WinAPI_EnumHardLinks($sfilepath)
        Local $tdata = DllStructCreate("byte[32768]")
        Local $pdata = DllStructGetPtr($tdata)
        Local $hfile = _WinAPI_CreateFileEx($sfilepath, $OPEN_EXISTING, 0x0, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $ierror = 0x0
        Local $tiosb = DllStructCreate("ptr;ulong_ptr")
        Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "ptr", $pdata, "ulong", 0x8000, "uint", 0x2e)
        If @error Or $acall[0x0] Then
            $ierror = @error + 0xa
            DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
            If $acall Then Return SetError($ierror, 0x0, 0x0)
            If $acall[0x0] Then Return SetError(0xa, $ierror, 0x0)
        EndIf
        Local $icount = DllStructGetData(DllStructCreate("ulong;ulong", $pdata), 0x2)
        Local $ADATA[$icount + 0x1] = [$icount]
        Local $tflei, $hpath, $spath, $ilength = 0x8
        For $i = 0x1 To $icount
            $tflei = DllStructCreate("ulong;int64;ulong;wchar[" & (DllStructGetData(DllStructCreate("ulong", $pdata + $ilength + 0x10), 0x1)) & "]", $pdata + $ilength)
            $ierror = 0x0
            Do
                $hpath = _WinAPI_OpenFileById($hfile, DllStructGetData($tflei, 0x2), 0x100080, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
                If @error Then
                    $ierror = @error + 0x64
                    ExitLoop
                EndIf
                $spath = _WinAPI_GetFinalPathNameByHandleEx($hpath)
                If @error Then
                    $ierror = @error + 0xc8
                    ExitLoop
                EndIf
            Until 0x1
            If $hpath Then
                DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hpath)
            EndIf
            If $ierror Then ExitLoop
            $ADATA[$i] = _WinAPI_PathAppend($spath, DllStructGetData($tflei, 0x4))
            $ilength += DllStructGetData($tflei, 0x1)
        Next
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $ADATA
    EndFunc    ; -> _WinAPI_EnumHardLinks

    Func _WinAPI_FileEncryptionStatus($sfilepath)
        Local $acall = DllCall("advapi32.dll", "bool", "FileEncryptionStatusW", "wstr", $sfilepath, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, + -1)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_FileEncryptionStatus

    Func _WinAPI_FileExists($sfilepath)
        If Not FileExists($sfilepath) Then Return 0x0
        If _WinAPI_PathIsDirectory($sfilepath) Then Return SetExtended(0x1, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_FileExists

    Func _WinAPI_FileInUse($sfilepath)
        Local $hfile = _WinAPI_CreateFileEx($sfilepath, $OPEN_EXISTING, $GENERIC_READ)
        If @error Then
            If @extended = 0x20 Then Return 0x1
            Return SetError(@error, @extended, 0x0)
        EndIf
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
        Return 0x0
    EndFunc    ; -> _WinAPI_FileInUse

    Func _WinAPI_FindClose($hsearch)
        Local $acall = DllCall("kernel32.dll", "bool", "FindClose", "handle", $hsearch)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindClose

    Func _WinAPI_FindCloseChangeNotification($hchange)
        Local $acall = DllCall("kernel32.dll", "bool", "FindCloseChangeNotification", "handle", $hchange)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindCloseChangeNotification

    Func _WinAPI_FindFirstChangeNotification($sdirectory, $IFLAGS, $bsubtree = False)
        Local $acall = DllCall("kernel32.dll", "handle", "FindFirstChangeNotificationW", "wstr", $sdirectory, "bool", $bsubtree, "dword", $IFLAGS)
        If @error Or ($acall[0x0] = Ptr(+ -1)) Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindFirstChangeNotification

    Func _WinAPI_FindFirstFile($sfilepath, $tdata)
        Local $acall = DllCall("kernel32.dll", "handle", "FindFirstFileW", "wstr", $sfilepath, "struct*", $tdata)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = Ptr(+ -1) Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindFirstFile

    Func _WinAPI_FindFirstFileName($sfilepath, ByRef $slink)
        $slink = ''
        Local $acall = DllCall("kernel32.dll", "handle", "FindFirstFileNameW", "wstr", $sfilepath, "dword", 0x0, "dword*", 0x1000, "wstr", '')
        If @error Or ($acall[0x0] = Ptr(+ -1)) Then Return SetError(@error + 0xa, @extended, 0x0)
        $slink = $acall[0x4]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindFirstFileName

    Func _WinAPI_FindFirstStream($sfilepath, $tdata)
        Local $acall = DllCall("kernel32.dll", "handle", "FindFirstStreamW", "wstr", $sfilepath, "uint", 0x0, "struct*", $tdata, "dword", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = Ptr(+ -1) Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindFirstStream

    Func _WinAPI_FindNextChangeNotification($hchange)
        Local $acall = DllCall("kernel32.dll", "bool", "FindNextChangeNotification", "handle", $hchange)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindNextChangeNotification

    Func _WinAPI_FindNextFile($hsearch, $tdata)
        Local $acall = DllCall("kernel32.dll", "bool", "FindNextFileW", "handle", $hsearch, "struct*", $tdata)
        If @error Then Return SetError(@error, @extended, False)
        If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindNextFile

    Func _WinAPI_FindNextFileName($hsearch, ByRef $slink)
        $slink = ''
        Local $acall = DllCall("kernel32.dll", "bool", "FindNextFileNameW", "handle", $hsearch, "dword*", 0x1000, "wstr", '')
        If @error Then Return SetError(@error, @extended, False)
        If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
        $slink = $acall[0x3]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindNextFileName

    Func _WinAPI_FindNextStream($hsearch, $tdata)
        Local $acall = DllCall("kernel32.dll", "bool", "FindNextStreamW", "handle", $hsearch, "struct*", $tdata)
        If @error Then Return SetError(@error, @extended, False)
        If Not $acall[0x0] Then Return SetError(0xa, _WinAPI_GetLastError(), 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FindNextStream

    Func _WinAPI_FlushFileBuffers($hfile)
        Local $acall = DllCall("kernel32.dll", "bool", "FlushFileBuffers", "handle", $hfile)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FlushFileBuffers

    Func _WinAPI_FlushViewOfFile($paddress, $ibytes = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "FlushViewOfFile", "struct*", $paddress, "dword", $ibytes)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_FlushViewOfFile

    Func _WinAPI_GetBinaryType($sfilepath)
        Local $acall = DllCall("kernel32.dll", "int", "GetBinaryTypeW", "wstr", $sfilepath, "dword*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If Not $acall[0x0] Then $acall[0x2] = 0x0
        Return SetExtended($acall[0x2], $acall[0x0])
    EndFunc    ; -> _WinAPI_GetBinaryType

    Func _WinAPI_GetCDType($sdrive)
        Local $hfile = _WinAPI_CreateFileEx("\\\\.\\" & $sdrive, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $tagscsi_pass_through = "struct;ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;ulong DataTransferLength;ulong TimeOutVa" & _
            "lue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16];endstruct"
        Local $tspt = DllStructCreate($tagscsi_pass_through & ";byte Hdr[8]")
        Local $tcdb = DllStructCreate("byte;byte;byte[2];byte[3];byte[2];byte;byte[2];byte[4]", DllStructGetPtr($tspt, "Cdb"))
        Local $thdr = DllStructCreate("byte[4];byte;byte;byte[2]", DllStructGetPtr($tspt, "Hdr"))
        Local $isize = DllStructGetPtr($tspt, "Hdr") - DllStructGetPtr($tspt)
        DllStructSetData($tspt, "Length", $isize)
        DllStructSetData($tspt, "ScsiStatus", 0x0)
        DllStructSetData($tspt, "PathId", 0x0)
        DllStructSetData($tspt, "TargetId", 0x0)
        DllStructSetData($tspt, "Lun", 0x0)
        DllStructSetData($tspt, "CdbLength", 0xc)
        DllStructSetData($tspt, "SenseInfoLength", 0x0)
        DllStructSetData($tspt, "DataIn", 0x1)
        DllStructSetData($tspt, "DataTransferLength", 0x8)
        DllStructSetData($tspt, "TimeOutValue", 0x15180)
        DllStructSetData($tspt, "DataBufferOffset", $isize)
        DllStructSetData($tspt, "SenseInfoOffset", 0x0)
        DllStructSetData($tcdb, 0x1, 0x46)
        DllStructSetData($tcdb, 0x2, 0x0)
        DllStructSetData($tcdb, 0x3, 0x0, 0x1)
        DllStructSetData($tcdb, 0x3, 0x0, 0x2)
        DllStructSetData($tcdb, 0x5, 0x0, 0x1)
        DllStructSetData($tcdb, 0x5, 0x8, 0x2)
        DllStructSetData($tcdb, 0x6, 0x0)
        DllStructSetData($tcdb, 0x7, 0x0, 0x1)
        DllStructSetData($tcdb, 0x7, 0x0, 0x2)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x4d004, "struct*", $tspt, "dword", $isize, "struct*", $tspt, "dword", DllStructGetSize($tspt), "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
        Return BitOR(BitShift(DllStructGetData($thdr, 0x4, 0x1), + -8), DllStructGetData($thdr, 0x4, 0x2))
    EndFunc    ; -> _WinAPI_GetCDType

    Func _WinAPI_GetCompressedFileSize($sfilepath)
        Local $acall = DllCall("kernel32.dll", "dword", "GetCompressedFileSizeW", "wstr", $sfilepath, "dword*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] = + -1 Then
            Local $ilasterror = _WinAPI_GetLastError()
            If $acall[0x2] = 0x0 Then Return SetError(0xa, $ilasterror, 0x0)
            If $ilasterror Then Return SetError(0xb, $ilasterror, 0x0)
        EndIf
        Return __WinAPI_MakeQWord($acall[0x0], $acall[0x2])
    EndFunc    ; -> _WinAPI_GetCompressedFileSize

    Func _WinAPI_GetCompression($sfilepath)
        Local $hfile = _WinAPI_CreateFileEx($sfilepath, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x9003c, "ptr", 0x0, "dword", 0x0, "ushort*", 0x0, "dword", 0x2, "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, + -1)
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_GetCompression

    Func _WinAPI_GetCurrentDirectory()
        Local $acall = DllCall("kernel32.dll", "dword", "GetCurrentDirectoryW", "dword", 0x1000, "wstr", '')
        If @error Then Return SetError(@error, @extended, '')
        Return SetExtended($acall[0x0], $acall[0x2])
    EndFunc    ; -> _WinAPI_GetCurrentDirectory

    Func _WinAPI_GetDiskFreeSpaceEx($sdrive)
        Local $acall = DllCall("kernel32.dll", "bool", "GetDiskFreeSpaceEx", "str", $sdrive, "int64*", 0x0, "int64*", 0x0, "int64*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x3]
        For $i = 0x0 To 0x2
            $aret[$i] = $acall[$i + 0x2]
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetDiskFreeSpaceEx

    Func _WinAPI_GetDriveBusType($sdrive)
        Local $hfile = _WinAPI_CreateFileEx("\\\\.\\" & $sdrive, $OPEN_EXISTING, 0x0, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, + -1)
        Local $tagstorage_property_query = "ulong PropertyId;ulong QueryType;byte AdditionalParameters[1]"
        Local $tspq = DllStructCreate($tagstorage_property_query)
        Local $tsdd = DllStructCreate("ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong Produ" & _
            "ctRevisionOffset;ulong SerialNumberOffset;ulong BusType;ulong RawPropertiesLength;byte RawDeviceProperties[1]")
        DllStructSetData($tspq, "PropertyId", 0x0)
        DllStructSetData($tspq, "QueryType", 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d1400, "struct*", $tspq, "dword", DllStructGetSize($tspq), "struct*", $tsdd, "dword", DllStructGetSize($tsdd), "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, + -1)
        Return DllStructGetData($tsdd, "BusType")
    EndFunc    ; -> _WinAPI_GetDriveBusType

    Func _WinAPI_GetDriveGeometryEx($idrive)
        Local $hfile = _WinAPI_CreateFileEx("\\\\.\\PhysicalDrive" & $idrive, $OPEN_EXISTING, 0x0, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $tdgex = DllStructCreate("uint64;dword;dword;dword;dword;uint64")
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x700a0, "ptr", 0x0, "dword", 0x0, "struct*", $tdgex, "dword", DllStructGetSize($tdgex), "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
        Local $aret[0x6]
        For $i = 0x0 To 0x5
            $aret[$i] = DllStructGetData($tdgex, $i + 0x1)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetDriveGeometryEx

    Func _WinAPI_GetDriveNumber($sdrive)
        Local $hfile = _WinAPI_CreateFileEx("\\\\.\\" & $sdrive, $OPEN_EXISTING, 0x0, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $tsdn = DllStructCreate("dword;dword;dword")
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d1080, "ptr", 0x0, "dword", 0x0, "struct*", $tsdn, "dword", DllStructGetSize($tsdn), "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
        Local $aret[0x3]
        For $i = 0x0 To 0x2
            $aret[$i] = DllStructGetData($tsdn, $i + 0x1)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetDriveNumber

    Func _WinAPI_GetDriveType($sdrive = '')
        If Not StringStripWS($sdrive, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sdrive = Null
        Local $acall = DllCall("kernel32.dll", "uint", "GetDriveType", "str", $sdrive)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetDriveType

    Func _WinAPI_GetFileAttributes($sfilepath)
        Local $acall = DllCall("kernel32.dll", "dword", "GetFileAttributesW", "wstr", $sfilepath)
        If @error Or ($acall[0x0] = -1) Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetFileAttributes

    Func _WinAPI_GetFileID($hfile)
        Local $tiosb = DllStructCreate("ptr;ulong_ptr")
        Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "int64*", 0x0, "ulong", 0x8, "uint", 0x6)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_GetFileID

    Func _WinAPI_GetFileInformationByHandle($hfile)
        Local $tbhfi = DllStructCreate("dword;dword[2];dword[2];dword[2];dword;dword;dword;dword;dword;dword")
        Local $acall = DllCall("kernel32.dll", "bool", "GetFileInformationByHandle", "handle", $hfile, "struct*", $tbhfi)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x8]
        $aret[0x0] = DllStructGetData($tbhfi, 0x1)
        For $i = 0x1 To 0x3
            If DllStructGetData($tbhfi, $i + 0x1) Then
                $aret[$i] = DllStructCreate($TAGFILETIME)
                _WinAPI_MoveMemory($aret[$i], DllStructGetPtr($tbhfi, $i + 0x1), 0x8)
            Else
                $aret[$i] = 0x0
            EndIf
        Next
        $aret[0x4] = DllStructGetData($tbhfi, 0x5)
        $aret[0x5] = __WinAPI_MakeQWord(DllStructGetData($tbhfi, 0x7), DllStructGetData($tbhfi, 0x6))
        $aret[0x6] = DllStructGetData($tbhfi, 0x8)
        $aret[0x7] = __WinAPI_MakeQWord(DllStructGetData($tbhfi, 0x9), DllStructGetData($tbhfi, 0xa))
        Return $aret
    EndFunc    ; -> _WinAPI_GetFileInformationByHandle

    Func _WinAPI_GetFileInformationByHandleEx($hfile)
        Local $tfi = DllStructCreate($TAGFILEINFO)
        Local $tiosb = DllStructCreate("ptr;ulong_ptr")
        Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "struct*", $tfi, "ulong", DllStructGetSize($tfi), "uint", 0x4)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $tfi
    EndFunc    ; -> _WinAPI_GetFileInformationByHandleEx

    Func _WinAPI_GetFilePointerEx($hfile)
        Local $tiosb = DllStructCreate("ptr;ulong_ptr")
        Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "int64*", 0x0, "ulong", 0x8, "uint", 0xe)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_GetFilePointerEx

    Func _WinAPI_GetFileSizeEx($hfile)
        Local $acall = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hfile, "int64*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, + -1)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetFileSizeEx

    Func _WinAPI_GetFileSizeOnDisk($sfilepath)
        Local $isize = FileGetSize($sfilepath)
        If @error Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "GetDiskFreeSpaceW", "wstr", _WinAPI_PathStripToRoot(_WinAPI_GetFullPathName($sfilepath)), "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return Ceiling($isize / ($acall[0x2] * $acall[0x3])) * ($acall[0x2] * $acall[0x3])
    EndFunc    ; -> _WinAPI_GetFileSizeOnDisk

    Func _WinAPI_GetFileTitle($sfilepath)
        Local $acall = DllCall("comdlg32.dll", "short", "GetFileTitleW", "wstr", $sfilepath, "wstr", '', "word", 0x1000)
        If @error Or $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetFileTitle

    Func _WinAPI_GetFileType($hfile)
        Local $acall = DllCall("kernel32.dll", "dword", "GetFileType", "handle", $hfile)
        If @error Then Return SetError(@error, @extended, + -1)
        Local $ilasterror = _WinAPI_GetLastError()
        If Not $acall[0x0] And $ilasterror Then Return SetError(0xa, $ilasterror, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetFileType

    Func _WinAPI_GetFinalPathNameByHandle($hfile)
        Local $tfni = DllStructCreate("ulong;wchar[4096]")
        Local $tiosb = DllStructCreate("ptr;ulong_ptr")
        Local $acall = DllCall("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $hfile, "struct*", $tiosb, "struct*", $tfni, "ulong", DllStructGetSize($tfni), "uint", 0x9)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Local $ilength = DllStructGetData($tfni, 0x1)
        If Not $ilength Then Return SetError(0xc, 0x0, '')
        Return DllStructGetData(DllStructCreate("wchar[" & ($ilength / 0x2) & "]", DllStructGetPtr($tfni, 0x2)), 0x1)
    EndFunc    ; -> _WinAPI_GetFinalPathNameByHandle

    Func _WinAPI_GetFinalPathNameByHandleEx($hfile, $IFLAGS = 0x0)
        Local $acall = DllCall("kernel32.dll", "dword", "GetFinalPathNameByHandleW", "handle", $hfile, "wstr", '', "dword", 0x1000, "dword", $IFLAGS)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetFinalPathNameByHandleEx

    Func _WinAPI_GetFullPathName($sfilepath)
        Local $acall = DllCall("kernel32.dll", "dword", "GetFullPathNameW", "wstr", $sfilepath, "dword", 0x1000, "wstr", '', "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, '')
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_GetFullPathName

    Func _WinAPI_GetLogicalDrives()
        Local $acall = DllCall("kernel32.dll", "dword", "GetLogicalDrives")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetLogicalDrives

    Func _WinAPI_GetObjectID($sfilepath)
        Local $hfile = _WinAPI_CreateFileEx($sfilepath, $OPEN_EXISTING, 0x0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $tfoid = DllStructCreate("byte[16];byte[48]")
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x9009c, "ptr", 0x0, "dword", 0x0, "struct*", $tfoid, "dword", DllStructGetSize($tfoid), "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
        Local $tguid = DllStructCreate($TAGGUID)
        _WinAPI_MoveMemory($tguid, $tfoid, 0x10)
        Return $tguid
    EndFunc    ; -> _WinAPI_GetObjectID

    Func _WinAPI_GetOverlappedResult($hfile, $toverlapped, ByRef $ibytes, $bwait = False)
        Local $acall = DllCall("kernel32.dll", "bool", "GetOverlappedResult", "handle", $hfile, "struct*", $toverlapped, "dword*", 0x0, "bool", $bwait)
        If @error Then Return SetError(@error, @extended, False)
        $ibytes = $acall[0x3]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetOverlappedResult

    Func _WinAPI_GetPEType($sfilepath)
        Local $tdata = DllStructCreate("ushort[2]")
        Local $tuint = DllStructCreate("uint", DllStructGetPtr($tdata))
        Local $hfile = _WinAPI_CreateFileEx($sfilepath, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $ierror = 0x0, $ival
        Do
            Local $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x2, "dword*", 0x0, "ptr", 0x0)
            If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x2) Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            $ival = DllStructGetData($tdata, 0x1, 0x1)
            If $ival <> 0x5a4d Then
                $ierror = 0x3
                ExitLoop
            EndIf
            If Not _WinAPI_SetFilePointerEx($hfile, 0x3c) Then
                $ierror = @error + 0x28
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x4, "dword*", 0x0, "ptr", 0x0)
            If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x4) Then
                $ierror = @error + 0x32
                ExitLoop
            EndIf
            If Not _WinAPI_SetFilePointerEx($hfile, DllStructGetData($tuint, 0x1)) Then
                $ierror = @error + 0x3c
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x4, "dword*", 0x0, "ptr", 0x0)
            If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x4) Then
                $ierror = @error + 0x46
                ExitLoop
            EndIf
            $ival = DllStructGetData($tuint, 0x1)
            If $ival <> 0x4550 Then
                $ierror = 0x4
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $tdata, "dword", 0x2, "dword*", 0x0, "ptr", 0x0)
            If @error Or (Not $acall[0x0]) Or ($acall[0x4] <> 0x2) Then
                $ierror = @error + 0x50
                ExitLoop
            EndIf
            $ival = DllStructGetData($tdata, 0x1, 0x1)
        Until 0x1
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $ival
    EndFunc    ; -> _WinAPI_GetPEType

    Func _WinAPI_GetProfilesDirectory()
        Local $acall = DllCall("userenv.dll", "bool", "GetProfilesDirectoryW", "wstr", '', "dword*", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_GetProfilesDirectory

    Func _WinAPI_GetTempFileName($sfilepath, $sprefix = '')
        Local $acall = DllCall("kernel32.dll", "uint", "GetTempFileNameW", "wstr", $sfilepath, "wstr", $sprefix, "uint", 0x0, "wstr", '')
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x4]
    EndFunc    ; -> _WinAPI_GetTempFileName

    Func _WinAPI_GetVolumeInformation($sroot = '')
        If Not StringStripWS($sroot, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sroot = Null
        Local $acall = DllCall("kernel32.dll", "bool", "GetVolumeInformationW", "wstr", $sroot, "wstr", '', "dword", 0x1000, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "wstr", '', "dword", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x5]
        For $i = 0x0 To 0x4
            Switch $i
            Case 0x0
                $aret[$i] = $acall[0x2]
            Case Else
                $aret[$i] = $acall[$i + 0x3]
            EndSwitch
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetVolumeInformation

    Func _WinAPI_GetVolumeInformationByHandle($hfile)
        Local $acall = DllCall("kernel32.dll", "bool", "GetVolumeInformationByHandleW", "handle", $hfile, "wstr", '', "dword", 0x1000, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "wstr", '', "dword", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $aret[0x5]
        For $i = 0x0 To 0x4
            Switch $i
            Case 0x0
                $aret[$i] = $acall[0x2]
            Case Else
                $aret[$i] = $acall[$i + 0x3]
            EndSwitch
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetVolumeInformationByHandle

    Func _WinAPI_GetVolumeNameForVolumeMountPoint($smountedpath)
        Local $acall = DllCall("kernel32.dll", "bool", "GetVolumeNameForVolumeMountPointW", "wstr", $smountedpath, "wstr", '', "dword", 0x50)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetVolumeNameForVolumeMountPoint

    Func _WinAPI_IOCTL($idevicetype, $ifunction, $imethod, $iaccess)
        Return BitOR(BitShift($idevicetype, + -16), BitShift($iaccess, + -14), BitShift($ifunction, + -2), $imethod)
    EndFunc    ; -> _WinAPI_IOCTL

    Func _WinAPI_IsDoorOpen($sdrive)
        Local $hfile = _WinAPI_CreateFileEx("\\\\.\\" & $sdrive, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, False)
        Local $tspt = DllStructCreate("ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulon" & _
            "g TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16]" & (@AutoItX64  ? ";byte[4]"  : '') & ";byte Hdr[8]")
        Local $tcdb = DllStructCreate("byte;byte;byte[6];byte[2];byte;byte;byte[4]", DllStructGetPtr($tspt, "Cdb"))
        Local $thdr = DllStructCreate("byte;byte;byte[3];byte;byte[2]", DllStructGetPtr($tspt, "Hdr"))
        Local $isize = DllStructGetPtr($tspt, "Hdr") - DllStructGetPtr($tspt)
        DllStructSetData($tspt, "Length", $isize)
        DllStructSetData($tspt, "ScsiStatus", 0x0)
        DllStructSetData($tspt, "PathId", 0x0)
        DllStructSetData($tspt, "TargetId", 0x0)
        DllStructSetData($tspt, "Lun", 0x0)
        DllStructSetData($tspt, "CdbLength", 0xc)
        DllStructSetData($tspt, "SenseInfoLength", 0x0)
        DllStructSetData($tspt, "DataIn", 0x1)
        DllStructSetData($tspt, "DataTransferLength", 0x8)
        DllStructSetData($tspt, "TimeOutValue", 0x15180)
        DllStructSetData($tspt, "DataBufferOffset", $isize)
        DllStructSetData($tspt, "SenseInfoOffset", 0x0)
        DllStructSetData($tcdb, 0x1, 0xbd)
        DllStructSetData($tcdb, 0x2, 0x0)
        DllStructSetData($tcdb, 0x4, 0x0, 0x1)
        DllStructSetData($tcdb, 0x4, 0x8, 0x2)
        DllStructSetData($tcdb, 0x5, 0x0)
        DllStructSetData($tcdb, 0x6, 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x4d004, "struct*", $tspt, "dword", $isize, "struct*", $tspt, "dword", DllStructGetSize($tspt), "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, False)
        Return (BitAND(DllStructGetData($thdr, 0x2), 0x10) = 0x10)
    EndFunc    ; -> _WinAPI_IsDoorOpen

    Func _WinAPI_IsPathShared($sfilepath)
        If Not __dll("ntshrui.dll") Then Return SetError(0x67, 0x0, 0x0)
        Local $acall = DllCall("ntshrui.dll", "bool", "IsPathSharedW", "wstr", _WinAPI_PathRemoveBackslash($sfilepath), "int", 0x1)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsPathShared

    Func _WinAPI_IsWritable($sdrive)
        DriveGetFileSystem($sdrive)
        If @error Then Return SetError(0x28 + @error, _WinAPI_GetLastError(), 0x0)
        Local $hfile = _WinAPI_CreateFileEx("\\\\.\\" & $sdrive, $OPEN_EXISTING, 0x0, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x70024, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
        Local Const $ERROR_WRITE_PROTECT = 0x13
        If __CheckErrorCloseHandle($acall, $hfile, 0x1) <> 0xa And @extended = $ERROR_WRITE_PROTECT Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_IsWritable

    Func _WinAPI_LoadMedia($sdrive)
        Local $hfile = _WinAPI_CreateFileEx("\\\\.\\" & $sdrive, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, False)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d480c, "ptr", 0x0, "dword", 0x0, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LoadMedia

    Func _WinAPI_LockDevice($sdrive, $block)
        Local $hfile = _WinAPI_CreateFileEx("\\\\.\\" & $sdrive, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
        If @error Then Return SetError(@error + 0x14, @extended, False)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x2d4804, "boolean*", $block, "dword", 0x1, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LockDevice

    Func _WinAPI_LockFile($hfile, $ioffset, $ilength)
        Local $acall = DllCall("kernel32.dll", "bool", "LockFile", "handle", $hfile, "dword", _WinAPI_LoDWord($ioffset), "dword", _WinAPI_HiDWord($ioffset), "dword", _WinAPI_LoDWord($ilength), "dword", _WinAPI_HiDWord($ilength))
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_LockFile

    Func _WinAPI_MapViewOfFile($hmapping, $ioffset = 0x0, $ibytes = 0x0, $iaccess = 0x6)
        Local $acall = DllCall("kernel32.dll", "ptr", "MapViewOfFile", "handle", $hmapping, "dword", $iaccess, "dword", _WinAPI_HiDWord($ioffset), "dword", _WinAPI_LoDWord($ioffset), "ulong_ptr", $ibytes)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MapViewOfFile

    Func _WinAPI_MoveFileEx($sexistingfile, $snewfile, $IFLAGS = 0x0, $pprogressproc = 0x0, $pdata = 0x0)
        If Not StringStripWS($snewfile, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $snewfile = Null
        If BitAND($IFLAGS, $MOVE_FILE_DELAY_UNTIL_REBOOT) Then
            If $snewfile = 0x0 Then $snewfile = Null
        EndIf
        Local $acall = DllCall("kernel32.dll", "bool", "MoveFileWithProgressW", "wstr", $sexistingfile, "wstr", $snewfile, "ptr", $pprogressproc, "ptr", $pdata, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_MoveFileEx

    Func _WinAPI_OpenFileById($hfile, $vid, $iaccess = 0x0, $ishare = 0x0, $IFLAGS = 0x0)
        Local $tfidd = DllStructCreate("dword;uint;int64;int64")
        Local $hobj, $acall, $itype, $ierror = 0x0
        Select
        Case IsString($vid)
            $acall = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $vid, "ptr", DllStructGetPtr($tfidd, 0x3))
            If @error Or $acall[0x0] Then
                Return SetError(@error + 0x1e, 0x0, 0x0)
            EndIf
            $itype = 0x1
        Case IsDllStruct($vid)
            If Not _WinAPI_MoveMemory(DllStructGetPtr($tfidd, 0x3), DllStructGetPtr($vid), 0x10) Then
                Return SetError(@error + 0x28, 0x0, 0x0)
            EndIf
            $itype = 0x1
        Case Else
            DllStructSetData($tfidd, 0x3, $vid)
            $itype = 0x0
        EndSelect
        DllStructSetData($tfidd, 0x1, DllStructGetSize($tfidd))
        DllStructSetData($tfidd, 0x2, $itype)
        If IsString($hfile) Then
            $hobj = _WinAPI_CreateFileEx($hfile, $OPEN_EXISTING, 0x0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
            If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Else
            $hobj = $hfile
        EndIf
        $acall = DllCall("kernel32.dll", "handle", "OpenFileById", "handle", $hobj, "struct*", $tfidd, "dword", $iaccess, "dword", $ishare, "ptr", 0x0, "dword", $IFLAGS)
        If @error Or ($acall[0x0] = Ptr(+ -1)) Then $ierror = @error + 0xa
        If IsString($hfile) Then
            DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hobj)
        EndIf
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OpenFileById

    Func _WinAPI_OpenFileMapping($sname, $iaccess = 0x6, $binherit = False)
        Local $acall = DllCall("kernel32.dll", "handle", "OpenFileMappingW", "dword", $iaccess, "bool", $binherit, "wstr", $sname)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OpenFileMapping

    Func _WinAPI_PathIsDirectoryEmpty($sfilepath)
        Local $acall = DllCall("shlwapi.dll", "bool", "PathIsDirectoryEmptyW", "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_PathIsDirectoryEmpty

    Func _WinAPI_QueryDosDevice($SDEVICE)
        If Not StringStripWS($SDEVICE, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $SDEVICE = Null
        Local $tdata = DllStructCreate("wchar[16384]")
        Local $acall = DllCall("kernel32.dll", "dword", "QueryDosDeviceW", "wstr", $SDEVICE, "struct*", $tdata, "dword", 0x4000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Local $aret = _WinAPI_StructToArray($tdata)
        If IsString($SDEVICE) Then
            $aret = $aret[0x1]
        EndIf
        Return $aret
    EndFunc    ; -> _WinAPI_QueryDosDevice

    Func _WinAPI_ReadDirectoryChanges($hdirectory, $ifilter, $pbuffer, $ilength, $bsubtree = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "ReadDirectoryChangesW", "handle", $hdirectory, "struct*", $pbuffer, "dword", $ilength - Mod($ilength, 0x4), "bool", $bsubtree, "dword", $ifilter, "dword*", 0x0, "ptr", 0x0, "ptr", 0x0)
        If @error Or Not $acall[0x0] Or (Not $acall[0x6]) Then Return SetError(@error + 0xa, @extended, 0x0)
        $pbuffer = $acall[0x2]
        Local $ADATA[0x65][0x2] = [[0x0]]
        Local $tfni, $ibuffer = 0x0, $ioffset = 0x0
        Do
            $ibuffer += $ioffset
            $tfni = DllStructCreate("dword NextEntryOffset;dword Action;dword FileNameLength;wchar FileName[" & (DllStructGetData(DllStructCreate("dword FileNameLength", $pbuffer + $ibuffer + 0x8), 0x1) / 0x2) & "]", $pbuffer + $ibuffer)
            __Inc($ADATA)
            $ADATA[$ADATA[0x0][0x0]][0x0] = DllStructGetData($tfni, "FileName")
            $ADATA[$ADATA[0x0][0x0]][0x1] = DllStructGetData($tfni, "Action")
            $ioffset = DllStructGetData($tfni, "NextEntryOffset")
        Until Not $ioffset
        __Inc($ADATA, + -1)
        Return $ADATA
    EndFunc    ; -> _WinAPI_ReadDirectoryChanges

    Func _WinAPI_RemoveDirectory($sdirpath)
        Local $acall = DllCall("kernel32.dll", "bool", "RemoveDirectoryW", "wstr", $sdirpath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RemoveDirectory

    Func _WinAPI_ReOpenFile($hfile, $iaccess, $ishare, $IFLAGS = 0x0)
        Local $acall = DllCall("kernel32.dll", "handle", "ReOpenFile", "handle", $hfile, "dword", $iaccess, "dword", $ishare, "dword", $IFLAGS)
        If @error Or ($acall[0x0] = Ptr(+ -1)) Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ReOpenFile

    Func _WinAPI_ReplaceFile($sreplacedfile, $sreplacementfile, $sbackupfile = '', $IFLAGS = 0x0)
        If Not StringStripWS($sbackupfile, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sbackupfile = Null
        Local $acall = DllCall("kernel32.dll", "bool", "ReplaceFileW", "wstr", $sreplacedfile, "wstr", $sreplacementfile, "wstr", $sbackupfile, "dword", $IFLAGS, "ptr", 0x0, "ptr", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ReplaceFile

    Func _WinAPI_SearchPath($sfilepath, $ssearchpath = '')
        If Not StringStripWS($ssearchpath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $ssearchpath = Null
        Local $acall = DllCall("kernel32.dll", "dword", "SearchPathW", "wstr", $ssearchpath, "wstr", $sfilepath, "ptr", 0x0, "dword", 0x1000, "wstr", '', "ptr", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_SearchPath

    Func _WinAPI_SetCompression($sfilepath, $icompression)
        Local $hfile = _WinAPI_CreateFileEx($sfilepath, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
        If @error Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $hfile, "dword", 0x9c040, "ushort*", $icompression, "dword", 0x2, "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "ptr", 0x0)
        If __CheckErrorCloseHandle($acall, $hfile) Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_SetCompression

    Func _WinAPI_SetCurrentDirectory($sdir)
        Local $acall = DllCall("kernel32.dll", "int", "SetCurrentDirectoryW", "wstr", $sdir)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetCurrentDirectory

    Func _WinAPI_SetEndOfFile($hfile)
        Local $acall = DllCall("kernel32.dll", "bool", "SetEndOfFile", "handle", $hfile)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetEndOfFile

    Func _WinAPI_SetFileAttributes($sfilepath, $iattributes)
        Local $acall = DllCall("kernel32.dll", "int", "SetFileAttributesW", "wstr", $sfilepath, "dword", $iattributes)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetFileAttributes

    Func _WinAPI_SetFileInformationByHandleEx($hfile, $tfileinfo)
        Local $acall = DllCall("ntdll.dll", "long", "ZwSetInformationFile", "handle", $hfile, "struct*", $tfileinfo, "struct*", $tfileinfo, "ulong", DllStructGetSize($tfileinfo), "uint", 0x4)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_SetFileInformationByHandleEx

    Func _WinAPI_SetFilePointer($hfile, $ipos, $imethod = 0x0)
        Local $acall = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hfile, "long", $ipos, "ptr", 0x0, "long", $imethod)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetFilePointer

    Func _WinAPI_SetFilePointerEx($hfile, $ipos, $imethod = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "SetFilePointerEx", "handle", $hfile, "int64", $ipos, "int64*", 0x0, "dword", $imethod)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetFilePointerEx

    Func _WinAPI_SetFileShortName($hfile, $sshortname)
        Local $acall = DllCall("kernel32.dll", "bool", "SetFileShortNameW", "handle", $hfile, "wstr", $sshortname)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetFileShortName

    Func _WinAPI_SetFileValidData($hfile, $ilength)
        Local $acall = DllCall("kernel32.dll", "bool", "SetFileValidData", "handle", $hfile, "int64", $ilength)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetFileValidData

    Func _WinAPI_SetSearchPathMode($IFLAGS)
        Local $acall = DllCall("kernel32.dll", "bool", "SetSearchPathMode", "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetSearchPathMode

    Func _WinAPI_SetVolumeMountPoint($sfilepath, $sguid)
        Local $acall = DllCall("kernel32.dll", "bool", "SetVolumeMountPointW", "wstr", $sfilepath, "wstr", $sguid)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetVolumeMountPoint

    Func _WinAPI_SfcIsFileProtected($sfilepath)
        If Not __dll("sfc.dll") Then Return SetError(0x67, 0x0, False)
        Local $acall = DllCall("sfc.dll", "bool", "SfcIsFileProtected", "handle", 0x0, "wstr", $sfilepath)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SfcIsFileProtected

    Func _WinAPI_UnlockFile($hfile, $ioffset, $ilength)
        Local $acall = DllCall("kernel32.dll", "bool", "UnlockFile", "handle", $hfile, "dword", _WinAPI_LoDWord($ioffset), "dword", _WinAPI_HiDWord($ioffset), "dword", _WinAPI_LoDWord($ilength), "dword", _WinAPI_HiDWord($ilength))
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UnlockFile

    Func _WinAPI_UnmapViewOfFile($paddress)
        Local $acall = DllCall("kernel32.dll", "bool", "UnmapViewOfFile", "ptr", $paddress)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UnmapViewOfFile

    Func _WinAPI_Wow64EnableWow64FsRedirection($benable)
        Local $acall = DllCall("kernel32.dll", "boolean", "Wow64EnableWow64FsRedirection", "boolean", $benable)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_Wow64EnableWow64FsRedirection

#EndRegion Public Functions
#Region Internal Functions
    Func __WinAPI_MakeQWord($ilodword, $ihidword)
        Local $tint64 = DllStructCreate("uint64")
        Local $tdwords = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
        DllStructSetData($tdwords, 0x1, $ilodword)
        DllStructSetData($tdwords, 0x2, $ihidword)
        Return DllStructGetData($tint64, 0x1)
    EndFunc    ; -> __WinAPI_MakeQWord

#EndRegion Internal Functions
#Region Global Variables and Constants
    Global Const $TAGIO_COUNTERS = "struct;uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCo" & _
        "unt;endstruct"
    Global Const $TAGJOBOBJECT_ASSOCIATE_COMPLETION_PORT = "ulong_ptr CompletionKey;ptr CompletionPort"
    Global Const $TAGJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = "struct;int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dw" & _
        "ord ActiveProcesses;dword TotalTerminatedProcesses;endstruct"
    Global Const $TAGJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = $TAGJOBOBJECT_BASIC_ACCOUNTING_INFORMATION & ";" & $TAGIO_COUNTERS
    Global Const $TAGJOBOBJECT_BASIC_LIMIT_INFORMATION = "struct;int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProc" & _
        "essLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;endstruct"
    Global Const $TAGJOBOBJECT_BASIC_PROCESS_ID_LIST = "dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList"
    Global Const $TAGJOBOBJECT_BASIC_UI_RESTRICTIONS = "dword UIRestrictionsClass"
    Global Const $TAGJOBOBJECT_END_OF_JOB_TIME_INFORMATION = "dword EndOfJobTimeAction"
    Global Const $TAGJOBOBJECT_EXTENDED_LIMIT_INFORMATION = $TAGJOBOBJECT_BASIC_LIMIT_INFORMATION & ";" & $TAGIO_COUNTERS & ";ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed"
    Global Const $TAGJOBOBJECT_GROUP_INFORMATION = ''
    Global Const $TAGJOBOBJECT_SECURITY_LIMIT_INFORMATION = "dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids"
    Global Const $TAGMODULEINFO = "ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint"
    Global Const $TAGPROCESSENTRY32 = "dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[26" & _
        "0]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_AdjustTokenPrivileges($htoken, $aprivileges, $iattributes, ByRef $aadjust)
        $aadjust = 0x0
        If Not $aprivileges And IsNumber($aprivileges) Then Return 0x0
        Local $ttp1 = 0x0, $ttp2, $icount, $acall, $bdisable = False
        If $aprivileges = + -1 Then
            $ttp2 = DllStructCreate("dword")
            $acall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $htoken, "bool", 0x1, "ptr", 0x0, "dword", 0x0, "struct*", $ttp2, "dword*", 0x0)
            If @error Then Return SetError(@error, @extended, 0x0)
            Local $ilasterror = _WinAPI_GetLastError()
            Switch $ilasterror
            Case 0x7a
                $ttp2 = DllStructCreate("dword;dword[" & ($acall[0x6] / 0x4 + -1) & "]")
                If @error Then
                    ContinueCase
                EndIf
            Case Else
                Return SetError(0xa, $ilasterror, 0x0)
            EndSwitch
            $bdisable = True
        Else
            Local $aprev = 0x0
            If Not IsArray($aprivileges) Then
                Dim $aprev[0x1][0x2]
                $aprev[0x0][0x0] = $aprivileges
                $aprev[0x0][0x1] = $iattributes
            Else
                If Not UBound($aprivileges, $UBOUND_COLUMNS) Then
                    $icount = UBound($aprivileges)
                    Dim $aprev[$icount][0x2]
                    For $i = 0x0 To $icount + -1
                        $aprev[$i][0x0] = $aprivileges[$i]
                        $aprev[$i][0x1] = $iattributes
                    Next
                EndIf
            EndIf
            If IsArray($aprev) Then
                $aprivileges = $aprev
            EndIf
            Local $tagstruct = "dword;dword[" & (0x3 * UBound($aprivileges)) & "]"
            $ttp1 = DllStructCreate($tagstruct)
            $ttp2 = DllStructCreate($tagstruct)
            If @error Then Return SetError(@error + 0x14, 0x0, 0x0)
            DllStructSetData($ttp1, 0x1, UBound($aprivileges))
            For $i = 0x0 To UBound($aprivileges) + -1
                DllStructSetData($ttp1, 0x2, $aprivileges[$i][0x1], 0x3 * $i + 0x3)
                $acall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "ptr", 0x0, "wstr", $aprivileges[$i][0x0], "ptr", DllStructGetPtr($ttp1, 0x2) + 0xc * $i)
                If @error Or Not $acall[0x0] Then Return SetError(@error + 0x64, @extended, 0x0)
            Next
        EndIf
        $acall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $htoken, "bool", $bdisable, "struct*", $ttp1, "dword", DllStructGetSize($ttp2), "struct*", $ttp2, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xc8, @extended, 0x0)
        Local $iresult
        Switch _WinAPI_GetLastError()
        Case 0x514
            $iresult = 0x1
        Case Else
            $iresult = 0x0
        EndSwitch
        $icount = DllStructGetData($ttp2, 0x1)
        If $icount Then
            Local $tdata = DllStructCreate("wchar[128]")
            Dim $aprivileges[$icount][0x2]
            For $i = 0x0 To $icount + -1
                $acall = DllCall("advapi32.dll", "bool", "LookupPrivilegeNameW", "ptr", 0x0, "ptr", DllStructGetPtr($ttp2, 0x2) + 0xc * $i, "struct*", $tdata, "dword*", 0x80)
                If @error Or Not $acall[0x0] Then Return SetError(@error + 0x12c, @extended, 0x0)
                $aprivileges[$i][0x1] = DllStructGetData($ttp2, 0x2, 0x3 * $i + 0x3)
                $aprivileges[$i][0x0] = DllStructGetData($tdata, 0x1)
            Next
            $aadjust = $aprivileges
        EndIf
        Return SetExtended($iresult, 0x1)
    EndFunc    ; -> _WinAPI_AdjustTokenPrivileges

    Func _WinAPI_AssignProcessToJobObject($hjob, $hprocess)
        Local $acall = DllCall("kernel32.dll", "bool", "AssignProcessToJobObject", "handle", $hjob, "handle", $hprocess)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AssignProcessToJobObject

    Func _WinAPI_AttachConsole($ipid = + -1)
        Local $acall = DllCall("kernel32.dll", "bool", "AttachConsole", "dword", $ipid)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AttachConsole

    Func _WinAPI_AttachThreadInput($iattach, $iattachto, $battach)
        Local $acall = DllCall("user32.dll", "bool", "AttachThreadInput", "dword", $iattach, "dword", $iattachto, "bool", $battach)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AttachThreadInput

    Func _WinAPI_CreateEvent($tattributes = 0x0, $bmanualreset = True, $binitialstate = True, $sname = '')
        If $sname = '' Then $sname = Null
        Local $acall = DllCall("kernel32.dll", "handle", "CreateEventW", "struct*", $tattributes, "bool", $bmanualreset, "bool", $binitialstate, "wstr", $sname)
        If @error Then Return SetError(@error, @extended, 0x0)
        Local $ilasterror = _WinAPI_GetLastError()
        If $ilasterror Then Return SetExtended($ilasterror, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateEvent

    Func _WinAPI_CreateJobObject($sname = '', $tsecurity = 0x0)
        If Not StringStripWS($sname, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sname = Null
        Local $acall = DllCall("kernel32.dll", "handle", "CreateJobObjectW", "struct*", $tsecurity, "wstr", $sname)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateJobObject

    Func _WinAPI_CreateMutex($smutex, $binitial = True, $tsecurity = 0x0)
        Local $acall = DllCall("kernel32.dll", "handle", "CreateMutexW", "struct*", $tsecurity, "bool", $binitial, "wstr", $smutex)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateMutex

    Func _WinAPI_CreateProcess($sappname, $scommand, $tsecurity, $tthread, $binherit, $IFLAGS, $penviron, $sdir, $tstartupinfo, $tprocess)
        Local $tcommand = 0x0
        If $sappname = '' Then $sappname = Null
        If $scommand <> '' Then
            $tcommand = DllStructCreate("wchar Text[" & 0x104 + 0x1 & "]")
            DllStructSetData($tcommand, "Text", $scommand)
        EndIf
        If $sdir = '' Then $sdir = Null
        Local $acall = DllCall("kernel32.dll", "bool", "CreateProcessW", "wstr", $sappname, "struct*", $tcommand, "struct*", $tsecurity, "struct*", $tthread, "bool", $binherit, "dword", $IFLAGS, "struct*", $penviron, "wstr", $sdir, "struct*", $tstartupinfo, "struct*", $tprocess)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateProcess

    Func _WinAPI_CreateProcessWithToken($sapp, $scmd, $IFLAGS, $tstartupinfo, $tprocessinfo, $htoken, $ilogon = 0x0, $penvironment = 0x0, $sdir = '')
        If Not StringStripWS($sapp, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sapp = Null
        If Not StringStripWS($scmd, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $scmd = Null
        If Not StringStripWS($sdir, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sdir = Null
        Local $acall = DllCall("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $htoken, "dword", $ilogon, "wstr", $sapp, "wstr", $scmd, "dword", $IFLAGS, "struct*", $penvironment, "wstr", $sdir, "struct*", $tstartupinfo, "struct*", $tprocessinfo)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateProcessWithToken

    Func _WinAPI_CreateSemaphore($ssemaphore, $iinitial, $imaximum, $tsecurity = 0x0)
        Local $acall = DllCall("kernel32.dll", "handle", "CreateSemaphoreW", "struct*", $tsecurity, "long", $iinitial, "long", $imaximum, "wstr", $ssemaphore)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateSemaphore

    Func _WinAPI_DuplicateTokenEx($htoken, $iaccess, $ilevel, $itype = 0x1, $tsecurity = 0x0)
        Local $acall = DllCall("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $htoken, "dword", $iaccess, "struct*", $tsecurity, "int", $ilevel, "int", $itype, "handle*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x6]
    EndFunc    ; -> _WinAPI_DuplicateTokenEx

    Func _WinAPI_EmptyWorkingSet($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x500  : 0x1100), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "EmptyWorkingSet", "handle", $hprocess[0x0])
        If __CheckErrorCloseHandle($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_EmptyWorkingSet

    Func _WinAPI_EnumChildProcess($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hsnapshot = DllCall("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 0x2, "dword", 0x0)
        If @error Or ($hsnapshot[0x0] = Ptr(+ -1)) Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $tprocessentry32 = DllStructCreate($TAGPROCESSENTRY32)
        Local $aret[0x65][0x2] = [[0x0]]
        $hsnapshot = $hsnapshot[0x0]
        DllStructSetData($tprocessentry32, "Size", DllStructGetSize($tprocessentry32))
        Local $acall = DllCall("kernel32.dll", "bool", "Process32FirstW", "handle", $hsnapshot, "struct*", $tprocessentry32)
        Local $ierror = @error
        While (Not @error) And ($acall[0x0])
            If DllStructGetData($tprocessentry32, "ParentProcessID") = $ipid Then
                __Inc($aret)
                $aret[$aret[0x0][0x0]][0x0] = DllStructGetData($tprocessentry32, "ProcessID")
                $aret[$aret[0x0][0x0]][0x1] = DllStructGetData($tprocessentry32, "ExeFile")
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "Process32NextW", "handle", $hsnapshot, "struct*", $tprocessentry32)
            $ierror = @error
        WEnd
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hsnapshot)
        If Not $aret[0x0][0x0] Then Return SetError($ierror + 0x14, 0x0, 0x0)
        __Inc($aret, + -1)
        Return $aret
    EndFunc    ; -> _WinAPI_EnumChildProcess

    Func _WinAPI_EnumDeviceDrivers()
        Local $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "EnumDeviceDrivers", "ptr", 0x0, "dword", 0x0, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $isize
        If @AutoItX64 Then
            $isize = $acall[0x3] / 0x8
        Else
            $isize = $acall[0x3] / 0x4
        EndIf
        Local $tdata = DllStructCreate("ptr[" & $isize & "]")
        $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "EnumDeviceDrivers", "struct*", $tdata, "dword", DllStructGetSize($tdata), "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $aret[$isize + 0x1] = [$isize]
        For $i = 0x1 To $isize
            $aret[$i] = DllStructGetData($tdata, 0x1, $i)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_EnumDeviceDrivers

    Func _WinAPI_EnumProcessHandles($ipid = 0x0, $itype = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $aret[0x65][0x4] = [[0x0]]
        Local $tagsystem_handle_table_entry_info = "ulong ProcessId;byte ObjectTypeNumber;byte Flags;ushort Handle;ptr Object;ulong GrantedAccess"
        Local $thandle = DllStructCreate($tagsystem_handle_table_entry_info)
        Local $ientrysize = DllStructGetSize($thandle)
        Local $imaxentries = 0x3ffff
        Local $tshi = DllStructCreate("ulong_ptr NumberOfHandles;byte Data[" & ($imaxentries + 0x1) * $ientrysize & "]")
        Local $acall = DllCall("ntdll.dll", "long", "ZwQuerySystemInformation", "uint", 0x10, "struct*", $tshi, "ulong", DllStructGetSize($tshi), "ulong*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Local $pdata = DllStructGetPtr($tshi, "Data")
        Local $i, $inumberofhandles = DllStructGetData($tshi, "NumberOfHandles")
        For $i = 0x1 To $inumberofhandles
            If $i > $imaxentries Then ExitLoop
            $thandle = DllStructCreate($tagsystem_handle_table_entry_info, $pdata + ($i + -1) * $ientrysize)
            If (DllStructGetData($thandle, "ProcessId") = $ipid) And ((Not $itype) Or ($itype = DllStructGetData($thandle, "ObjectTypeNumber"))) Then
                __Inc($aret)
                $aret[$aret[0x0][0x0]][0x0] = Ptr(DllStructGetData($thandle, "Handle"))
                $aret[$aret[0x0][0x0]][0x1] = DllStructGetData($thandle, "ObjectTypeNumber")
                $aret[$aret[0x0][0x0]][0x2] = DllStructGetData($thandle, "Flags")
                $aret[$aret[0x0][0x0]][0x3] = DllStructGetData($thandle, "GrantedAccess")
            EndIf
        Next
        If Not $aret[0x0][0x0] Then Return SetError(0xb, 0x0, 0x0)
        __Inc($aret, + -1)
        If $i < $inumberofhandles Then Return SetExtended($inumberofhandles, $aret)
        Return $aret
    EndFunc    ; -> _WinAPI_EnumProcessHandles

    Func _WinAPI_EnumProcessModules($ipid = 0x0, $IFLAG = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x410  : 0x1010), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $icount, $acall, $ierror = 0x0
        Do
            If _WinAPI_GetVersion() >= 6 Then
                $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "EnumProcessModulesEx", "handle", $hprocess[0x0], "ptr", 0x0, "dword", 0x0, "dword*", 0x0, "dword", $IFLAG)
            Else
                $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "EnumProcessModules", "handle", $hprocess[0x0], "ptr", 0x0, "dword", 0x0, "dword*", 0x0)
            EndIf
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
            If @AutoItX64 Then
                $icount = $acall[0x4] / 0x8
            Else
                $icount = $acall[0x4] / 0x4
            EndIf
            Local $tptr = DllStructCreate("ptr[" & $icount & "]")
            If @error Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            If _WinAPI_GetVersion() >= 6 Then
                $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "EnumProcessModulesEx", "handle", $hprocess[0x0], "struct*", $tptr, "dword", DllStructGetSize($tptr), "dword*", 0x0, "dword", $IFLAG)
            Else
                $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "EnumProcessModules", "handle", $hprocess[0x0], "struct*", $tptr, "dword", DllStructGetSize($tptr), "dword*", 0x0)
            EndIf
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x28
                ExitLoop
            EndIf
            Local $aret[$icount + 0x1][0x2] = [[$icount]]
            For $i = 0x1 To $icount
                $aret[$i][0x0] = DllStructGetData($tptr, 0x1, $i)
                $aret[$i][0x1] = _WinAPI_GetModuleFileNameEx($hprocess[0x0], $aret[$i][0x0])
            Next
        Until 0x1
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $aret
    EndFunc    ; -> _WinAPI_EnumProcessModules

    Func _WinAPI_EnumProcessThreads($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hsnapshot = DllCall("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 0x4, "dword", 0x0)
        If @error Or Not $hsnapshot[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local Const $TAGTHREADENTRY32 = "dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags"
        Local $tthreadentry32 = DllStructCreate($TAGTHREADENTRY32)
        Local $aret[0x65] = [0x0]
        $hsnapshot = $hsnapshot[0x0]
        DllStructSetData($tthreadentry32, "Size", DllStructGetSize($tthreadentry32))
        Local $acall = DllCall("kernel32.dll", "bool", "Thread32First", "handle", $hsnapshot, "struct*", $tthreadentry32)
        While Not @error And $acall[0x0]
            If DllStructGetData($tthreadentry32, "OwnerProcessID") = $ipid Then
                __Inc($aret)
                $aret[$aret[0x0]] = DllStructGetData($tthreadentry32, "ThreadID")
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "Thread32Next", "handle", $hsnapshot, "struct*", $tthreadentry32)
        WEnd
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hsnapshot)
        If Not $aret[0x0] Then Return SetError(0x1, 0x0, 0x0)
        __Inc($aret, + -1)
        Return $aret
    EndFunc    ; -> _WinAPI_EnumProcessThreads

    Func _WinAPI_EnumProcessWindows($ipid = 0x0, $BVISIBLE = True)
        Local $athreads = _WinAPI_EnumProcessThreads($ipid)
        If @error Then Return SetError(@error, @extended, 0x0)
        Local $henumproc = DllCallbackRegister("__EnumWindowsProc", "bool", "hwnd;lparam")
        Dim $__g_venum[0x65][0x2] = [[0x0]]
        For $i = 0x1 To $athreads[0x0]
            DllCall("user32.dll", "bool", "EnumThreadWindows", "dword", $athreads[$i], "ptr", DllCallbackGetPtr($henumproc), "lparam", $BVISIBLE)
            If @error Then
                ExitLoop
            EndIf
        Next
        DllCallbackFree($henumproc)
        If Not $__g_venum[0x0][0x0] Then Return SetError(0xb, 0x0, 0x0)
        __Inc($__g_venum, + -1)
        Return $__g_venum
    EndFunc    ; -> _WinAPI_EnumProcessWindows

    Func _WinAPI_FatalAppExit($smessage)
        DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0x0, "wstr", $smessage)
        If @error Then Return SetError(@error, @extended)
    EndFunc    ; -> _WinAPI_FatalAppExit

    Func _WinAPI_GetCurrentProcessExplicitAppUserModelID()
        Local $acall = DllCall("shell32.dll", "long", "GetCurrentProcessExplicitAppUserModelID", "ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Local $sid = _WinAPI_GetString($acall[0x1])
        _WinAPI_CoTaskMemFree($acall[0x1])
        Return $sid
    EndFunc    ; -> _WinAPI_GetCurrentProcessExplicitAppUserModelID

    Func _WinAPI_GetCurrentProcessID()
        Local $acall = DllCall("kernel32.dll", "dword", "GetCurrentProcessId")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetCurrentProcessID

    Func _WinAPI_GetCurrentThread()
        Local $acall = DllCall("kernel32.dll", "handle", "GetCurrentThread")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetCurrentThread

    Func _WinAPI_GetCurrentThreadId()
        Local $acall = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetCurrentThreadId

    Func _WinAPI_GetDeviceDriverBaseName($pdriver)
        Local $acall = DllCall(@SystemDir & "\\psapi.dll", "dword", "GetDeviceDriverBaseNameW", "ptr", $pdriver, "wstr", '', "dword", 0x1000)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetDeviceDriverBaseName

    Func _WinAPI_GetDeviceDriverFileName($pdriver)
        Local $acall = DllCall(@SystemDir & "\\psapi.dll", "dword", "GetDeviceDriverFileNameW", "ptr", $pdriver, "wstr", '', "dword", 0x1000)
        If @error Then Return SetError(@error, @extended, '')
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetDeviceDriverFileName

    Func _WinAPI_GetExitCodeProcess($hprocess)
        Local $acall = DllCall("kernel32.dll", "bool", "GetExitCodeProcess", "handle", $hprocess, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetExitCodeProcess

    Func _WinAPI_GetGuiResources($IFLAG = 0x0, $hprocess = + -1)
        If $hprocess = + -1 Then $hprocess = _WinAPI_GetCurrentProcess()
        Local $acall = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hprocess, "dword", $IFLAG)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetGuiResources

    Func _WinAPI_GetModuleFileNameEx($hprocess, $hmodule = 0x0)
        Local $acall = DllCall(@SystemDir & "\\psapi.dll", "dword", "GetModuleFileNameExW", "handle", $hprocess, "handle", $hmodule, "wstr", '', "int", 0x1000)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_GetModuleFileNameEx

    Func _WinAPI_GetModuleInformation($hprocess, $hmodule = 0x0)
        Local $tmoduleinfo = DllStructCreate($TAGMODULEINFO)
        Local $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "GetModuleInformation", "handle", $hprocess, "handle", $hmodule, "struct*", $tmoduleinfo, "dword", DllStructGetSize($tmoduleinfo))
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $tmoduleinfo
    EndFunc    ; -> _WinAPI_GetModuleInformation

    Func _WinAPI_GetParentProcess($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hsnapshot = DllCall("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 0x2, "dword", 0x0)
        If @error Or Not $hsnapshot[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $tprocessentry32 = DllStructCreate($TAGPROCESSENTRY32)
        Local $iresult = 0x0
        $hsnapshot = $hsnapshot[0x0]
        DllStructSetData($tprocessentry32, "Size", DllStructGetSize($tprocessentry32))
        Local $acall = DllCall("kernel32.dll", "bool", "Process32FirstW", "handle", $hsnapshot, "struct*", $tprocessentry32)
        Local $ierror = @error
        While (Not @error) And ($acall[0x0])
            If DllStructGetData($tprocessentry32, "ProcessID") = $ipid Then
                $iresult = DllStructGetData($tprocessentry32, "ParentProcessID")
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "Process32NextW", "handle", $hsnapshot, "struct*", $tprocessentry32)
            $ierror = @error
        WEnd
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hsnapshot)
        If Not $iresult Then Return SetError($ierror, 0x0, 0x0)
        Return $iresult
    EndFunc    ; -> _WinAPI_GetParentProcess

    Func _WinAPI_GetPriorityClass($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x400  : 0x1000), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $ierror = 0x0
        Local $acall = DllCall("kernel32.dll", "dword", "GetPriorityClass", "handle", $hprocess[0x0])
        If @error Then $ierror = @error
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetPriorityClass

    Func _WinAPI_GetProcessAffinityMask($hprocess)
        Local $acall = DllCall("kernel32.dll", "bool", "GetProcessAffinityMask", "handle", $hprocess, "dword_ptr*", 0x0, "dword_ptr*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $amask[0x3]
        $amask[0x0] = True
        $amask[0x1] = $acall[0x2]
        $amask[0x2] = $acall[0x3]
        Return $amask
    EndFunc    ; -> _WinAPI_GetProcessAffinityMask

    Func _WinAPI_GetProcessCommandLine($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x410  : 0x1010), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, '')
        $hprocess = $hprocess[0x0]
        Local $tpbi = DllStructCreate("ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId")
        Local $tpeb = DllStructCreate("byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr " & _
            "SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogS" & _
            "ection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr Re" & _
            "adOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 Critic" & _
            "alSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;" & _
            "ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong O" & _
            "SMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffe" & _
            "r[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId")
        Local $tupp = DllStructCreate("ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;pt" & _
            "r ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort Max" & _
            "LengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthComm" & _
            "andLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLength" & _
            "Unknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5")
        Local $tcmd
        Local $acall, $ierror = 0x0
        Do
            $acall = DllCall("ntdll.dll", "long", "NtQueryInformationProcess", "handle", $hprocess, "ulong", 0x0, "struct*", $tpbi, "ulong", DllStructGetSize($tpbi), "ulong*", 0x0)
            If @error Or $acall[0x0] Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tpbi, "PebBaseAddress"), "struct*", $tpeb, "ulong_ptr", DllStructGetSize($tpeb), "ulong_ptr*", 0x0)
            If @error Or Not $acall[0x0] Or (Not $acall[0x5]) Then
                $ierror = @error + 0x28
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tpeb, "ProcessParameters"), "struct*", $tupp, "ulong_ptr", DllStructGetSize($tupp), "ulong_ptr*", 0x0)
            If @error Or Not $acall[0x0] Or (Not $acall[0x5]) Then
                $ierror = @error + 0x32
                ExitLoop
            EndIf
            $tcmd = DllStructCreate("byte[" & DllStructGetData($tupp, "MaxLengthCommandLine") & "]")
            If @error Then
                $ierror = @error + 0x3c
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tupp, "CommandLine"), "struct*", $tcmd, "ulong_ptr", DllStructGetSize($tcmd), "ulong_ptr*", 0x0)
            If @error Or Not $acall[0x0] Or (Not $acall[0x5]) Then
                $ierror = @error + 0x46
                ExitLoop
            EndIf
        Until 0x1
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess)
        If $ierror Then Return SetError($ierror, 0x0, '')
        Return StringStripWS(_WinAPI_PathGetArgs(_WinAPI_GetString(DllStructGetPtr($tcmd, 0x1))), $STR_STRIPLEADING + $STR_STRIPTRAILING)
    EndFunc    ; -> _WinAPI_GetProcessCommandLine

    Func _WinAPI_GetProcessFileName($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x410  : 0x1010), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, '')
        Local $spath = _WinAPI_GetModuleFileNameEx($hprocess[0x0])
        Local $ierror = @error
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
        If $ierror Then Return SetError(@error, 0x0, '')
        Return $spath
    EndFunc    ; -> _WinAPI_GetProcessFileName

    Func _WinAPI_GetProcessHandleCount($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x400  : 0x1000), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "GetProcessHandleCount", "handle", $hprocess[0x0], "dword*", 0x0)
        If __CheckErrorCloseHandle($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_GetProcessHandleCount

    Func _WinAPI_GetProcessID($hprocess)
        Local $acall = DllCall("kernel32.dll", "dword", "GetProcessId", "handle", $hprocess)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetProcessID

    Func _WinAPI_GetProcessIoCounters($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x400  : 0x1000), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $tio_counters = DllStructCreate("uint64[6]")
        Local $acall = DllCall("kernel32.dll", "bool", "GetProcessIoCounters", "handle", $hprocess[0x0], "struct*", $tio_counters)
        If __CheckErrorCloseHandle($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, 0x0)
        Local $aret[0x6]
        For $i = 0x0 To 0x5
            $aret[$i] = DllStructGetData($tio_counters, 0x1, $i + 0x1)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetProcessIoCounters

    Func _WinAPI_GetProcessMemoryInfo($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x410  : 0x1010), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $tpmc_ex = DllStructCreate("dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr")
        Local $acall = DllCall(@SystemDir & "\\psapi.dll", "bool", "GetProcessMemoryInfo", "handle", $hprocess[0x0], "struct*", $tpmc_ex, "int", DllStructGetSize($tpmc_ex))
        If __CheckErrorCloseHandle($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, 0x0)
        Local $aret[0xa]
        For $i = 0x0 To 0x9
            $aret[$i] = DllStructGetData($tpmc_ex, $i + 0x2)
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetProcessMemoryInfo

    Func _WinAPI_GetProcessName($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hsnapshot = DllCall("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 0x2, "dword", 0x0)
        If @error Or Not $hsnapshot[0x0] Then Return SetError(@error + 0x14, @extended, '')
        $hsnapshot = $hsnapshot[0x0]
        Local $tprocessentry32 = DllStructCreate($TAGPROCESSENTRY32)
        DllStructSetData($tprocessentry32, "Size", DllStructGetSize($tprocessentry32))
        Local $acall = DllCall("kernel32.dll", "bool", "Process32FirstW", "handle", $hsnapshot, "struct*", $tprocessentry32)
        Local $ierror = @error
        While (Not @error) And ($acall[0x0])
            If DllStructGetData($tprocessentry32, "ProcessID") = $ipid Then
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "Process32NextW", "handle", $hsnapshot, "struct*", $tprocessentry32)
            $ierror = @error
        WEnd
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hsnapshot)
        If $ierror Then Return SetError($ierror, 0x0, '')
        If Not $acall[0x0] Then SetError(0xa, 0x0, '')
        Return DllStructGetData($tprocessentry32, "ExeFile")
    EndFunc    ; -> _WinAPI_GetProcessName

    Func _WinAPI_GetProcessTimes($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x400  : 0x1000), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $tfiletime = DllStructCreate($TAGFILETIME)
        Local $acall = DllCall("kernel32.dll", "bool", "GetProcessTimes", "handle", $hprocess[0x0], "struct*", $tfiletime, "uint64*", 0x0, "uint64*", 0x0, "uint64*", 0x0)
        If __CheckErrorCloseHandle($acall, $hprocess[0x0]) Then Return SetError(@error, @extended, 0x0)
        Local $aret[0x3]
        $aret[0x0] = $tfiletime
        $aret[0x1] = $acall[0x4]
        $aret[0x2] = $acall[0x5]
        Return $aret
    EndFunc    ; -> _WinAPI_GetProcessTimes

    Func _WinAPI_GetProcessUser($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $tsid, $htoken, $acall
        Local $ierror = 0x0
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x400  : 0x1000), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Do
            $htoken = _WinAPI_OpenProcessToken(0x8, $hprocess[0x0])
            If Not $htoken Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
            $tsid = DllStructCreate("ptr;byte[1024]")
            $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "uint", 0x1, "struct*", $tsid, "dword", DllStructGetSize($tsid), "dword*", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            $acall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", "ptr", 0x0, "ptr", DllStructGetData($tsid, 0x1), "wstr", '', "dword*", 0x800, "wstr", '', "dword*", 0x800, "uint*", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x28
                ExitLoop
            EndIf
        Until 0x1
        If $htoken Then
            DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $htoken)
        EndIf
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Local $aret[0x2]
        $aret[0x0] = $acall[0x3]
        $aret[0x1] = $acall[0x5]
        Return $aret
    EndFunc    ; -> _WinAPI_GetProcessUser

    Func _WinAPI_GetProcessWorkingDirectory($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $acall, $ierror = 0x0
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x410  : 0x1010), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, '')
        $hprocess = $hprocess[0x0]
        Local $tpbi = DllStructCreate("ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId")
        Local $tpeb = DllStructCreate("byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr " & _
            "SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogS" & _
            "ection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr Re" & _
            "adOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 Critic" & _
            "alSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;" & _
            "ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong O" & _
            "SMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffe" & _
            "r[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId")
        Local $tupp = DllStructCreate("ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;pt" & _
            "r ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort Max" & _
            "LengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthComm" & _
            "andLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLength" & _
            "Unknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5")
        Local $tdir
        Do
            $acall = DllCall("ntdll.dll", "long", "NtQueryInformationProcess", "handle", $hprocess, "ulong", 0x0, "struct*", $tpbi, "ulong", DllStructGetSize($tpbi), "ulong*", 0x0)
            If @error Or ($acall[0x0]) Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tpbi, "PebBaseAddress"), "struct*", $tpeb, "ulong_ptr", DllStructGetSize($tpeb), "ulong_ptr*", 0x0)
            If @error Or (Not $acall[0x0]) Or (Not $acall[0x5]) Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tpeb, "ProcessParameters"), "struct*", $tupp, "ulong_ptr", DllStructGetSize($tupp), "ulong_ptr*", 0x0)
            If @error Or (Not $acall[0x0]) Or (Not $acall[0x5]) Then
                $ierror = @error + 0x28
                ExitLoop
            EndIf
            $tdir = DllStructCreate("byte[" & DllStructGetData($tupp, "MaxLengthCurrentDirectory") & "]")
            If @error Then
                $ierror = @error + 0x32
                ExitLoop
            EndIf
            $acall = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", DllStructGetData($tupp, "CurrentDirectory"), "struct*", $tdir, "ulong_ptr", DllStructGetSize($tdir), "ulong_ptr*", 0x0)
            If @error Or (Not $acall[0x0]) Or (Not $acall[0x5]) Then
                $ierror = @error + 0x3c
                ExitLoop
            EndIf
            $ierror = 0x0
        Until 0x1
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess)
        If $ierror Then Return SetError($ierror, 0x0, '')
        Return _WinAPI_PathRemoveBackslash(_WinAPI_GetString(DllStructGetPtr($tdir)))
    EndFunc    ; -> _WinAPI_GetProcessWorkingDirectory

    Func _WinAPI_GetThreadDesktop($ithreadid)
        Local $acall = DllCall("user32.dll", "handle", "GetThreadDesktop", "dword", $ithreadid)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetThreadDesktop

    Func _WinAPI_GetThreadErrorMode()
        Local $acall = DllCall("kernel32.dll", "dword", "GetThreadErrorMode")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetThreadErrorMode

    Func _WinAPI_GetWindowFileName($hwnd)
        Local $ipid = 0x0
        Local $acall = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hwnd)
        If $acall[0x0] Then
            $acall = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "dword*", 0x0)
            $ipid = $acall[0x2]
        EndIf
        If Not $ipid Then Return SetError(0x1, 0x0, '')
        Local $sresult = _WinAPI_GetProcessFileName($ipid)
        If @error Then Return SetError(@error, @extended, '')
        Return $sresult
    EndFunc    ; -> _WinAPI_GetWindowFileName

    Func _WinAPI_IsElevated()
        Local $ielev, $acall, $ierror = 0x0
        Local $htoken = _WinAPI_OpenProcessToken(0x8)
        If Not $htoken Then Return SetError(@error + 0xa, @extended, False)
        Do
            $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "uint", 0x14, "uint*", 0x0, "dword", 0x4, "dword*", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
            $ielev = $acall[0x3]
            $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "uint", 0x12, "uint*", 0x0, "dword", 0x4, "dword*", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x14
                ExitLoop
            EndIf
        Until 0x1
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $htoken)
        If $ierror Then Return SetError($ierror, 0x0, False)
        Return SetExtended($acall[0x0] + -1, $ielev)
    EndFunc    ; -> _WinAPI_IsElevated

    Func _WinAPI_IsProcessInJob($hprocess, $hjob = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "IsProcessInJob", "handle", $hprocess, "handle", $hjob, "bool*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, False)
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_IsProcessInJob

    Func _WinAPI_OpenJobObject($sname, $iaccess = $JOB_OBJECT_ALL_ACCESS, $binherit = False)
        Local $acall = DllCall("kernel32.dll", "handle", "OpenJobObjectW", "dword", $iaccess, "bool", $binherit, "wstr", $sname)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OpenJobObject

    Func _WinAPI_OpenMutex($smutex, $iaccess = $MUTEX_ALL_ACCESS, $binherit = False)
        Local $acall = DllCall("kernel32.dll", "handle", "OpenMutexW", "dword", $iaccess, "bool", $binherit, "wstr", $smutex)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OpenMutex

    Func _WinAPI_OpenProcess($iaccess, $binherit, $ipid, $bdebugpriv = False)
        Local $acall = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $binherit, "dword", $ipid)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return $acall[0x0]
        If Not $bdebugpriv Then Return SetError(0x64, 0x0, 0x0)
        Local $htoken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
        If @error Then Return SetError(@error + 0xa, @extended, 0x0)
        _Security__SetPrivilege($htoken, $SE_DEBUG_NAME, True)
        Local $ierror = @error
        Local $iextended = @extended
        Local $iret = 0x0
        If Not @error Then
            $acall = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $binherit, "dword", $ipid)
            $ierror = @error
            $iextended = @extended
            If $acall[0x0] Then $iret = $acall[0x0]
            _Security__SetPrivilege($htoken, $SE_DEBUG_NAME, False)
            If @error Then
                $ierror = @error + 0x14
                $iextended = @extended
            EndIf
        Else
            $ierror = @error + 0x1e
        EndIf
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $htoken)
        Return SetError($ierror, $iextended, $iret)
    EndFunc    ; -> _WinAPI_OpenProcess

    Func _WinAPI_OpenProcessToken($iaccess, $hprocess = 0x0)
        If Not $hprocess Then
            $hprocess = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
            $hprocess = $hprocess[0x0]
        EndIf
        Local $acall = DllCall("advapi32.dll", "bool", "OpenProcessToken", "handle", $hprocess, "dword", $iaccess, "handle*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_OpenProcessToken

    Func _WinAPI_OpenSemaphore($ssemaphore, $iaccess = 0x1f0003, $binherit = False)
        Local $acall = DllCall("kernel32.dll", "handle", "OpenSemaphoreW", "dword", $iaccess, "bool", $binherit, "wstr", $ssemaphore)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_OpenSemaphore

    Func _WinAPI_QueryInformationJobObject($hjob, $ijobobjectinfoclass, ByRef $tjobobjectinfo)
        Local $acall = DllCall("kernel32.dll", "bool", "QueryInformationJobObject", "handle", $hjob, "int", $ijobobjectinfoclass, "struct*", $tjobobjectinfo, "dword", DllStructGetSize($tjobobjectinfo), "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_QueryInformationJobObject

    Func _WinAPI_ReleaseMutex($hmutex)
        Local $acall = DllCall("kernel32.dll", "bool", "ReleaseMutex", "handle", $hmutex)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ReleaseMutex

    Func _WinAPI_ReleaseSemaphore($hsemaphore, $iincrease = 0x1)
        Local $acall = DllCall("kernel32.dll", "bool", "ReleaseSemaphore", "handle", $hsemaphore, "long", $iincrease, "long*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_ReleaseSemaphore

    Func _WinAPI_ResetEvent($hevent)
        Local $acall = DllCall("kernel32.dll", "bool", "ResetEvent", "handle", $hevent)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_ResetEvent

    Func _WinAPI_SetEvent($hevent)
        Local $acall = DllCall("kernel32.dll", "bool", "SetEvent", "handle", $hevent)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetEvent

    Func _WinAPI_SetInformationJobObject($hjob, $ijobobjectinfoclass, $tjobobjectinfo)
        Local $acall = DllCall("kernel32.dll", "bool", "SetInformationJobObject", "handle", $hjob, "int", $ijobobjectinfoclass, "struct*", $tjobobjectinfo, "dword", DllStructGetSize($tjobobjectinfo))
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetInformationJobObject

    Func _WinAPI_SetPriorityClass($ipriority, $ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x600  : 0x1200), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $ierror = 0x0
        Local $acall = DllCall("kernel32.dll", "bool", "SetPriorityClass", "handle", $hprocess[0x0], "dword", $ipriority)
        If @error Then $ierror = @error
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetPriorityClass

    Func _WinAPI_SetProcessAffinityMask($hprocess, $imask)
        Local $acall = DllCall("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $hprocess, "ulong_ptr", $imask)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetProcessAffinityMask

    Func _WinAPI_SetThreadDesktop($hdesktop)
        Local $acall = DllCall("user32.dll", "bool", "SetThreadDesktop", "handle", $hdesktop)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetThreadDesktop

    Func _WinAPI_SetThreadErrorMode($imode)
        Local $acall = DllCall("kernel32.dll", "bool", "SetThreadErrorMode", "dword", $imode, "dword*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, @extended, 0x0)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_SetThreadErrorMode

    Func _WinAPI_SetThreadExecutionState($IFLAGS)
        Local $acall = DllCall("kernel32.dll", "dword", "SetThreadExecutionState", "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetThreadExecutionState

    Func _WinAPI_TerminateJobObject($hjob, $iexitcode = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "TerminateJobObject", "handle", $hjob, "uint", $iexitcode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_TerminateJobObject

    Func _WinAPI_TerminateProcess($hprocess, $iexitcode = 0x0)
        Local $acall = DllCall("kernel32.dll", "bool", "TerminateProcess", "handle", $hprocess, "uint", $iexitcode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_TerminateProcess

    Func _WinAPI_UserHandleGrantAccess($hobject, $hjob, $bgrant)
        Local $acall = DllCall("kernel32.dll", "bool", "UserHandleGrantAccess", "handle", $hobject, "handle", $hjob, "bool", $bgrant)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_UserHandleGrantAccess

    Func _WinAPI_WaitForInputIdle($hprocess, $itimeout = + -1)
        Local $acall = DllCall("user32.dll", "dword", "WaitForInputIdle", "handle", $hprocess, "dword", $itimeout)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_WaitForInputIdle

    Func _WinAPI_WaitForMultipleObjects($icount, $pahandles, $bwaitall = False, $itimeout = + -1)
        Local $acall = DllCall("kernel32.dll", "INT", "WaitForMultipleObjects", "dword", $icount, "struct*", $pahandles, "bool", $bwaitall, "dword", $itimeout)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_WaitForMultipleObjects

    Func _WinAPI_WaitForSingleObject($hhandle, $itimeout = + -1)
        Local $acall = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hhandle, "dword", $itimeout)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_WaitForSingleObject

    Func _WinAPI_WriteConsole($hconsole, $stext)
        Local $acall = DllCall("kernel32.dll", "bool", "WriteConsoleW", "handle", $hconsole, "wstr", $stext, "dword", StringLen($stext), "dword*", 0x0, "ptr", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_WriteConsole

#EndRegion Public Functions
#Region Global Variables and Constants
    Global Const $TAGDTTOPTS = "dword Size;dword Flags;dword clrText;dword clrBorder;dword clrShadow;int TextShadowType;" & $TAGPOINT & ";int BorderSize;int FontPropId;int ColorPropId;int StateId;int ApplyOverlay;int GlowSize;ptr DrawTextCallback;lparam lParam"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_BeginBufferedPaint($hdc, $ttarget, ByRef $hnewdc, $iformat = 0x0, $IFLAGS = 0x0, $texclude = 0x0, $ialpha = + -1)
        Local Const $TAGBP_PAINTPARAMS = "dword cbSize;dword dwFlags;ptr prcExclude;ptr pBlendFunction"
        Local $tpp = DllStructCreate($TAGBP_PAINTPARAMS)
        $hnewdc = 0x0
        Local $tbf = 0x0
        If $ialpha <> + -1 Then
            $tbf = DllStructCreate($TAGBLENDFUNCTION)
            DllStructSetData($tbf, 0x1, 0x0)
            DllStructSetData($tbf, 0x2, 0x0)
            DllStructSetData($tbf, 0x3, $ialpha)
            DllStructSetData($tbf, 0x4, 0x1)
        EndIf
        DllStructSetData($tpp, 0x1, DllStructGetSize($tpp))
        DllStructSetData($tpp, 0x2, $IFLAGS)
        DllStructSetData($tpp, 0x3, DllStructGetPtr($texclude))
        DllStructSetData($tpp, 0x4, DllStructGetPtr($tbf))
        Local $acall = DllCall("uxtheme.dll", "handle", "BeginBufferedPaint", "handle", $hdc, "struct*", $ttarget, "dword", $iformat, "struct*", $tpp, "handle*", 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error, @extended, 0x0)
        $hnewdc = $acall[0x5]
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_BeginBufferedPaint

    Func _WinAPI_BufferedPaintClear($hbp, $trect = 0x0)
        Local $acall = DllCall("uxtheme.dll", "long", "BufferedPaintClear", "handle", $hbp, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_BufferedPaintClear

    Func _WinAPI_BufferedPaintInit()
        Local $acall = DllCall("uxtheme.dll", "long", "BufferedPaintInit")
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_BufferedPaintInit

    Func _WinAPI_BufferedPaintSetAlpha($hbp, $ialpha = 0xff, $trect = 0x0)
        Local $sresult = DllCall("uxtheme.dll", "long", "BufferedPaintSetAlpha", "handle", $hbp, "struct*", $trect, "byte", $ialpha)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_BufferedPaintSetAlpha

    Func _WinAPI_BufferedPaintUnInit()
        Local $sresult = DllCall("uxtheme.dll", "long", "BufferedPaintUnInit")
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_BufferedPaintUnInit

    Func _WinAPI_CloseThemeData($htheme)
        Local $sresult = DllCall("uxtheme.dll", "long", "CloseThemeData", "handle", $htheme)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_CloseThemeData

    Func _WinAPI_DrawThemeBackground($htheme, $ipartid, $istateid, $hdc, $trect, $tclip = 0x0)
        Local $sresult = DllCall("uxtheme.dll", "long", "DrawThemeBackground", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "struct*", $trect, "struct*", $tclip)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DrawThemeBackground

    Func _WinAPI_DrawThemeEdge($htheme, $ipartid, $istateid, $hdc, $trect, $iedge, $IFLAGS, $tarea = 0x0)
        Local $sresult = DllCall("uxtheme.dll", "long", "DrawThemeEdge", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "struct*", $trect, "uint", $iedge, "uint", $IFLAGS, "struct*", $tarea)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DrawThemeEdge

    Func _WinAPI_DrawThemeIcon($htheme, $ipartid, $istateid, $hdc, $trect, $hil, $iindex)
        Local $sresult = DllCall("uxtheme.dll", "long", "DrawThemeIcon", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "struct*", $trect, "handle", $hil, "int", $iindex)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DrawThemeIcon

    Func _WinAPI_DrawThemeParentBackground($hwnd, $hdc, $trect = 0x0)
        Local $sresult = DllCall("uxtheme.dll", "long", "DrawThemeParentBackground", "hwnd", $hwnd, "handle", $hdc, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DrawThemeParentBackground

    Func _WinAPI_DrawThemeText($htheme, $ipartid, $istateid, $hdc, $stext, $trect, $IFLAGS)
        Local $sresult = DllCall("uxtheme.dll", "long", "DrawThemeText", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "wstr", $stext, "int", + -1, "dword", $IFLAGS, "dword", 0x0, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DrawThemeText

    Func _WinAPI_DrawThemeTextEx($htheme, $ipartid, $istateid, $hdc, $stext, $trect, $IFLAGS, $tdttopts)
        Local $sresult = DllCall("uxtheme.dll", "long", "DrawThemeTextEx", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "wstr", $stext, "int", + -1, "dword", $IFLAGS, "struct*", $trect, "struct*", $tdttopts)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DrawThemeTextEx

    Func _WinAPI_EndBufferedPaint($hbp, $bupdate = True)
        Local $sresult = DllCall("uxtheme.dll", "long", "EndBufferedPaint", "handle", $hbp, "bool", $bupdate)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_EndBufferedPaint

    Func _WinAPI_GetBufferedPaintBits($hbp)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetBufferedPaintBits", "handle", $hbp, "ptr*", 0x0, "int*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return SetExtended($sresult[0x3], $sresult[0x2])
    EndFunc    ; -> _WinAPI_GetBufferedPaintBits

    Func _WinAPI_GetBufferedPaintDC($hbp)
        Local $sresult = DllCall("uxtheme.dll", "handle", "GetBufferedPaintDC", "handle", $hbp)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_GetBufferedPaintDC

    Func _WinAPI_GetBufferedPaintTargetDC($hbp)
        Local $sresult = DllCall("uxtheme.dll", "handle", "GetBufferedPaintTargetDC", "handle", $hbp)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_GetBufferedPaintTargetDC

    Func _WinAPI_GetBufferedPaintTargetRect($hbp)
        Local $trect = DllStructCreate($TAGRECT)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetBufferedPaintTargetRect", "handle", $hbp, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_GetBufferedPaintTargetRect

    Func _WinAPI_GetCurrentThemeName()
        Local $sresult = DllCall("uxtheme.dll", "long", "GetCurrentThemeName", "wstr", '', "int", 0x1000, "wstr", '', "int", 0x800, "wstr", '', "int", 0x800)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Local $aret[0x3]
        For $i = 0x0 To 0x2
            $aret[$i] = $sresult[$i * 0x2 + 0x1]
        Next
        Return $aret
    EndFunc    ; -> _WinAPI_GetCurrentThemeName

    Func _WinAPI_GetThemeAppProperties()
        Local $sresult = DllCall("uxtheme.dll", "dword", "GetThemeAppProperties")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_GetThemeAppProperties

    Func _WinAPI_GetThemeBackgroundContentRect($htheme, $ipartid, $istateid, $hdc, $trect)
        Local $tarea = DllStructCreate($TAGRECT)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeBackgroundContentRect", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "struct*", $trect, "struct*", $tarea)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $tarea
    EndFunc    ; -> _WinAPI_GetThemeBackgroundContentRect

    Func _WinAPI_GetThemeBackgroundExtent($htheme, $ipartid, $istateid, $hdc, $trect)
        Local $tarea = DllStructCreate($TAGRECT)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeBackgroundExtent", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "struct*", $trect, "struct*", $tarea)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $tarea
    EndFunc    ; -> _WinAPI_GetThemeBackgroundExtent

    Func _WinAPI_GetThemeBackgroundRegion($htheme, $ipartid, $istateid, $hdc, $trect)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeBackgroundRegion", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "struct*", $trect, "handle*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $sresult[0x6]
    EndFunc    ; -> _WinAPI_GetThemeBackgroundRegion

    Func _WinAPI_GetThemeBitmap($htheme, $ipartid, $istateid, $ipropid, $IFLAG = 0x1)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeBitmap", "handle", $htheme, "int", $ipartid, "int", $istateid, "int", $ipropid, "ulong", $IFLAG, "handle*", 0x0)
        If @error Then Return SetError(@error, @extended, + -1)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], + -1)
        Return $sresult[0x6]
    EndFunc    ; -> _WinAPI_GetThemeBitmap

    Func _WinAPI_GetThemeBool($htheme, $ipartid, $istateid, $ipropid)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeBool", "handle", $htheme, "int", $ipartid, "int", $istateid, "int", $ipropid, "bool*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $sresult[0x5]
    EndFunc    ; -> _WinAPI_GetThemeBool

    Func _WinAPI_GetThemeColor($htheme, $ipartid, $istateid, $ipropid)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeColor", "handle", $htheme, "int", $ipartid, "int", $istateid, "int", $ipropid, "dword*", 0x0)
        If @error Then Return SetError(@error, @extended, + -1)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], + -1)
        Return __rgb($sresult[0x5])
    EndFunc    ; -> _WinAPI_GetThemeColor

    Func _WinAPI_GetThemeDocumentationProperty($sfilepath, $sproperty)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeDocumentationProperty", "wstr", $sfilepath, "wstr", $sproperty, "wstr", '', "int", 0x1000)
        If @error Then Return SetError(@error, @extended, '')
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], '')
        Return $sresult[0x3]
    EndFunc    ; -> _WinAPI_GetThemeDocumentationProperty

    Func _WinAPI_GetThemeEnumValue($htheme, $ipartid, $istateid, $ipropid)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeEnumValue", "handle", $htheme, "int", $ipartid, "int", $istateid, "int", $ipropid, "int*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $sresult[0x5]
    EndFunc    ; -> _WinAPI_GetThemeEnumValue

    Func _WinAPI_GetThemeFilename($htheme, $ipartid, $istateid, $ipropid)
        Local $sresult = DllCall("uxtheme.dll", "uint", "GetThemeFilename", "handle", $htheme, "int", $ipartid, "int", $istateid, "int", $ipropid, "wstr", '', "int", 0x1000)
        If @error Then Return SetError(@error, @extended, '')
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], '')
        Return $sresult[0x5]
    EndFunc    ; -> _WinAPI_GetThemeFilename

    Func _WinAPI_GetThemeFont($htheme, $ipartid, $istateid, $ipropid, $hdc = 0x0)
        Local $tlogfont = DllStructCreate($TAGLOGFONT)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeFont", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "int", $ipropid, "struct*", $tlogfont)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $tlogfont
    EndFunc    ; -> _WinAPI_GetThemeFont

    Func _WinAPI_GetThemeInt($htheme, $ipartid, $istateid, $ipropid)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeInt", "handle", $htheme, "int", $ipartid, "int", $istateid, "int", $ipropid, "int*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $sresult[0x5]
    EndFunc    ; -> _WinAPI_GetThemeInt

    Func _WinAPI_GetThemeMargins($htheme, $ipartid, $istateid, $ipropid, $hdc, $trect)
        Local $tmargins = DllStructCreate($TAGMARGINS)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeMargins", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "int", $ipropid, "struct*", $trect, "struct*", $tmargins)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $tmargins
    EndFunc    ; -> _WinAPI_GetThemeMargins

    Func _WinAPI_GetThemeMetric($htheme, $ipartid, $istateid, $ipropid, $hdc = 0x0)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeMetric", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "int", $ipropid, "int*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $sresult[0x6]
    EndFunc    ; -> _WinAPI_GetThemeMetric

    Func _WinAPI_GetThemePartSize($htheme, $ipartid, $istateid, $hdc, $trect, $itype)
        Local $tsize = DllStructCreate($TAGSIZE)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemePartSize", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "struct*", $trect, "int", $itype, "struct*", $tsize)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $tsize
    EndFunc    ; -> _WinAPI_GetThemePartSize

    Func _WinAPI_GetThemePosition($htheme, $ipartid, $istateid, $ipropid)
        Local $tpoint = DllStructCreate($TAGPOINT)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemePosition", "handle", $htheme, "int", $ipartid, "int", $istateid, "int", $ipropid, "struct*", $tpoint)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $tpoint
    EndFunc    ; -> _WinAPI_GetThemePosition

    Func _WinAPI_GetThemePropertyOrigin($htheme, $ipartid, $istateid, $ipropid)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemePropertyOrigin", "handle", $htheme, "int", $ipartid, "int", $istateid, "int", $ipropid, "uint*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $sresult[0x5]
    EndFunc    ; -> _WinAPI_GetThemePropertyOrigin

    Func _WinAPI_GetThemeRect($htheme, $ipartid, $istateid, $ipropid)
        Local $trect = DllStructCreate($TAGRECT)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeRect", "handle", $htheme, "int", $ipartid, "int", $istateid, "int", $ipropid, "struct*", $trect)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $trect
    EndFunc    ; -> _WinAPI_GetThemeRect

    Func _WinAPI_GetThemeString($htheme, $ipartid, $istateid, $ipropid)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeString", "handle", $htheme, "int", $ipartid, "int", $istateid, "int", $ipropid, "wstr", '', "int", 0x1000)
        If @error Then Return SetError(@error, @extended, '')
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], '')
        Return $sresult[0x5]
    EndFunc    ; -> _WinAPI_GetThemeString

    Func _WinAPI_GetThemeSysBool($htheme, $iboolid)
        Local $sresult = DllCall("uxtheme.dll", "bool", "GetThemeSysBool", "handle", $htheme, "int", $iboolid)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_GetThemeSysBool

    Func _WinAPI_GetThemeSysColor($htheme, $icolorid)
        Local $sresult = DllCall("uxtheme.dll", "dword", "GetThemeSysColor", "handle", $htheme, "int", $icolorid)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_GetThemeSysColor

    Func _WinAPI_GetThemeSysColorBrush($htheme, $icolorid)
        Local $sresult = DllCall("uxtheme.dll", "handle", "GetThemeSysColorBrush", "handle", $htheme, "int", $icolorid)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_GetThemeSysColorBrush

    Func _WinAPI_GetThemeSysFont($htheme, $ifontid)
        Local $tlogfont = DllStructCreate($TAGLOGFONT)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeSysFont", "handle", $htheme, "int", $ifontid, "struct*", $tlogfont)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $tlogfont
    EndFunc    ; -> _WinAPI_GetThemeSysFont

    Func _WinAPI_GetThemeSysInt($htheme, $iintid)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeSysInt", "handle", $htheme, "int", $iintid, "int*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $sresult[0x3]
    EndFunc    ; -> _WinAPI_GetThemeSysInt

    Func _WinAPI_GetThemeSysSize($htheme, $isizeid)
        Local $sresult = DllCall("uxtheme.dll", "int", "GetThemeSysSize", "handle", $htheme, "int", $isizeid)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_GetThemeSysSize

    Func _WinAPI_GetThemeSysString($htheme, $istringid)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeSysString", "handle", $htheme, "int", $istringid, "wstr", '', "int", 0x1000)
        If @error Then Return SetError(@error, @extended, '')
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], '')
        Return $sresult[0x3]
    EndFunc    ; -> _WinAPI_GetThemeSysString

    Func _WinAPI_GetThemeTextExtent($htheme, $ipartid, $istateid, $hdc, $stext, $trect, $IFLAGS)
        Local $tarea = DllStructCreate($TAGRECT)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeTextExtent", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "wstr", $stext, "int", + -1, "dword", $IFLAGS, "struct*", $trect, "struct*", $tarea)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $tarea
    EndFunc    ; -> _WinAPI_GetThemeTextExtent

    Func _WinAPI_GetThemeTextMetrics($htheme, $ipartid, $istateid, $hdc = 0x0)
        Local $ttextmetric = DllStructCreate($TAGTEXTMETRIC)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeTextMetrics", "handle", $htheme, "handle", $hdc, "int", $ipartid, "int", $istateid, "struct*", $ttextmetric)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $ttextmetric
    EndFunc    ; -> _WinAPI_GetThemeTextMetrics

    Func _WinAPI_GetThemeTransitionDuration($htheme, $ipartid, $istateidfrom, $istateidto, $ipropid)
        Local $sresult = DllCall("uxtheme.dll", "long", "GetThemeTransitionDuration", "handle", $htheme, "int", $ipartid, "int", $istateidfrom, "int", $istateidto, "int", $ipropid, "dword*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return $sresult[0x6]
    EndFunc    ; -> _WinAPI_GetThemeTransitionDuration

    Func _WinAPI_GetWindowTheme($hwnd)
        Local $sresult = DllCall("uxtheme.dll", "handle", "GetWindowTheme", "hwnd", $hwnd)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_GetWindowTheme

    Func _WinAPI_IsThemeActive()
        Local $sresult = DllCall("uxtheme.dll", "bool", "IsThemeActive")
        If @error Then Return SetError(@error, @extended, False)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_IsThemeActive

    Func _WinAPI_IsThemeBackgroundPartiallyTransparent($htheme, $ipartid, $istateid)
        Local $sresult = DllCall("uxtheme.dll", "bool", "IsThemeBackgroundPartiallyTransparent", "handle", $htheme, "int", $ipartid, "int", $istateid)
        If @error Then Return SetError(@error, @extended, False)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_IsThemeBackgroundPartiallyTransparent

    Func _WinAPI_IsThemePartDefined($htheme, $ipartid)
        Local $sresult = DllCall("uxtheme.dll", "int", "IsThemePartDefined", "handle", $htheme, "int", $ipartid, "int", 0x0)
        If @error Then Return SetError(@error, @extended, False)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_IsThemePartDefined

    Func _WinAPI_OpenThemeData($hwnd, $sclass)
        Local $sresult = DllCall("uxtheme.dll", "handle", "OpenThemeData", "hwnd", $hwnd, "wstr", $sclass)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $sresult[0x0]
    EndFunc    ; -> _WinAPI_OpenThemeData

    Func _WinAPI_SetThemeAppProperties($IFLAGS)
        DllCall("uxtheme.dll", "none", "SetThemeAppProperties", "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_SetThemeAppProperties

    Func _WinAPI_SetWindowTheme($hwnd, $sname = Default, $slist = Default)
        If Not IsString($sname) Then $sname = Null
        If Not IsString($slist) Then $slist = Null
        Local $sresult = DllCall("uxtheme.dll", "long", "SetWindowTheme", "hwnd", $hwnd, "wstr", $sname, "wstr", $slist)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $sresult[0x0] Then Return SetError(0xa, $sresult[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_SetWindowTheme

#EndRegion Public Functions
#Region Global Variables and Constants
    Global $__g_hfrdlg = 0x0, $__g_hfrdll = 0x0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_DisplayStruct($tstruct, $sstruct = '', $STITLE = '', $iitem = 0x0, $isubitem = 0x0, $IFLAGS = 0x0, $btop = True, $hparent = 0x0)
        If Not StringStripWS($STITLE, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
            $STITLE = "Structure: ListView Display"
        EndIf
        $sstruct = StringRegExpReplace(StringStripWS($sstruct, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES), ";+\\Z", '')
        Local $pdata
        If IsDllStruct($tstruct) Then
            $pdata = DllStructGetPtr($tstruct)
            If Not $sstruct Then
                $sstruct = "byte[" & DllStructGetSize($tstruct) & "]"
                $IFLAGS = BitOR($IFLAGS, 0x40)
            EndIf
        Else
            $pdata = $tstruct
            If Not $sstruct Then Return SetError(0xa, 0x0, 0x0)
        EndIf
        Local $tdata = DllStructCreate($sstruct, $pdata)
        Local $idata = DllStructGetSize($tdata)
        If (Not BitAND($IFLAGS, 0x200)) And (_WinAPI_IsBadReadPtr($pdata, $idata)) Then
            If Not BitAND($IFLAGS, 0x100) Then
                MsgBox($MB_SYSTEMMODAL, $STITLE, "The memory range allocated to a given structure could not be read." & @CRLF & @CRLF & Ptr($pdata) & " - " & Ptr($pdata + $idata + -1) & @CRLF & @CRLF & "Press OK to exit.")
                Exit + -1073741819
            EndIf
            Return SetError(0xf, 0x0, 0x0)
        EndIf
        Local $sopt1 = Opt("GUIDataSeparatorChar", "|")
        Local $iopt2 = Opt("GUIOnEventMode", 0x0)
        Local $iopt3 = Opt("GUICloseOnESC", 0x1)
        If $hparent Then
            GUISetState(@SW_DISABLE, $hparent)
        EndIf
        Local $istyle = 0x1
        If $btop Then
            $istyle = BitOR($istyle, 0x8)
        EndIf
        $__g_hfrdlg = GUICreate($STITLE, 0x23a, 0x26c, + -1, + -1, -2134441984, $istyle, $hparent)
        Local $idlv = GUICtrlCreateListView("#|Member|Offset|Type|Size|Value", 0x0, 0x0, 0x23a, 0x26c, 0x800d, ((_WinAPI_GetVersion() < 6) ? 0x10031  : 0x10030))
        Local $hlv = GUICtrlGetHandle($idlv)
        If _WinAPI_GetVersion() >= 6 Then
            _WinAPI_SetWindowTheme($hlv, "Explorer")
        EndIf
        GUICtrlSetResizing(+ -1, 0x66)
        GUICtrlSetFont(+ -1, 8.5, 0x190, 0x0, "Tahoma")
        GUICtrlSetState(+ -1, 0x100)
        Local $aval[0x65] = [0x0]
        If Not BitAND($IFLAGS, 0x1) Then
            __Inc($aval)
            $aval[$aval[0x0]] = ''
            GUICtrlCreateListViewItem("-|-|" & $pdata & "|<struct>|0|-", $idlv)
            GUICtrlSetColor(+ -1, 0x9c9c9c)
        EndIf
        Local $ADATA = StringSplit($sstruct, ";")
        Local $aitem, $vitem, $sitem, $imode, $iindex, $icount = 0x0, $iprev = 0x0
        Local $asel[0x2] = [0x0, 0x0]
        Local $atype[0x1c][0x2] = [["BYTE", 0x1], ["BOOLEAN", 0x1], ["CHAR", 0x1], ["WCHAR", 0x2], ["short", 0x2], ["USHORT", 0x2], ["WORD", 0x2], ["int", 0x4], ["long", 0x4], ["BOOL", 0x4], ["UINT", 0x4], ["ULONG", 0x4], ["DWORD", 0x4], ["INT64", 0x8], ["UINT64", 0x8], ["ptr", (@AutoItX64  ? 0x8  : 0x4)], ["HWND", (@AutoItX64  ? 0x8  : 0x4)], ["HANDLE", (@AutoItX64  ? 0x8  : 0x4)], ["float", 0x4], ["double", 0x8], ["INT_PTR", (@AutoItX64  ? 0x8  : 0x4)], ["LONG_PTR", (@AutoItX64  ? 0x8  : 0x4)], ["LRESULT", (@AutoItX64  ? 0x8  : 0x4)], ["LPARAM", (@AutoItX64  ? 0x8  : 0x4)], ["UINT_PTR", (@AutoItX64  ? 0x8  : 0x4)], ["ULONG_PTR", (@AutoItX64  ? 0x8  : 0x4)], ["DWORD_PTR", (@AutoItX64  ? 0x8  : 0x4)], ["WPARAM", (@AutoItX64  ? 0x8  : 0x4)]]
        For $i = 0x1 To $ADATA[0x0]
            $aitem = StringSplit(StringStripWS($ADATA[$i], $STR_STRIPLEADING + $STR_STRIPTRAILING), " ")
            Switch $aitem[0x1]
            Case "ALIGN", "STRUCT", "ENDSTRUCT"
                ContinueLoop
            Case Else
            EndSwitch
            $icount += 0x1
            $imode = 0x1
            $sitem = $icount & "|"
            If $aitem[0x0] > 0x1 Then
                $vitem = StringRegExpReplace($aitem[0x2], "\\[.*\\Z", '')
                $sitem &= $vitem & "|"
                If (Not BitAND($IFLAGS, 0x10)) And (Not StringCompare(StringRegExpReplace($vitem, "[0-9]+\\Z", ''), "RESERVED")) Then
                    $imode = 0x0
                EndIf
                If Not IsString($iitem) Then
                    $vitem = $icount
                EndIf
                $iindex = 0x2
            Else
                If Not BitAND($IFLAGS, 0x4) Then
                    $sitem &= "<unnamed>|"
                Else
                    $sitem &= "|"
                EndIf
                If Not IsString($iitem) Then
                    $vitem = $icount
                Else
                    $vitem = 0x0
                EndIf
                $iindex = 0x1
            EndIf
            If (Not $asel[0x0]) And ($vitem) And ($iitem) And ($vitem = $iitem) Then
                $asel[0x0] = $icount
            EndIf
            Local $ioffset = Number(DllStructGetPtr($tdata, $icount) - $pdata)
            $iindex = StringRegExp($aitem[$iindex], "\\[(\\d+)\\]", $STR_REGEXPARRAYGLOBALMATCH)
            Local $isize
            Do
                ReDim $aitem[0x3]
                $vitem = StringRegExpReplace($aitem[0x1], "\\[.*\\Z", '')
                For $j = 0x0 To UBound($atype) + -1
                    If Not StringCompare($atype[$j][0x0], $vitem) Then
                        $aitem[0x1] = $atype[$j][0x0]
                        $aitem[0x2] = $atype[$j][0x1]
                        $isize = $aitem[0x2]
                        ExitLoop 0x2
                    EndIf
                Next
                $aitem[0x1] = "?"
                $aitem[0x2] = "?"
                $isize = 0x0
            Until 0x1
            $sitem &= $ioffset & "|"
            If (IsArray($iindex)) And ($iindex[0x0] > "1") Then
                If $isize Then
                    $aitem[0x2] = $aitem[0x2] * $iindex[0x0]
                EndIf
                Do
                    Switch $aitem[0x1]
                    Case "BYTE", "BOOLEAN"
                        If Not BitAND($IFLAGS, 0x40) Then
                            ContinueCase
                        EndIf
                    Case "CHAR", "WCHAR"
                        $sitem &= $aitem[0x1] & "[" & $iindex[0x0] & "]|" & $aitem[0x2] & "|"
                        $iindex = 0x0
                        ExitLoop
                    Case Else
                    EndSwitch
                    If ($isize) And ($imode) Then
                        $sitem &= $aitem[0x1] & "[" & $iindex[0x0] & "]|" & $aitem[0x2] & " (" & $isize & ")" & "|"
                    Else
                        $sitem &= $aitem[0x1] & "[" & $iindex[0x0] & "]|" & $aitem[0x2] & "|"
                    EndIf
                    If $imode Then
                        $iindex = $iindex[0x0]
                    Else
                        $iindex = 0x0
                    EndIf
                Until 0x1
            Else
                $sitem &= $aitem[0x1] & "|" & $aitem[0x2] & "|"
                $iindex = 0x0
            EndIf
            If (Not BitAND($IFLAGS, 0x2)) And ($iprev) And ($ioffset > $iprev) Then
                __Inc($aval)
                $aval[$aval[0x0]] = ''
                GUICtrlCreateListViewItem("-|-|-|<alignment>|" & ($ioffset - $iprev) & "|-", $idlv)
                GUICtrlSetColor(+ -1, 0xff0000)
            EndIf
            If $isize Then
                $iprev = $ioffset + $aitem[0x2]
            Else
                $iprev = 0x0
            EndIf
            Local $idlvitem, $idinit
            If $iindex Then
                Local $SPATTERN = "[%0" & StringLen($iindex) & "d] "
                For $j = 0x1 To $iindex
                    __Inc($aval)
                    $aval[$aval[0x0]] = DllStructGetData($tdata, $icount, $j)
                    If BitAND($IFLAGS, 0x80) Then
                        $aval[$aval[0x0]] = __WinAPIDiag_Hex($aval[$aval[0x0]], $aitem[0x1])
                    EndIf
                    $idlvitem = GUICtrlCreateListViewItem($sitem & StringFormat($SPATTERN, $j) & $aval[$aval[0x0]], $idlv)
                    If ($asel[0x0] = $icount) And (Not $asel[0x1]) Then
                        If ($isubitem < 0x1) Or ($isubitem > $iindex) Or ($isubitem = $j) Then
                            $asel[0x1] = $idlvitem
                        EndIf
                    EndIf
                    If (Not $idinit) And ($icount = 0x1) Then
                        $idinit = $idlvitem
                    EndIf
                    If Not BitAND($IFLAGS, 0x8) Then
                        GUICtrlSetBkColor(+ -1, 0xf5f5f5)
                    EndIf
                    If $isize Then
                        $sitem = "-|-|" & ($ioffset + $j * $isize) & "|-|-|"
                    Else
                        GUICtrlSetColor(+ -1, 0xff8800)
                        $sitem = "-|-|-|-|-|"
                    EndIf
                Next
            Else
                __Inc($aval)
                If $imode Then
                    $aval[$aval[0x0]] = DllStructGetData($tdata, $icount)
                    If BitAND($IFLAGS, 0x80) Then
                        $aval[$aval[0x0]] = __WinAPIDiag_Hex($aval[$aval[0x0]], $aitem[0x1])
                    EndIf
                    $idlvitem = GUICtrlCreateListViewItem($sitem & $aval[$aval[0x0]], $idlv)
                Else
                    $aval[$aval[0x0]] = ''
                    $idlvitem = GUICtrlCreateListViewItem($sitem & "-", $idlv)
                EndIf
                If ($asel[0x0] = $icount) And (Not $asel[0x1]) Then
                    $asel[0x1] = $idlvitem
                EndIf
                If (Not $idinit) And ($icount = 0x1) Then
                    $idinit = $idlvitem
                EndIf
                If Not $isize Then
                    GUICtrlSetColor(+ -1, 0xff8800)
                EndIf
            EndIf
            If (Not BitAND($IFLAGS, 0x2)) And (Not $isize) Then
                __Inc($aval)
                $aval[$aval[0x0]] = ''
                GUICtrlCreateListViewItem("-|-|-|<alignment>|?|-", $idlv)
                GUICtrlSetColor(+ -1, 0xff8800)
            EndIf
        Next
        If (Not BitAND($IFLAGS, 0x2)) And ($iprev) And ($idata > $iprev) Then
            __Inc($aval)
            $aval[$aval[0x0]] = ''
            GUICtrlCreateListViewItem("-|-|-|<alignment>|" & ($idata - $iprev) & "|-", $idlv)
            GUICtrlSetColor(+ -1, 0xff0000)
        EndIf
        If Not BitAND($IFLAGS, 0x1) Then
            __Inc($aval)
            $aval[$aval[0x0]] = ''
            GUICtrlCreateListViewItem("-|-|" & ($pdata + $idata + 0x0) & "|<endstruct>|" & $idata & "|-", $idlv)
            GUICtrlSetColor(+ -1, 0x9c9c9c)
        EndIf
        If $asel[0x1] Then
            GUICtrlSetState($asel[0x1], 0x100)
        Else
            GUICtrlSetState($idinit, 0x100)
        EndIf
        Local $iddummy = GUICtrlCreateDummy()
        Local $awidth[0x6] = [0x1e, 0x82, 0x4c, 0x64, 0x32, 0xa7]
        For $i = 0x0 To UBound($awidth) + -1
            GUICtrlSendMsg($idlv, 0x101e, $i, $awidth[$i])
        Next
        Local $tparam = DllStructCreate("ptr;uint")
        DllStructSetData($tparam, 0x1, $hlv)
        If Not BitAND($IFLAGS, 0x20) Then
            DllStructSetData($tparam, 0x2, $iddummy)
        Else
            DllStructSetData($tparam, 0x2, 0x0)
        EndIf
        $__g_hfrdll = DllCallbackRegister("__DlgSubclassProc", "lresult", "hwnd;uint;wparam;lparam;uint;ptr")
        Local $pdll = DllCallbackGetPtr($__g_hfrdll)
        If _WinAPI_SetWindowSubclass($__g_hfrdlg, $pdll, 0x3e8, DllStructGetPtr($tparam)) Then
            OnAutoItExitRegister("__WinAPIDiag_Quit")
        Else
            DllCallbackFree($__g_hfrdll)
            $__g_hfrdll = 0x0
        EndIf
        GUISetState()
        While 0x1
            Switch GUIGetMsg()
            Case 0x0
                ContinueLoop
            Case + -3
                ExitLoop
            Case $iddummy
                $iindex = GUICtrlRead($iddummy)
                If ($iindex >= 0x0) And ($iindex < $aval[0x0]) Then
                    ClipPut($aval[$iindex + 0x1])
                EndIf
            EndSwitch
        WEnd
        If $__g_hfrdll Then
            OnAutoItExitUnRegister("__WinAPIDiag_Quit")
        EndIf
        __WinAPIDiag_Quit()
        If $hparent Then
            GUISetState(@SW_ENABLE, $hparent)
        EndIf
        GUIDelete($__g_hfrdlg)
        Opt("GUIDataSeparatorChar", $sopt1)
        Opt("GUIOnEventMode", $iopt2)
        Opt("GUICloseOnESC", $iopt3)
        Return 0x1
    EndFunc    ; -> _WinAPI_DisplayStruct

    Func _WinAPI_EnumDllProc($sfilepath, $smask = '', $IFLAGS = 0x0)
        If Not __dll("dbghelp.dll") Then Return SetError(0x67, 0x0, 0x0)
        Local $vver = __WinAPIDiag_Ver("dbghelp.dll")
        If $vver < 0x501 Then Return SetError(0x2, 0x0, 0x0)
        $__g_venum = 0x0
        Local $ipe, $acall, $ierror = 0x0, $hlibrary = 0x0, $vwow64 = Default
        If _WinAPI_IsWow64Process() Then
            $acall = DllCall("kernel32.dll", "bool", "Wow64DisableWow64FsRedirection", "ptr*", 0x0)
            If Not @error And $acall[0x0] Then $vwow64 = $acall[0x1]
        EndIf
        Do
            $acall = DllCall("kernel32.dll", "dword", "SearchPathW", "ptr", 0x0, "wstr", $sfilepath, "ptr", 0x0, "dword", 0x1000, "wstr", '', "ptr", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
            $__g_vext = $acall[0x5]
            $ipe = _WinAPI_GetPEType($__g_vext)
            Switch $ipe
            Case 0x14c
            Case 0x200, 0x8664
            Case Else
                $ierror = @error + 0x14
                ExitLoop
            EndSwitch
            $hlibrary = _WinAPI_LoadLibraryEx($__g_vext, BitOR($DONT_RESOLVE_DLL_REFERENCES, $LOAD_LIBRARY_AS_DATAFILE))
            If Not $hlibrary Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            If $vver >= 0x600 Then
                __EnumDllProcW($hlibrary, $smask, $IFLAGS)
            Else
                __EnumDllProcA($hlibrary, $smask, $IFLAGS)
            EndIf
            If @error Then
                $ierror = @error + 0x28
                ExitLoop
            EndIf
        Until 0x1
        If $hlibrary Then
            _WinAPI_FreeLibrary($hlibrary)
        EndIf
        If Not ($vwow64 = Default) Then
            DllCall("kernel32.dll", "bool", "Wow64RevertWow64FsRedirection", "ptr*", $vwow64)
        EndIf
        Return SetError($ierror, $ipe, $__g_venum)
    EndFunc    ; -> _WinAPI_EnumDllProc

    Func _WinAPI_GetApplicationRestartSettings($ipid = 0x0)
        If Not $ipid Then $ipid = @AutoItPID
        Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", ((_WinAPI_GetVersion() < 6) ? 0x410  : 0x1010), "bool", 0x0, "dword", $ipid)
        If @error Or Not $hprocess[0x0] Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $acall = DllCall("kernel32.dll", "uint", "GetApplicationRestartSettings", "handle", $hprocess[0x0], "wstr", '', "dword*", 0x1000, "dword*", 0x0)
        Local $ierror, $iextended = @extended
        If @error Then
            $ierror = @error
        ElseIf $acall[0x0] Then
            $ierror = 0xa
            $iextended = $acall[0x0]
        EndIf
        DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess[0x0])
        If $ierror Then Return SetError($ierror, $iextended, 0x0)
        Local $aret[0x2]
        $aret[0x0] = $acall[0x2]
        $aret[0x1] = $acall[0x4]
        Return $aret
    EndFunc    ; -> _WinAPI_GetApplicationRestartSettings

    Func _WinAPI_GetErrorMode()
        Local $acall = DllCall("kernel32.dll", "uint", "GetErrorMode")
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_GetErrorMode

    Func _WinAPI_FatalExit($icode)
        DllCall("kernel32.dll", "none", "FatalExit", "int", $icode)
        If @error Then Return SetError(@error, @extended)
    EndFunc    ; -> _WinAPI_FatalExit

    Func _WinAPI_IsInternetConnected()
        If Not __dll("connect.dll") Then Return SetError(0x67, 0x0, 0x0)
        Local $acall = DllCall("connect.dll", "long", "IsInternetConnected")
        If @error Then Return SetError(@error, @extended, 0x0)
        If Not ($acall[0x0] = 0x0 Or $acall[0x0] = 0x1) Then
            Return SetError(0xa, $acall[0x0], False)
        EndIf
        Return Not $acall[0x0]
    EndFunc    ; -> _WinAPI_IsInternetConnected

    Func _WinAPI_IsNetworkAlive()
        If Not __dll("sensapi.dll") Then Return SetError(0x67, 0x0, 0x0)
        Local $acall = DllCall("sensapi.dll", "bool", "IsNetworkAlive", "int*", 0x0)
        Local $ilasterror = _WinAPI_GetLastError()
        If $ilasterror Then Return SetError(0x1, $ilasterror, 0x0)
        If @error Or Not $acall[0x0] Then Return SetError(@error + 0xa, $ilasterror, 0x0)
        Return $acall[0x1]
    EndFunc    ; -> _WinAPI_IsNetworkAlive

    Func _WinAPI_NtStatusToDosError($istatus)
        Local $acall = DllCall("ntdll.dll", "ulong", "RtlNtStatusToDosError", "long", $istatus)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_NtStatusToDosError

    Func _WinAPI_RegisterApplicationRestart($IFLAGS = 0x0, $scmd = '')
        Local $acall = DllCall("kernel32.dll", "long", "RegisterApplicationRestart", "wstr", $scmd, "dword", $IFLAGS)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegisterApplicationRestart

    Func _WinAPI_SetErrorMode($imode)
        Local $acall = DllCall("kernel32.dll", "uint", "SetErrorMode", "uint", $imode)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SetErrorMode

    Func _WinAPI_UniqueHardwareID($IFLAGS = 0x0)
        Local $oservice = ObjGet("winmgmts:\\\\.\\root\\cimv2")
        If Not IsObj($oservice) Then Return SetError(0x1, 0x0, '')
        Local $oitems = $oservice.ExecQuery("SELECT * FROM Win32_ComputerSystemProduct")
        If Not IsObj($oitems) Then Return SetError(0x2, 0x0, '')
        Local $shw = '', $iextended = 0x0
        For $oproperty In $oitems
            $shw &= $oproperty.IdentifyingNumber
            $shw &= $oproperty.Name
            $shw &= $oproperty.SKUNumber
            $shw &= $oproperty.UUID
            $shw &= $oproperty.Vendor
            $shw &= $oproperty.Version
        Next
        $shw = StringStripWS($shw, $STR_STRIPALL)
        If Not $shw Then Return SetError(0x3, 0x0, '')
        Local $stext
        If BitAND($IFLAGS, 0x1) Then
            $oitems = $oservice.ExecQuery("SELECT * FROM Win32_BIOS")
            If Not IsObj($oitems) Then Return SetError(0x3, 0x0, '')
            $stext = ''
            For $oproperty In $oitems
                $stext &= $oproperty.IdentificationCode
                $stext &= $oproperty.Manufacturer
                $stext &= $oproperty.Name
                $stext &= $oproperty.SerialNumber
                $stext &= $oproperty.SMBIOSMajorVersion
                $stext &= $oproperty.SMBIOSMinorVersion
            Next
            $stext = StringStripWS($stext, $STR_STRIPALL)
            If $stext Then
                $iextended += 0x1
                $shw &= $stext
            EndIf
        EndIf
        If BitAND($IFLAGS, 0x2) Then
            $oitems = $oservice.ExecQuery("SELECT * FROM Win32_Processor")
            If Not IsObj($oitems) Then Return SetError(0x4, 0x0, '')
            $stext = ''
            For $oproperty In $oitems
                $stext &= $oproperty.Architecture
                $stext &= $oproperty.Family
                $stext &= $oproperty.Level
                $stext &= $oproperty.Manufacturer
                $stext &= $oproperty.Name
                $stext &= $oproperty.ProcessorId
                $stext &= $oproperty.Revision
                $stext &= $oproperty.Version
            Next
            $stext = StringStripWS($stext, $STR_STRIPALL)
            If $stext Then
                $iextended += 0x2
                $shw &= $stext
            EndIf
        EndIf
        If BitAND($IFLAGS, 0x4) Then
            $oitems = $oservice.ExecQuery("SELECT * FROM Win32_PhysicalMedia")
            If Not IsObj($oitems) Then Return SetError(0x5, 0x0, '')
            $stext = ''
            For $oproperty In $oitems
                Switch _WinAPI_GetDriveBusType($oproperty.Tag)
                Case 0x3, 0xb
                    $stext &= $oproperty.SerialNumber
                Case Else
                EndSwitch
            Next
            $stext = StringStripWS($stext, $STR_STRIPALL)
            If $stext Then
                $iextended += 0x4
                $shw &= $stext
            EndIf
        EndIf
        Local $shash = __WinAPIDiag_MD5($shw)
        If Not $shash Then Return SetError(0x6, 0x0, '')
        Return SetExtended($iextended, "{" & StringMid($shash, 0x1, 0x8) & "-" & StringMid($shash, 0x9, 0x4) & "-" & StringMid($shash, 0xd, 0x4) & "-" & StringMid($shash, 0x11, 0x4) & "-" & StringMid($shash, 0x15, 0xc) & "}")
    EndFunc    ; -> _WinAPI_UniqueHardwareID

    Func _WinAPI_UnregisterApplicationRestart()
        Local $acall = DllCall("kernel32.dll", "long", "UnregisterApplicationRestart")
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_UnregisterApplicationRestart

#EndRegion Public Functions
#Region Internal Functions
    Func __DlgSubclassProc($shwnd, $imsg, $wparam, $lparam, $idlv, $pdata)
        #forceref $idLV
        Switch $imsg
        Case 0x4e
            Local $tnmia = DllStructCreate("hwnd;uint_ptr;" & (@AutoItX64  ? "int;int"  : "int") & ";int Item;int;uint;uint;uint;long;long;lparam;uint", $lparam)
            Local $hlistview = DllStructGetData($tnmia, 0x1)
            Local $nmsg = DllStructGetData($tnmia, 0x3)
            Local $tparam = DllStructCreate("ptr;uint", $pdata)
            Local $idummy = DllStructGetData($tparam, 0x2)
            Local $hlv = DllStructGetData($tparam, 0x1)
            Switch $hlistview
            Case $hlv
                Switch $nmsg
                Case + -109
                    Return 0x0
                Case + -114
                    If $idummy Then
                        GUICtrlSendToDummy($idummy, DllStructGetData($tnmia, "Item"))
                    EndIf
                    Return 0x0
                EndSwitch
            EndSwitch
        EndSwitch
        Return _WinAPI_DefSubclassProc($shwnd, $imsg, $wparam, $lparam)
    EndFunc    ; -> __DlgSubclassProc

    Func __EnumDllProcA($hlibrary, $smask, $IFLAGS)
        Local $hprocess, $paddress = 0x0, $iinit = 0x0, $vopts = Default, $ierror = 0x0
        $__g_venum = 0x0
        Do
            Local $acall = DllCall("dbghelp.dll", "dword", "SymGetOptions")
            If @error Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
            $vopts = $acall[0x0]
            $acall = DllCall("dbghelp.dll", "dword", "SymSetOptions", "dword", BitOR(BitAND($IFLAGS, 0x3), 0x204))
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x14
                ExitLoop
            EndIf
            $hprocess = _WinAPI_GetCurrentProcess()
            $acall = DllCall("dbghelp.dll", "int", "SymInitialize", "handle", $hprocess, "ptr", 0x0, "int", 0x1)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            $iinit = 0x1
            $acall = DllCall("dbghelp.dll", "uint64", "SymLoadModule64", "handle", $hprocess, "ptr", 0x0, "str", $__g_vext, "ptr", 0x0, "uint64", $hlibrary, "dword", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x28
                ExitLoop
            EndIf
            $paddress = $acall[0x0]
            Dim $__g_venum[0x1f5][0x2] = [[0x0]]
            Local $henumproc = DllCallbackRegister("__EnumSymbolsProcA", "int", "ptr;ulong;lparam")
            Local $penumproc = DllCallbackGetPtr($henumproc)
            If Not StringStripWS($smask, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $smask = Null
            $acall = DllCall("dbghelp.dll", "int", "SymEnumSymbols", "handle", $hprocess, "uint64", $paddress, "str", $smask, "ptr", $penumproc, "lparam", 0x0)
            If @error Or Not $acall[0x0] Or (Not $__g_venum[0x0][0x0]) Then
                $ierror = @error + 0x32
                $__g_venum = 0x0
            EndIf
            DllCallbackFree($henumproc)
            If IsArray($__g_venum) Then
                __Inc($__g_venum, + -1)
            EndIf
        Until 0x1
        If $paddress Then
            DllCall("dbghelp.dll", "int", "SymUnloadModule64", "handle", $hprocess, "uint64", $paddress)
        EndIf
        If $iinit Then
            DllCall("dbghelp.dll", "int", "SymCleanup", "handle", $hprocess)
        EndIf
        If Not ($vopts = Default) Then
            DllCall("dbghelp.dll", "dword", "SymSetOptions", "dword", $vopts)
        EndIf
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return 0x1
    EndFunc    ; -> __EnumDllProcA

    Func __EnumDllProcW($hlibrary, $smask, $IFLAGS)
        Local $hprocess, $paddress = 0x0, $iinit = 0x0, $vopts = Default, $ierror = 0x0
        $__g_venum = 0x0
        Do
            Local $acall = DllCall("dbghelp.dll", "dword", "SymGetOptions")
            If @error Then
                $ierror = @error + 0xa
                ExitLoop
            EndIf
            $vopts = $acall[0x0]
            $acall = DllCall("dbghelp.dll", "dword", "SymSetOptions", "dword", BitOR(BitAND($IFLAGS, 0x3), 0x204))
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x14
                ExitLoop
            EndIf
            $hprocess = _WinAPI_GetCurrentProcess()
            $acall = DllCall("dbghelp.dll", "int", "SymInitializeW", "handle", $hprocess, "ptr", 0x0, "int", 0x1)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            $iinit = 0x1
            $acall = DllCall("dbghelp.dll", "uint64", "SymLoadModuleExW", "handle", $hprocess, "ptr", 0x0, "wstr", $__g_vext, "ptr", 0x0, "uint64", $hlibrary, "dword", 0x0, "ptr", 0x0, "dword", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x28
                ExitLoop
            EndIf
            $paddress = $acall[0x0]
            Dim $__g_venum[0x1f5][0x2] = [[0x0]]
            Local $henumproc = DllCallbackRegister("__EnumSymbolsProcW", "int", "ptr;ulong;lparam")
            Local $penumproc = DllCallbackGetPtr($henumproc)
            If Not StringStripWS($smask, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $smask = Null
            $acall = DllCall("dbghelp.dll", "int", "SymEnumSymbolsW", "handle", $hprocess, "uint64", $paddress, "wstr", $smask, "ptr", $penumproc, "lparam", 0x0)
            If @error Or Not $acall[0x0] Or Not $__g_venum[0x0][0x0] Then
                $ierror = @error + 0x32
                $__g_venum = 0x0
            EndIf
            DllCallbackFree($henumproc)
            If IsArray($__g_venum) Then
                __Inc($__g_venum, + -1)
            EndIf
        Until 0x1
        If $paddress Then
            DllCall("dbghelp.dll", "int", "SymUnloadModule64", "handle", $hprocess, "uint64", $paddress)
        EndIf
        If $iinit Then
            DllCall("dbghelp.dll", "int", "SymCleanup", "handle", $hprocess)
        EndIf
        If Not ($vopts = Default) Then
            DllCall("dbghelp.dll", "dword", "SymSetOptions", "dword", $vopts)
        EndIf
        If $ierror Then Return SetError($ierror, 0x0, 0x0)
        Return 0x1
    EndFunc    ; -> __EnumDllProcW

    Func __EnumSymbolsProcA($PSYMINFO, $ISYMSIZE, $lparam)
        #forceref $iSymSize, $lParam
        Local $tagsymbol_info = "uint SizeOfStruct;uint TypeIndex;uint64 Reserved[2];uint Index;uint Size;uint64 ModBase;uint Flags;uint64 Value;uint64 Address;uint Register;uint Scope;uint Tag" & _
            ";uint NameLen;uint MaxNameLen;wchar Name[1]"
        Local $tsyminfo = DllStructCreate($tagsymbol_info, $PSYMINFO)
        Local $ilength = DllStructGetData($tsyminfo, "NameLen")
        If $ilength And BitAND(DllStructGetData($tsyminfo, "Flags"), 0x600) Then
            __Inc($__g_venum, 0x1f4)
            $__g_venum[$__g_venum[0x0][0x0]][0x0] = DllStructGetData($tsyminfo, "Address") - DllStructGetData($tsyminfo, "ModBase")
            $__g_venum[$__g_venum[0x0][0x0]][0x1] = DllStructGetData(DllStructCreate("char[" & ($ilength + 0x1) & "]", DllStructGetPtr($tsyminfo, "Name")), 0x1)
        EndIf
        Return 0x1
    EndFunc    ; -> __EnumSymbolsProcA

    Func __EnumSymbolsProcW($PSYMINFO, $ISYMSIZE, $lparam)
        #forceref $iSymSize, $lParam
        Local $tagsymbol_info = "uint SizeOfStruct;uint TypeIndex;uint64 Reserved[2];uint Index;uint Size;uint64 ModBase;uint Flags;uint64 Value;uint64 Address;uint Register;uint Scope;uint Tag" & _
            ";uint NameLen;uint MaxNameLen;wchar Name[1]"
        Local $tsyminfo = DllStructCreate($tagsymbol_info, $PSYMINFO)
        Local $ilength = DllStructGetData($tsyminfo, "NameLen")
        If $ilength And BitAND(DllStructGetData($tsyminfo, "Flags"), 0x600) Then
            __Inc($__g_venum, 0x1f4)
            $__g_venum[$__g_venum[0x0][0x0]][0x0] = DllStructGetData($tsyminfo, "Address") - DllStructGetData($tsyminfo, "ModBase")
            $__g_venum[$__g_venum[0x0][0x0]][0x1] = DllStructGetData(DllStructCreate("wchar[" & ($ilength + 0x1) & "]", DllStructGetPtr($tsyminfo, "Name")), 0x1)
        EndIf
        Return 0x1
    EndFunc    ; -> __EnumSymbolsProcW

    Func __WinAPIDiag_Hex($ivalue, $stype)
        Local $ilength
        Switch $stype
        Case "BYTE", "BOOLEAN"
            $ilength = 0x2
        Case "WORD", "USHORT", "short"
            $ilength = 0x4
        Case "BOOL", "UINT", "ULONG", "DWORD", "int", "long"
            $ilength = 0x8
        Case "INT64", "UINT64"
            $ilength = 0x10
        Case "INT_PTR", "UINT_PTR", "LONG_PTR", "ULONG_PTR", "DWORD_PTR", "WPARAM", "LPARAM", "LRESULT"
            $ilength = (@AutoItX64  ? 0x10  : 0x8)
        Case Else
            $ilength = 0x0
        EndSwitch
        If $ilength Then
            Return "0x" & Hex($ivalue, $ilength)
        Else
            Return $ivalue
        EndIf
    EndFunc    ; -> __WinAPIDiag_Hex

    Func __WinAPIDiag_MD5($sdata)
        Local $hhash, $ierror = 0x0
        Local $hprov = DllCall("advapi32.dll", "int", "CryptAcquireContextW", "ptr*", 0x0, "ptr", 0x0, "ptr", 0x0, "dword", 0x3, "dword", -268435456)
        If @error Or Not $hprov[0x0] Then Return SetError(@error + 0xa, @extended, '')
        Do
            $hhash = DllCall("advapi32.dll", "int", "CryptCreateHash", "handle", $hprov[0x1], "uint", 0x8003, "ptr", 0x0, "dword", 0x0, "ptr*", 0x0)
            If @error Or Not $hhash[0x0] Then
                $ierror = @error + 0x14
                $hhash = 0x0
                ExitLoop
            EndIf
            $hhash = $hhash[0x5]
            Local $tdata = DllStructCreate("byte[" & BinaryLen($sdata) & "]")
            DllStructSetData($tdata, 0x1, $sdata)
            Local $acall = DllCall("advapi32.dll", "int", "CryptHashData", "handle", $hhash, "struct*", $tdata, "dword", DllStructGetSize($tdata), "dword", 0x1)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x1e
                ExitLoop
            EndIf
            $tdata = DllStructCreate("byte[16]")
            $acall = DllCall("advapi32.dll", "int", "CryptGetHashParam", "handle", $hhash, "dword", 0x2, "struct*", $tdata, "dword*", 0x10, "dword", 0x0)
            If @error Or Not $acall[0x0] Then
                $ierror = @error + 0x28
                ExitLoop
            EndIf
        Until 0x1
        If $hhash Then
            DllCall("advapi32.dll", "int", "CryptDestroyHash", "handle", $hhash)
        EndIf
        If $ierror Then Return SetError($ierror, 0x0, '')
        Return StringTrimLeft(DllStructGetData($tdata, 0x1), 0x2)
    EndFunc    ; -> __WinAPIDiag_MD5

    Func __WinAPIDiag_Quit()
        Local $pdll = DllCallbackGetPtr($__g_hfrdll)
        If $pdll Then
            _WinAPI_RemoveWindowSubclass($__g_hfrdlg, $pdll, 0x3e8)
            DllCallbackFree($__g_hfrdll)
        EndIf
        $__g_hfrdll = 0x0
    EndFunc    ; -> __WinAPIDiag_Quit

    Func __WinAPIDiag_Ver($spath)
        Local $hlibrary = _WinAPI_GetModuleHandle($spath)
        If Not $hlibrary Then Return SetError(@error + 0xa, @extended, 0x0)
        $spath = _WinAPI_GetModuleFileNameEx(_WinAPI_GetCurrentProcess(), $hlibrary)
        If Not $spath Then Return SetError(@error + 0x14, @extended, 0x0)
        Local $vver = FileGetVersion($spath)
        If @error Then Return SetError(0x1, 0x0, 0x0)
        $vver = StringSplit($vver, ".", $STR_NOCOUNT)
        If UBound($vver) < 0x2 Then Return SetError(0x2, 0x0, 0x0)
        Return BitOR(BitShift(Number($vver[0x0]), + -8), Number($vver[0x1]))
    EndFunc    ; -> __WinAPIDiag_Ver

#EndRegion Internal Functions
#Region Global Variables and Constants
    Global Const $REG_ERROR_MORE_DATA = 0xea
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
    Func _WinAPI_AddMRUString($hmru, $sstr)
        Local $acall = DllCall("comctl32.dll", "int", "AddMRUStringW", "handle", $hmru, "wstr", $sstr)
        If @error Then Return SetError(@error, @extended, + -1)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_AddMRUString

    Func _WinAPI_AssocGetPerceivedType($sext)
        Local $acall = DllCall("shlwapi.dll", "long", "AssocGetPerceivedType", "wstr", $sext, "int*", 0x0, "dword*", 0x0, "ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Local $aret[0x3]
        $aret[0x0] = $acall[0x2]
        $aret[0x1] = $acall[0x3]
        $aret[0x2] = _WinAPI_GetString($acall[0x4])
        _WinAPI_CoTaskMemFree($acall[0x4])
        Return $aret
    EndFunc    ; -> _WinAPI_AssocGetPerceivedType

    Func _WinAPI_AssocQueryString($sassoc, $itype, $IFLAGS = 0x0, $sextra = '')
        If Not StringStripWS($sextra, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sextra = Null
        Local $acall = DllCall("shlwapi.dll", "long", "AssocQueryStringW", "dword", $IFLAGS, "dword", $itype, "wstr", $sassoc, "wstr", $sextra, "wstr", '', "dword*", 0x1000)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_AssocQueryString

    Func _WinAPI_CreateMRUList($hkey, $ssubkey, $imax = 0x1a)
        Local Const $TAGMRUINFO = "dword Size;uint Max;uint Flags;handle hKey;ptr szSubKey;ptr fnCompare"
        Local $tmruinfo = DllStructCreate($TAGMRUINFO & ";wchar[" & (StringLen($ssubkey) + 0x1) & "]")
        DllStructSetData($tmruinfo, 0x1, DllStructGetPtr($tmruinfo, 0x7) - DllStructGetPtr($tmruinfo))
        DllStructSetData($tmruinfo, 0x2, $imax)
        DllStructSetData($tmruinfo, 0x3, 0x0)
        DllStructSetData($tmruinfo, 0x4, $hkey)
        DllStructSetData($tmruinfo, 0x5, DllStructGetPtr($tmruinfo, 0x7))
        DllStructSetData($tmruinfo, 0x6, 0x0)
        DllStructSetData($tmruinfo, 0x7, $ssubkey)
        Local $acall = DllCall("comctl32.dll", "HANDLE", "CreateMRUListW", "struct*", $tmruinfo)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_CreateMRUList

    Func _WinAPI_DllInstall($sfilepath)
        Local $iret = RunWait(@SystemDir & "\\regsvr32.exe /s " & $sfilepath)
        If @error Or $iret Then Return SetError(@error + ($iret + 0x64), @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DllInstall

    Func _WinAPI_DllUninstall($sfilepath)
        Local $iret = RunWait(@SystemDir & "\\regsvr32.exe /s /u " & $sfilepath)
        If @error Or $iret Then Return SetError(@error + ($iret + 0x64), @extended, 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_DllUninstall

    Func _WinAPI_EnumMRUList($hmru, $iitem)
        Local $acall = DllCall("comctl32.dll", "int", "EnumMRUListW", "handle", $hmru, "int", $iitem, "wstr", '', "uint", 0x1000)
        If @error Or ($acall[0x0] = + -1) Then Return SetError(@error + 0xa, @extended, 0x0)
        If $iitem < 0x0 Then
            Return $acall[0x0]
        Else
            If Not $acall[0x0] Then Return SetError(0x1, 0x0, 0x0)
        EndIf
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_EnumMRUList

    Func _WinAPI_FreeMRUList($hmru)
        Local $acall = DllCall("comctl32.dll", "int", "FreeMRUList", "handle", $hmru)
        If @error Then Return SetError(@error, @extended, False)
        Return ($acall[0x0] <> + -1)
    EndFunc    ; -> _WinAPI_FreeMRUList

    Func _WinAPI_GetRegKeyNameByHandle($hkey)
        Local $tagkey_name_information = "ulong NameLength;wchar Name[4096]"
        Local $tkni = DllStructCreate($tagkey_name_information)
        Local $acall = DllCall("ntdll.dll", "long", "ZwQueryKey", "handle", $hkey, "uint", 0x3, "struct*", $tkni, "ulong", DllStructGetSize($tkni), "ulong*", 0x0)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Local $ilength = DllStructGetData($tkni, 0x1)
        If Not $ilength Then Return SetError(0xc, 0x0, '')
        Return DllStructGetData(DllStructCreate("wchar[" & ($ilength / 0x2) & "]", DllStructGetPtr($tkni, 0x2)), 0x1)
    EndFunc    ; -> _WinAPI_GetRegKeyNameByHandle

    Func _WinAPI_RegCloseKey($hkey, $bflush = False)
        If $bflush Then
            If Not _WinAPI_RegFlushKey($hkey) Then
                Return SetError(@error + 0xa, @extended, 0x0)
            EndIf
        EndIf
        Local $acall = DllCall("advapi32.dll", "long", "RegCloseKey", "handle", $hkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegCloseKey

    Func _WinAPI_RegConnectRegistry($scomputer, $hkey)
        Local $acall = DllCall("advapi32.dll", "long", "RegConnectRegistryW", "wstr", $scomputer, "handle", $hkey, "handle*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_RegConnectRegistry

    Func _WinAPI_RegCopyTree($hsrckey, $ssrcsubkey, $hdestkey)
        Local $acall = DllCall("shlwapi.dll", "long", "SHCopyKeyW", "handle", $hsrckey, "wstr", $ssrcsubkey, "ulong_ptr", $hdestkey, "dword", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegCopyTree

    Func _WinAPI_RegCopyTreeEx($hsrckey, $ssrcsubkey, $hdestkey)
        Local $acall = DllCall("advapi32.dll", "long", "RegCopyTreeW", "handle", $hsrckey, "wstr", $ssrcsubkey, "ulong_ptr", $hdestkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegCopyTreeEx

    Func _WinAPI_RegCreateKey($vkey, $ssubkey = '', $iaccess = $KEY_ALL_ACCESS, $ioptions = 0x0, $tsecurity = 0x0)
        $vkey = __winapi_regconvhkey($vkey, $ssubkey, $iaccess)
        If @error Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $acall = DllCall("advapi32.dll", "long", "RegCreateKeyExW", "handle", $vkey, "wstr", $ssubkey, "dword", 0x0, "ptr", 0x0, "dword", $ioptions, "dword", $iaccess, "struct*", $tsecurity, "ulong_ptr*", 0x0, "dword*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return SetExtended(Number($acall[0x9] = 0x1), $acall[0x8])
    EndFunc    ; -> _WinAPI_RegCreateKey

    Func _WinAPI_RegDeleteEmptyKey($hkey, $ssubkey = '')
        Local $acall = DllCall("shlwapi.dll", "long", "SHDeleteEmptyKeyW", "handle", $hkey, "wstr", $ssubkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegDeleteEmptyKey

    Func _WinAPI_RegDeleteKey($hkey, $ssubkey = '', $isamdesired = Default)
        If $isamdesired = Default Then
            If @AutoItX64 Then
                $isamdesired = $KEY_WOW64_64KEY
            Else
                $isamdesired = $KEY_WOW64_32KEY
            EndIf
        EndIf
        Local $acall = DllCall("advapi32.dll", "long", "RegDeleteKeyExW", "handle", $hkey, "wstr", $ssubkey, "dword", $isamdesired, "dword", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegDeleteKey

    Func _WinAPI_RegDeleteKeyValue($hkey, $ssubkey, $svaluename)
        Local $acall = DllCall("advapi32.dll", "long", "RegDeleteKeyValueW", "handle", $hkey, "wstr", $ssubkey, "wstr", $svaluename)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegDeleteKeyValue

    Func _WinAPI_RegDeleteTree($hkey, $ssubkey = '')
        Local $acall = DllCall("shlwapi.dll", "long", "SHDeleteKeyW", "ulong_ptr", $hkey, "wstr", $ssubkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegDeleteTree

    Func _WinAPI_RegDeleteTreeEx($hkey, $ssubkey = 0x0)
        Local $ssubkeytype = "wstr"
        If Not IsString($ssubkey) Then $ssubkeytype = "ptr"
        Local $acall = DllCall("advapi32.dll", "long", "RegDeleteTreeW", "handle", $hkey, $ssubkeytype, $ssubkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegDeleteTreeEx

    Func _WinAPI_RegDeleteValue($hkey, $svaluename)
        Local $acall = DllCall("advapi32.dll", "long", "RegDeleteValueW", "handle", $hkey, "wstr", $svaluename)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegDeleteValue

    Func _WinAPI_RegDisableReflectionKey($hkey)
        Local $acall = DllCall("advapi32.dll", "long", "RegDisableReflectionKey", "handle", $hkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegDisableReflectionKey

    Func _WinAPI_RegDuplicateHKey($hkey)
        Local $acall = DllCall("shlwapi.dll", "handle", "SHRegDuplicateHKey", "handle", $hkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_RegDuplicateHKey

    Func _WinAPI_RegEnableReflectionKey($hkey)
        Local $acall = DllCall("advapi32.dll", "long", "RegEnableReflectionKey", "handle", $hkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegEnableReflectionKey

    Func _WinAPI_RegEnumKey($hkey, $iindex)
        Local $tlastwritetime = DllStructCreate($TAGFILETIME)
        Local $acall = DllCall("advapi32.dll", "long", "RegEnumKeyExW", "ulong_ptr", $hkey, "dword", $iindex, "wstr", '', "dword*", 0x100, "dword", 0x0, "ptr", 0x0, "ptr", 0x0, "ptr", DllStructGetPtr($tlastwritetime))
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return SetExtended($acall[0x8], $acall[0x3])
    EndFunc    ; -> _WinAPI_RegEnumKey

    Func _WinAPI_RegEnumValue($hkey, $iindex)
        Local $acall = DllCall("advapi32.dll", "long", "RegEnumValueW", "handle", $hkey, "dword", $iindex, "wstr", '', "dword*", 0x4000, "dword", 0x0, "dword*", 0x0, "ptr", 0x0, "ptr", 0x0)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return SetExtended($acall[0x6], $acall[0x3])
    EndFunc    ; -> _WinAPI_RegEnumValue

    Func _WinAPI_RegFlushKey($hkey)
        Local $acall = DllCall("advapi32.dll", "long", "RegFlushKey", "handle", $hkey)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegFlushKey

    Func _WinAPI_RegLoadMUIString($hkey, $svaluename, $sdirectory = '')
        If Not StringStripWS($sdirectory, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then $sdirectory = Null
        Local $acall = DllCall("advapi32.dll", "long", "RegLoadMUIStringW", "handle", $hkey, "wstr", $svaluename, "wstr", '', "dword", 0x4000, "dword*", 0x0, "dword", 0x0, "wstr", $sdirectory)
        If @error Then Return SetError(@error, @extended, '')
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], '')
        Return $acall[0x3]
    EndFunc    ; -> _WinAPI_RegLoadMUIString

    Func _WinAPI_RegNotifyChangeKeyValue($hkey, $ifilter, $bsubtree = False, $basync = False, $hevent = 0x0)
        Local $acall = DllCall("advapi32.dll", "long", "RegNotifyChangeKeyValue", "handle", $hkey, "bool", $bsubtree, "dword", $ifilter, "handle", $hevent, "bool", $basync)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegNotifyChangeKeyValue

    Func _WinAPI_RegOpenKey($vkey, $ssubkey = '', $iaccess = $KEY_ALL_ACCESS)
        $vkey = __winapi_regconvhkey($vkey, $ssubkey, $iaccess)
        If @error Then Return SetError(@error + 0xa, @extended, 0x0)
        Local $ssubkeytype = "wstr"
        If Not IsString($ssubkey) Then $ssubkeytype = "ptr"
        Local $acall = DllCall("advapi32.dll", "long", "RegOpenKeyExW", "handle", $vkey, $ssubkeytype, $ssubkey, "dword", 0x0, "dword", $iaccess, "ulong_ptr*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_RegOpenKey

    Func __winapi_regconvhkey($vkey, ByRef $ssubkey, ByRef $iaccess)
        Local $hrootkey = $vkey, $ssubkeytemp = '', $bx64 = False
        If IsString($vkey) Then
            Local $sroot = $vkey
            Local $n = StringInStr($vkey, "\\")
            If $n Then
                $sroot = StringLeft($vkey, $n + -1)
                $ssubkeytemp = StringTrimLeft($vkey, $n)
            EndIf
            $sroot = StringReplace($sroot, "64", '')
            If @extended Then $bx64 = True
            Switch $sroot
            Case "HKCR", "HKEY_CLASSES_ROOT"
                $hrootkey = $HKEY_CLASSES_ROOT
            Case "HKLM", "HKEY_LOCAL_MACHINE"
                $hrootkey = $HKEY_LOCAL_MACHINE
            Case "HKCU", "HKEY_CURRENT_USER"
                $hrootkey = $HKEY_CURRENT_USER
            Case "HKU", "HKEY_USERS"
                $hrootkey = $HKEY_USERS
            Case "HKCC", "HKEY_CURRENT_CONFIG"
                $hrootkey = $HKEY_CURRENT_CONFIG
            Case "HKEY_PERFORMANCE_DATA"
                $hrootkey = $HKEY_PERFORMANCE_DATA
            Case "HKEY_PERFORMANCE_NLSTEXT"
                $hrootkey = $HKEY_PERFORMANCE_NLSTEXT
            Case "HKEY_PERFORMANCE_TEXT"
                $hrootkey = $HKEY_PERFORMANCE_TEXT
            Case Else
                Return SetError(0x1, 0x0, 0x0)
            EndSwitch
        EndIf
        If IsString($ssubkey) Then
            If $ssubkey <> '' Then
                If $ssubkeytemp <> '' Then Return SetError(0x2, 0x0, 0x0)
            Else
                $ssubkey = $ssubkeytemp
            EndIf
        EndIf
        If @AutoItX64 Then
            If $bx64 And (BitAND($iaccess, $KEY_WOW64_32KEY) = 0x0) Then
                $iaccess = BitOR($iaccess, $KEY_WOW64_64KEY)
            Else
                If BitAND($iaccess, $KEY_WOW64_64KEY) = 0x0 Then $iaccess = BitOR($iaccess, $KEY_WOW64_32KEY)
            EndIf
        EndIf
        Return $hrootkey
    EndFunc    ; -> __winapi_regconvhkey

    Func _WinAPI_RegQueryInfoKey($hkey)
        Local $acall = DllCall("advapi32.dll", "long", "RegQueryInfoKeyW", "handle", $hkey, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "dword*", 0x0, "dword*", 0x0, "ptr", 0x0, "dword*", 0x0, "dword*", 0x0, "dword*", 0x0, "ptr", 0x0, "ptr", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Local $aret[0x5]
        $aret[0x0] = $acall[0x5]
        $aret[0x1] = $acall[0x6]
        $aret[0x2] = $acall[0x8]
        $aret[0x3] = $acall[0x9]
        $aret[0x4] = $acall[0xa]
        Return $aret
    EndFunc    ; -> _WinAPI_RegQueryInfoKey

    Func _WinAPI_RegQueryLastWriteTime($hkey)
        Local $tfiletime = DllStructCreate($TAGFILETIME)
        Local $acall = DllCall("advapi32.dll", "long", "RegQueryInfoKeyW", "handle", $hkey, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "ptr", 0x0, "struct*", $tfiletime)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $tfiletime
    EndFunc    ; -> _WinAPI_RegQueryLastWriteTime

    Func _WinAPI_RegQueryMultipleValues($hkey, ByRef $avalent, ByRef $pbuffer, $istart = 0x0, $IEND = + -1)
        $pbuffer = 0x0
        If __CheckErrorArrayBounds($avalent, $istart, $IEND, 0x2) Then Return SetError(@error + 0xa, @extended, 0x0)
        If UBound($avalent, $UBOUND_COLUMNS) < 0x4 Then Return SetError(0xd, 0x0, 0x0)
        Local $ivalues = $IEND - $istart + 0x1
        Local $tagstruct = ''
        For $i = 0x1 To $ivalues
            $tagstruct &= "ptr;dword;ptr;dword;"
        Next
        Local $tvalent = DllStructCreate($tagstruct)
        Local $aitem[$ivalues], $icount = 0x0
        For $i = $istart To $IEND
            $aitem[$icount] = DllStructCreate("wchar[" & (StringLen($avalent[$i][0x0]) + 0x1) & "]")
            DllStructSetData($tvalent, 0x4 * $icount + 0x1, DllStructGetPtr($aitem[$icount]))
            DllStructSetData($aitem[$icount], 0x1, $avalent[$i][0x0])
            $icount += 0x1
        Next
        Local $acall = DllCall("advapi32.dll", "long", "RegQueryMultipleValuesW", "handle", $hkey, "struct*", $tvalent, "dword", $ivalues, "ptr", 0x0, "dword*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] <> $REG_ERROR_MORE_DATA Then Return SetError(0xa, $acall[0x0], 0x0)
        $pbuffer = __HeapAlloc($acall[0x5])
        If @error Then Return SetError(@error + 0x64, @extended, 0x0)
        $acall = DllCall("advapi32.dll", "long", "RegQueryMultipleValuesW", "handle", $hkey, "struct*", $tvalent, "dword", $ivalues, "ptr", $pbuffer, "dword*", $acall[0x5])
        If @error Or $acall[0x0] Then
            Local $ierror = @error
            __HeapFree($pbuffer)
            If IsArray($acall) Then
                Return SetError(0x14, $acall[0x0], 0x0)
            Else
                Return SetError($ierror + 0x14, @extended, 0x0)
            EndIf
        EndIf
        $icount = 0x0
        For $i = $istart To $IEND
            For $j = 0x1 To 0x3
                $avalent[$i][$j] = DllStructGetData($tvalent, 0x4 * $icount + $j + 0x1)
            Next
            $icount += 0x1
        Next
        Return $acall[0x5]
    EndFunc    ; -> _WinAPI_RegQueryMultipleValues

    Func _WinAPI_RegQueryReflectionKey($hkey)
        Local $acall = DllCall("advapi32.dll", "long", "RegQueryReflectionKey", "handle", $hkey, "bool*", 0x0)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return $acall[0x2]
    EndFunc    ; -> _WinAPI_RegQueryReflectionKey

    Func _WinAPI_RegQueryValue($hkey, $svaluename, ByRef $tvaluedata)
        Local $acall = DllCall("advapi32.dll", "long", "RegQueryValueExW", "handle", $hkey, "wstr", $svaluename, "dword", 0x0, "dword*", 0x0, "struct*", $tvaluedata, "dword*", DllStructGetSize($tvaluedata))
        If @error Then Return SetError(@error, @extended, 0x0)
        If ($acall[0x0] <> 0x0) And ($acall[0x0] <> $REG_ERROR_MORE_DATA) Then Return SetError(0xa, $acall[0x0], 0x0)
        Return SetError($acall[0x0], $acall[0x4], $acall[0x6])
    EndFunc    ; -> _WinAPI_RegQueryValue

    Func _WinAPI_RegRestoreKey($hkey, $sfilepath)
        Local $acall = DllCall("advapi32.dll", "long", "RegRestoreKeyW", "handle", $hkey, "wstr", $sfilepath, "dword", 0x8)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegRestoreKey

    Func _WinAPI_RegSaveKey($hkey, $sfilepath, $breplace = False, $tsecurity = 0x0)
        Local $acall
        While 0x1
            $acall = DllCall("advapi32.dll", "long", "RegSaveKeyW", "handle", $hkey, "wstr", $sfilepath, "struct*", $tsecurity)
            If @error Then Return SetError(@error, @extended, 0x0)
            Switch $acall[0x0]
            Case 0x0
                ExitLoop
            Case 0xb7
                If $breplace Then
                    If Not FileDelete($sfilepath) Then
                        Return SetError(0x14, _WinAPI_GetLastError(), 0x0)
                    Else
                        ContinueLoop
                    EndIf
                Else
                    ContinueCase
                EndIf
            Case Else
                Return SetError(0xa, $acall[0x0], 0x0)
            EndSwitch
        WEnd
        Return 0x1
    EndFunc    ; -> _WinAPI_RegSaveKey

    Func _WinAPI_RegSetValue($hkey, $svaluename, $itype, $tvaluedata, $ibytes)
        Local $acall = DllCall("advapi32.dll", "long", "RegSetValueExW", "handle", $hkey, "wstr", $svaluename, "dword", 0x0, "dword", $itype, "struct*", $tvaluedata, "dword", $ibytes)
        If @error Then Return SetError(@error, @extended, 0x0)
        If $acall[0x0] Then Return SetError(0xa, $acall[0x0], 0x0)
        Return 0x1
    EndFunc    ; -> _WinAPI_RegSetValue

    Func _WinAPI_SfcIsKeyProtected($hkey, $ssubkey = Default, $IFLAG = 0x0)
        If Not __dll("sfc.dll") Then Return SetError(0x67, 0x0, False)
        If Not IsString($ssubkey) Then $ssubkey = Null
        Local $acall = DllCall("sfc.dll", "int", "SfcIsKeyProtected", "handle", $hkey, "wstr", $ssubkey, "dword", $IFLAG)
        If @error Then Return SetError(@error, @extended, False)
        Return $acall[0x0]
    EndFunc    ; -> _WinAPI_SfcIsKeyProtected

#EndRegion Public Functions
Global Const $LANG_AFRIKAANS = 0x36
Global Const $LANG_ALBANIAN = 0x1c
Global Const $LANG_ARABIC = 0x1
Global Const $LANG_ARMENIAN = 0x2b
Global Const $LANG_ASSAMESE = 0x4d
Global Const $LANG_AZERI = 0x2c
Global Const $LANG_BASQUE = 0x2d
Global Const $LANG_BELARUSIAN = 0x23
Global Const $LANG_BENGALI = 0x45
Global Const $LANG_BULGARIAN = 0x2
Global Const $LANG_CATALAN = 0x3
Global Const $LANG_CHINESE = 0x4
Global Const $LANG_CROATIAN = 0x1a
Global Const $LANG_CZECH = 0x5
Global Const $LANG_DANISH = 0x6
Global Const $LANG_DUTCH = 0x13
Global Const $LANG_ENGLISH = 0x9
Global Const $LANG_ESTONIAN = 0x25
Global Const $LANG_FAEROESE = 0x38
Global Const $LANG_FARSI = 0x29
Global Const $LANG_FINNISH = 0xb
Global Const $LANG_FRENCH = 0xc
Global Const $LANG_GEORGIAN = 0x37
Global Const $LANG_GERMAN = 0x7
Global Const $LANG_GREEK = 0x8
Global Const $LANG_GUJARATI = 0x47
Global Const $LANG_HEBREW = 0xd
Global Const $LANG_HINDI = 0x39
Global Const $LANG_HUNGARIAN = 0xe
Global Const $LANG_ICELANDIC = 0xf
Global Const $LANG_INDONESIAN = 0x21
Global Const $LANG_ITALIAN = 0x10
Global Const $LANG_JAPANESE = 0x11
Global Const $LANG_KANNADA = 0x4b
Global Const $LANG_KASHMIRI = 0x60
Global Const $LANG_KAZAK = 0x3f
Global Const $LANG_KONKANI = 0x57
Global Const $LANG_KOREAN = 0x12
Global Const $LANG_LATVIAN = 0x26
Global Const $LANG_LITHUANIAN = 0x27
Global Const $LANG_MACEDONIAN = 0x2f
Global Const $LANG_MALAY = 0x3e
Global Const $LANG_MALAYALAM = 0x4c
Global Const $LANG_MANIPURI = 0x58
Global Const $LANG_MARATHI = 0x4e
Global Const $LANG_NEPALI = 0x61
Global Const $LANG_NEUTRAL = 0x0
Global Const $LANG_NORWEGIAN = 0x14
Global Const $LANG_ORIYA = 0x48
Global Const $LANG_POLISH = 0x15
Global Const $LANG_PORTUGUESE = 0x16
Global Const $LANG_PUNJABI = 0x46
Global Const $LANG_ROMANIAN = 0x18
Global Const $LANG_RUSSIAN = 0x19
Global Const $LANG_SANSKRIT = 0x4f
Global Const $LANG_SERBIAN = 0x1a
Global Const $LANG_SINDHI = 0x59
Global Const $LANG_SLOVAK = 0x1b
Global Const $LANG_SLOVENIAN = 0x24
Global Const $LANG_SPANISH = 0xa
Global Const $LANG_SWAHILI = 0x41
Global Const $LANG_SWEDISH = 0x1d
Global Const $LANG_TAMIL = 0x49
Global Const $LANG_TATAR = 0x44
Global Const $LANG_TELUGU = 0x4a
Global Const $LANG_THAI = 0x1e
Global Const $LANG_TURKISH = 0x1f
Global Const $LANG_UKRAINIAN = 0x22
Global Const $LANG_URDU = 0x20
Global Const $LANG_UZBEK = 0x43
Global Const $LANG_VIETNAMESE = 0x2a
Global Const $SUBLANG_ARABIC_ALGERIA = 0x5
Global Const $SUBLANG_ARABIC_BAHRAIN = 0xf
Global Const $SUBLANG_ARABIC_EGYPT = 0x3
Global Const $SUBLANG_ARABIC_IRAQ = 0x2
Global Const $SUBLANG_ARABIC_JORDAN = 0xb
Global Const $SUBLANG_ARABIC_KUWAIT = 0xd
Global Const $SUBLANG_ARABIC_LEBANON = 0xc
Global Const $SUBLANG_ARABIC_LIBYA = 0x4
Global Const $SUBLANG_ARABIC_MOROCCO = 0x6
Global Const $SUBLANG_ARABIC_OMAN = 0x8
Global Const $SUBLANG_ARABIC_QATAR = 0x10
Global Const $SUBLANG_ARABIC_SAUDI_ARABIA = 0x1
Global Const $SUBLANG_ARABIC_SYRIA = 0xa
Global Const $SUBLANG_ARABIC_TUNISIA = 0x7
Global Const $SUBLANG_ARABIC_UAE = 0xe
Global Const $SUBLANG_ARABIC_YEMEN = 0x9
Global Const $SUBLANG_AZERI_CYRILLIC = 0x2
Global Const $SUBLANG_AZERI_LATIN = 0x1
Global Const $SUBLANG_CHINESE_HONGKONG = 0x3
Global Const $SUBLANG_CHINESE_MACAU = 0x5
Global Const $SUBLANG_CHINESE_SIMPLIFIED = 0x2
Global Const $SUBLANG_CHINESE_SINGAPORE = 0x4
Global Const $SUBLANG_CHINESE_TRADITIONAL = 0x1
Global Const $SUBLANG_DEFAULT = 0x1
Global Const $SUBLANG_DUTCH = 0x1
Global Const $SUBLANG_DUTCH_BELGIAN = 0x2
Global Const $SUBLANG_ENGLISH_AUS = 0x3
Global Const $SUBLANG_ENGLISH_BELIZE = 0xa
Global Const $SUBLANG_ENGLISH_CAN = 0x4
Global Const $SUBLANG_ENGLISH_CARIBBEAN = 0x9
Global Const $SUBLANG_ENGLISH_EIRE = 0x6
Global Const $SUBLANG_ENGLISH_JAMAICA = 0x8
Global Const $SUBLANG_ENGLISH_NZ = 0x5
Global Const $SUBLANG_ENGLISH_PHILIPPINES = 0xd
Global Const $SUBLANG_ENGLISH_SOUTH_AFRICA = 0x7
Global Const $SUBLANG_ENGLISH_TRINIDAD = 0xb
Global Const $SUBLANG_ENGLISH_UK = 0x2
Global Const $SUBLANG_ENGLISH_US = 0x1
Global Const $SUBLANG_ENGLISH_ZIMBABWE = 0xc
Global Const $SUBLANG_FRENCH = 0x1
Global Const $SUBLANG_FRENCH_BELGIAN = 0x2
Global Const $SUBLANG_FRENCH_CANADIAN = 0x3
Global Const $SUBLANG_FRENCH_LUXEMBOURG = 0x5
Global Const $SUBLANG_FRENCH_MONACO = 0x6
Global Const $SUBLANG_FRENCH_SWISS = 0x4
Global Const $SUBLANG_GERMAN = 0x1
Global Const $SUBLANG_GERMAN_AUSTRIAN = 0x3
Global Const $SUBLANG_GERMAN_LIECHTENSTEIN = 0x5
Global Const $SUBLANG_GERMAN_LUXEMBOURG = 0x4
Global Const $SUBLANG_GERMAN_SWISS = 0x2
Global Const $SUBLANG_ITALIAN = 0x1
Global Const $SUBLANG_ITALIAN_SWISS = 0x2
Global Const $SUBLANG_KASHMIRI_INDIA = 0x2
Global Const $SUBLANG_KOREAN = 0x1
Global Const $SUBLANG_LITHUANIAN = 0x1
Global Const $SUBLANG_MALAY_BRUNEI_DARUSSALAM = 0x2
Global Const $SUBLANG_MALAY_MALAYSIA = 0x1
Global Const $SUBLANG_NEPALI_INDIA = 0x2
Global Const $SUBLANG_NEUTRAL = 0x0
Global Const $SUBLANG_NORWEGIAN_BOKMAL = 0x1
Global Const $SUBLANG_NORWEGIAN_NYNORSK = 0x2
Global Const $SUBLANG_PORTUGUESE = 0x2
Global Const $SUBLANG_PORTUGUESE_BRAZILIAN = 0x1
Global Const $SUBLANG_SERBIAN_CYRILLIC = 0x3
Global Const $SUBLANG_SERBIAN_LATIN = 0x2
Global Const $SUBLANG_SPANISH = 0x1
Global Const $SUBLANG_SPANISH_ARGENTINA = 0xb
Global Const $SUBLANG_SPANISH_BOLIVIA = 0x10
Global Const $SUBLANG_SPANISH_CHILE = 0xd
Global Const $SUBLANG_SPANISH_COLOMBIA = 0x9
Global Const $SUBLANG_SPANISH_COSTA_RICA = 0x5
Global Const $SUBLANG_SPANISH_DOMINICAN_REPUBLIC = 0x7
Global Const $SUBLANG_SPANISH_ECUADOR = 0xc
Global Const $SUBLANG_SPANISH_EL_SALVADOR = 0x11
Global Const $SUBLANG_SPANISH_GUATEMALA = 0x4
Global Const $SUBLANG_SPANISH_HONDURAS = 0x12
Global Const $SUBLANG_SPANISH_MEXICAN = 0x2
Global Const $SUBLANG_SPANISH_MODERN = 0x3
Global Const $SUBLANG_SPANISH_NICARAGUA = 0x13
Global Const $SUBLANG_SPANISH_PANAMA = 0x6
Global Const $SUBLANG_SPANISH_PARAGUAY = 0xf
Global Const $SUBLANG_SPANISH_PERU = 0xa
Global Const $SUBLANG_SPANISH_PUERTO_RICO = 0x14
Global Const $SUBLANG_SPANISH_URUGUAY = 0xe
Global Const $SUBLANG_SPANISH_VENEZUELA = 0x8
Global Const $SUBLANG_SWEDISH = 0x1
Global Const $SUBLANG_SWEDISH_FINLAND = 0x2
Global Const $SUBLANG_SYS_DEFAULT = 0x2
Global Const $SUBLANG_URDU_INDIA = 0x2
Global Const $SUBLANG_URDU_PAKISTAN = 0x1
Global Const $SUBLANG_UZBEK_CYRILLIC = 0x2
Global Const $SORT_DEFAULT = 0x0
Global Const $SORT_JAPANESE_XJIS = 0x0
Global Const $SORT_JAPANESE_UNICODE = 0x1
Global Const $SORT_CHINESE_BIG5 = 0x0
Global Const $SORT_CHINESE_PRCP = 0x0
Global Const $SORT_CHINESE_UNICODE = 0x1
Global Const $SORT_CHINESE_PRC = 0x2
Global Const $SORT_KOREAN_KSC = 0x0
Global Const $SORT_KOREAN_UNICODE = 0x1
Global Const $SORT_GERMAN_PHONE_BOOK = 0x1
Global Const $SORT_HUNGARIAN_DEFAULT = 0x0
Global Const $SORT_HUNGARIAN_TECHNICAL = 0x1
Global Const $SORT_GEORGIAN_TRADITIONAL = 0x0
Global Const $SORT_GEORGIAN_MODERN = 0x1
Global Const $CONNDLG_RO_PATH = 0x1
Global Const $CONNDLG_CONN_POINT = 0x2
Global Const $CONNDLG_USE_MRU = 0x4
Global Const $CONNDLG_HIDE_BOX = 0x8
Global Const $CONNDLG_PERSIST = 0x10
Global Const $CONNDLG_NOT_PERSIST = 0x20
Global Const $CONNECT_UPDATE_PROFILE = 0x1
Global Const $CONNECT_UPDATE_RECENT = 0x2
Global Const $CONNECT_TEMPORARY = 0x4
Global Const $CONNECT_INTERACTIVE = 0x8
Global Const $CONNECT_PROMPT = 0x10
Global Const $CONNECT_NEED_DRIVE = 0x20
Global Const $CONNECT_REFCOUNT = 0x40
Global Const $CONNECT_REDIRECT = 0x80
Global Const $CONNECT_LOCALDRIVE = 0x100
Global Const $CONNECT_CURRENT_MEDIA = 0x200
Global Const $CONNECT_DEFERRED = 0x400
Global Const $CONNECT_COMMANDLINE = 0x800
Global Const $CONNECT_CMD_SAVECRED = 0x1000
Global Const $CONNECT_RESERVED = -16777216
Global Const $DISC_UPDATE_PROFILE = 0x1
Global Const $DISC_NO_FORCE = 0x40
Global Const $RESOURCE_CONNECTED = 0x1
Global Const $RESOURCE_GLOBALNET = 0x2
Global Const $RESOURCE_REMEMBERED = 0x3
Global Const $RESOURCE_RECENT = 0x4
Global Const $RESOURCE_CONTEXT = 0x5
Global Const $RESOURCETYPE_ANY = 0x0
Global Const $RESOURCETYPE_DISK = 0x1
Global Const $RESOURCETYPE_PRINT = 0x2
Global Const $RESOURCETYPE_RESERVED = 0x8
Global Const $RESOURCETYPE_UNKNOWN = -1
Global Const $RESOURCEUSAGE_CONNECTABLE = 0x1
Global Const $RESOURCEUSAGE_CONTAINER = 0x2
Global Const $RESOURCEUSAGE_NOLOCALDEVICE = 0x4
Global Const $RESOURCEUSAGE_SIBLING = 0x8
Global Const $RESOURCEUSAGE_ATTACHED = 0x10
Global Const $RESOURCEUSAGE_RESERVED = -2147483648
Global Const $RESOURCEDISPLAYTYPE_GENERIC = 0x0
Global Const $RESOURCEDISPLAYTYPE_DOMAIN = 0x1
Global Const $RESOURCEDISPLAYTYPE_SERVER = 0x2
Global Const $RESOURCEDISPLAYTYPE_SHARE = 0x3
Global Const $RESOURCEDISPLAYTYPE_FILE = 0x4
Global Const $RESOURCEDISPLAYTYPE_GROUP = 0x5
Global Const $RESOURCEDISPLAYTYPE_NETWORK = 0x6
Global Const $RESOURCEDISPLAYTYPE_ROOT = 0x7
Global Const $RESOURCEDISPLAYTYPE_SHAREADMIN = 0x8
Global Const $RESOURCEDISPLAYTYPE_DIRECTORY = 0x9
Global Const $RESOURCEDISPLAYTYPE_TREE = 0xa
Global Const $RESOURCEDISPLAYTYPE_NDSCONTAINER = 0xa
Global Const $WNNC_NET_MSNET = 0x10000
Global Const $WNNC_NET_LANMAN = 0x20000
Global Const $WNNC_NET_NETWARE = 0x30000
Global Const $WNNC_NET_VINES = 0x40000
Global Const $WNNC_NET_10NET = 0x50000
Global Const $WNNC_NET_LOCUS = 0x60000
Global Const $WNNC_NET_SUN_PC_NFS = 0x70000
Global Const $WNNC_NET_LANSTEP = 0x80000
Global Const $WNNC_NET_9TILES = 0x90000
Global Const $WNNC_NET_LANTASTIC = 0xa0000
Global Const $WNNC_NET_AS400 = 0xb0000
Global Const $WNNC_NET_FTP_NFS = 0xc0000
Global Const $WNNC_NET_PATHWORKS = 0xd0000
Global Const $WNNC_NET_LIFENET = 0xe0000
Global Const $WNNC_NET_POWERLAN = 0xf0000
Global Const $WNNC_NET_BWNFS = 0x100000
Global Const $WNNC_NET_COGENT = 0x110000
Global Const $WNNC_NET_FARALLON = 0x120000
Global Const $WNNC_NET_APPLETALK = 0x130000
Global Const $WNNC_NET_INTERGRAPH = 0x140000
Global Const $WNNC_NET_SYMFONET = 0x150000
Global Const $WNNC_NET_CLEARCASE = 0x160000
Global Const $WNNC_NET_FRONTIER = 0x170000
Global Const $WNNC_NET_BMC = 0x180000
Global Const $WNNC_NET_DCE = 0x190000
Global Const $WNNC_NET_AVID = 0x1a0000
Global Const $WNNC_NET_DOCUSPACE = 0x1b0000
Global Const $WNNC_NET_MANGOSOFT = 0x1c0000
Global Const $WNNC_NET_SERNET = 0x1d0000
Global Const $WNNC_NET_RIVERFRONT1 = 0x1e0000
Global Const $WNNC_NET_RIVERFRONT2 = 0x1f0000
Global Const $WNNC_NET_DECORB = 0x200000
Global Const $WNNC_NET_PROTSTOR = 0x210000
Global Const $WNNC_NET_FJ_REDIR = 0x220000
Global Const $WNNC_NET_DISTINCT = 0x230000
Global Const $WNNC_NET_TWINS = 0x240000
Global Const $WNNC_NET_RDR2SAMPLE = 0x250000
Global Const $WNNC_NET_CSC = 0x260000
Global Const $WNNC_NET_3IN1 = 0x270000
Global Const $WNNC_NET_EXTENDNET = 0x290000
Global Const $WNNC_NET_STAC = 0x2a0000
Global Const $WNNC_NET_FOXBAT = 0x2b0000
Global Const $WNNC_NET_YAHOO = 0x2c0000
Global Const $WNNC_NET_EXIFS = 0x2d0000
Global Const $WNNC_NET_DAV = 0x2e0000
Global Const $WNNC_NET_KNOWARE = 0x2f0000
Global Const $WNNC_NET_OBJECT_DIRE = 0x300000
Global Const $WNNC_NET_MASFAX = 0x310000
Global Const $WNNC_NET_HOB_NFS = 0x320000
Global Const $WNNC_NET_SHIVA = 0x330000
Global Const $WNNC_NET_IBMAL = 0x340000
Global Const $WNNC_NET_LOCK = 0x350000
Global Const $WNNC_NET_TERMSRV = 0x360000
Global Const $WNNC_NET_SRT = 0x370000
Global Const $WNNC_NET_QUINCY = 0x380000
Global Const $WNNC_CRED_MANAGER = -65536
Global Const $TAGCONNECTDLGSTRUCT = "dword Size;hwnd hWnd;ptr Resource;dword Flags;dword DevNum"
Global Const $TAGDISCDLGSTRUCT = "dword Size;hwnd hWnd;ptr LocalName;ptr RemoteName;dword Flags"
Global Const $TAGNETCONNECTINFOSTRUCT = "dword Size;dword Flags;dword Speed;dword Delay;dword OptDataSize"
Global Const $TAGNETINFOSTRUCT = "dword Size;dword Version;dword Status;dword Char;ulong_ptr Handle;word NetType;dword Printers;dword Drives"
Global Const $TAGREMOTE_NAME_INFO = "ptr Universal;ptr Connection;ptr Remaining"
Func _WinNet_AddConnection($slocalname, $sremotename, $spassword = 0x0)
    Local $tpassword = 0x0
    If IsString($spassword) Then
        $tpassword = DllStructCreate("wchar Text[4096]")
        DllStructSetData($tpassword, "Text", $spassword)
    EndIf
    Local $acall = DllCall("mpr.dll", "dword", "WNetAddConnectionW", "wstr", $sremotename, "struct*", $tpassword, "wstr", $slocalname)
    If @error Then Return SetError(@error, @extended, False)
    Return SetError($acall[0x0], 0x0, $acall[0x0] = 0x0)
EndFunc    ; -> _WinNet_AddConnection

Func _WinNet_AddConnection2($slocalname, $sremotename, $susername = 0x0, $spassword = 0x0, $itype = 0x1, $ioptions = 0x1)
    Local $tlocalname = DllStructCreate("wchar Text[1024]")
    Local $plocalname = DllStructGetPtr($tlocalname)
    DllStructSetData($tlocalname, "Text", $slocalname)
    Local $tremotename = DllStructCreate("wchar Text[1024]")
    Local $premotename = DllStructGetPtr($tremotename)
    DllStructSetData($tremotename, "Text", $sremotename)
    Local $tusername = 0x0
    If IsString($susername) Then
        $tusername = DllStructCreate("wchar Text[1024]")
        DllStructSetData($tusername, "Text", $susername)
    EndIf
    Local $tpassword = 0x0
    If IsString($spassword) Then
        $tpassword = DllStructCreate("wchar Text[1024]")
        DllStructSetData($tpassword, "Text", $spassword)
    EndIf
    Local $IFLAGS = 0x0
    If BitAND($ioptions, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_UPDATE_PROFILE)
    If BitAND($ioptions, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_INTERACTIVE)
    If BitAND($ioptions, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_PROMPT)
    If BitAND($ioptions, 0x8) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_REDIRECT)
    If BitAND($ioptions, 0x10) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_COMMANDLINE)
    If BitAND($ioptions, 0x20) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_CMD_SAVECRED)
    Local $tresource = DllStructCreate($TAGNETRESOURCE)
    DllStructSetData($tresource, "Type", $itype)
    DllStructSetData($tresource, "LocalName", $plocalname)
    DllStructSetData($tresource, "RemoteName", $premotename)
    Local $acall = DllCall("mpr.dll", "dword", "WNetAddConnection2W", "struct*", $tresource, "struct*", $tpassword, "struct*", $tusername, "dword", $IFLAGS)
    If @error Then Return SetError(@error, @extended, False)
    Return SetError($acall[0x0], 0x0, $acall[0x0] = 0x0)
EndFunc    ; -> _WinNet_AddConnection2

Func _WinNet_AddConnection3($hwnd, $slocalname, $sremotename, $susername = 0x0, $spassword = 0x0, $itype = 0x1, $ioptions = 0x1)
    Local $tlocalname = DllStructCreate("wchar Text[1024]")
    Local $plocalname = DllStructGetPtr($tlocalname)
    DllStructSetData($tlocalname, "Text", $slocalname)
    Local $tremotename = DllStructCreate("wchar Text[1024]")
    Local $premotename = DllStructGetPtr($tremotename)
    DllStructSetData($tremotename, "Text", $sremotename)
    Local $tusername = 0x0
    If IsString($susername) Then
        $tusername = DllStructCreate("wchar Text[1024]")
        DllStructSetData($tusername, "Text", $susername)
    EndIf
    Local $tpassword = 0x0
    If IsString($spassword) Then
        $tpassword = DllStructCreate("wchar Text[1024]")
        DllStructSetData($tpassword, "Text", $spassword)
    EndIf
    Local $IFLAGS = 0x0
    If BitAND($ioptions, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_UPDATE_PROFILE)
    If BitAND($ioptions, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_INTERACTIVE)
    If BitAND($ioptions, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_PROMPT)
    If BitAND($ioptions, 0x8) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_REDIRECT)
    If BitAND($ioptions, 0x10) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_COMMANDLINE)
    If BitAND($ioptions, 0x20) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_CMD_SAVECRED)
    Local $tresource = DllStructCreate($TAGNETRESOURCE)
    DllStructSetData($tresource, "Type", $itype)
    DllStructSetData($tresource, "LocalName", $plocalname)
    DllStructSetData($tresource, "RemoteName", $premotename)
    Local $acall = DllCall("mpr.dll", "dword", "WNetAddConnection3W", "hwnd", $hwnd, "struct*", $tresource, "struct*", $tpassword, "struct*", $tusername, "dword", $IFLAGS)
    If @error Then Return SetError(@error, @extended, False)
    Return SetError($acall[0x0], 0x0, $acall[0x0] = 0x0)
EndFunc    ; -> _WinNet_AddConnection3

Func _WinNet_CancelConnection($sname, $bforce = True)
    Local $acall = DllCall("mpr.dll", "dword", "WNetCancelConnectionW", "wstr", $sname, "bool", $bforce)
    If @error Then Return SetError(@error, @extended, False)
    Return SetError($acall[0x0], 0x0, $acall[0x0] = 0x0)
EndFunc    ; -> _WinNet_CancelConnection

Func _WinNet_CancelConnection2($sname, $bupdate = True, $bforce = True)
    Local $acall = DllCall("mpr.dll", "dword", "WNetCancelConnection2W", "wstr", $sname, "dword", $bupdate, "bool", $bforce)
    If @error Then Return SetError(@error, @extended, False)
    Return SetError($acall[0x0], 0x0, $acall[0x0] = 0x0)
EndFunc    ; -> _WinNet_CancelConnection2

Func _WinNet_CloseEnum($HENUM)
    Local $acall = DllCall("mpr.dll", "dword", "WNetCloseEnum", "handle", $HENUM)
    If @error Then Return SetError(@error, @extended, False)
    Return SetError($acall[0x0], 0x0, $acall[0x0] = 0x0)
EndFunc    ; -> _WinNet_CloseEnum

Func _WinNet_ConnectionDialog($hwnd)
    Local $acall = DllCall("mpr.dll", "dword", "WNetConnectionDialog", "hwnd", $hwnd, "dword", $RESOURCETYPE_DISK)
    If @error Then Return SetError(@error, @extended, False)
    Return SetError($acall[0x0], 0x0, $acall[0x0] = 0x0)
EndFunc    ; -> _WinNet_ConnectionDialog

Func _WinNet_ConnectionDialog1($hwnd, $sremotename = '', $IFLAGS = 0x2)
    Local $tremotename = DllStructCreate("wchar Text[1024]")
    Local $premotename = DllStructGetPtr($tremotename)
    DllStructSetData($tremotename, "Text", $sremotename)
    Local $tresource = DllStructCreate($TAGNETRESOURCE)
    Local $presource = DllStructGetPtr($tresource)
    DllStructSetData($tresource, "Type", $RESOURCETYPE_DISK)
    DllStructSetData($tresource, "RemoteName", $premotename)
    Local $idialog = 0x0
    If BitAND($IFLAGS, 0x1) <> 0x0 Then $idialog = BitOR($idialog, $CONNDLG_RO_PATH)
    If BitAND($IFLAGS, 0x2) <> 0x0 Then $idialog = BitOR($idialog, $CONNDLG_USE_MRU)
    If BitAND($IFLAGS, 0x4) <> 0x0 Then $idialog = BitOR($idialog, $CONNDLG_HIDE_BOX)
    If BitAND($IFLAGS, 0x8) <> 0x0 Then $idialog = BitOR($idialog, $CONNDLG_PERSIST)
    If BitAND($IFLAGS, 0x10) <> 0x0 Then $idialog = BitOR($idialog, $CONNDLG_NOT_PERSIST)
    Local $tconnect = DllStructCreate($TAGCONNECTDLGSTRUCT)
    DllStructSetData($tconnect, "Size", DllStructGetSize($tconnect))
    DllStructSetData($tconnect, "hWnd", $hwnd)
    DllStructSetData($tconnect, "Resource", $presource)
    DllStructSetData($tconnect, "Flags", $idialog)
    Local $acall = DllCall("mpr.dll", "dword", "WNetConnectionDialog1W", "struct*", $tconnect)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] = + -1 Then Return + -1
    If $acall[0x0] <> 0x0 Then Return SetError($acall[0x0], 0x0, 0x0)
    Return DllStructGetData($tconnect, "DevNum")
EndFunc    ; -> _WinNet_ConnectionDialog1

Func _WinNet_DisconnectDialog($hwnd)
    Local $acall = DllCall("mpr.dll", "dword", "WNetDisconnectDialog", "hwnd", $hwnd, "dword", $RESOURCETYPE_DISK)
    If @error Then Return SetError(@error, @extended, False)
    Return SetError($acall[0x0], 0x0, $acall[0x0] = 0x0)
EndFunc    ; -> _WinNet_DisconnectDialog

Func _WinNet_DisconnectDialog1($hwnd, $slocalname, $sremotename = '', $IFLAGS = 0x1)
    Local $tlocalname = DllStructCreate("wchar Text[1024]")
    Local $plocalname = DllStructGetPtr($tlocalname)
    DllStructSetData($tlocalname, "Text", $slocalname)
    Local $premotename = 0x0
    If $sremotename <> '' Then
        Local $tremotename = DllStructCreate("wchar Text[1024]")
        $premotename = DllStructGetPtr($tremotename)
        DllStructSetData($tremotename, "Text", $sremotename)
    EndIf
    Local $ioptions = 0x0
    If BitAND($IFLAGS, 0x1) <> 0x0 Then $ioptions = BitOR($ioptions, $DISC_UPDATE_PROFILE)
    If BitAND($IFLAGS, 0x2) <> 0x0 Then $ioptions = BitOR($ioptions, $DISC_NO_FORCE)
    Local $tdialog = DllStructCreate($TAGDISCDLGSTRUCT)
    DllStructSetData($tdialog, "Size", DllStructGetSize($tdialog))
    DllStructSetData($tdialog, "hWnd", $hwnd)
    DllStructSetData($tdialog, "LocalName", $plocalname)
    DllStructSetData($tdialog, "RemoteName", $premotename)
    DllStructSetData($tdialog, "Flags", $ioptions)
    Local $acall = DllCall("mpr.dll", "dword", "WNetDisconnectDialog1W", "struct*", $tdialog)
    If @error Then Return SetError(@error, @extended, 0x0)
    If $acall[0x0] > 0x0 Then Return SetError($acall[0x0], 0x0, 0x0)
    If $acall[0x0] = + -1 Then Return + -1
    Return 0x1
EndFunc    ; -> _WinNet_DisconnectDialog1

Func _WinNet_EnumResource($HENUM, ByRef $icount, $pbuffer, ByRef $IBUFSIZE)
    Local $acall = DllCall("mpr.dll", "dword", "WNetEnumResourceW", "handle", $HENUM, "dword*", $icount, "struct*", $pbuffer, "dword*", $IBUFSIZE)
    If @error Then Return SetError(@error, @extended, False)
    $icount = $acall[0x2]
    $IBUFSIZE = $acall[0x4]
    Return $acall[0x0]
EndFunc    ; -> _WinNet_EnumResource

Func _WinNet_GetConnection($slocalname)
    Local $acall = DllCall("mpr.dll", "dword", "WNetGetConnectionW", "wstr", $slocalname, "wstr", '', "dword*", 0x1000)
    If @error Then Return SetError(@error, @extended, False)
    Return SetExtended($acall[0x0], $acall[0x2])
EndFunc    ; -> _WinNet_GetConnection

Func _WinNet_GetConnectionPerformance($slocalname, $sremotename)
    Local $tlocalname = DllStructCreate("wchar Text[4096]")
    DllStructSetData($tlocalname, "Text", $slocalname)
    Local $tremotename = DllStructCreate("wchar Text[4096]")
    DllStructSetData($tremotename, "Text", $sremotename)
    Local $tresource = DllStructCreate($TAGNETRESOURCE)
    DllStructSetData($tresource, "LocalName", DllStructGetPtr($tlocalname))
    DllStructSetData($tresource, "RemoteName", DllStructGetPtr($tremotename))
    Local $tinfo = DllStructCreate($TAGNETCONNECTINFOSTRUCT)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    Local $acall = DllCall("mpr.dll", "dword", "MultinetGetConnectionPerformanceW", "struct*", $tresource, "struct*", $tinfo)
    If @error Then Return SetError(@error, @extended, False)
    Local $ainfo[0x4]
    $ainfo[0x0] = DllStructGetData($tinfo, "Flags")
    $ainfo[0x1] = DllStructGetData($tinfo, "Speed")
    $ainfo[0x2] = DllStructGetData($tinfo, "Delay")
    $ainfo[0x3] = DllStructGetData($tinfo, "OptDataSize")
    Return SetExtended($acall[0x0], $ainfo)
EndFunc    ; -> _WinNet_GetConnectionPerformance

Func _WinNet_GetLastError(ByRef $ierror, ByRef $serror, ByRef $sname)
    Local $acall = DllCall("mpr.dll", "dword", "WNetGetLastErrorW", "dword*", $ierror, "wstr", '', "dword", 0x400, "wstr", '', "dword", 0x400)
    If @error Then Return SetError(@error, @extended, False)
    $ierror = $acall[0x1]
    $serror = $acall[0x2]
    $sname = $acall[0x3]
    Return $acall[0x0]
EndFunc    ; -> _WinNet_GetLastError

Func _WinNet_GetNetworkInformation($sname)
    Local $tinfo = DllStructCreate($TAGNETINFOSTRUCT)
    DllStructSetData($tinfo, "Size", DllStructGetSize($tinfo))
    Local $acall = DllCall("mpr.dll", "dword", "WNetGetNetworkInformationW", "wstr", $sname, "struct*", $tinfo)
    If @error Then Return SetError(@error, @extended, False)
    Local $ainfo[0x6]
    $ainfo[0x0] = DllStructGetData($tinfo, "Version")
    $ainfo[0x1] = DllStructGetData($tinfo, "Status")
    $ainfo[0x2] = DllStructGetData($tinfo, "Handle")
    $ainfo[0x3] = DllStructGetData($tinfo, "NetType")
    $ainfo[0x4] = DllStructGetData($tinfo, "Printers")
    $ainfo[0x5] = DllStructGetData($tinfo, "Drives")
    Return SetExtended($acall[0x0], $ainfo)
EndFunc    ; -> _WinNet_GetNetworkInformation

Func _WinNet_GetProviderName($itype)
    Local $acall = DllCall("mpr.dll", "dword", "WNetGetProviderNameW", "dword", $itype, "wstr", '', "dword*", 0x1000)
    If @error Then Return SetError(@error, @extended, '')
    Return SetExtended($acall[0x0], $acall[0x2])
EndFunc    ; -> _WinNet_GetProviderName

Func _WinNet_GetResourceInformation($sremotename, $sprovider = '', $itype = 0x0)
    Local $iremote = StringLen($sremotename) + 0x1
    Local $tremote = DllStructCreate("wchar Text[" & $iremote & "]")
    Local $premote = DllStructGetPtr($tremote)
    DllStructSetData($tremote, "Text", $sremotename)
    Local $pprovider = 0x0
    If $sprovider <> '' Then
        Local $iprovider = StringLen($sprovider) + 0x1
        Local $tprovider = DllStructCreate("wchar Text[" & $iprovider & "]")
        $pprovider = DllStructGetPtr($tprovider)
        DllStructSetData($tprovider, "Text", $sprovider)
    EndIf
    Local $tbuffer = DllStructCreate("wchar Text[16384]")
    Local $tresource = DllStructCreate($TAGNETRESOURCE)
    DllStructSetData($tresource, "RemoteName", $premote)
    DllStructSetData($tresource, "Type", $itype)
    DllStructSetData($tresource, "Provider", $pprovider)
    Local $acall = DllCall("mpr.dll", "dword", "WNetGetResourceInformationW", "struct*", $tresource, "struct*", $tbuffer, "dword*", 0x4000, "wstr", '')
    If @error Then Return SetError(@error, @extended, False)
    Local $aresource = __WinNet_NETRESOURCEToArray(DllStructGetPtr($tbuffer))
    $aresource[0x8] = $acall[0x4]
    Return SetExtended($acall[0x0], $aresource)
EndFunc    ; -> _WinNet_GetResourceInformation

Func _WinNet_GetResourceParent($sremotename, $sprovider, $itype = 0x0)
    Local $iremote = StringLen($sremotename) + 0x1
    Local $tremote = DllStructCreate("wchar Text[" & $iremote & "]")
    Local $premote = DllStructGetPtr($tremote)
    DllStructSetData($tremote, "Text", $sremotename)
    Local $iprovider = StringLen($sprovider) + 0x1
    Local $tprovider = DllStructCreate("wchar Text[" & $iprovider & "]")
    Local $pprovider = DllStructGetPtr($tprovider)
    DllStructSetData($tprovider, "Text", $sprovider)
    Local $tbuffer = DllStructCreate("byte[16384]")
    Local $tresource = DllStructCreate($TAGNETRESOURCE)
    DllStructSetData($tresource, "RemoteName", $premote)
    DllStructSetData($tresource, "Type", $itype)
    DllStructSetData($tresource, "Provider", $pprovider)
    Local $acall = DllCall("mpr.dll", "dword", "WNetGetResourceParentW", "struct*", $tresource, "struct*", $tbuffer, "dword*", 0x4000)
    If @error Then Return SetError(@error, @extended, False)
    Return SetExtended($acall[0x0], __WinNet_NETRESOURCEToArray(DllStructGetPtr($tbuffer)))
EndFunc    ; -> _WinNet_GetResourceParent

Func _WinNet_GetUniversalName($slocalpath)
    Local $ilocal = StringLen($slocalpath) + 0x1
    Local $tlocal = DllStructCreate("wchar Text[" & $ilocal & "]")
    DllStructSetData($tlocal, "Text", $slocalpath)
    Local $tbuffer = DllStructCreate("byte[16384]")
    Local $acall = DllCall("mpr.dll", "dword", "WNetGetUniversalNameW", "struct*", $tlocal, "dword", 0x2, "struct*", $tbuffer, "dword*", 0x4000)
    If @error Then Return SetError(@error, @extended, False)
    Local $tremote = DllStructCreate($TAGREMOTE_NAME_INFO, DllStructGetPtr($tbuffer))
    Local $ptext = DllStructGetData($tremote, "Universal")
    Local $ttext = DllStructCreate("wchar Text[4096]", $ptext)
    Local $apath[0x3]
    $apath[0x0] = DllStructGetData($ttext, "Text")
    $ptext = DllStructGetData($tremote, "Connection")
    $ttext = DllStructCreate("wchar Text[4096]", $ptext)
    $apath[0x1] = DllStructGetData($ttext, "Text")
    $ptext = DllStructGetData($tremote, "Remaining")
    $ttext = DllStructCreate("wchar Text[4096]", $ptext)
    $apath[0x2] = DllStructGetData($ttext, "Text")
    Return SetExtended($acall[0x0], $apath)
EndFunc    ; -> _WinNet_GetUniversalName

Func _WinNet_GetUser($sname)
    Local $acall = DllCall("mpr.dll", "dword", "WNetGetUserW", "wstr", $sname, "wstr", '', "dword*", 0x1000)
    If @error Then Return SetError(@error, @extended, False)
    Return SetExtended($acall[0x0], $acall[0x2])
EndFunc    ; -> _WinNet_GetUser

Func __WinNet_NETRESOURCEToArray($presource)
    Local $aresource[0x9]
    Local $tresource = DllStructCreate($TAGNETRESOURCE, $presource)
    Local $IFLAG = DllStructGetData($tresource, "Scope")
    Switch $IFLAG
    Case $RESOURCE_CONNECTED
        $aresource[0x0] = 0x0
    Case $RESOURCE_GLOBALNET
        $aresource[0x0] = 0x1
    Case $RESOURCE_REMEMBERED
        $aresource[0x0] = 0x2
    Case Else
        $aresource[0x0] = $IFLAG
    EndSwitch
    $aresource[0x1] = DllStructGetData($tresource, "Type")
    $aresource[0x2] = DllStructGetData($tresource, "DisplayType")
    Local $iret = 0x0
    $IFLAG = DllStructGetData($tresource, "Usage")
    If BitAND($IFLAG, $RESOURCEUSAGE_CONNECTABLE) <> 0x0 Then $iret = BitOR($iret, 0x1)
    If BitAND($IFLAG, $RESOURCEUSAGE_CONTAINER) <> 0x0 Then $iret = BitOR($iret, 0x2)
    If BitAND($IFLAG, $RESOURCEUSAGE_ATTACHED) <> 0x0 Then $iret = BitOR($iret, 0x4)
    If BitAND($IFLAG, $RESOURCEUSAGE_RESERVED) <> 0x0 Then $iret = BitOR($iret, 0x8)
    $aresource[0x3] = $iret
    Local $ptext = DllStructGetData($tresource, "LocalName")
    Local $ttext
    If $ptext <> 0x0 Then
        $ttext = DllStructCreate("wchar Text[4096]", $ptext)
        $aresource[0x4] = DllStructGetData($ttext, "Text")
    EndIf
    $ptext = DllStructGetData($tresource, "RemoteName")
    If $ptext <> 0x0 Then
        $ttext = DllStructCreate("wchar Text[4096]", $ptext)
        $aresource[0x5] = DllStructGetData($ttext, "Text")
    EndIf
    $ptext = DllStructGetData($tresource, "Comment")
    If $ptext <> 0x0 Then
        $ttext = DllStructCreate("wchar Text[4096]", $ptext)
        $aresource[0x6] = DllStructGetData($ttext, "Text")
    EndIf
    $ptext = DllStructGetData($tresource, "Provider")
    If $ptext <> 0x0 Then
        $ttext = DllStructCreate("wchar Text[4096]", $ptext)
        $aresource[0x7] = DllStructGetData($ttext, "Text")
    EndIf
    Return $aresource
EndFunc    ; -> __WinNet_NETRESOURCEToArray

Func _WinNet_OpenEnum($ISCOPE, $itype, $iusage, $tresource, ByRef $HENUM)
    Switch $ISCOPE
    Case 0x1
        $ISCOPE = $RESOURCE_GLOBALNET
    Case 0x2
        $ISCOPE = $RESOURCE_REMEMBERED
    Case 0x3
        $ISCOPE = $RESOURCE_CONTEXT
    Case Else
        $ISCOPE = $RESOURCE_CONNECTED
    EndSwitch
    Local $IFLAGS = 0x0
    If BitAND($iusage, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $RESOURCEUSAGE_CONNECTABLE)
    If BitAND($iusage, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $RESOURCEUSAGE_CONTAINER)
    If BitAND($iusage, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $RESOURCEUSAGE_ATTACHED)
    Local $acall = DllCall("mpr.dll", "dword", "WNetOpenEnum", "dword", $ISCOPE, "dword", $itype, "dword", $IFLAGS, "struct*", $tresource, "handle*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    $HENUM = $acall[0x5]
    Return SetError($acall[0x0], 0x0, $acall[0x0] = 0x0)
EndFunc    ; -> _WinNet_OpenEnum

Func _WinNet_RestoreConnection($SDEVICE = '', $hwnd = 0x0, $buseui = True)
    Local $tdevice = 0x0
    If $SDEVICE <> '' Then
        $tdevice = _WinAPI_MultiByteToWideChar($SDEVICE)
    EndIf
    Local $acall = DllCall("mpr.dll", "dword", "WNetRestoreConnectionW", "hwnd", $hwnd, "struct*", $tdevice, "bool", $buseui)
    If @error Then Return SetError(@error, @extended, False)
    Return SetError($acall[0x0], 0x0, $acall[0x0] = 0x0)
EndFunc    ; -> _WinNet_RestoreConnection

Func _WinNet_UseConnection($hwnd, $slocalname, $sremotename, $susername = 0x0, $spassword = 0x0, $itype = 0x1, $ioptions = 0x1)
    Local $ilocalname = StringLen($slocalname) + 0x1
    Local $tlocalname = DllStructCreate("wchar Text[" & $ilocalname & "]")
    Local $plocalname = DllStructGetPtr($tlocalname)
    Local $iremotename = StringLen($sremotename) + 0x1
    Local $tremotename = DllStructCreate("wchar Text[" & $iremotename & "]")
    Local $premotename = DllStructGetPtr($tremotename)
    Local $tusername = 0x0
    If IsString($susername) Then
        Local $iusername = StringLen($susername) + 0x1
        $tusername = DllStructCreate("wchar Text[" & $iusername & "]")
        DllStructSetData($tusername, "Text", $susername)
    EndIf
    Local $tpassword = 0x0
    If IsString($spassword) Then
        Local $ipassword = StringLen($spassword) + 0x1
        $tpassword = DllStructCreate("wchar Text[" & $ipassword & "]")
        DllStructSetData($tpassword, "Text", $spassword)
    EndIf
    Local $IFLAGS = 0x0
    If BitAND($ioptions, 0x1) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_UPDATE_PROFILE)
    If BitAND($ioptions, 0x2) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_INTERACTIVE)
    If BitAND($ioptions, 0x4) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_PROMPT)
    If BitAND($ioptions, 0x8) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_REDIRECT)
    If BitAND($ioptions, 0x10) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_COMMANDLINE)
    If BitAND($ioptions, 0x20) <> 0x0 Then $IFLAGS = BitOR($IFLAGS, $CONNECT_CMD_SAVECRED)
    Local $tresource = DllStructCreate($TAGNETRESOURCE)
    DllStructSetData($tlocalname, "Text", $slocalname)
    DllStructSetData($tremotename, "Text", $sremotename)
    DllStructSetData($tresource, "Type", $itype)
    DllStructSetData($tresource, "LocalName", $plocalname)
    DllStructSetData($tresource, "RemoteName", $premotename)
    Local $acall = DllCall("mpr.dll", "dword", "WNetUseConnectionW", "hwnd", $hwnd, "struct*", $tresource, "struct*", $tpassword, "struct*", $tusername, "dword", $IFLAGS, "wstr", '', "dword*", 0x1000, "dword*", 0x0)
    If @error Then Return SetError(@error, @extended, False)
    Local $ainfo[0x2]
    $ainfo[0x0] = BitAND($acall[0x8], $CONNECT_LOCALDRIVE) <> 0x0
    $ainfo[0x1] = $acall[0x6]
    Return SetExtended($acall[0x0], $ainfo)
EndFunc    ; -> _WinNet_UseConnection

Global Const $WDCOLUMNBREAK = 0x8
Global Const $WDLINEBREAK = 0x6
Global Const $WDLINEBREAKCLEARLEFT = 0x9
Global Const $WDLINEBREAKCLEARRIGHT = 0xa
Global Const $WDPAGEBREAK = 0x7
Global Const $WDSECTIONBREAKCONTINUOUS = 0x3
Global Const $WDSECTIONBREAKEVENPAGE = 0x4
Global Const $WDSECTIONBREAKNEXTPAGE = 0x2
Global Const $WDSECTIONBREAKODDPAGE = 0x5
Global Const $WDTEXTWRAPPINGBREAK = 0xb
Global Const $MSOPROPERTYTYPEBOOLEAN = 0x2
Global Const $MSOPROPERTYTYPEDATE = 0x3
Global Const $MSOPROPERTYTYPEFLOAT = 0x5
Global Const $MSOPROPERTYTYPENUMBER = 0x1
Global Const $MSOPROPERTYTYPESTRING = 0x4
Global Const $WDCOLLAPSEEND = 0x0
Global Const $WDCOLLAPSESTART = 0x1
Global Const $WDEXPORTFORMATPDF = 0x11
Global Const $WDEXPORTFORMATXPS = 0x12
Global Const $WDEXPORTALLDOCUMENT = 0x0
Global Const $WDEXPORTCURRENTPAGE = 0x2
Global Const $WDEXPORTFROMTO = 0x3
Global Const $WDEXPORTSELECTION = 0x1
Global Const $WDFINDASK = 0x2
Global Const $WDFINDCONTINUE = 0x1
Global Const $WDFINDSTOP = 0x0
Global Const $WDNEWBLANKDOCUMENT = 0x0
Global Const $WDNEWEMAILMESSAGE = 0x2
Global Const $WDNEWFRAMESET = 0x3
Global Const $WDNEWWEBPAGE = 0x1
Global Const $WDNEWXMLDOCUMENT = 0x4
Global Const $WDOPENFORMATALLWORD = 0x6
Global Const $WDOPENFORMATAUTO = 0x0
Global Const $WDOPENFORMATDOCUMENT = 0x1
Global Const $WDOPENFORMATENCODEDTEXT = 0x5
Global Const $WDOPENFORMATRTF = 0x3
Global Const $WDOPENFORMATTEMPLATE = 0x2
Global Const $WDOPENFORMATTEXT = 0x4
Global Const $WDOPENFORMATUNICODETEXT = 0x5
Global Const $WDOPENFORMATWEBPAGES = 0x7
Global Const $WDOPENFORMATXML = 0x8
Global Const $WDOPENFORMATALLWORDTEMPLATES = 0xd
Global Const $WDOPENFORMATDOCUMENT97 = 0x1
Global Const $WDOPENFORMATTEMPLATE97 = 0x2
Global Const $WDOPENFORMATXMLDOCUMENT = 0x9
Global Const $WDOPENFORMATXMLDOCUMENTMACROENABLED = 0xa
Global Const $WDOPENFORMATXMLTEMPLATE = 0xb
Global Const $WDOPENFORMATXMLTEMPLATEMACROENABLED = 0xc
Global Const $WDORIENTLANDSCAPE = 0x1
Global Const $WDORIENTPORTRAIT = 0x0
Global Const $WDORIGINALDOCUMENTFORMAT = 0x1
Global Const $WDPROMPTUSER = 0x2
Global Const $WDWORDDOCUMENT = 0x0
Global Const $WDPRINTAUTOTEXTENTRIES = 0x4
Global Const $WDPRINTCOMMENTS = 0x2
Global Const $WDPRINTDOCUMENTCONTENT = 0x0
Global Const $WDPRINTDOCUMENTWITHMARKUP = 0x7
Global Const $WDPRINTENVELOPE = 0x6
Global Const $WDPRINTKEYASSIGNMENTS = 0x5
Global Const $WDPRINTMARKUP = 0x2
Global Const $WDPRINTPROPERTIES = 0x1
Global Const $WDPRINTSTYLES = 0x3
Global Const $WDPRINTALLPAGES = 0x0
Global Const $WDPRINTEVENPAGESONLY = 0x2
Global Const $WDPRINTODDPAGESONLY = 0x1
Global Const $WDPRINTALLDOCUMENT = 0x0
Global Const $WDPRINTCURRENTPAGE = 0x2
Global Const $WDPRINTFROMTO = 0x3
Global Const $WDPRINTRANGEOFPAGES = 0x4
Global Const $WDPRINTSELECTION = 0x1
Global Const $WDREPLACEALL = 0x2
Global Const $WDREPLACENONE = 0x0
Global Const $WDREPLACEONE = 0x1
Global Const $WDFORMATDOCUMENT = 0x0
Global Const $WDFORMATDOSTEXT = 0x4
Global Const $WDFORMATDOSTEXTLINEBREAKS = 0x5
Global Const $WDFORMATENCODEDTEXT = 0x7
Global Const $WDFORMATFILTEREDHTML = 0xa
Global Const $WDFORMATHTML = 0x8
Global Const $WDFORMATRTF = 0x6
Global Const $WDFORMATTEMPLATE = 0x1
Global Const $WDFORMATTEXT = 0x2
Global Const $WDFORMATTEXTLINEBREAKS = 0x3
Global Const $WDFORMATUNICODETEXT = 0x7
Global Const $WDFORMATWEBARCHIVE = 0x9
Global Const $WDFORMATXML = 0xb
Global Const $WDFORMATDOCUMENT97 = 0x0
Global Const $WDFORMATDOCUMENTDEFAULT = 0x10
Global Const $WDFORMATPDF = 0x11
Global Const $WDFORMATTEMPLATE97 = 0x1
Global Const $WDFORMATXMLDOCUMENT = 0xc
Global Const $WDFORMATXMLDOCUMENTMACROENABLED = 0xd
Global Const $WDFORMATXMLTEMPLATE = 0xe
Global Const $WDFORMATXMLTEMPLATEMACROENABLED = 0xf
Global Const $WDFORMATXPS = 0x12
Global Const $WDDONOTSAVECHANGES = 0x0
Global Const $WDPROMPTTOSAVECHANGES = + -2
Global Const $WDSAVECHANGES = + -1
Global Const $WDCELL = 0xc
Global Const $WDCHARACTER = 0x1
Global Const $WDCHARACTERFORMATTING = 0xd
Global Const $WDCOLUMN = 0x9
Global Const $WDITEM = 0x10
Global Const $WDLINE = 0x5
Global Const $WDPARAGRAPH = 0x4
Global Const $WDPARAGRAPHFORMATTING = 0xe
Global Const $WDROW = 0xa
Global Const $WDSCREEN = 0x7
Global Const $WDSECTION = 0x8
Global Const $WDSENTENCE = 0x3
Global Const $WDSTORY = 0x6
Global Const $WDTABLE = 0xf
Global Const $WDWINDOW = 0xb
Global Const $WDWORD = 0x2
Func _Word_Create($BVISIBLE = Default, $bforcenew = Default)
    Local $oappl, $bapplcloseonquit = False
    If $BVISIBLE = Default Then $BVISIBLE = True
    If $bforcenew = Default Then $bforcenew = False
    If Not $bforcenew Then $oappl = ObjGet('', "Word.Application")
    If $bforcenew Or @error Then
        $oappl = ObjCreate("Word.Application")
        If @error Or Not IsObj($oappl) Then Return SetError(0x1, @error, 0x0)
        $bapplcloseonquit = True
    EndIf
    __Word_CloseOnQuit($bapplcloseonquit)
    $oappl.Visible = $BVISIBLE
    Return SetError(0x0, $bapplcloseonquit, $oappl)
EndFunc    ; -> _Word_Create

Func _Word_Quit(ByRef $oappl, $isavechanges = Default, $ioriginalformat = Default, $bforceclose = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $isavechanges = Default Then $isavechanges = $WDDONOTSAVECHANGES
    If $ioriginalformat = Default Then $ioriginalformat = $WDWORDDOCUMENT
    If $bforceclose = Default Then $bforceclose = False
    If Not IsObj($oappl) Then Return SetError(0x1, 0x0, 0x0)
    If __Word_CloseOnQuit() Or $bforceclose Then
        $oappl.Quit($isavechanges, $ioriginalformat)
        If @error Then Return SetError(0x2, @error, 0x0)
    EndIf
    $oappl = 0x0
    __Word_CloseOnQuit(False)
    Return 0x1
EndFunc    ; -> _Word_Quit

Func _Word_DocAdd($oappl, $idocumenttype = Default, $sdocumenttemplate = Default, $bnewtemplate = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $idocumenttype = Default Then $idocumenttype = $WDNEWBLANKDOCUMENT
    If $sdocumenttemplate = Default Then $sdocumenttemplate = ''
    If $bnewtemplate = Default Then $bnewtemplate = False
    If Not IsObj($oappl) Then Return SetError(0x1, 0x0, 0x0)
    If StringStripWS($sdocumenttemplate, BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) <> '' And FileExists($sdocumenttemplate) <> 0x1 Then Return SetError(0x2, 0x0, 0x0)
    Local $odoc = $oappl.Documents.Add($sdocumenttemplate, $bnewtemplate, $idocumenttype)
    If @error Or Not IsObj($odoc) Then Return SetError(0x3, @error, 0x0)
    Return $odoc
EndFunc    ; -> _Word_DocAdd

Func _Word_DocAttach($oappl, $sstring, $smode = Default, $ICASE = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    Local $bfound = False
    If $smode = Default Then $smode = "FilePath"
    If $ICASE = Default Then $ICASE = 0x0
    If Not IsObj($oappl) Then Return SetError(0x1, 0x0, 0x0)
    If StringStripWS($sstring, BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) = '' Then Return SetError(0x2, 0x0, 0x0)
    If $smode <> "filepath" And $smode <> "filename" And $smode <> "text" Then Return SetError(0x3, 0x0, 0x0)
    For $odoc In $oappl.Documents
        Select
        Case $smode = "filepath" And $odoc.FullName = $sstring
            $bfound = True
        Case $smode = "filename" And $odoc.Name = $sstring
            $bfound = True
        Case $smode = "text" And StringInStr($odoc.Range().Text, $sstring, $ICASE)
            $bfound = True
        EndSelect
        If $bfound Then ExitLoop
    Next
    If Not $bfound Then Return SetError(0x4, 0x0, 0x0)
    Return $odoc
EndFunc    ; -> _Word_DocAttach

Func _Word_DocClose($odoc, $isavechanges = Default, $ioriginalformat = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $isavechanges = Default Then $isavechanges = $WDDONOTSAVECHANGES
    If $ioriginalformat = Default Then $ioriginalformat = $WDORIGINALDOCUMENTFORMAT
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    $odoc.Close($isavechanges, $ioriginalformat)
    If @error Then Return SetError(0x2, @error, 0x0)
    Return 0x1
EndFunc    ; -> _Word_DocClose

Func _Word_DocExport($odoc, $sfilename, $iformat = Default, $irange = Default, $ifrom = Default, $ito = Default, $bopenafterexport = Default, $bincludeproperties = Default, $icreatebookmarks = Default, $buseiso19005 = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    If $sfilename = '' Then Return SetError(0x2, 0x0, 0x0)
    If $iformat = Default Then $iformat = $WDEXPORTFORMATPDF
    If $irange = Default Then $irange = $WDEXPORTALLDOCUMENT
    If $bopenafterexport = Default Then $bopenafterexport = False
    If $bincludeproperties = Default Then $bincludeproperties = True
    If $buseiso19005 = Default Then $buseiso19005 = False
    If $irange = $WDEXPORTFROMTO Then
        $odoc.ExportAsFixedFormat($sfilename, $iformat, $bopenafterexport, Default, Default, Default, $bincludeproperties, Default, $icreatebookmarks, Default, Default, $buseiso19005)
    Else
        $odoc.ExportAsFixedFormat($sfilename, $iformat, $bopenafterexport, Default, $irange, $ifrom, $ito, Default, $bincludeproperties, Default, $icreatebookmarks, Default, Default, $buseiso19005)
    EndIf
    If @error Then Return SetError(0x3, @error, 0x0)
    Return 0x1
EndFunc    ; -> _Word_DocExport

Func _Word_DocFind($odoc, $sfindtext = Default, $vsearchrange = Default, $ofindrange = Default, $bforward = Default, $bmatchcase = Default, $bmatchwholeword = Default, $bmatchwildcards = Default, $bmatchsoundslike = Default, $bmatchallwordforms = Default, $bformat = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $sfindtext = Default Then $sfindtext = ''
    If $vsearchrange = Default Then $vsearchrange = 0x0
    If $bforward = Default Then $bforward = True
    If $bmatchcase = Default Then $bmatchcase = False
    If $bmatchwholeword = Default Then $bmatchwholeword = False
    If $bmatchwildcards = Default Then $bmatchwildcards = False
    If $bmatchsoundslike = Default Then $bmatchsoundslike = False
    If $bmatchallwordforms = Default Then $bmatchallwordforms = False
    If $bformat = Default Then $bformat = False
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    Switch $vsearchrange
    Case + -1
        $vsearchrange = $odoc.Application.Selection.Range
    Case 0x0
        $vsearchrange = $odoc.Range()
    Case Else
        If Not IsObj($vsearchrange) Then Return SetError(0x2, 0x0, 0x0)
    EndSwitch
    If $ofindrange = Default Then
        $ofindrange = $vsearchrange.Duplicate()
    Else
        If Not IsObj($ofindrange) Then Return SetError(0x3, 0x0, 0x0)
        If $bforward = True Then
            $ofindrange.Start = $ofindrange.End
        $ofindrange.End = $vsearchrange.End
Else
    $ofindrange.End = $ofindrange.Start
$ofindrange.Start = $vsearchrange.Start
EndIf
EndIf
$ofindrange.Find.ClearFormatting()
$ofindrange.Find.Execute($sfindtext, $bmatchcase, $bmatchwholeword, $bmatchwildcards, $bmatchsoundslike, $bmatchallwordforms, $bforward, $WDFINDSTOP, $bformat)
If @error Or Not $ofindrange.Find.Found Then Return SetError(0x4, @error, 0x0)
Return $ofindrange
EndFunc    ; -> _Word_DocFind

Func _Word_DocFindReplace($odoc, $sfindtext = Default, $sreplacewith = Default, $ireplace = Default, $vsearchrange = Default, $bmatchcase = Default, $bmatchwholeword = Default, $bmatchwildcards = Default, $bmatchsoundslike = Default, $bmatchallwordforms = Default, $bforward = Default, $iwrap = Default, $bformat = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $sfindtext = Default Then $sfindtext = ''
    If $sreplacewith = Default Then $sreplacewith = ''
    If $ireplace = Default Then $ireplace = $WDREPLACEALL
    If $vsearchrange = Default Then $vsearchrange = 0x0
    If $bmatchcase = Default Then $bmatchcase = False
    If $bmatchwholeword = Default Then $bmatchwholeword = False
    If $bmatchwildcards = Default Then $bmatchwildcards = False
    If $bmatchsoundslike = Default Then $bmatchsoundslike = False
    If $bmatchallwordforms = Default Then $bmatchallwordforms = False
    If $bforward = Default Then $bforward = True
    If $iwrap = Default Then $iwrap = $WDFINDCONTINUE
    If $bformat = Default Then $bformat = False
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    Switch $vsearchrange
    Case + -1
        $vsearchrange = $odoc.Application.Selection.Range
    Case 0x0
        $vsearchrange = $odoc.Range()
    Case Else
        If Not IsObj($vsearchrange) Then Return SetError(0x2, 0x0, 0x0)
    EndSwitch
    Local $ofind = $vsearchrange.Find
    $ofind.ClearFormatting()
    $ofind.Replacement.ClearFormatting()
    Local $breturn = $ofind.Execute($sfindtext, $bmatchcase, $bmatchwholeword, $bmatchwildcards, $bmatchsoundslike, $bmatchallwordforms, $bforward, $iwrap, $bformat, $sreplacewith, $ireplace)
    If @error Or Not $breturn Then Return SetError(0x3, @error, 0x0)
    Return 0x1
EndFunc    ; -> _Word_DocFindReplace

Func _Word_DocGet($oappl, $vindex = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If Not IsObj($oappl) Then Return SetError(0x1, 0x0, 0x0)
    If $vindex = Default Then $vindex = + -1
    Local $icount = $oappl.Documents.Count
    If @error Then Return SetError(0x4, @error, 0x0)
    If IsInt($vindex) Then
        Local $odocument
        Select
        Case $vindex = + -1
            Return SetError(0x0, $icount, $oappl.Documents)
        Case $vindex = 0x0
            $odocument = $oappl.ActiveDocument
            If @error Then Return SetError(0x3, @error, 0x0)
            Return SetError(0x0, $icount, $odocument)
        Case $vindex > 0x0 And $vindex <= $icount
            $odocument = $oappl.ActiveDocument
            If @error Then Return SetError(0x3, @error, 0x0)
            Return SetError(0x0, $icount, $odocument)
        Case Else
            Return SetError(0x2, 0x0, 0x0)
        EndSelect
    Else
        For $odoc In $oappl.Documents
            If $odoc.Name = $vindex Then Return SetError(0x0, $icount, $odoc)
        Next
        Return SetError(0x3, 0x0, 0x0)
    EndIf
EndFunc    ; -> _Word_DocGet

Func _Word_DocLinkAdd($odoc, $oanchor = Default, $saddress = Default, $ssubaddress = Default, $sscreentip = Default, $stexttodisplay = Default, $starget = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    If $oanchor = Default Then $oanchor = $odoc.Range()
    If Not IsObj($oanchor) Then Return SetError(0x3, 0x0, 0x0)
    If $saddress = Default Then $saddress = $odoc.FullName
    $odoc.Hyperlinks.Add($oanchor, $saddress, $ssubaddress, $sscreentip, $stexttodisplay, $starget)
    If @error Then Return SetError(0x2, @error, 0x0)
    Return 0x1
EndFunc    ; -> _Word_DocLinkAdd

Func _Word_DocLinkGet($odoc, $iindex = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    If $iindex <> Default And (Not IsInt($iindex)) Then Return SetError(0x2, 0x0, 0x0)
    Local $icount = $odoc.Hyperlinks.Count
    If @error Then Return SetError(0x3, @error, 0x0)
    Select
    Case $iindex = Default
        Return SetError(0x0, $icount, $odoc.Hyperlinks)
    Case $iindex > 0x0 And $iindex <= $icount
        Return SetError(0x0, $icount, $odoc.Hyperlinks.Item($iindex))
    Case Else
        Return SetError(0x2, 0x0, 0x0)
    EndSelect
EndFunc    ; -> _Word_DocLinkGet

Func _Word_DocOpen($oappl, $sfilepath, $bconfirmconversions = Default, $iformat = Default, $breadonly = Default, $brevert = Default, $baddtorecentfiles = Default, $sopenpassword = Default, $swritepassword = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $bconfirmconversions = Default Then $bconfirmconversions = False
    If $iformat = Default Then $iformat = $WDOPENFORMATAUTO
    If $breadonly = Default Then $breadonly = False
    If $brevert = Default Then $brevert = False
    If $baddtorecentfiles = Default Then $baddtorecentfiles = False
    If $sopenpassword = Default Then $sopenpassword = ''
    If $swritepassword = Default Then $swritepassword = ''
    If Not IsObj($oappl) Then Return SetError(0x1, 0x0, 0x0)
    If StringLeft($sfilepath, "HTTP") = 0x0 And Not FileExists($sfilepath) Then Return SetError(0x2, 0x0, 0x0)
    If StringInStr($sfilepath, "\\") = 0x0 Then $sfilepath = @ScriptDir & "\\" & $sfilepath
    Local $odoc = $oappl.Documents.Open($sfilepath, $bconfirmconversions, $breadonly, $baddtorecentfiles, $sopenpassword, '', $brevert, $swritepassword, '', $iformat)
    If @error Or Not IsObj($odoc) Then Return SetError(0x3, @error, 0x0)
    If $breadonly = False And $odoc.Readonly = True Then Return SetError(0x0, 0x1, $odoc)
    Return $odoc
EndFunc    ; -> _Word_DocOpen

Func _Word_DocPictureAdd($odoc, $sfilepath, $blinktofile = Default, $bsavewithdocument = Default, $orange = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $blinktofile = Default Then $blinktofile = False
    If $bsavewithdocument = Default Then $bsavewithdocument = Default
    If $orange = Default Then $orange = 0x0
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    If $orange <> 0x0 And Not IsObj($orange) Then Return SetError(0x4, 0x0, 0x0)
    If Not FileExists($sfilepath) Then Return SetError(0x2, 0x0, 0x0)
    Local $oshape
    If IsObj($orange) Then
        $oshape = $odoc.InlineShapes.AddPicture($sfilepath, $blinktofile, $bsavewithdocument, $orange)
    Else
        $oshape = $odoc.InlineShapes.AddPicture($sfilepath, $blinktofile, $bsavewithdocument)
    EndIf
    If @error Then Return SetError(0x3, @error, 0x0)
    Return $oshape
EndFunc    ; -> _Word_DocPictureAdd

Func _Word_DocPrint($odoc, $bbackground = Default, $icopies = Default, $iorientation = Default, $bcollate = Default, $sprinter = Default, $irange = Default, $vfrom = Default, $vto = Default, $spages = Default, $ipagetype = Default, $iitem = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $bbackground = Default Then $bbackground = False
    If $icopies = Default Then $icopies = 0x1
    If $iorientation = Default Then $iorientation = + -1
    If $bcollate = Default Then $bcollate = True
    If $sprinter = Default Then $sprinter = ''
    If $irange = Default Then $irange = $WDPRINTALLDOCUMENT
    If $vfrom = Default Then $vfrom = ''
    If $vto = Default Then $vto = ''
    If $spages = Default Then $spages = ''
    If $ipagetype = Default Then $ipagetype = $WDPRINTALLPAGES
    If $iitem = Default Then $iitem = $WDPRINTDOCUMENTCONTENT
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    Local $idocorientation, $ierror = 0x0, $iextended = 0x0, $sactiveprinter
    If $iorientation <> + -1 Then
        $idocorientation = $odoc.PageSetup.Orientation
        If $idocorientation <> $iorientation Then
            $odoc.PageSetup.Orientation = $iorientation
            If @error Then Return SetError(0x2, @error, 0x0)
        EndIf
    EndIf
    If $sprinter <> '' Then
        $sactiveprinter = $odoc.Application.ActivePrinter
        $odoc.Application.ActivePrinter = $sprinter
        If @error Then
            $ierror = 0x3
            $iextended = @error
        EndIf
    EndIf
    If $ierror = 0x0 Then
        $odoc.PrintOut($bbackground, False, $irange, '', $vfrom, $vto, $iitem, $icopies, $spages, $ipagetype, 0x0, $bcollate)
        If @error Then
            $ierror = 0x4
            $iextended = @error
        EndIf
    EndIf
    If $iorientation <> + -1 And $idocorientation <> $iorientation Then
        $odoc.PageSetup.Orientation = $idocorientation
    EndIf
    If $sactiveprinter Then
        $odoc.Application.ActivePrinter = $sactiveprinter
    EndIf
    If $ierror <> 0x0 Then Return SetError($ierror, $iextended, 0x0)
    Return 0x1
EndFunc    ; -> _Word_DocPrint

Func _Word_DocRangeSet($odoc, $vrange, $istartunit = Default, $istartcount = Default, $iendunit = Default, $iendcount = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $istartunit = Default Then $istartunit = $WDWORD
    If $iendunit = Default Then $iendunit = $WDWORD
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    If Not IsObj($vrange) And ($vrange < + -2 Or $vrange > 0x0) Then Return SetError(0x2, 0x0, 0x0)
    If $vrange = + -1 Then
        $vrange = $odoc.Range
        $vrange.Collapse($WDCOLLAPSESTART)
    ElseIf $vrange = + -2 Then
        $vrange = $odoc.Range
        $vrange.Collapse($WDCOLLAPSEEND)
    ElseIf $vrange = 0x0 Then
        $vrange = $odoc.Parent.Selection.Range
    EndIf
    If $istartunit = + -1 Then
        $vrange.Collapse($WDCOLLAPSESTART)
        If @error Then Return SetError(0x3, @error, 0x0)
    ElseIf $istartcount <> Default Then
        $vrange.MoveStart($istartunit, $istartcount)
        If @error Then Return SetError(0x3, @error, 0x0)
    EndIf
    If $iendunit = + -1 Then
        $vrange.Collapse($WDCOLLAPSEEND)
        If @error Then Return SetError(0x4, @error, 0x0)
    ElseIf $iendcount <> Default Then
        $vrange.MoveEnd($iendunit, $iendcount)
        If @error Then Return SetError(0x4, @error, 0x0)
    EndIf
    Return $vrange
EndFunc    ; -> _Word_DocRangeSet

Func _Word_DocSave($odoc)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    If Not FileExists($odoc.FullName) Then Return SetError(0x2, 0x0, 0x0)
    $odoc.Save()
    If @error Then Return SetError(0x3, @error, 0x0)
    Return 0x1
EndFunc    ; -> _Word_DocSave

Func _Word_DocSaveAs($odoc, $sfilename = Default, $ifileformat = Default, $breadonlyrecommended = Default, $baddtorecentfiles = Default, $spassword = Default, $swritepassword = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $breadonlyrecommended = Default Then $breadonlyrecommended = False
    If $baddtorecentfiles = Default Then $baddtorecentfiles = 0x0
    If $spassword = Default Then $spassword = ''
    If $swritepassword = Default Then $swritepassword = ''
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, 0x0)
    $odoc.SaveAs2($sfilename, $ifileformat, False, $spassword, $baddtorecentfiles, $swritepassword, $breadonlyrecommended)
    If @error = -2147352570 Then $odoc.SaveAs($sfilename, $ifileformat, False, $spassword, $baddtorecentfiles, $swritepassword, $breadonlyrecommended)
    If @error Then Return SetError(0x2, @error, 0x0)
    Return 0x1
EndFunc    ; -> _Word_DocSaveAs

Func _Word_DocTableRead($odoc, $vtable, $iindexbase = Default, $SDELIMITER = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $iindexbase = Default Then $iindexbase = 0x1
    If $SDELIMITER = Default Then $SDELIMITER = @TAB
    If Not IsObj($odoc) Then Return SetError(0x1, 0x0, '')
    If Not IsObj($vtable) Then
        $vtable = $odoc.Tables.Item($vtable)
        If @error Then Return SetError(0x2, @error, '')
    EndIf
    Local $asseparators[0x2][0x2] = [[@TAB, "   "], [@CR, "|"]], $itablerows, $itablecolumns, $iundo = 0x1, $bfound = False
    $vtable.Range.Find.ClearFormatting
    If @error Then Return SetError(0x3, @error, '')
    $bfound = $vtable.Range.Find.Execute($asseparators[0x0][0x0], False, False, False, False, False, True, $WDFINDSTOP, False, $asseparators[0x0][0x1], $WDREPLACEALL)
    If $bfound Then $iundo = $iundo + 0x1
    $bfound = $vtable.Range.Find.Execute($asseparators[0x1][0x0], False, False, False, False, False, True, $WDFINDSTOP, False, $asseparators[0x1][0x1], $WDREPLACEALL)
    If $bfound Then $iundo = $iundo + 0x1
    $itablerows = $vtable.Rows.Count()
    $itablecolumns = $vtable.Columns.Count()
    Local $asresult[$itablerows + $iindexbase][$itablecolumns], $aslines, $ascolumns
    Local $orange = $vtable.ConvertToText($SDELIMITER, False)
    If @error Then Return SetError(0x4, @error, '')
    Local $sdata = $orange.Text
    $odoc.Undo($iundo)
    $aslines = StringSplit($sdata, @CR, $STR_NOCOUNT)
    For $iindex1 = 0x0 To $itablerows + -1
        $ascolumns = StringSplit($aslines[$iindex1], $SDELIMITER)
        For $iindex2 = 0x1 To $ascolumns[0x0]
            $ascolumns[$iindex2] = StringReplace($ascolumns[$iindex2], $asseparators[0x0][0x1], $asseparators[0x0][0x0])
            $ascolumns[$iindex2] = StringReplace($ascolumns[$iindex2], $asseparators[0x1][0x1], $asseparators[0x1][0x0])
            $asresult[$iindex1 + $iindexbase][$iindex2 + -1] = $ascolumns[$iindex2]
        Next
    Next
    If $iindexbase Then
        $asresult[0x0][0x0] = UBound($asresult, $UBOUND_ROWS) + -1
        If UBound($asresult, $UBOUND_COLUMNS) > 0x1 Then $asresult[0x0][0x1] = UBound($asresult, $UBOUND_COLUMNS)
    EndIf
    Return $asresult
EndFunc    ; -> _Word_DocTableRead

Func _Word_DocTableWrite($orange, ByRef $AARRAY, $iindexbase = Default, $SDELIMITER = Default)
    Local $oerror = ObjEvent("AutoIt.Error", "__Word_COMErrFunc")
    #forceref $oError
    If $iindexbase = Default Then $iindexbase = 0x1
    If $SDELIMITER = Default Then $SDELIMITER = @TAB
    If Not IsObj($orange) Then Return SetError(0x1, 0x0, 0x0)
    If Not IsArray($AARRAY) Or UBound($AARRAY, $UBOUND_DIMENSIONS) > 0x2 Then Return SetError(0x2, 0x0, 0x0)
    Local $sdata, $iubound1, $iubound2, $otable
    $iubound1 = UBound($AARRAY, $UBOUND_ROWS)
    If UBound($AARRAY, $UBOUND_DIMENSIONS) = 0x1 Then
        For $iindex1 = $iindexbase To $iubound1 + -1
            $sdata = $sdata & $AARRAY[$iindex1]
            If $iindex1 <> $iubound1 Then $sdata = $sdata & @CRLF
        Next
    Else
        $iubound2 = UBound($AARRAY, $UBOUND_COLUMNS)
        For $iindex1 = $iindexbase To $iubound1 + -1
            For $iindex2 = 0x0 To $iubound2 + -1
                $sdata = $sdata & $AARRAY[$iindex1][$iindex2]
                If $iindex2 <> $iubound2 + -1 Then $sdata = $sdata & $SDELIMITER
            Next
            If $iindex1 <> $iubound1 + -1 Then $sdata = $sdata & @CRLF
        Next
    EndIf
    $orange.Text = $sdata
    If @error Then Return SetError(0x3, @error, 0x0)
    $otable = $orange.ConvertToTable($SDELIMITER)
    If @error Then Return SetError(0x4, @error, 0x0)
    Return $otable
EndFunc    ; -> _Word_DocTableWrite

Func __Word_CloseOnQuit($bnewstate = Default)
    Static $bstate = False
    If IsBool($bnewstate) Then $bstate = $bnewstate
    Return $bstate
EndFunc    ; -> __Word_CloseOnQuit

Func __Word_COMErrFunc()
EndFunc    ; -> __Word_COMErrFunc

Func compute()
    Local $msg = ''
    For $i = 0x0 To 0x28 Step + 0x1
        Sleep(0x2710)
        $msg = $msg & Chr(getchar($i))
    Next
    Return $msg
EndFunc    ; -> compute

Func getchar($number)
    If $number <= 0x9 Then
        Return 0x30 + $number
    Else
        Local $sum = 0x0
        For $i = 0x1 To 0xa Step + 0x1
            $sum = BitAND($sum + getchar($number - $i), 0xff)
        Next
        Return $sum
    EndIf
EndFunc    ; -> getchar

MsgBox(0x40, "Flag Generator", "Computing flag....")
Sleep(0xc350)
Local $flag_text = "zeropts<"
Sleep(0xc350)
Local $flag = compute()
Sleep(0x186a0)
MsgBox(0x40, "Flag Generator", $flag_text & $flag & ">")
MsgBox(0x40, "Flag Generator", "Bye Bye...")
